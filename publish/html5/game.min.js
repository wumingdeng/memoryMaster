var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
var _p = window, _p = Object.prototype, _p = null;
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._supportRender = !1;
cc._canvas = null;
cc.container = null;
cc._gameDiv = null;
cc.newElement = function (a) {
    return document.createElement(a)
};
cc.each = function (a, b, d) {
    if (a)if (a instanceof Array)for (var e = 0, f = a.length; e < f && !1 !== b.call(d, a[e], e); e++); else for (e in a)if (!1 === b.call(d, a[e], e))break
};
cc.extend = function (a) {
    var b = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
    cc.each(b, function (b) {
        for (var e in b)b.hasOwnProperty(e) && (a[e] = b[e])
    });
    return a
};
cc.isFunction = function (a) {
    return "function" === typeof a
};
cc.isNumber = function (a) {
    return "number" === typeof a || "[object Number]" === Object.prototype.toString.call(a)
};
cc.isString = function (a) {
    return "string" === typeof a || "[object String]" === Object.prototype.toString.call(a)
};
cc.isArray = function (a) {
    return Array.isArray(a) || "object" === typeof a && "[object Array]" === Object.prototype.toString.call(a)
};
cc.isUndefined = function (a) {
    return "undefined" === typeof a
};
cc.isObject = function (a) {
    return "object" === typeof a && "[object Object]" === Object.prototype.toString.call(a)
};
cc.isCrossOrigin = function (a) {
    if (!a)return cc.log("invalid URL"), !1;
    var b = a.indexOf("://");
    if (-1 === b)return !1;
    b = a.indexOf("/", b + 3);
    return (-1 === b ? a : a.substring(0, b)) !== location.origin
};
cc.AsyncPool = function (a, b, d, e, f) {
    var g = this;
    g._srcObj = a;
    g._limit = b;
    g._pool = [];
    g._iterator = d;
    g._iteratorTarget = f;
    g._onEnd = e;
    g._onEndTarget = f;
    g._results = a instanceof Array ? [] : {};
    cc.each(a, function (a, b) {
        g._pool.push({index: b, value: a})
    });
    g.size = g._pool.length;
    g.finishedSize = 0;
    g._workingSize = 0;
    g._limit = g._limit || g.size;
    g.onIterator = function (a, b) {
        g._iterator = a;
        g._iteratorTarget = b
    };
    g.onEnd = function (a, b) {
        g._onEnd = a;
        g._onEndTarget = b
    };
    g._handleItem = function () {
        var a = this;
        if (!(0 === a._pool.length || a._workingSize >=
            a._limit)) {
            var b = a._pool.shift(), d = b.value, e = b.index;
            a._workingSize++;
            a._iterator.call(a._iteratorTarget, d, e, function (b) {
                a.finishedSize++;
                a._workingSize--;
                var d = Array.prototype.slice.call(arguments, 1);
                a._results[this.index] = d[0];
                a.finishedSize === a.size ? a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results) : a._handleItem()
            }.bind(b), a)
        }
    };
    g.flow = function () {
        if (0 === this._pool.length)this._onEnd && this._onEnd.call(this._onEndTarget, null, []); else for (var a = 0; a < this._limit; a++)this._handleItem()
    }
};
cc.async = {
    series: function (a, b, d) {
        a = new cc.AsyncPool(a, 1, function (a, b, g) {
            a.call(d, g)
        }, b, d);
        a.flow();
        return a
    }, parallel: function (a, b, d) {
        a = new cc.AsyncPool(a, 0, function (a, b, g) {
            a.call(d, g)
        }, b, d);
        a.flow();
        return a
    }, waterfall: function (a, b, d) {
        var e = [], f = [null], g = new cc.AsyncPool(a, 1, function (b, g, p) {
            e.push(function (b) {
                e = Array.prototype.slice.call(arguments, 1);
                a.length - 1 === g && (f = f.concat(e));
                p.apply(null, arguments)
            });
            b.apply(d, e)
        }, function (a) {
            if (b) {
                if (a)return b.call(d, a);
                b.apply(d, f)
            }
        });
        g.flow();
        return g
    },
    map: function (a, b, d, e) {
        var f = b;
        "object" === typeof b && (d = b.cb, e = b.iteratorTarget, f = b.iterator);
        a = new cc.AsyncPool(a, 0, f, d, e);
        a.flow();
        return a
    }, mapLimit: function (a, b, d, e, f) {
        a = new cc.AsyncPool(a, b, d, e, f);
        a.flow();
        return a
    }
};
cc.path = {
    normalizeRE: /[^\.\/]+\/\.\.\//, join: function () {
        for (var a = arguments.length, b = "", d = 0; d < a; d++)b = (b + ("" === b ? "" : "/") + arguments[d]).replace(/(\/|\\\\)$/, "");
        return b
    }, extname: function (a) {
        return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
    }, mainFileName: function (a) {
        if (a) {
            var b = a.lastIndexOf(".");
            if (-1 !== b)return a.substring(0, b)
        }
        return a
    }, basename: function (a, b) {
        var d = a.indexOf("?");
        0 < d && (a = a.substring(0, d));
        d = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
        if (!d)return null;
        d = d[2];
        return b && a.substring(a.length - b.length).toLowerCase() === b.toLowerCase() ? d.substring(0, d.length - b.length) : d
    }, dirname: function (a) {
        return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    }, changeExtname: function (a, b) {
        b = b || "";
        var d = a.indexOf("?"), e = "";
        0 < d && (e = a.substring(d), a = a.substring(0, d));
        d = a.lastIndexOf(".");
        return 0 > d ? a + b + e : a.substring(0, d) + b + e
    }, changeBasename: function (a, b, d) {
        if (0 === b.indexOf("."))return this.changeExtname(a, b);
        var e = a.indexOf("?"), f = "";
        d = d ? this.extname(a) : "";
        0 < e && (f = a.substring(e),
            a = a.substring(0, e));
        e = a.lastIndexOf("/");
        return a.substring(0, 0 >= e ? 0 : e + 1) + b + d + f
    }, _normalize: function (a) {
        var b = a = String(a);
        do b = a, a = a.replace(this.normalizeRE, ""); while (b.length !== a.length);
        return a
    }
};
cc.loader = function () {
    var a = {}, b = {}, d = {}, e = {}, f = {}, g = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
    return {
        resPath: "", audioPath: "", cache: {}, getXMLHttpRequest: function () {
            return window.XMLHttpRequest ?
                new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
        }, _getArgs4Js: function (a) {
            var b = a[0], d = a[1], e = a[2], f = ["", null, null];
            if (1 === a.length)f[1] = b instanceof Array ? b : [b]; else if (2 === a.length)"function" === typeof d ? (f[1] = b instanceof Array ? b : [b], f[2] = d) : (f[0] = b || "", f[1] = d instanceof Array ? d : [d]); else if (3 === a.length)f[0] = b || "", f[1] = d instanceof Array ? d : [d], f[2] = e; else throw Error("arguments error to load js!");
            return f
        }, isLoading: function (a) {
            return void 0 !== f[a]
        }, loadJs: function (b, d, e) {
            var f = this,
                g = f._getArgs4Js(arguments), t = g[0], v = g[1], g = g[2];
            -1 < navigator.userAgent.indexOf("Trident/5") ? f._loadJs4Dependency(t, v, 0, g) : cc.async.map(v, function (b, d, e) {
                b = cc.path.join(t, b);
                if (a[b])return e(null);
                f._createScript(b, !1, e)
            }, g)
        }, loadJsWithImg: function (a, b, d) {
            var e = this._loadJsImg(), f = this._getArgs4Js(arguments);
            this.loadJs(f[0], f[1], function (a) {
                if (a)throw Error(a);
                e.parentNode.removeChild(e);
                if (f[2])f[2]()
            })
        }, _createScript: function (b, d, e) {
            var f = document, g = document.createElement("script");
            g.async = d;
            a[b] = !0;
            cc.game.config.noCache && "string" === typeof b ? this._noCacheRex.test(b) ? g.src = b + "\x26_t\x3d" + (new Date - 0) : g.src = b + "?_t\x3d" + (new Date - 0) : g.src = b;
            g.addEventListener("load", function () {
                g.parentNode.removeChild(g);
                this.removeEventListener("load", arguments.callee, !1);
                e()
            }, !1);
            g.addEventListener("error", function () {
                g.parentNode.removeChild(g);
                e("Load " + b + " failed!")
            }, !1);
            f.body.appendChild(g)
        }, _loadJs4Dependency: function (a, b, d, e) {
            if (d >= b.length)e && e(); else {
                var f = this;
                f._createScript(cc.path.join(a, b[d]),
                    !1, function (g) {
                        if (g)return e(g);
                        f._loadJs4Dependency(a, b, d + 1, e)
                    })
            }
        }, _loadJsImg: function () {
            var a = document, b = a.getElementById("cocos2d_loadJsImg");
            if (!b) {
                b = document.createElement("img");
                cc._loadingImage && (b.src = cc._loadingImage);
                a = a.getElementById(cc.game.config.id);
                a.style.backgroundColor = "transparent";
                a.parentNode.appendChild(b);
                var d = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
                d || (d = {width: a.width, height: a.height});
                b.style.left = a.offsetLeft + (parseFloat(d.width) - b.width) / 2 + "px";
                b.style.top =
                    a.offsetTop + (parseFloat(d.height) - b.height) / 2 + "px";
                b.style.position = "absolute"
            }
            return b
        }, loadTxt: function (a, b) {
            if (cc._isNodeJs)require("fs").readFile(a, function (a, d) {
                a ? b(a) : b(null, d.toString())
            }); else {
                var d = this.getXMLHttpRequest(), e = "load " + a + " failed!";
                d.open("GET", a, !0);
                /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "utf-8"), d.onreadystatechange = function () {
                    4 === d.readyState && (200 === d.status ? b(null, d.responseText) : b({
                            status: d.status,
                            errorMessage: e
                        },
                        null))
                }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dutf-8"), d.onload = function () {
                    4 === d.readyState && (200 === d.status ? b(null, d.responseText) : b({
                        status: d.status,
                        errorMessage: e
                    }, null))
                }, d.onerror = function () {
                    b({status: d.status, errorMessage: e}, null)
                });
                d.send(null)
            }
        }, _loadTxtSync: function (a) {
            if (cc._isNodeJs)return require("fs").readFileSync(a).toString();
            var b = this.getXMLHttpRequest();
            b.open("GET", a, !1);
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset",
                "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dutf-8");
            b.send(null);
            return 4 === !b.readyState || 200 !== b.status ? null : b.responseText
        }, loadCsb: function (a, b) {
            var d = new XMLHttpRequest, e = "load " + a + " failed!";
            d.open("GET", a, !0);
            d.responseType = "arraybuffer";
            d.onload = function () {
                var a = d.response;
                a && (window.msg = a);
                4 === d.readyState && (200 === d.status ? b(null, d.response) : b({
                    status: d.status,
                    errorMessage: e
                }, null))
            };
            d.onerror = function () {
                b({status: d.status, errorMessage: e}, null)
            };
            d.send(null)
        },
        loadJson: function (a, b) {
            this.loadTxt(a, function (d, e) {
                if (d)b(d); else {
                    try {
                        var f = JSON.parse(e)
                    } catch (g) {
                        throw Error("parse json [" + a + "] failed : " + g);
                    }
                    b(null, f)
                }
            })
        }, _checkIsImageURL: function (a) {
            return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
        }, loadImg: function (a, b, d) {
            var e = {isCrossOrigin: !0};
            void 0 !== d ? e.isCrossOrigin = void 0 === b.isCrossOrigin ? e.isCrossOrigin : b.isCrossOrigin : void 0 !== b && (d = b);
            var s = this.getRes(a);
            if (s)return d && d(null, s), s;
            if (b = f[a])return b.callbacks.push(d), b.img;
            s = new Image;
            e.isCrossOrigin && "file://" !== location.origin && (s.crossOrigin = "Anonymous");
            var t = function () {
                this.removeEventListener("load", t, !1);
                this.removeEventListener("error", u, !1);
                g.test(a) || (cc.loader.cache[a] = s);
                var b = f[a];
                if (b) {
                    callbacks = b.callbacks;
                    for (var d = 0; d < callbacks.length; ++d) {
                        var e = callbacks[d];
                        e && e(null, s)
                    }
                    b.img = null;
                    delete f[a]
                }
            }, v = this, u = function () {
                this.removeEventListener("error", u, !1);
                if (s.crossOrigin && "anonymous" === s.crossOrigin.toLowerCase())e.isCrossOrigin = !1, v.release(a), cc.loader.loadImg(a,
                    e, d); else {
                    var b = f[a];
                    if (b) {
                        callbacks = b.callbacks;
                        for (var g = 0; g < callbacks.length; ++g) {
                            var n = callbacks[g];
                            n && n("load image failed")
                        }
                        b.img = null;
                        delete f[a]
                    }
                }
            };
            f[a] = {img: s, callbacks: d ? [d] : []};
            s.addEventListener("load", t);
            s.addEventListener("error", u);
            s.src = a;
            return s
        }, _loadResIterator: function (a, d, e) {
            var f = this, s = null, t = a.type;
            t ? (t = "." + t.toLowerCase(), s = a.src ? a.src : a.name + t) : (s = a, t = cc.path.extname(s));
            if (d = f.getRes(s))return e(null, d);
            d = null;
            t && (d = b[t.toLowerCase()]);
            if (!d)return cc.error("loader for [" +
                t + "] not exists!"), e();
            t = s;
            g.test(s) || (t = d.getBasePath ? d.getBasePath() : f.resPath, t = f.getUrl(t, s));
            cc.game.config.noCache && "string" === typeof t && (t = f._noCacheRex.test(t) ? t + ("\x26_t\x3d" + (new Date - 0)) : t + ("?_t\x3d" + (new Date - 0)));
            d.load(t, s, a, function (a, b) {
                a ? (cc.log(a), f.cache[s] = null, delete f.cache[s], e({
                    status: 520,
                    errorMessage: a
                }, null)) : (f.cache[s] = b, e(null, b))
            })
        }, _noCacheRex: /\?/, getUrl: function (a, e) {
            var f = cc.path;
            if (void 0 !== a && void 0 === e) {
                e = a;
                var g = f.extname(e), g = g ? g.toLowerCase() : "";
                a = (g = b[g]) ?
                    g.getBasePath ? g.getBasePath() : this.resPath : this.resPath
            }
            e = cc.path.join(a || "", e);
            if (e.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
                if (d[e])return d[e];
                f = f.extname(e) || "";
                e = d[e] = e.substring(0, e.length - f.length) + "_" + cc.sys.language + f
            }
            return e
        }, load: function (a, b, d) {
            var e = this, f = arguments.length;
            if (0 === f)throw Error("arguments error!");
            3 === f ? "function" === typeof b && (b = "function" === typeof d ? {trigger: b, cb: d} : {
                cb: b,
                cbTarget: d
            }) : 2 === f ? "function" === typeof b && (b = {cb: b}) : 1 === f && (b = {});
            a instanceof Array || (a = [a]);
            f = new cc.AsyncPool(a,
                0, function (a, d, f, g) {
                    e._loadResIterator(a, d, function (a) {
                        var d = Array.prototype.slice.call(arguments, 1);
                        b.trigger && b.trigger.call(b.triggerTarget, d[0], g.size, g.finishedSize);
                        f(a, d[0])
                    })
                }, b.cb, b.cbTarget);
            f.flow();
            return f
        }, _handleAliases: function (a, b) {
            var d = [], f;
            for (f in a) {
                var g = a[f];
                e[f] = g;
                d.push(g)
            }
            this.load(d, b)
        }, loadAliases: function (a, b) {
            var d = this, e = d.getRes(a);
            e ? d._handleAliases(e.filenames, b) : d.load(a, function (a, e) {
                d._handleAliases(e[0].filenames, b)
            })
        }, register: function (a, d) {
            if (a && d) {
                if ("string" === typeof a)return b[a.trim().toLowerCase()] = d;
                for (var e = 0, f = a.length; e < f; e++)b["." + a[e].trim().toLowerCase()] = d
            }
        }, getRes: function (a) {
            return this.cache[a] || this.cache[e[a]]
        }, _getAliase: function (a) {
            return e[a]
        }, release: function (a) {
            var b = this.cache, d = f[a];
            d && (d.img = null, delete f[a]);
            delete b[a];
            delete b[e[a]];
            delete e[a]
        }, releaseAll: function () {
            var a = this.cache, b;
            for (b in a)delete a[b];
            for (b in e)delete e[b]
        }
    }
}();
cc.formatStr = function () {
    var a = arguments, b = a.length;
    if (1 > b)return "";
    var d = a[0], e = !0;
    "object" === typeof d && (e = !1);
    for (var f = 1; f < b; ++f) {
        var g = a[f];
        if (e)for (; ;) {
            var h = null;
            if ("number" === typeof g && (h = d.match(/(%d)|(%s)/))) {
                d = d.replace(/(%d)|(%s)/, g);
                break
            }
            d = (h = d.match(/%s/)) ? d.replace(/%s/, g) : d + ("    " + g);
            break
        } else d += "    " + g
    }
    return d
};
(function () {
    function a(a) {
        var b = cc.game.CONFIG_KEY, d = parseInt(a[b.renderMode]) || 0;
        if (isNaN(d) || 2 < d || 0 > d)a[b.renderMode] = 0;
        cc._renderType = cc.game.RENDER_TYPE_CANVAS;
        cc._supportRender = !1;
        0 === d ? cc.sys.capabilities.opengl ? (cc._renderType = cc.game.RENDER_TYPE_WEBGL, cc._supportRender = !0) : cc.sys.capabilities.canvas && (cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc._supportRender = !0) : 1 === d && cc.sys.capabilities.canvas ? (cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc._supportRender = !0) : 2 === d && cc.sys.capabilities.opengl &&
        (cc._renderType = cc.game.RENDER_TYPE_WEBGL, cc._supportRender = !0)
    }

    function b(a, d, e) {
        if (n[d])return null;
        e = e || "";
        var f = [], g = a[d];
        if (!g)throw Error("can not find module [" + d + "]");
        d = cc.path;
        for (var h = 0, p = g.length; h < p; h++) {
            var r = g[h];
            if (!n[r]) {
                var D = d.extname(r);
                D ? ".js" === D.toLowerCase() && f.push(d.join(e, r)) : (D = b(a, r, e)) && (f = f.concat(D));
                n[r] = 1
            }
        }
        return f
    }

    function d(a) {
        cc._initDebugSetting && cc._initDebugSetting(a[cc.game.CONFIG_KEY.debugMode]);
        cc._engineLoaded = !0;
        cc.log(cc.ENGINE_VERSION);
        r && r()
    }

    function e(a) {
        var e =
            a[cc.game.CONFIG_KEY.engineDir], f = cc.loader;
        if (cc.Class)d(a); else {
            var g = cc.path.join(e, "moduleConfig.json");
            f.loadJson(g, function (f, g) {
                if (f)throw Error(f);
                var h = a.modules || [], n = g.module, p = [];
                cc.sys.capabilities.opengl && 0 > h.indexOf("base4webgl") ? h.splice(0, 0, "base4webgl") : 0 > h.indexOf("core") && h.splice(0, 0, "core");
                for (var r = 0, u = h.length; r < u; r++) {
                    var v = b(n, h[r], e);
                    v && (p = p.concat(v))
                }
                cc.loader.loadJsWithImg(p, function (b) {
                    if (b)throw b;
                    d(a)
                })
            })
        }
    }

    function f() {
        this.removeEventListener("load", f, !1);
        e(cc.game.config)
    }

    var g = document.createElement("canvas"), h = document.createElement("canvas");
    cc.create3DContext = function (a, b) {
        for (var d = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], e = null, f = 0; f < d.length; ++f) {
            try {
                e = a.getContext(d[f], b)
            } catch (g) {
            }
            if (e)break
        }
        return e
    };
    (function () {
        cc.sys = {};
        var a = cc.sys;
        a.LANGUAGE_ENGLISH = "en";
        a.LANGUAGE_CHINESE = "zh";
        a.LANGUAGE_FRENCH = "fr";
        a.LANGUAGE_ITALIAN = "it";
        a.LANGUAGE_GERMAN = "de";
        a.LANGUAGE_SPANISH = "es";
        a.LANGUAGE_DUTCH = "du";
        a.LANGUAGE_RUSSIAN = "ru";
        a.LANGUAGE_KOREAN = "ko";
        a.LANGUAGE_JAPANESE = "ja";
        a.LANGUAGE_HUNGARIAN = "hu";
        a.LANGUAGE_PORTUGUESE = "pt";
        a.LANGUAGE_ARABIC = "ar";
        a.LANGUAGE_NORWEGIAN = "no";
        a.LANGUAGE_POLISH = "pl";
        a.LANGUAGE_UNKNOWN = "unkonwn";
        a.OS_IOS = "iOS";
        a.OS_ANDROID = "Android";
        a.OS_WINDOWS = "Windows";
        a.OS_MARMALADE = "Marmalade";
        a.OS_LINUX = "Linux";
        a.OS_BADA = "Bada";
        a.OS_BLACKBERRY = "Blackberry";
        a.OS_OSX = "OS X";
        a.OS_WP8 = "WP8";
        a.OS_WINRT = "WINRT";
        a.OS_UNKNOWN = "Unknown";
        a.UNKNOWN = -1;
        a.WIN32 = 0;
        a.LINUX = 1;
        a.MACOS = 2;
        a.ANDROID = 3;
        a.IPHONE = 4;
        a.IPAD = 5;
        a.BLACKBERRY = 6;
        a.NACL =
            7;
        a.EMSCRIPTEN = 8;
        a.TIZEN = 9;
        a.WINRT = 10;
        a.WP8 = 11;
        a.MOBILE_BROWSER = 100;
        a.DESKTOP_BROWSER = 101;
        a.BROWSER_TYPE_WECHAT = "wechat";
        a.BROWSER_TYPE_ANDROID = "androidbrowser";
        a.BROWSER_TYPE_IE = "ie";
        a.BROWSER_TYPE_QQ = "qqbrowser";
        a.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
        a.BROWSER_TYPE_UC = "ucbrowser";
        a.BROWSER_TYPE_360 = "360browser";
        a.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
        a.BROWSER_TYPE_BAIDU = "baidubrowser";
        a.BROWSER_TYPE_MAXTHON = "maxthon";
        a.BROWSER_TYPE_OPERA = "opera";
        a.BROWSER_TYPE_OUPENG = "oupeng";
        a.BROWSER_TYPE_MIUI =
            "miuibrowser";
        a.BROWSER_TYPE_FIREFOX = "firefox";
        a.BROWSER_TYPE_SAFARI = "safari";
        a.BROWSER_TYPE_CHROME = "chrome";
        a.BROWSER_TYPE_LIEBAO = "liebao";
        a.BROWSER_TYPE_QZONE = "qzone";
        a.BROWSER_TYPE_SOUGOU = "sogou";
        a.BROWSER_TYPE_UNKNOWN = "unknown";
        a.isNative = !1;
        var b = window, d = b.navigator, e = document, f = e.documentElement, n = d.userAgent.toLowerCase();
        a.isMobile = -1 !== n.indexOf("mobile") || -1 !== n.indexOf("android");
        a.platform = a.isMobile ? a.MOBILE_BROWSER : a.DESKTOP_BROWSER;
        var p = d.language, p = (p = p ? p : d.browserLanguage) ? p.split("-")[0] :
            a.LANGUAGE_ENGLISH;
        a.language = p;
        var r = p = !1, D = "", G = 0, B = /android (\d+(?:\.\d+)+)/i.exec(n) || /android (\d+(?:\.\d+)+)/i.exec(d.platform);
        B && (p = !0, D = B[1] || "", G = parseInt(D) || 0);
        if (B = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(n))r = !0, D = B[2] || "", G = parseInt(D) || 0;
        B = a.OS_UNKNOWN;
        -1 !== d.appVersion.indexOf("Win") ? B = a.OS_WINDOWS : r ? B = a.OS_IOS : -1 !== d.appVersion.indexOf("Mac") ? B = a.OS_OSX : -1 !== d.appVersion.indexOf("X11") && -1 === d.appVersion.indexOf("Linux") ? B = a.OS_UNIX : p ? B = a.OS_ANDROID : -1 !== d.appVersion.indexOf("Linux") &&
        (B = a.OS_LINUX);
        a.os = B;
        a.osVersion = D;
        a.osMainVersion = G;
        a.browserType = a.BROWSER_TYPE_UNKNOWN;
        (function () {
            var b = /qqbrowser|chrome|safari|firefox|opr|oupeng|opera/i, d = /mqqbrowser|sogou|qzone|liebao|micromessenger|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|trident|miuibrowser/i.exec(n);
            d || (d = b.exec(n));
            b = d ? d[0] : a.BROWSER_TYPE_UNKNOWN;
            "micromessenger" === b ? b = a.BROWSER_TYPE_WECHAT : "safari" === b && n.match(/android.*applewebkit/) ? b = a.BROWSER_TYPE_ANDROID : "trident" === b ? b = a.BROWSER_TYPE_IE :
                "360 aphone" === b ? b = a.BROWSER_TYPE_360 : "mxbrowser" === b ? b = a.BROWSER_TYPE_MAXTHON : "opr" === b && (b = a.BROWSER_TYPE_OPERA);
            a.browserType = b
        })();
        a.browserVersion = "";
        (function () {
            var b = /(msie |rv:|firefox|chrome|ucbrowser|oupeng|opera|opr|safari|miui)(mobile)?(browser)?\/?([\d.]+)/i, d = n.match(/(micromessenger|qq|mx|maxthon|baidu|sogou)(mobile)?(browser)?\/?([\d.]+)/i);
            d || (d = n.match(b));
            a.browserVersion = d ? d[4] : ""
        })();
        p = window.devicePixelRatio || 1;
        a.windowPixelResolution = {
            width: p * (window.innerWidth || document.documentElement.clientWidth),
            height: p * (window.innerHeight || document.documentElement.clientHeight)
        };
        a._checkWebGLRenderMode = function () {
            if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL)throw Error("This feature supports WebGL render mode only.");
        };
        a._supportCanvasNewBlendModes = function () {
            var a = g;
            a.width = 1;
            a.height = 1;
            a = a.getContext("2d");
            a.fillStyle = "#000";
            a.fillRect(0, 0, 1, 1);
            a.globalCompositeOperation = "multiply";
            var b = h;
            b.width = 1;
            b.height = 1;
            var d = b.getContext("2d");
            d.fillStyle = "#fff";
            d.fillRect(0, 0, 1, 1);
            a.drawImage(b, 0, 0, 1, 1);
            return 0 ===
                a.getImageData(0, 0, 1, 1).data[0]
        }();
        cc.sys.isMobile && (p = document.createElement("style"), p.type = "text/css", document.body.appendChild(p), p.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
        try {
            var C = a.localStorage = b.localStorage;
            C.setItem("storage", "");
            C.removeItem("storage");
            C = null
        } catch (E) {
            C = function () {
                cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option")
            },
                a.localStorage = {getItem: C, setItem: C, removeItem: C, clear: C}
        }
        C = !!g.getContext("2d");
        p = !1;
        if (b.WebGLRenderingContext) {
            r = document.createElement("CANVAS");
            try {
                if (cc.create3DContext(r, {
                        stencil: !0,
                        preserveDrawingBuffer: !0
                    }) && (p = !0), p && a.os === a.OS_ANDROID)switch (a.browserType) {
                    case a.BROWSER_TYPE_MOBILE_QQ:
                    case a.BROWSER_TYPE_BAIDU:
                    case a.BROWSER_TYPE_BAIDU_APP:
                        p = 6.2 <= parseFloat(a.browserVersion) ? !0 : !1;
                        break;
                    case a.BROWSER_TYPE_ANDROID:
                        a.osMainVersion && 5 <= a.osMainVersion && (p = !0);
                        break;
                    case a.BROWSER_TYPE_UNKNOWN:
                    case a.BROWSER_TYPE_360:
                    case a.BROWSER_TYPE_MIUI:
                        p = !1
                }
            } catch (I) {
            }
            r = null
        }
        C = a.capabilities = {canvas: C, opengl: p};
        if (void 0 !== f.ontouchstart || void 0 !== e.ontouchstart || d.msPointerEnabled)C.touches = !0;
        void 0 !== f.onmouseup && (C.mouse = !0);
        void 0 !== f.onkeyup && (C.keyboard = !0);
        if (b.DeviceMotionEvent || b.DeviceOrientationEvent)C.accelerometer = !0;
        a.garbageCollect = function () {
        };
        a.dumpRoot = function () {
        };
        a.restartVM = function () {
        };
        a.cleanScript = function (a) {
        };
        a.isObjectValid = function (a) {
            return a ? !0 : !1
        };
        a.dump = function () {
            var a;
            a = "" + ("isMobile : " + this.isMobile + "\r\n");
            a +=
                "language : " + this.language + "\r\n";
            a += "browserType : " + this.browserType + "\r\n";
            a += "browserVersion : " + this.browserVersion + "\r\n";
            a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
            a += "os : " + this.os + "\r\n";
            a += "osVersion : " + this.osVersion + "\r\n";
            a += "platform : " + this.platform + "\r\n";
            a += "Using " + (cc._renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n";
            cc.log(a)
        };
        a.openURL = function (a) {
            window.open(a)
        }
    })();
    h = g = null;
    cc.log = cc.warn = cc.error = cc.assert = function () {
    };
    var n =
    {}, p = !1, r = null;
    cc._engineLoaded = !1;
    cc.initEngine = function (b, d) {
        if (p) {
            var g = r;
            r = function () {
                g && g();
                d && d()
            }
        } else r = d, !cc.game.config && b ? cc.game.config = b : cc.game.config || cc.game._loadConfig(), b = cc.game.config, a(b), document.body ? e(b) : cc._addEventListener(window, "load", f, !1), p = !0
    }
})();
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    EVENT_RESIZE: "game_on_resize",
    EVENT_RENDERER_INITED: "renderer_inited",
    RENDER_TYPE_CANVAS: 0,
    RENDER_TYPE_WEBGL: 1,
    RENDER_TYPE_OPENGL: 2,
    _eventHide: null,
    _eventShow: null,
    CONFIG_KEY: {
        width: "width",
        height: "height",
        engineDir: "engineDir",
        modules: "modules",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList"
    },
    _paused: !0,
    _prepareCalled: !1,
    _prepared: !1,
    _rendererInitialized: !1,
    _renderContext: null,
    _intervalId: null,
    _lastTime: null,
    _frameTime: null,
    frame: null,
    container: null,
    canvas: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function (a) {
        this.config[this.CONFIG_KEY.frameRate] = a;
        this._intervalId && window.cancelAnimationFrame(this._intervalId);
        this._paused = !0;
        this._setAnimFrame();
        this._runMainLoop()
    },
    step: function () {
        cc.director.mainLoop()
    },
    pause: function () {
        this._paused || (this._paused = !0, cc.audioEngine && cc.audioEngine._pausePlaying(), this._intervalId && window.cancelAnimationFrame(this._intervalId), this._intervalId = 0)
    },
    resume: function () {
        this._paused && (this._paused = !1, cc.audioEngine && cc.audioEngine._resumePlaying(), this._runMainLoop())
    },
    isPaused: function () {
        return this._paused
    },
    restart: function () {
        cc.director.popToSceneStackLevel(0);
        cc.audioEngine && cc.audioEngine.end();
        cc.game.onStart()
    },
    end: function () {
        close()
    },
    prepare: function (a) {
        var b =
            this, d = b.config, e = b.CONFIG_KEY;
        this._loadConfig();
        this._prepared ? a && a() : this._prepareCalled || (cc._engineLoaded ? (this._prepareCalled = !0, this._initRenderer(d[e.width], d[e.height]), cc.view = cc.EGLView._getInstance(), cc.director = cc.Director._getInstance(), cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view), cc.winSize = cc.director.getWinSize(), this._initEvents(), this._setAnimFrame(), this._runMainLoop(), (d = d[e.jsList]) ? cc.loader.loadJsWithImg(d, function (d) {
            if (d)throw Error(d);
            b._prepared = !0;
            a &&
            a()
        }) : a && a()) : cc.initEngine(this.config, function () {
            b.prepare(a)
        }))
    },
    run: function (a, b) {
        "function" === typeof a ? cc.game.onStart = a : (a && ("string" === typeof a ? (cc.game.config || this._loadConfig(), cc.game.config[cc.game.CONFIG_KEY.id] = a) : cc.game.config = a), "function" === typeof b && (cc.game.onStart = b));
        this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game))
    },
    _setAnimFrame: function () {
        this._lastTime = new Date;
        this._frameTime = 1E3 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
        cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType ===
        cc.sys.BROWSER_TYPE_WECHAT || 60 !== cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (window.requestAnimFrame = this._stTime, window.cancelAnimationFrame = this._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame ||
            window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime)
    },
    _stTime: function (a) {
        var b = (new Date).getTime(), d = Math.max(0, cc.game._frameTime - (b - cc.game._lastTime)), e = window.setTimeout(function () {
            a()
        }, d);
        cc.game._lastTime = b + d;
        return e
    },
    _ctTime: function (a) {
        window.clearTimeout(a)
    },
    _runMainLoop: function () {
        var a = this, b, d = cc.director;
        d.setDisplayStats(a.config[a.CONFIG_KEY.showFPS]);
        b = function () {
            a._paused || (d.mainLoop(), a._intervalId && window.cancelAnimationFrame(a._intervalId), a._intervalId = window.requestAnimFrame(b))
        };
        window.requestAnimFrame(b);
        a._paused = !1
    },
    _loadConfig: function () {
        if (this.config)this._initConfig(this.config); else if (document.ccConfig)this._initConfig(document.ccConfig); else {
            var a = {};
            try {
                for (var b = document.getElementsByTagName("script"), d = 0; d < b.length; d++) {
                    var e = b[d].getAttribute("cocos");
                    if ("" === e || e)break
                }
                var f, g, h;
                if (d < b.length) {
                    if (f = b[d].src)h = /(.*)\//.exec(f)[0],
                        cc.loader.resPath = h, f = cc.path.join(h, "project.json");
                    g = cc.loader._loadTxtSync(f)
                }
                g || (g = cc.loader._loadTxtSync("project.json"));
                a = JSON.parse(g)
            } catch (n) {
                cc.log("Failed to read or parse project.json")
            }
            this._initConfig(a)
        }
    },
    _initConfig: function (a) {
        var b = this.CONFIG_KEY, d = a[b.modules];
        a[b.showFPS] = "undefined" === typeof a[b.showFPS] ? !0 : a[b.showFPS];
        a[b.engineDir] = a[b.engineDir] || "frameworks/cocos2d-html5";
        null == a[b.debugMode] && (a[b.debugMode] = 0);
        a[b.frameRate] = a[b.frameRate] || 60;
        null == a[b.renderMode] &&
        (a[b.renderMode] = 0);
        null == a[b.registerSystemEvent] && (a[b.registerSystemEvent] = !0);
        d && 0 > d.indexOf("core") && d.splice(0, 0, "core");
        d && (a[b.modules] = d);
        this.config = a
    },
    _initRenderer: function (a, b) {
        if (!this._rendererInitialized) {
            if (!cc._supportRender)throw Error("The renderer doesn't support the renderMode " + this.config[this.CONFIG_KEY.renderMode]);
            var d = this.config[cc.game.CONFIG_KEY.id], e = window, f = cc.$(d) || cc.$("#" + d), g;
            "CANVAS" === f.tagName ? (a = a || f.width, b = b || f.height, this.canvas = cc._canvas = d = f, this.container =
                cc.container = g = document.createElement("DIV"), d.parentNode && d.parentNode.insertBefore(g, d)) : ("DIV" !== f.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), a = a || f.clientWidth, b = b || f.clientHeight, this.canvas = cc._canvas = d = document.createElement("CANVAS"), this.container = cc.container = g = document.createElement("DIV"), f.appendChild(g));
            g.setAttribute("id", "Cocos2dGameContainer");
            g.appendChild(d);
            this.frame = g.parentNode === document.body ? document.documentElement : g.parentNode;
            d.addClass("gameCanvas");
            d.setAttribute("width", a || 480);
            d.setAttribute("height", b || 320);
            d.setAttribute("tabindex", 99);
            d.style.outline = "none";
            f = g.style;
            f.width = (a || 480) + "px";
            f.height = (b || 320) + "px";
            f.margin = "0 auto";
            f.position = "relative";
            f.overflow = "hidden";
            g.top = "100%";
            cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(d, {
                stencil: !0,
                preserveDrawingBuffer: !0,
                antialias: !cc.sys.isMobile,
                alpha: !0
            }));
            this._renderContext ? (cc.renderer = cc.rendererWebGL, e.gl = this._renderContext,
                cc.renderer.init(), cc.shaderCache._init(), cc._drawingUtil = new cc.DrawingPrimitiveWebGL(this._renderContext), cc.textureCache._initializingRenderer(), cc.glExt = {}, cc.glExt.instanced_arrays = gl.getExtension("ANGLE_instanced_arrays"), cc.glExt.element_uint = gl.getExtension("OES_element_index_uint")) : (cc.renderer = cc.rendererCanvas, this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(d.getContext("2d")), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(this._renderContext) :
                null);
            cc._gameDiv = g;
            cc.game.canvas.oncontextmenu = function () {
                if (!cc._isContextMenuEnable)return !1
            };
            this.dispatchEvent(this.EVENT_RENDERER_INITED, !0);
            this._rendererInitialized = !0
        }
    },
    _initEvents: function () {
        var a = window, b, d;
        this._eventHide = this._eventHide || new cc.EventCustom(this.EVENT_HIDE);
        this._eventHide.setUserData(this);
        this._eventShow = this._eventShow || new cc.EventCustom(this.EVENT_SHOW);
        this._eventShow.setUserData(this);
        this.config[this.CONFIG_KEY.registerSystemEvent] && cc.inputManager.registerSystemEvent(this.canvas);
        cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (b = "webkitHidden", d = "webkitvisibilitychange") : (b = "msHidden", d = "msvisibilitychange") : (b = "mozHidden", d = "mozvisibilitychange") : (b = "hidden", d = "visibilitychange");
        var e = function () {
            cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
        }, f = function () {
            cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow)
        };
        b ? document.addEventListener(d, function () {
            document[b] ? e() : f()
        }, !1) : (a.addEventListener("blur", e, !1), a.addEventListener("focus", f, !1));
        -1 < navigator.userAgent.indexOf("MicroMessenger") && (a.onfocus = function () {
            f()
        });
        "onpageshow" in window && "onpagehide" in window && (a.addEventListener("pagehide", e, !1), a.addEventListener("pageshow", f, !1));
        cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function () {
            cc.game.pause()
        });
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
            cc.game.resume()
        })
    }
};
Function.prototype.bind = Function.prototype.bind || function (a) {
        if (!cc.isFunction(this))throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        var b = Array.prototype.slice.call(arguments, 1), d = this, e = function () {
        }, f = function () {
            return d.apply(this instanceof e && a ? this : a, b.concat(Array.prototype.slice.call(arguments)))
        };
        e.prototype = this.prototype;
        f.prototype = new e;
        return f
    };
cc._urlRegExp = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
cc.EventHelper = function () {
};
cc.EventHelper.prototype = {
    constructor: cc.EventHelper, apply: function (a) {
        a.addEventListener = cc.EventHelper.prototype.addEventListener;
        a.hasEventListener = cc.EventHelper.prototype.hasEventListener;
        a.removeEventListener = cc.EventHelper.prototype.removeEventListener;
        a.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
    }, addEventListener: function (a, b, d) {
        if ("load" === a && this._textureLoaded)setTimeout(function () {
            b.call(d)
        }, 0); else {
            void 0 === this._listeners && (this._listeners = {});
            var e = this._listeners;
            void 0 ===
            e[a] && (e[a] = []);
            this.hasEventListener(a, b, d) || e[a].push({callback: b, eventTarget: d})
        }
    }, hasEventListener: function (a, b, d) {
        if (void 0 === this._listeners)return !1;
        var e = this._listeners;
        if (void 0 !== e[a]) {
            a = 0;
            for (var f = e.length; a < f; a++) {
                var g = e[a];
                if (g.callback === b && g.eventTarget === d)return !0
            }
        }
        return !1
    }, removeEventListener: function (a, b) {
        if (void 0 !== this._listeners) {
            var d = this._listeners[a];
            if (void 0 !== d)for (var e = 0; e < d.length;)d[e].eventTarget === b ? d.splice(e, 1) : e++
        }
    }, dispatchEvent: function (a, b) {
        if (void 0 !==
            this._listeners) {
            null == b && (b = !0);
            var d = this._listeners[a];
            if (void 0 !== d) {
                for (var e = [], f = d.length, g = 0; g < f; g++)e[g] = d[g];
                for (g = 0; g < f; g++)e[g].callback.call(e[g].eventTarget, this);
                b && (d.length = 0)
            }
        }
    }
};
cc.EventHelper.prototype.apply(cc.game);
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag \x3d %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX !\x3d RotationY. Don't know which one to return",
    Node_getScale: "ScaleX !\x3d ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag \x3d %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex \x3d %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id\x3d%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id\x3d HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function (a) {
    if (cc._canvas) {
        var b = cc._logList, d = document;
        if (!b) {
            var e = d.createElement("Div"), b = e.style;
            e.setAttribute("id", "logInfoDiv");
            cc._canvas.parentNode.appendChild(e);
            e.setAttribute("width", "200");
            e.setAttribute("height", cc._canvas.height);
            b.zIndex = "99999";
            b.position = "absolute";
            b.top = "0";
            b.left = "0";
            b = cc._logList = d.createElement("textarea");
            d = b.style;
            b.setAttribute("rows", "20");
            b.setAttribute("cols", "30");
            b.setAttribute("disabled", !0);
            e.appendChild(b);
            d.backgroundColor = "transparent";
            d.borderBottom = "1px solid #cccccc";
            d.borderRightWidth = "0px";
            d.borderLeftWidth = "0px";
            d.borderTopWidth = "0px";
            d.borderTopStyle = "none";
            d.borderRightStyle = "none";
            d.borderLeftStyle = "none";
            d.padding = "0px";
            d.margin = 0
        }
        b.value = b.value + a + "\r\n";
        b.scrollTop = b.scrollHeight
    }
};
cc._formatString = function (a) {
    if (cc.isObject(a))try {
        return JSON.stringify(a)
    } catch (b) {
        return ""
    } else return a
};
cc._initDebugSetting = function (a) {
    var b = cc.game;
    if (a !== b.DEBUG_MODE_NONE) {
        var d;
        a > b.DEBUG_MODE_ERROR ? (d = cc._logToWebPage.bind(cc), cc.error = function () {
            d("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }, cc.assert = function (a, b) {
            if (!a && b) {
                for (var g = 2; g < arguments.length; g++)b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[g]));
                d("Assert: " + b)
            }
        }, a !== b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function () {
            d("WARN :  " + cc.formatStr.apply(cc, arguments))
        }), a === b.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function () {
            d(cc.formatStr.apply(cc,
                arguments))
        })) : console && console.log.apply && (cc.error = function () {
            return console.error.apply(console, arguments)
        }, cc.assert = function (a, b) {
            if (!a && b) {
                for (var d = 2; d < arguments.length; d++)b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[d]));
                throw Error(b);
            }
        }, a !== b.DEBUG_MODE_ERROR && (cc.warn = function () {
            return console.warn.apply(console, arguments)
        }), a === b.DEBUG_MODE_INFO && (cc.log = function () {
            return console.log.apply(console, arguments)
        }))
    }
};
cc.SimplePool = function () {
    this._pool = []
};
cc.SimplePool.prototype = {
    constructor: cc.SimplePool, size: function () {
        return this._pool.length
    }, put: function (a) {
        a && -1 === this._pool.indexOf(a) && this._pool.unshift(a)
    }, get: function () {
        var a = this._pool.length - 1;
        if (0 > a)return null;
        var b = this._pool[a];
        this._pool.length = a;
        return b
    }, find: function (a, b) {
        var d, e, f, g = this._pool, h = g.length - 1;
        for (e = g.length; 0 <= e; --e)if (f = g[e], d = a(e, f))return g[e] = g[h], g.length = h, f;
        return b && (d = b(), 0 <= d) ? (g[d] = g[h], g.length = h, f) : null
    }
};
cc.loader.loadBinary = function (a, b) {
    var d = this, e = this.getXMLHttpRequest(), f = "load " + a + " failed!";
    e.open("GET", a, !0);
    cc.loader.loadBinary._IEFilter ? (e.setRequestHeader("Accept-Charset", "x-user-defined"), e.onreadystatechange = function () {
        if (4 === e.readyState && 200 === e.status) {
            var a = cc._convertResponseBodyToText(e.responseBody);
            b(null, d._str2Uint8Array(a))
        } else b(f)
    }) : (e.overrideMimeType && e.overrideMimeType("text/plain; charset\x3dx-user-defined"), e.onload = function () {
        4 === e.readyState && 200 === e.status ? b(null,
            d._str2Uint8Array(e.responseText)) : b(f)
    });
    e.send(null)
};
cc.loader.loadBinary._IEFilter = /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && window.IEBinaryToArray_ByteStr && window.IEBinaryToArray_ByteStr_Last;
cc.loader._str2Uint8Array = function (a) {
    if (!a)return null;
    for (var b = new Uint8Array(a.length), d = 0; d < a.length; d++)b[d] = a.charCodeAt(d) & 255;
    return b
};
cc.loader.loadBinarySync = function (a) {
    var b = this.getXMLHttpRequest(), d = "load " + a + " failed!";
    b.open("GET", a, !1);
    a = null;
    if (cc.loader.loadBinary._IEFilter) {
        b.setRequestHeader("Accept-Charset", "x-user-defined");
        b.send(null);
        if (200 !== b.status)return cc.log(d), null;
        (b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
    } else {
        b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dx-user-defined");
        b.send(null);
        if (200 !== b.status)return cc.log(d), null;
        a = this._str2Uint8Array(b.responseText)
    }
    return a
};
window.Uint8Array = window.Uint8Array || window.Array;
if (cc.loader.loadBinary._IEFilter) {
    var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n', myVBScript =
        document.createElement("script");
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function (a) {
        for (var b = {}, d = 0; 256 > d; d++)for (var e = 0; 256 > e; e++)b[String.fromCharCode(d + 256 * e)] = String.fromCharCode(d) + String.fromCharCode(e);
        d = IEBinaryToArray_ByteStr(a);
        a = IEBinaryToArray_ByteStr_Last(a);
        return d.replace(/[\s\S]/g, function (a) {
                return b[a]
            }) + a
    }
}
;cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII\x3d";
cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k\x3d";
var cc = cc || {}, ClassManager = {
    id: 0 | 998 * Math.random(),
    instanceId: 0 | 998 * Math.random(),
    getNewID: function () {
        return this.id++
    },
    getNewInstanceId: function () {
        return this.instanceId++
    }
};
(function () {
    var a = /\b_super\b/;
    cc.Class = function () {
    };
    cc.Class.extend = function (b) {
        function d() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments)
        }

        var e = this.prototype, f = Object.create(e), g = ClassManager.getNewID();
        ClassManager[g] = e;
        var h = {writable: !0, enumerable: !1, configurable: !0};
        f.__instanceId = null;
        d.id = g;
        h.value = g;
        Object.defineProperty(f, "__pid", h);
        d.prototype = f;
        h.value = d;
        Object.defineProperty(d.prototype, "constructor", h);
        this.__getters__ && (d.__getters__ =
            cc.clone(this.__getters__));
        this.__setters__ && (d.__setters__ = cc.clone(this.__setters__));
        for (var g = 0, n = arguments.length; g < n; ++g) {
            var p = arguments[g], r;
            for (r in p) {
                var s = "function" === typeof p[r], t = "function" === typeof e[r], v = a.test(p[r]);
                s && t && v ? (h.value = function (a, b) {
                    return function () {
                        var d = this._super;
                        this._super = e[a];
                        var f = b.apply(this, arguments);
                        this._super = d;
                        return f
                    }
                }(r, p[r]), Object.defineProperty(f, r, h)) : s ? (h.value = p[r], Object.defineProperty(f, r, h)) : f[r] = p[r];
                if (s) {
                    var u, x;
                    if (this.__getters__ &&
                        this.__getters__[r]) {
                        var s = this.__getters__[r], w;
                        for (w in this.__setters__)if (this.__setters__[w] === s) {
                            x = w;
                            break
                        }
                        cc.defineGetterSetter(f, s, p[r], p[x] ? p[x] : f[x], r, x)
                    }
                    if (this.__setters__ && this.__setters__[r]) {
                        s = this.__setters__[r];
                        for (w in this.__getters__)if (this.__getters__[w] === s) {
                            u = w;
                            break
                        }
                        cc.defineGetterSetter(f, s, p[u] ? p[u] : f[u], p[r], u, r)
                    }
                }
            }
        }
        d.extend = cc.Class.extend;
        d.implement = function (a) {
            for (var b in a)f[b] = a[b]
        };
        return d
    }
})();
cc.defineGetterSetter = function (a, b, d, e, f, g) {
    if (a.__defineGetter__)d && a.__defineGetter__(b, d), e && a.__defineSetter__(b, e); else if (Object.defineProperty) {
        var h = {enumerable: !1, configurable: !0};
        d && (h.get = d);
        e && (h.set = e);
        Object.defineProperty(a, b, h)
    } else throw Error("browser does not support getters");
    if (!f && !g)for (var h = null != d, n = void 0 != e, p = Object.getOwnPropertyNames(a), r = 0; r < p.length; r++) {
        var s = p[r];
        if ((a.__lookupGetter__ ? !a.__lookupGetter__(s) : !Object.getOwnPropertyDescriptor(a, s)) && "function" === typeof a[s]) {
            var t =
                a[s];
            if (h && t === d && (f = s, !n || g))break;
            if (n && t === e && (g = s, !h || f))break
        }
    }
    a = a.constructor;
    f && (a.__getters__ || (a.__getters__ = {}), a.__getters__[f] = b);
    g && (a.__setters__ || (a.__setters__ = {}), a.__setters__[g] = b)
};
cc.clone = function (a) {
    var b = a.constructor ? new a.constructor : {}, d;
    for (d in a) {
        var e = a[d];
        b[d] = "object" !== typeof e || !e || e instanceof cc.Node || e instanceof HTMLElement ? e : cc.clone(e)
    }
    return b
};
cc.inject = function (a, b) {
    for (var d in a)b[d] = a[d]
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function (a, b) {
};
cc.KEY = {
    none: 0,
    back: 6,
    menu: 18,
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    select: 41,
    insert: 45,
    Delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    semicolon: 186,
    equal: 187,
    "\x3d": 187,
    ",": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    backslash: 220,
    "]": 221,
    closebracket: 221,
    quote: 222,
    dpadLeft: 1E3,
    dpadRight: 1001,
    dpadUp: 1003,
    dpadDown: 1004,
    dpadCenter: 1005
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function (a) {
    return 8 < a.length && 137 === a[0] && 80 === a[1] && 78 === a[2] && 71 === a[3] && 13 === a[4] && 10 === a[5] && 26 === a[6] && 10 === a[7] ? cc.FMT_PNG : 2 < a.length && (73 === a[0] && 73 === a[1] || 77 === a[0] && 77 === a[1] || 255 === a[0] && 216 === a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function (a, b) {
    function d() {
    }

    d.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new d;
    a.prototype.constructor = a
};
cc.base = function (a, b, d) {
    var e = arguments.callee.caller;
    if (e.superClass_)return ret = e.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var f = Array.prototype.slice.call(arguments, 2), g = !1, h = a.constructor; h; h = h.superClass_ && h.superClass_.constructor)if (h.prototype[b] === e)g = !0; else if (g)return h.prototype[b].apply(a, f);
    if (a[b] === e)return a.constructor.prototype[b].apply(a, f);
    throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.Point = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.p = function (a, b) {
    return void 0 === a ? {x: 0, y: 0} : void 0 === b ? {x: a.x, y: a.y} : {x: a, y: b}
};
cc.pointEqualToPoint = function (a, b) {
    return a && b && a.x === b.x && a.y === b.y
};
cc.Size = function (a, b) {
    this.width = a || 0;
    this.height = b || 0
};
cc.size = function (a, b) {
    return void 0 === a ? {width: 0, height: 0} : void 0 === b ? {width: a.width, height: a.height} : {
        width: a,
        height: b
    }
};
cc.sizeEqualToSize = function (a, b) {
    return a && b && a.width === b.width && a.height === b.height
};
cc.Rect = function (a, b, d, e) {
    this.x = a || 0;
    this.y = b || 0;
    this.width = d || 0;
    this.height = e || 0
};
cc.rect = function (a, b, d, e) {
    return void 0 === a ? {x: 0, y: 0, width: 0, height: 0} : void 0 === b ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {x: a, y: b, width: d, height: e}
};
cc.rectEqualToRect = function (a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
};
cc._rectEqualToZero = function (a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function (a, b) {
    return a && b ? !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height) : !1
};
cc.rectGetMaxX = function (a) {
    return a.x + a.width
};
cc.rectGetMidX = function (a) {
    return a.x + a.width / 2
};
cc.rectGetMinX = function (a) {
    return a.x
};
cc.rectGetMaxY = function (a) {
    return a.y + a.height
};
cc.rectGetMidY = function (a) {
    return a.y + a.height / 2
};
cc.rectGetMinY = function (a) {
    return a.y
};
cc.rectContainsPoint = function (a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function (a, b) {
    var d = a.y + a.height, e = b.x + b.width, f = b.y + b.height;
    return !(a.x + a.width < b.x || e < a.x || d < b.y || f < a.y)
};
cc.rectOverlapsRect = function (a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
};
cc.rectUnion = function (a, b) {
    var d = cc.rect(0, 0, 0, 0);
    d.x = Math.min(a.x, b.x);
    d.y = Math.min(a.y, b.y);
    d.width = Math.max(a.x + a.width, b.x + b.width) - d.x;
    d.height = Math.max(a.y + a.height, b.y + b.height) - d.y;
    return d
};
cc.rectIntersection = function (a, b) {
    var d = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    d.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(d);
    d.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(d);
    return d
};
cc.SAXParser = cc.Class.extend({
    _parser: null, _isSupportDOMParser: null, ctor: function () {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    }, parse: function (a) {
        return this._parseXML(a)
    }, _parseXML: function (a) {
        var b;
        this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a));
        return b
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse: function (a) {
        a = this._parseXML(a).documentElement;
        if ("plist" !== a.tagName)return cc.warn("Not a plist file!"), {};
        for (var b = null, d = 0, e = a.childNodes.length; d < e && (b = a.childNodes[d], 1 !== b.nodeType); d++);
        return this._parseNode(b)
    }, _parseNode: function (a) {
        var b = null, d = a.tagName;
        if ("dict" === d)b = this._parseDict(a); else if ("array" === d)b = this._parseArray(a); else if ("string" === d)if (1 === a.childNodes.length)b = a.firstChild.nodeValue; else for (b = "", d = 0; d < a.childNodes.length; d++)b +=
            a.childNodes[d].nodeValue; else"false" === d ? b = !1 : "true" === d ? b = !0 : "real" === d ? b = parseFloat(a.firstChild.nodeValue) : "integer" === d && (b = parseInt(a.firstChild.nodeValue, 10));
        return b
    }, _parseArray: function (a) {
        for (var b = [], d = 0, e = a.childNodes.length; d < e; d++) {
            var f = a.childNodes[d];
            1 === f.nodeType && b.push(this._parseNode(f))
        }
        return b
    }, _parseDict: function (a) {
        for (var b = {}, d = null, e = 0, f = a.childNodes.length; e < f; e++) {
            var g = a.childNodes[e];
            1 === g.nodeType && ("key" === g.tagName ? d = g.firstChild.nodeValue : b[d] = this._parseNode(g))
        }
        return b
    }
});
cc.saxParser = new cc.SAXParser;
cc.plistParser = new cc.PlistParser;
cc._txtLoader = {
    load: function (a, b, d, e) {
        cc.loader.loadTxt(a, e)
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
    load: function (a, b, d, e) {
        cc.loader.loadJson(a, e)
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._jsLoader = {
    load: function (a, b, d, e) {
        cc.loader.loadJs(a, e)
    }
};
cc.loader.register(["js"], cc._jsLoader);
cc._imgLoader = {
    load: function (a, b, d, e) {
        d = cc.loader.isLoading(a) ? e : function (a, d) {
            if (a)return e(a);
            cc.loader.cache[b] = d;
            cc.textureCache.handleLoadedTexture(b);
            e(null, d)
        };
        cc.loader.loadImg(a, d)
    }
};
cc.loader.register("png jpg bmp jpeg gif ico tiff webp".split(" "), cc._imgLoader);
cc._serverImgLoader = {
    load: function (a, b, d, e) {
        cc._imgLoader.load(d.src, b, d, e)
    }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
    load: function (a, b, d, e) {
        cc.loader.loadTxt(a, function (a, b) {
            if (a)return e(a);
            e(null, cc.plistParser.parse(b))
        })
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE: {".eot": "embedded-opentype", ".ttf": "truetype", ".ttc": "truetype", ".woff": "woff", ".svg": "svg"},
    _loadFont: function (a, b, d) {
        var e = document, f = cc.path, g = this.TYPE, h = document.createElement("style");
        h.type = "text/css";
        e.body.appendChild(h);
        var n = "", n = isNaN(a - 0) ? n + ("@font-face { font-family:" + a + "; src:") : n + ("@font-face { font-family:'" + a + "'; src:");
        if (b instanceof Array)for (var p = 0, r = b.length; p < r; p++)d = f.extname(b[p]).toLowerCase(), n += "url('" + b[p] + "') format('" + g[d] + "')", n += p === r - 1 ? ";" :
            ","; else d = d.toLowerCase(), n += "url('" + b + "') format('" + g[d] + "');";
        h.textContent += n + "}";
        b = document.createElement("div");
        d = b.style;
        d.fontFamily = a;
        b.innerHTML = ".";
        d.position = "absolute";
        d.left = "-100px";
        d.top = "-100px";
        e.body.appendChild(b)
    },
    load: function (a, b, d, e) {
        b = d.type;
        a = d.name;
        b = d.srcs;
        cc.isString(d) ? (b = cc.path.extname(d), a = cc.path.basename(d, b), this._loadFont(a, d, b)) : this._loadFont(a, b);
        document.fonts ? document.fonts.load("1em " + a).then(function () {
            e(null, !0)
        }, function (a) {
            e(a)
        }) : e(null, !0)
    }
};
cc.loader.register("font eot ttf woff svg ttc".split(" "), cc._fontLoader);
cc._binaryLoader = {
    load: function (a, b, d, e) {
        cc.loader.loadBinary(a, e)
    }
};
cc._csbLoader = {
    load: function (a, b, d, e) {
        cc.loader.loadCsb(a, e)
    }
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.11";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function (a) {
    var b = this === cc ? document : this;
    if (a = a instanceof HTMLElement ? a : b.querySelector(a))a.find = a.find || cc.$, a.hasClass = a.hasClass || function (a) {
            return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
        }, a.addClass = a.addClass || function (a) {
            this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
            return this
        }, a.removeClass = a.removeClass || function (a) {
            this.hasClass(a) && (this.className = this.className.replace(a, ""));
            return this
        }, a.remove = a.remove || function () {
            this.parentNode &&
            this.parentNode.removeChild(this);
            return this
        }, a.appendTo = a.appendTo || function (a) {
            a.appendChild(this);
            return this
        }, a.prependTo = a.prependTo || function (a) {
            a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
            return this
        }, a.transforms = a.transforms || function () {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this
        }, a.position = a.position || {x: 0, y: 0}, a.rotation = a.rotation || 0, a.scale = a.scale || {
            x: 1,
            y: 1
        }, a.skew =
        a.skew || {x: 0, y: 0}, a.translates = function (a, b) {
        this.position.x = a;
        this.position.y = b;
        this.transforms();
        return this
    }, a.rotate = function (a) {
        this.rotation = a;
        this.transforms();
        return this
    }, a.resize = function (a, b) {
        this.scale.x = a;
        this.scale.y = b;
        this.transforms();
        return this
    }, a.setSkew = function (a, b) {
        this.skew.x = a;
        this.skew.y = b;
        this.transforms();
        return this
    };
    return a
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function (a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function (a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function (a) {
    return "rotateZ(" + a + "deg) "
} : function (a) {
    return "rotate(" + a + "deg) "
};
cc.$.scale = function (a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function (a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function (a) {
    return cc.$(document.createElement(a))
};
cc.$.findpos = function (a) {
    var b = 0, d = 0;
    do b += a.offsetLeft, d += a.offsetTop; while (a = a.offsetParent);
    return {x: b, y: d}
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function (a, b, d) {
    if (!cc.isObject(d) || cc.isUndefined(d.x) || cc.isUndefined(d.y))cc.log(cc._LogInfos.swap); else {
        var e = d[a];
        d[a] = d[b];
        d[b] = e
    }
};
cc.lerp = function (a, b, d) {
    return a + (b - a) * d
};
cc.rand = function () {
    return 16777215 * Math.random()
};
cc.randomMinus1To1 = function () {
    return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function (a) {
    return a * cc.RAD
};
cc.radiansToDegrees = function (a) {
    return a * cc.DEG
};
cc.radiansToDegress = function (a) {
    cc.log(cc._LogInfos.radiansToDegress);
    return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.nodeDrawSetup = function (a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function () {
};
cc.disableDefaultGLStates = function () {
};
cc.incrementGLDraws = function (a) {
    cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function () {
    return cc.director.getContentScaleFactor()
} : function () {
    return 1
};
cc.pointPointsToPixels = function (a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x * b, a.y * b)
};
cc.pointPixelsToPoints = function (a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x / b, a.y / b)
};
cc._pointPixelsToPointsOut = function (a, b) {
    var d = cc.contentScaleFactor();
    b.x = a.x / d;
    b.y = a.y / d
};
cc.sizePointsToPixels = function (a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width * b, a.height * b)
};
cc.sizePixelsToPoints = function (a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width / b, a.height / b)
};
cc._sizePixelsToPointsOut = function (a, b) {
    var d = cc.contentScaleFactor();
    b.width = a.width / d;
    b.height = a.height / d
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function (a) {
    return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function (a) {
    return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.LINEAR = 9729;
cc.REPEAT = 10497;
cc.CLAMP_TO_EDGE = 33071;
cc.MIRRORED_REPEAT = 33648;
cc.BLEND_SRC = cc.SRC_ALPHA;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA && (cc.BLEND_SRC = cc.ONE)
});
cc.BLEND_DST = cc.ONE_MINUS_SRC_ALPHA;
cc.checkGLErrorDebug = function () {
    if (cc.renderMode === cc.game.RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 7;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_SPRITE_POSITION_TEXTURECOLOR = "ShaderSpritePositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST = "ShaderSpritePositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_SPRITE_POSITION_COLOR = "ShaderSpritePositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ATTRIBUTE_NAME_MVMAT = "a_mvMatrix";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function (a, b) {
    if (a && 0 < a.length)for (var d = 0; d < a.length; d++)if (!(a[d] instanceof b))return cc.log("element type is wrong!"), !1;
    return !0
};
cc.arrayRemoveObject = function (a, b) {
    for (var d = 0, e = a.length; d < e; d++)if (a[d] === b) {
        a.splice(d, 1);
        break
    }
};
cc.arrayRemoveArray = function (a, b) {
    for (var d = 0, e = b.length; d < e; d++)cc.arrayRemoveObject(a, b[d])
};
cc.arrayAppendObjectsToIndex = function (a, b, d) {
    a.splice.apply(a, [d, 0].concat(b));
    return a
};
cc.copyArray = function (a) {
    var b, d = a.length, e = Array(d);
    for (b = 0; b < d; b += 1)e[b] = a[b];
    return e
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.color = function (a, d, e, f, g, h) {
            return void 0 === a ? new cc.Color(0, 0, 0, 255, g, h) : cc.isString(a) ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : cc.isObject(a) ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, d, e, f, g, h)
        };
        cc.Color = function (a, d, e, f, g, h) {
            this._arrayBuffer = g || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
            this._offset = h || 0;
            g = this._arrayBuffer;
            h = this._offset;
            var n =
                Uint8Array.BYTES_PER_ELEMENT;
            this._rU8 = new Uint8Array(g, h, 1);
            this._gU8 = new Uint8Array(g, h + n, 1);
            this._bU8 = new Uint8Array(g, h + 2 * n, 1);
            this._aU8 = new Uint8Array(g, h + 3 * n, 1);
            this._rU8[0] = a || 0;
            this._gU8[0] = d || 0;
            this._bU8[0] = e || 0;
            this._aU8[0] = null == f ? 255 : f;
            void 0 === f && (this.a_undefined = !0)
        };
        cc.Color.BYTES_PER_ELEMENT = 4;
        var a = cc.Color.prototype;
        a._getR = function () {
            return this._rU8[0]
        };
        a._setR = function (a) {
            this._rU8[0] = 0 > a ? 0 : a
        };
        a._getG = function () {
            return this._gU8[0]
        };
        a._setG = function (a) {
            this._gU8[0] = 0 > a ? 0 : a
        };
        a._getB = function () {
            return this._bU8[0]
        };
        a._setB = function (a) {
            this._bU8[0] = 0 > a ? 0 : a
        };
        a._getA = function () {
            return this._aU8[0]
        };
        a._setA = function (a) {
            this._aU8[0] = 0 > a ? 0 : a
        };
        cc.defineGetterSetter(a, "r", a._getR, a._setR);
        cc.defineGetterSetter(a, "g", a._getG, a._setG);
        cc.defineGetterSetter(a, "b", a._getB, a._setB);
        cc.defineGetterSetter(a, "a", a._getA, a._setA);
        cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
        cc._tmp.PrototypeColor();
        delete cc._tmp.PrototypeColor
    }
});
cc._tmp.PrototypeColor = function () {
    var a = cc.color;
    a._getWhite = function () {
        return a(255, 255, 255)
    };
    a._getYellow = function () {
        return a(255, 255, 0)
    };
    a._getBlue = function () {
        return a(0, 0, 255)
    };
    a._getGreen = function () {
        return a(0, 255, 0)
    };
    a._getRed = function () {
        return a(255, 0, 0)
    };
    a._getMagenta = function () {
        return a(255, 0, 255)
    };
    a._getBlack = function () {
        return a(0, 0, 0)
    };
    a._getOrange = function () {
        return a(255, 127, 0)
    };
    a._getGray = function () {
        return a(166, 166, 166)
    };
    cc.defineGetterSetter(a, "WHITE", a._getWhite);
    cc.defineGetterSetter(a,
        "YELLOW", a._getYellow);
    cc.defineGetterSetter(a, "BLUE", a._getBlue);
    cc.defineGetterSetter(a, "GREEN", a._getGreen);
    cc.defineGetterSetter(a, "RED", a._getRed);
    cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
    cc.defineGetterSetter(a, "BLACK", a._getBlack);
    cc.defineGetterSetter(a, "ORANGE", a._getOrange);
    cc.defineGetterSetter(a, "GRAY", a._getGray);
    cc.BlendFunc._disable = function () {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    };
    cc.BlendFunc._alphaPremultiplied = function () {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._alphaNonPremultiplied = function () {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._additive = function () {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    };
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function (a, b, d, e) {
    this.r = a || 0;
    this.g = b || 0;
    this.b = d || 0;
    this.a = null == e ? 255 : e
};
cc.color = function (a, b, d, e) {
    return void 0 === a ? {r: 0, g: 0, b: 0, a: 255} : cc.isString(a) ? cc.hexToColor(a) : cc.isObject(a) ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: null == a.a ? 255 : a.a
    } : {r: a, g: b, b: d, a: null == e ? 255 : e}
};
cc.colorEqual = function (a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
};
cc.Acceleration = function (a, b, d, e) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = d || 0;
    this.timestamp = e || 0
};
cc.Vertex2F = function (a, b, d, e) {
    this._arrayBuffer = d || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
    this._offset = e || 0;
    this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
    this._xF32[0] = a || 0;
    this._yF32[0] = b || 0
};
cc.Vertex2F.BYTES_PER_ELEMENT = 8;
_p = cc.Vertex2F.prototype;
_p._getX = function () {
    return this._xF32[0]
};
_p._setX = function (a) {
    this._xF32[0] = a
};
_p._getY = function () {
    return this._yF32[0]
};
_p._setY = function (a) {
    this._yF32[0] = a
};
cc.defineGetterSetter(_p, "x", _p._getX, _p._setX);
cc.defineGetterSetter(_p, "y", _p._getY, _p._setY);
cc.Vertex3F = function (a, b, d, e, f) {
    this._arrayBuffer = e || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
    this._offset = f || 0;
    e = this._arrayBuffer;
    f = this._offset;
    this._xF32 = new Float32Array(e, f, 1);
    this._xF32[0] = a || 0;
    this._yF32 = new Float32Array(e, f + Float32Array.BYTES_PER_ELEMENT, 1);
    this._yF32[0] = b || 0;
    this._zF32 = new Float32Array(e, f + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
    this._zF32[0] = d || 0
};
cc.Vertex3F.BYTES_PER_ELEMENT = 12;
_p = cc.Vertex3F.prototype;
_p._getX = function () {
    return this._xF32[0]
};
_p._setX = function (a) {
    this._xF32[0] = a
};
_p._getY = function () {
    return this._yF32[0]
};
_p._setY = function (a) {
    this._yF32[0] = a
};
_p._getZ = function () {
    return this._zF32[0]
};
_p._setZ = function (a) {
    this._zF32[0] = a
};
cc.defineGetterSetter(_p, "x", _p._getX, _p._setX);
cc.defineGetterSetter(_p, "y", _p._getY, _p._setY);
cc.defineGetterSetter(_p, "z", _p._getZ, _p._setZ);
cc.Tex2F = function (a, b, d, e) {
    this._arrayBuffer = d || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
    this._offset = e || 0;
    this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
    this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
    this._uF32[0] = a || 0;
    this._vF32[0] = b || 0
};
cc.Tex2F.BYTES_PER_ELEMENT = 8;
_p = cc.Tex2F.prototype;
_p._getU = function () {
    return this._uF32[0]
};
_p._setU = function (a) {
    this._uF32[0] = a
};
_p._getV = function () {
    return this._vF32[0]
};
_p._setV = function (a) {
    this._vF32[0] = a
};
cc.defineGetterSetter(_p, "u", _p._getU, _p._setU);
cc.defineGetterSetter(_p, "v", _p._getV, _p._setV);
cc.Quad2 = function (a, b, d, e, f, g) {
    this._arrayBuffer = f || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
    this._offset = g || 0;
    f = this._arrayBuffer;
    g = cc.Vertex2F.BYTES_PER_ELEMENT;
    this._tl = a ? new cc.Vertex2F(a.x, a.y, f, 0) : new cc.Vertex2F(0, 0, f, 0);
    this._tr = b ? new cc.Vertex2F(b.x, b.y, f, g) : new cc.Vertex2F(0, 0, f, g);
    this._bl = d ? new cc.Vertex2F(d.x, d.y, f, 2 * g) : new cc.Vertex2F(0, 0, f, 2 * g);
    this._br = e ? new cc.Vertex2F(e.x, e.y, f, 3 * g) : new cc.Vertex2F(0, 0, f, 3 * g)
};
cc.Quad2.BYTES_PER_ELEMENT = 32;
_p = cc.Quad2.prototype;
_p._getTL = function () {
    return this._tl
};
_p._setTL = function (a) {
    this._tl.x = a.x;
    this._tl.y = a.y
};
_p._getTR = function () {
    return this._tr
};
_p._setTR = function (a) {
    this._tr.x = a.x;
    this._tr.y = a.y
};
_p._getBL = function () {
    return this._bl
};
_p._setBL = function (a) {
    this._bl.x = a.x;
    this._bl.y = a.y
};
_p._getBR = function () {
    return this._br
};
_p._setBR = function (a) {
    this._br.x = a.x;
    this._br.y = a.y
};
cc.defineGetterSetter(_p, "tl", _p._getTL, _p._setTL);
cc.defineGetterSetter(_p, "tr", _p._getTR, _p._setTR);
cc.defineGetterSetter(_p, "bl", _p._getBL, _p._setBL);
cc.defineGetterSetter(_p, "br", _p._getBR, _p._setBR);
cc.Quad3 = function (a, b, d, e) {
    this.bl = a || new cc.Vertex3F(0, 0, 0);
    this.br = b || new cc.Vertex3F(0, 0, 0);
    this.tl = d || new cc.Vertex3F(0, 0, 0);
    this.tr = e || new cc.Vertex3F(0, 0, 0)
};
cc.V3F_C4B_T2F = function (a, b, d, e, f) {
    this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = f || 0;
    e = this._arrayBuffer;
    f = this._offset;
    var g = cc.Vertex3F.BYTES_PER_ELEMENT;
    this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, e, f) : new cc.Vertex3F(0, 0, 0, e, f);
    this._colors = b ? cc.color(b.r, b.g, b.b, b.a, e, f + g) : cc.color(0, 0, 0, 0, e, f + g);
    this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
};
cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
_p = cc.V3F_C4B_T2F.prototype;
_p._getVertices = function () {
    return this._vertices
};
_p._setVertices = function (a) {
    var b = this._vertices;
    b.x = a.x;
    b.y = a.y;
    b.z = a.z
};
_p._getColor = function () {
    return this._colors
};
_p._setColor = function (a) {
    var b = this._colors;
    b.r = a.r;
    b.g = a.g;
    b.b = a.b;
    b.a = a.a
};
_p._getTexCoords = function () {
    return this._texCoords
};
_p._setTexCoords = function (a) {
    this._texCoords.u = a.u;
    this._texCoords.v = a.v
};
cc.defineGetterSetter(_p, "vertices", _p._getVertices, _p._setVertices);
cc.defineGetterSetter(_p, "colors", _p._getColor, _p._setColor);
cc.defineGetterSetter(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
cc.V3F_C4B_T2F_Quad = function (a, b, d, e, f, g) {
    this._arrayBuffer = f || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
    this._offset = g || 0;
    f = this._arrayBuffer;
    g = this._offset;
    var h = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
    this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, g) : new cc.V3F_C4B_T2F(null, null, null, f, g);
    this._bl = b ? new cc.V3F_C4B_T2F(b.vertices, b.colors, b.texCoords, f, g + h) : new cc.V3F_C4B_T2F(null, null, null, f, g + h);
    this._tr = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, f, g + 2 * h) : new cc.V3F_C4B_T2F(null,
        null, null, f, g + 2 * h);
    this._br = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, f, g + 3 * h) : new cc.V3F_C4B_T2F(null, null, null, f, g + 3 * h)
};
cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
_p = cc.V3F_C4B_T2F_Quad.prototype;
_p._getTL = function () {
    return this._tl
};
_p._setTL = function (a) {
    var b = this._tl;
    b.vertices = a.vertices;
    b.colors = a.colors;
    b.texCoords = a.texCoords
};
_p._getBL = function () {
    return this._bl
};
_p._setBL = function (a) {
    var b = this._bl;
    b.vertices = a.vertices;
    b.colors = a.colors;
    b.texCoords = a.texCoords
};
_p._getTR = function () {
    return this._tr
};
_p._setTR = function (a) {
    var b = this._tr;
    b.vertices = a.vertices;
    b.colors = a.colors;
    b.texCoords = a.texCoords
};
_p._getBR = function () {
    return this._br
};
_p._setBR = function (a) {
    var b = this._br;
    b.vertices = a.vertices;
    b.colors = a.colors;
    b.texCoords = a.texCoords
};
_p._getArrayBuffer = function () {
    return this._arrayBuffer
};
cc.defineGetterSetter(_p, "tl", _p._getTL, _p._setTL);
cc.defineGetterSetter(_p, "tr", _p._getTR, _p._setTR);
cc.defineGetterSetter(_p, "bl", _p._getBL, _p._setBL);
cc.defineGetterSetter(_p, "br", _p._getBR, _p._setBR);
cc.defineGetterSetter(_p, "arrayBuffer", _p._getArrayBuffer, null);
cc.V3F_C4B_T2F_QuadZero = function () {
    return new cc.V3F_C4B_T2F_Quad
};
cc.V3F_C4B_T2F_QuadCopy = function (a) {
    if (!a)return cc.V3F_C4B_T2F_QuadZero();
    var b = a.tl, d = a.bl, e = a.tr;
    a = a.br;
    return {
        tl: {
            vertices: {x: b.vertices.x, y: b.vertices.y, z: b.vertices.z},
            colors: {r: b.colors.r, g: b.colors.g, b: b.colors.b, a: b.colors.a},
            texCoords: {u: b.texCoords.u, v: b.texCoords.v}
        },
        bl: {
            vertices: {x: d.vertices.x, y: d.vertices.y, z: d.vertices.z},
            colors: {r: d.colors.r, g: d.colors.g, b: d.colors.b, a: d.colors.a},
            texCoords: {u: d.texCoords.u, v: d.texCoords.v}
        },
        tr: {
            vertices: {x: e.vertices.x, y: e.vertices.y, z: e.vertices.z},
            colors: {r: e.colors.r, g: e.colors.g, b: e.colors.b, a: e.colors.a},
            texCoords: {u: e.texCoords.u, v: e.texCoords.v}
        },
        br: {
            vertices: {x: a.vertices.x, y: a.vertices.y, z: a.vertices.z},
            colors: {r: a.colors.r, g: a.colors.g, b: a.colors.b, a: a.colors.a},
            texCoords: {u: a.texCoords.u, v: a.texCoords.v}
        }
    }
};
cc.V3F_C4B_T2F_QuadsCopy = function (a) {
    if (!a)return [];
    for (var b = [], d = 0; d < a.length; d++)b.push(cc.V3F_C4B_T2F_QuadCopy(a[d]));
    return b
};
cc.V2F_C4B_T2F = function (a, b, d, e, f) {
    this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
    this._offset = f || 0;
    e = this._arrayBuffer;
    f = this._offset;
    var g = cc.Vertex2F.BYTES_PER_ELEMENT;
    this._vertices = a ? new cc.Vertex2F(a.x, a.y, e, f) : new cc.Vertex2F(0, 0, e, f);
    this._colors = b ? cc.color(b.r, b.g, b.b, b.a, e, f + g) : cc.color(0, 0, 0, 0, e, f + g);
    this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
};
cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
_p = cc.V2F_C4B_T2F.prototype;
_p._getVertices = function () {
    return this._vertices
};
_p._setVertices = function (a) {
    this._vertices.x = a.x;
    this._vertices.y = a.y
};
_p._getColor = function () {
    return this._colors
};
_p._setColor = function (a) {
    var b = this._colors;
    b.r = a.r;
    b.g = a.g;
    b.b = a.b;
    b.a = a.a
};
_p._getTexCoords = function () {
    return this._texCoords
};
_p._setTexCoords = function (a) {
    this._texCoords.u = a.u;
    this._texCoords.v = a.v
};
cc.defineGetterSetter(_p, "vertices", _p._getVertices, _p._setVertices);
cc.defineGetterSetter(_p, "colors", _p._getColor, _p._setColor);
cc.defineGetterSetter(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
cc.V2F_C4B_T2F_Triangle = function (a, b, d, e, f) {
    this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
    this._offset = f || 0;
    e = this._arrayBuffer;
    f = this._offset;
    var g = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
    this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, e, f) : new cc.V2F_C4B_T2F(null, null, null, e, f);
    this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, e, f + g) : new cc.V2F_C4B_T2F(null, null, null, e, f + g);
    this._c = d ? new cc.V2F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 2 * g) : new cc.V2F_C4B_T2F(null,
        null, null, e, f + 2 * g)
};
cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
_p = cc.V2F_C4B_T2F_Triangle.prototype;
_p._getA = function () {
    return this._a
};
_p._setA = function (a) {
    var b = this._a;
    b.vertices = a.vertices;
    b.colors = a.colors;
    b.texCoords = a.texCoords
};
_p._getB = function () {
    return this._b
};
_p._setB = function (a) {
    var b = this._b;
    b.vertices = a.vertices;
    b.colors = a.colors;
    b.texCoords = a.texCoords
};
_p._getC = function () {
    return this._c
};
_p._setC = function (a) {
    var b = this._c;
    b.vertices = a.vertices;
    b.colors = a.colors;
    b.texCoords = a.texCoords
};
cc.defineGetterSetter(_p, "a", _p._getA, _p._setA);
cc.defineGetterSetter(_p, "b", _p._getB, _p._setB);
cc.defineGetterSetter(_p, "c", _p._getC, _p._setC);
cc.vertex2 = function (a, b) {
    return new cc.Vertex2F(a, b)
};
cc.vertex3 = function (a, b, d) {
    return new cc.Vertex3F(a, b, d)
};
cc.tex2 = function (a, b) {
    return new cc.Tex2F(a, b)
};
cc.BlendFunc = function (a, b) {
    this.src = a;
    this.dst = b
};
cc.blendFuncDisable = function () {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function (a) {
    a = a.replace(/^#?/, "0x");
    a = parseInt(a);
    return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function (a) {
    var b = a.r.toString(16), d = a.g.toString(16), e = a.b.toString(16);
    return "#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + d : d) + (16 > a.b ? "0" + e : e)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null, _valueMapTb: null, __currId: 0, ctor: function () {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | 10 * Math.random())
    }, __getKey: function () {
        this.__currId++;
        return "key_" + this.__currId
    }, setObject: function (a, b) {
        if (null != b) {
            var d = this.__getKey();
            this._keyMapTb[d] = b;
            this._valueMapTb[d] = a
        }
    }, objectForKey: function (a) {
        if (null == a)return null;
        var b = this._keyMapTb, d;
        for (d in b)if (b[d] === a)return this._valueMapTb[d];
        return null
    }, valueForKey: function (a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function (a) {
        if (null != a) {
            var b = this._keyMapTb, d;
            for (d in b)if (b[d] === a) {
                delete this._valueMapTb[d];
                delete b[d];
                break
            }
        }
    }, removeObjectsForKeys: function (a) {
        if (null != a)for (var b = 0; b < a.length; b++)this.removeObjectForKey(a[b])
    }, allKeys: function () {
        var a = [], b = this._keyMapTb, d;
        for (d in b)a.push(b[d]);
        return a
    }, removeAllObjects: function () {
        this._keyMapTb = {};
        this._valueMapTb = {}
    }, count: function () {
        return this.allKeys().length
    }
});
cc.FontDefinition = function (a) {
    this.fontName = "Arial";
    this.fontSize = 12;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = 0;
    this.strokeEnabled = !1;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.fontWeight = this.fontStyle = this.lineHeight = "normal";
    this.shadowEnabled = !1;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = 1;
    if (a && a instanceof Object)for (var b in a)this[b] =
        a[b]
};
cc.FontDefinition.prototype._getCanvasFontStr = function () {
    return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + (this.lineHeight.charAt ? this.lineHeight : this.lineHeight + "px") + " '" + this.fontName + "'"
};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    cc._renderType === cc.game.RENDER_TYPE_CANVAS && (cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"), cc._tmp.PrototypeColor(), delete cc._tmp.PrototypeColor)
});
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.__BrowserGetter = {
    init: function () {
        this.html = document.getElementsByTagName("html")[0]
    }, availWidth: function (a) {
        return a && a !== this.html ? a.clientWidth : window.innerWidth
    }, availHeight: function (a) {
        return a && a !== this.html ? a.clientHeight : window.innerHeight
    }, meta: {width: "device-width"}, adaptationType: cc.sys.browserType
};
-1 < window.navigator.userAgent.indexOf("OS 8_1_") && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI);
cc.sys.os === cc.sys.OS_IOS && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
switch (cc.__BrowserGetter.adaptationType) {
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.__BrowserGetter.meta["minimal-ui"] = "true";
        cc.__BrowserGetter.availWidth = function (a) {
            return a.clientWidth
        };
        cc.__BrowserGetter.availHeight = function (a) {
            return a.clientHeight
        };
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
        cc.__BrowserGetter.__defineGetter__("target-densitydpi", function () {
            return cc.view._targetDensityDPI
        });
    case cc.sys.BROWSER_TYPE_SOUGOU:
    case cc.sys.BROWSER_TYPE_UC:
        cc.__BrowserGetter.availWidth = function (a) {
            return a.clientWidth
        };
        cc.__BrowserGetter.availHeight = function (a) {
            return a.clientHeight
        };
        break;
    case cc.sys.BROWSER_TYPE_MIUI:
        cc.__BrowserGetter.init = function (a) {
            if (!a.__resizeWithBrowserSize) {
                var b = function () {
                    a.setDesignResolutionSize(a._designResolutionSize.width, a._designResolutionSize.height, a._resolutionPolicy);
                    window.removeEventListener("resize", b, !1)
                };
                window.addEventListener("resize", b, !1)
            }
        }
}
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !1,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    _targetDensityDPI: null,
    ctor: function () {
        var a = document, b = cc.ContainerStrategy, d = cc.ContentStrategy;
        cc.__BrowserGetter.init(this);
        this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var a = cc._canvas.width, e = cc._canvas.height;
        this._designResolutionSize = cc.size(a, e);
        this._originalDesignResolutionSize =
            cc.size(a, e);
        this._viewPortRect = cc.rect(0, 0, a, e);
        this._visibleRect = cc.rect(0, 0, a, e);
        this._contentTranslateLeftTop = {left: 0, top: 0};
        this._viewName = "Cocos2dHTML5";
        a = cc.sys;
        this.enableRetina(a.os === a.OS_IOS || a.os === a.OS_OSX);
        this.enableAutoFullScreen(a.isMobile && a.browserType !== a.BROWSER_TYPE_BAIDU);
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        this._rpExactFit = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(b.PROPORTION_TO_FRAME, d.SHOW_ALL);
        this._rpNoBorder =
            new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.NO_BORDER);
        this._rpFixedHeight = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext;
        this._targetDensityDPI = cc.DENSITYDPI_HIGH
    },
    _resizeEvent: function () {
        var a;
        a = this.setDesignResolutionSize ? this : cc.view;
        var b = a._frameSize.width, d = a._frameSize.height;
        a._initFrameSize();
        if (a._frameSize.width !== b || a._frameSize.height !== d)a._resizeCallback &&
        a._resizeCallback.call(), b = a._originalDesignResolutionSize.width, d = a._originalDesignResolutionSize.height, 0 < b && a.setDesignResolutionSize(b, d, a._resolutionPolicy)
    },
    setTargetDensityDPI: function (a) {
        this._targetDensityDPI = a;
        this._adjustViewportMeta()
    },
    getTargetDensityDPI: function () {
        return this._targetDensityDPI
    },
    resizeWithBrowserSize: function (a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), window.addEventListener("orientationchange",
            this._resizeEvent)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1, window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._resizeEvent))
    },
    setResizeCallback: function (a) {
        if (cc.isFunction(a) || null == a)this._resizeCallback = a
    },
    _initFrameSize: function () {
        var a = this._frameSize;
        a.width = cc.__BrowserGetter.availWidth(this._frame);
        a.height = cc.__BrowserGetter.availHeight(this._frame)
    },
    _adjustSizeKeepCanvasSize: function () {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    _setViewportMeta: function (a, b) {
        var d = document.getElementById("cocosMetaElement");
        d && b && document.head.removeChild(d);
        var e = document.getElementsByName("viewport"), e = e ? e[0] : null, f, g, h;
        f = e ? e.content : "";
        d = d || document.createElement("meta");
        d.id = "cocosMetaElement";
        d.name = "viewport";
        d.content = "";
        for (g in a)-1 == f.indexOf(g) ? f += "," + g + "\x3d" + a[g] : b && (h = RegExp(g + "s*\x3ds*[^,]+"), f.replace(h, g + "\x3d" + a[g]));
        /^,/.test(f) && (f = f.substr(1));
        d.content = f;
        e && (e.content = f);
        document.head.appendChild(d)
    },
    _adjustViewportMeta: function () {
        this._isAdjustViewPort && (this._setViewportMeta(cc.__BrowserGetter.meta, !1), this._isAdjustViewPort = !1)
    },
    _setScaleXYForRenderTexture: function () {
        var a = cc.contentScaleFactor();
        this._scaleY = this._scaleX = a
    },
    _resetScale: function () {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function () {
    },
    initialize: function () {
        this._initialized = !0
    },
    adjustViewPort: function (a) {
        this._isAdjustViewPort =
            a
    },
    enableRetina: function (a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function () {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function (a) {
        a && a !== this._autoFullScreen && cc.sys.isMobile && this._frame === document.documentElement ? (this._autoFullScreen = !0, cc.screen.autoFullScreen(this._frame)) : this._autoFullScreen = !1
    },
    isAutoFullScreenEnabled: function () {
        return this._autoFullScreen
    },
    end: function () {
    },
    isOpenGLReady: function () {
        return null !== this._hDC && null !== this._hRC
    },
    setFrameZoomFactor: function (a) {
        this._frameZoomFactor =
            a;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function () {
    },
    setIMEKeyboardState: function (a) {
    },
    setContentTranslateLeftTop: function (a, b) {
        this._contentTranslateLeftTop = {left: a, top: b}
    },
    getContentTranslateLeftTop: function () {
        return this._contentTranslateLeftTop
    },
    getCanvasSize: function () {
        return cc.size(cc._canvas.width, cc._canvas.height)
    },
    getFrameSize: function () {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function (a, b) {
        this._frameSize.width =
            a;
        this._frameSize.height = b;
        this._frame.style.width = a + "px";
        this._frame.style.height = b + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function () {
    },
    getVisibleSize: function () {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleSizeInPixel: function () {
        return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY)
    },
    getVisibleOrigin: function () {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    getVisibleOriginInPixel: function () {
        return cc.p(this._visibleRect.x *
            this._scaleX, this._visibleRect.y * this._scaleY)
    },
    canSetContentScaleFactor: function () {
        return !0
    },
    getResolutionPolicy: function () {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function (a) {
        if (a instanceof cc.ResolutionPolicy)this._resolutionPolicy = a; else {
            var b = cc.ResolutionPolicy;
            a === b.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
            a === b.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
            a === b.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
            a === b.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
            a === b.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function (a, b, d) {
        if (0 < a || 0 < b)if (this.setResolutionPolicy(d), d = this._resolutionPolicy) {
            d.preApply(this);
            cc.sys.isMobile && this._adjustViewportMeta();
            this._initFrameSize();
            this._originalDesignResolutionSize.width = this._designResolutionSize.width = a;
            this._originalDesignResolutionSize.height = this._designResolutionSize.height = b;
            var e = d.apply(this, this._designResolutionSize);
            e.scale && 2 === e.scale.length && (this._scaleX =
                e.scale[0], this._scaleY = e.scale[1]);
            e.viewport && (a = this._viewPortRect, b = this._visibleRect, e = e.viewport, a.x = e.x, a.y = e.y, a.width = e.width, a.height = e.height, b.x = -a.x / this._scaleX, b.y = -a.y / this._scaleY, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, cc._renderContext.setOffset && cc._renderContext.setOffset(a.x, -a.y));
            a = cc.director;
            a._winSizeInPoints.width = this._designResolutionSize.width;
            a._winSizeInPoints.height = this._designResolutionSize.height;
            d.postApply(this);
            cc.winSize.width =
                a._winSizeInPoints.width;
            cc.winSize.height = a._winSizeInPoints.height;
            cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.setGLDefaultValues();
            this._originalScaleX = this._scaleX;
            this._originalScaleY = this._scaleY;
            cc.DOM && cc.DOM._resetEGLViewDiv();
            cc.visibleRect && cc.visibleRect.init(this._visibleRect)
        } else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2); else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize)
    },
    getDesignResolutionSize: function () {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setRealPixelResolution: function (a, b, d) {
        this._setViewportMeta({width: a, "target-densitydpi": cc.DENSITYDPI_DEVICE}, !0);
        document.body.style.width = a + "px";
        document.body.style.left = "0px";
        document.body.style.top = "0px";
        this.setDesignResolutionSize(a, b, d)
    },
    setViewPortInPoints: function (a, b, d, e) {
        var f = this._frameZoomFactor, g = this._scaleX, h = this._scaleY;
        cc._renderContext.viewport(a * g * f + this._viewPortRect.x * f, b * h * f + this._viewPortRect.y * f, d * g * f, e * h * f)
    },
    setScissorInPoints: function (a, b, d, e) {
        var f = this._frameZoomFactor,
            g = this._scaleX, h = this._scaleY;
        cc._renderContext.scissor(a * g * f + this._viewPortRect.x * f, b * h * f + this._viewPortRect.y * f, d * g * f, e * h * f)
    },
    isScissorEnabled: function () {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function () {
        var a = cc._renderContext, b = this._scaleX, d = this._scaleY, a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) / b, (a[1] - this._viewPortRect.y) / d, a[2] / b, a[3] / d)
    },
    setViewName: function (a) {
        null != a && 0 < a.length && (this._viewName = a)
    },
    getViewName: function () {
        return this._viewName
    },
    getViewPortRect: function () {
        return this._viewPortRect
    },
    getScaleX: function () {
        return this._scaleX
    },
    getScaleY: function () {
        return this._scaleY
    },
    getDevicePixelRatio: function () {
        return this._devicePixelRatio
    },
    convertToLocationInView: function (a, b, d) {
        return {x: this._devicePixelRatio * (a - d.left), y: this._devicePixelRatio * (d.top + d.height - b)}
    },
    _convertMouseToLocationInView: function (a, b) {
        var d = this._viewPortRect;
        a.x = (this._devicePixelRatio * (a.x - b.left) - d.x) / this._scaleX;
        a.y = (this._devicePixelRatio * (b.top + b.height -
            a.y) - d.y) / this._scaleY
    },
    _convertTouchesWithScale: function (a) {
        for (var b = this._viewPortRect, d = this._scaleX, e = this._scaleY, f, g, h, n = 0; n < a.length; n++)f = a[n], g = f._point, h = f._prevPoint, f._setPoint((g.x - b.x) / d, (g.y - b.y) / e), f._setPrevPoint((h.x - b.x) / d, (h.y - b.y) / e)
    }
});
cc.EGLView._getInstance = function () {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function (a) {
    }, apply: function (a, b) {
    }, postApply: function (a) {
    }, _setupContainer: function (a, b, d) {
        var e = cc._canvas, f = cc.container;
        f.style.width = e.style.width = b + "px";
        f.style.height = e.style.height = d + "px";
        f = a._devicePixelRatio = 1;
        a.isRetinaEnabled() && (f = a._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1));
        e.width = b * f;
        e.height = d * f;
        cc._renderContext.resetCache && cc._renderContext.resetCache();
        a = document.body;
        var g;
        a && (g = a.style) && (g.paddingTop = g.paddingTop ||
            "0px", g.paddingRight = g.paddingRight || "0px", g.paddingBottom = g.paddingBottom || "0px", g.paddingLeft = g.paddingLeft || "0px", g.borderTop = g.borderTop || "0px", g.borderRight = g.borderRight || "0px", g.borderBottom = g.borderBottom || "0px", g.borderLeft = g.borderLeft || "0px", g.marginTop = g.marginTop || "0px", g.marginRight = g.marginRight || "0px", g.marginBottom = g.marginBottom || "0px", g.marginLeft = g.marginLeft || "0px")
    }, _fixContainer: function () {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var a = document.body.style;
        a.width = window.innerWidth + "px";
        a.height = window.innerHeight + "px";
        a.overflow = "hidden";
        a = cc.container.style;
        a.position = "fixed";
        a.left = a.top = "0px";
        document.body.scrollTop = 0
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {scale: [1, 1], viewport: null},
    _buildResult: function (a, b, d, e, f, g) {
        2 > Math.abs(a - d) && (d = a);
        2 > Math.abs(b - e) && (e = b);
        a = cc.rect(Math.round((a - d) / 2), Math.round((b - e) / 2), d, e);
        this._result.scale = [f, g];
        this._result.viewport = a;
        return this._result
    },
    preApply: function (a) {
    },
    apply: function (a, b) {
        return {scale: [1, 1]}
    },
    postApply: function (a) {
    }
});
(function () {
    var a = cc.ContainerStrategy.extend({
        apply: function (a) {
            this._setupContainer(a, a._frameSize.width, a._frameSize.height)
        }
    }), b = cc.ContainerStrategy.extend({
        apply: function (a, b) {
            var d = a._frameSize.width, e = a._frameSize.height, f = cc.container.style, s = b.width, t = b.height, v = d / s, u = e / t, x, w;
            v < u ? (x = d, w = t * v) : (x = s * u, w = e);
            s = Math.round((d - x) / 2);
            w = Math.round((e - w) / 2);
            this._setupContainer(a, d - 2 * s, e - 2 * w);
            f.marginLeft = s + "px";
            f.marginRight = s + "px";
            f.marginTop = w + "px";
            f.marginBottom = w + "px"
        }
    });
    a.extend({
        preApply: function (a) {
            this._super(a);
            a._frame = document.documentElement
        }, apply: function (a) {
            this._super(a);
            this._fixContainer()
        }
    });
    b.extend({
        preApply: function (a) {
            this._super(a);
            a._frame = document.documentElement
        }, apply: function (a, b) {
            this._super(a, b);
            this._fixContainer()
        }
    });
    var d = cc.ContainerStrategy.extend({
        apply: function (a) {
            this._setupContainer(a, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new b;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new d;
    var a = cc.ContentStrategy.extend({
        apply: function (a,
                         b) {
            var d = cc._canvas.width, e = cc._canvas.height;
            return this._buildResult(d, e, d, e, d / b.width, e / b.height)
        }
    }), b = cc.ContentStrategy.extend({
        apply: function (a, b) {
            var d = cc._canvas.width, e = cc._canvas.height, f = b.width, s = b.height, t = d / f, v = e / s, u = 0, x, w;
            t < v ? (u = t, x = d, w = s * u) : (u = v, x = f * u, w = e);
            return this._buildResult(d, e, x, w, u, u)
        }
    }), d = cc.ContentStrategy.extend({
        apply: function (a, b) {
            var d = cc._canvas.width, e = cc._canvas.height, f = b.width, s = b.height, t = d / f, v = e / s, u, x, w;
            t < v ? (u = v, x = f * u, w = e) : (u = t, x = d, w = s * u);
            return this._buildResult(d,
                e, x, w, u, u)
        }
    }), e = cc.ContentStrategy.extend({
        apply: function (a, b) {
            var d = cc._canvas.width, e = cc._canvas.height, f = e / b.height;
            return this._buildResult(d, e, d, e, f, f)
        }, postApply: function (a) {
            cc.director._winSizeInPoints = a.getVisibleSize()
        }
    }), f = cc.ContentStrategy.extend({
        apply: function (a, b) {
            var d = cc._canvas.width, e = cc._canvas.height, f = d / b.width;
            return this._buildResult(d, e, d, e, f, f)
        }, postApply: function (a) {
            cc.director._winSizeInPoints = a.getVisibleSize()
        }
    });
    cc.ContentStrategy.EXACT_FIT = new a;
    cc.ContentStrategy.SHOW_ALL =
        new b;
    cc.ContentStrategy.NO_BORDER = new d;
    cc.ContentStrategy.FIXED_HEIGHT = new e;
    cc.ContentStrategy.FIXED_WIDTH = new f
})();
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null, _contentStrategy: null, ctor: function (a, b) {
        this.setContainerStrategy(a);
        this.setContentStrategy(b)
    }, preApply: function (a) {
        this._containerStrategy.preApply(a);
        this._contentStrategy.preApply(a)
    }, apply: function (a, b) {
        this._containerStrategy.apply(a, b);
        return this._contentStrategy.apply(a, b)
    }, postApply: function (a) {
        this._containerStrategy.postApply(a);
        this._contentStrategy.postApply(a)
    }, setContainerStrategy: function (a) {
        a instanceof cc.ContainerStrategy &&
        (this._containerStrategy = a)
    }, setContentStrategy: function (a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"], ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen",
        "mozFullScreenElement"], ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]],
    init: function () {
        this._fn = {};
        var a, b, d = this._fnMap, e;
        a = 0;
        for (l = d.length; a < l; a++)if ((b = d[a]) && b[1] in document) {
            a = 0;
            for (e = b.length; a < e; a++)this._fn[d[0][a]] = b[a];
            break
        }
        this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function () {
        return this._supportsFullScreen ? void 0 ===
        document[this._fn.fullscreenElement] || null === document[this._fn.fullscreenElement] ? !1 : !0 : !1
    },
    requestFullScreen: function (a, b) {
        if (this._supportsFullScreen) {
            a = a || document.documentElement;
            if (b) {
                var d = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(d, this._preOnFullScreenChange);
                this._preOnFullScreenChange = b;
                document.addEventListener(d, b, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function () {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() :
            !0
    },
    autoFullScreen: function (a, b) {
        function d() {
            e.removeEventListener(f._touchEvent, d);
            f.requestFullScreen(a, b)
        }

        a = a || document.body;
        var e = cc.game.canvas || a, f = this;
        this.requestFullScreen(a, b);
        e.addEventListener(this._touchEvent, d)
    }
};
cc.screen.init();
cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function (a) {
        var b = this.width = a.width, d = this.height = a.height, e = a.x;
        a = a.y;
        var f = a + d, g = e + b;
        this.topLeft.x = e;
        this.topLeft.y = f;
        this.topRight.x = g;
        this.topRight.y = f;
        this.top.x = e + b / 2;
        this.top.y = f;
        this.bottomLeft.x = e;
        this.bottomLeft.y = a;
        this.bottomRight.x = g;
        this.bottomRight.y = a;
        this.bottom.x = e + b / 2;
        this.bottom.y =
            a;
        this.center.x = e + b / 2;
        this.center.y = a + d / 2;
        this.left.x = e;
        this.left.y = a + d / 2;
        this.right.x = g;
        this.right.y = a + d / 2
    }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function () {
        for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
            if (!(a & 1))return this._indexBitsUsed |= 1 << b, b;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function (a) {
        0 > a ||
        a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
    },
    _glView: null,
    handleTouchesBegin: function (a) {
        for (var b, d, e, f = [], g = this._touchesIntegerDict, h = 0, n = a.length; h < n; h++)if (b = a[h], e = b.getID(), d = g[e], null == d) {
            var p = this._getUnUsedIndex();
            -1 === p ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, p) : (d = this._touches[p] = new cc.Touch(b._point.x, b._point.y, b.getID()), d._setPrevPoint(b._prevPoint), g[e] = p, f.push(d))
        }
        0 < f.length && (this._glView._convertTouchesWithScale(f), a = new cc.EventTouch(f), a._eventCode =
            cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesMove: function (a) {
        for (var b, d, e = [], f = this._touches, g = 0, h = a.length; g < h; g++)b = a[g], d = b.getID(), d = this._touchesIntegerDict[d], null != d && f[d] && (f[d]._setPoint(b._point), f[d]._setPrevPoint(b._prevPoint), e.push(f[d]));
        0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesEnd: function (a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesCancel: function (a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
    },
    getSetOfTouchesEndOrCancel: function (a) {
        for (var b, d, e, f = [], g = this._touches, h = this._touchesIntegerDict, n = 0, p = a.length; n <
        p; n++)b = a[n], e = b.getID(), d = h[e], null != d && g[d] && (g[d]._setPoint(b._point), g[d]._setPrevPoint(b._prevPoint), f.push(g[d]), this._removeUsedIndexBit(d), delete h[e]);
        return f
    },
    getHTMLElementPosition: function (a) {
        var b = document.documentElement, d = window, e = null, e = cc.isFunction(a.getBoundingClientRect) ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
            left: 0,
            top: 0,
            width: a.width,
            height: a.height
        } : {left: 0, top: 0, width: parseInt(a.style.width), height: parseInt(a.style.height)};
        return {
            left: e.left + d.pageXOffset -
            b.clientLeft, top: e.top + d.pageYOffset - b.clientTop, width: e.width, height: e.height
        }
    },
    getPreTouch: function (a) {
        for (var b = null, d = this._preTouchPool, e = a.getID(), f = d.length - 1; 0 <= f; f--)if (d[f].getID() === e) {
            b = d[f];
            break
        }
        b || (b = a);
        return b
    },
    setPreTouch: function (a) {
        for (var b = !1, d = this._preTouchPool, e = a.getID(), f = d.length - 1; 0 <= f; f--)if (d[f].getID() === e) {
            d[f] = a;
            b = !0;
            break
        }
        b || (50 >= d.length ? d.push(a) : (d[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function (a,
                            b, d) {
        var e = this._preTouchPoint;
        a = this._glView.convertToLocationInView(a, b, d);
        b = new cc.Touch(a.x, a.y);
        b._setPrevPoint(e.x, e.y);
        e.x = a.x;
        e.y = a.y;
        return b
    },
    getMouseEvent: function (a, b, d) {
        var e = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(a, b);
        b = new cc.EventMouse(d);
        b.setLocation(a.x, a.y);
        b._setPrevCursor(e.x, e.y);
        e.x = a.x;
        e.y = a.y;
        return b
    },
    getPointByEvent: function (a, b) {
        if (null != a.pageX)return {x: a.pageX, y: a.pageY};
        b.left -= document.body.scrollLeft;
        b.top -= document.body.scrollTop;
        return {
            x: a.clientX,
            y: a.clientY
        }
    },
    getTouchesByEvent: function (a, b) {
        for (var d = [], e = this._glView, f, g, h = this._preTouchPoint, n = a.changedTouches.length, p = 0; p < n; p++)if (f = a.changedTouches[p]) {
            var r;
            r = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? e.convertToLocationInView(f.pageX, f.pageY, b) : e.convertToLocationInView(f.clientX, f.clientY, b);
            null != f.identifier ? (f = new cc.Touch(r.x, r.y, f.identifier), g = this.getPreTouch(f).getLocation(), f._setPrevPoint(g.x, g.y), this.setPreTouch(f)) : (f = new cc.Touch(r.x, r.y), f._setPrevPoint(h.x, h.y));
            h.x = r.x;
            h.y = r.y;
            d.push(f)
        }
        return d
    },
    registerSystemEvent: function (a) {
        if (!this._isRegisterEvent) {
            this._glView = cc.view;
            var b = this, d = "mouse" in cc.sys.capabilities, e = "touches" in cc.sys.capabilities, f = !1;
            cc.sys.isMobile && (f = !0);
            d && (window.addEventListener("mousedown", function () {
                b._mousePressed = !0
            }, !1), window.addEventListener("mouseup", function (d) {
                if (!f) {
                    var e = b._mousePressed;
                    b._mousePressed = !1;
                    if (e) {
                        var e = b.getHTMLElementPosition(a), g = b.getPointByEvent(d, e);
                        cc.rectContainsPoint(new cc.Rect(e.left, e.top,
                            e.width, e.height), g) || (b.handleTouchesEnd([b.getTouchByXY(g.x, g.y, e)]), e = b.getMouseEvent(g, e, cc.EventMouse.UP), e.setButton(d.button), cc.eventManager.dispatchEvent(e))
                    }
                }
            }, !1), a.addEventListener("mousedown", function (d) {
                if (!f) {
                    b._mousePressed = !0;
                    var e = b.getHTMLElementPosition(a), g = b.getPointByEvent(d, e);
                    b.handleTouchesBegin([b.getTouchByXY(g.x, g.y, e)]);
                    e = b.getMouseEvent(g, e, cc.EventMouse.DOWN);
                    e.setButton(d.button);
                    cc.eventManager.dispatchEvent(e);
                    d.stopPropagation();
                    d.preventDefault();
                    a.focus()
                }
            }, !1),
                a.addEventListener("mouseup", function (d) {
                    if (!f) {
                        b._mousePressed = !1;
                        var e = b.getHTMLElementPosition(a), g = b.getPointByEvent(d, e);
                        b.handleTouchesEnd([b.getTouchByXY(g.x, g.y, e)]);
                        e = b.getMouseEvent(g, e, cc.EventMouse.UP);
                        e.setButton(d.button);
                        cc.eventManager.dispatchEvent(e);
                        d.stopPropagation();
                        d.preventDefault()
                    }
                }, !1), a.addEventListener("mousemove", function (d) {
                if (!f) {
                    var e = b.getHTMLElementPosition(a), g = b.getPointByEvent(d, e);
                    b.handleTouchesMove([b.getTouchByXY(g.x, g.y, e)]);
                    e = b.getMouseEvent(g, e, cc.EventMouse.MOVE);
                    b._mousePressed ? e.setButton(d.button) : e.setButton(null);
                    cc.eventManager.dispatchEvent(e);
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1), a.addEventListener("mousewheel", function (d) {
                var e = b.getHTMLElementPosition(a), f = b.getPointByEvent(d, e), e = b.getMouseEvent(f, e, cc.EventMouse.SCROLL);
                e.setButton(d.button);
                e.setScrollData(0, d.wheelDelta);
                cc.eventManager.dispatchEvent(e);
                d.stopPropagation();
                d.preventDefault()
            }, !1), a.addEventListener("DOMMouseScroll", function (d) {
                var e = b.getHTMLElementPosition(a), f = b.getPointByEvent(d,
                    e), e = b.getMouseEvent(f, e, cc.EventMouse.SCROLL);
                e.setButton(d.button);
                e.setScrollData(0, -120 * d.detail);
                cc.eventManager.dispatchEvent(e);
                d.stopPropagation();
                d.preventDefault()
            }, !1));
            if (window.navigator.msPointerEnabled) {
                var d = {
                    MSPointerDown: b.handleTouchesBegin,
                    MSPointerMove: b.handleTouchesMove,
                    MSPointerUp: b.handleTouchesEnd,
                    MSPointerCancel: b.handleTouchesCancel
                }, g;
                for (g in d)(function (d, e) {
                    a.addEventListener(d, function (d) {
                        var f = b.getHTMLElementPosition(a);
                        f.left -= document.documentElement.scrollLeft;
                        f.top -= document.documentElement.scrollTop;
                        e.call(b, [b.getTouchByXY(d.clientX, d.clientY, f)]);
                        d.stopPropagation()
                    }, !1)
                })(g, d[g])
            }
            e && (a.addEventListener("touchstart", function (d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesBegin(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault();
                    a.focus()
                }
            }, !1), a.addEventListener("touchmove", function (d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -=
                        document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesMove(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1), a.addEventListener("touchend", function (d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesEnd(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1), a.addEventListener("touchcancel", function (d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -=
                        document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesCancel(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1));
            this._registerKeyboardEvent();
            this._registerAccelerometerEvent();
            this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function () {
    },
    _registerAccelerometerEvent: function () {
    },
    update: function (a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
        this._accelCurTime +=
            a
    }
};
_p = cc.inputManager;
_p.setAccelerometerEnabled = function (a) {
    this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelCurTime = 0, a.scheduleUpdate(this))
};
_p.setAccelerometerInterval = function (a) {
    this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function () {
    cc._canvas.addEventListener("keydown", function (a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
        a.stopPropagation();
        a.preventDefault()
    }, !1);
    cc._canvas.addEventListener("keyup", function (a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
        a.stopPropagation();
        a.preventDefault()
    }, !1)
};
_p._registerAccelerometerEvent = function () {
    var a = window;
    this._acceleration = new cc.Acceleration;
    this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
    cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var b = this._accelDeviceEvent === a.DeviceMotionEvent ? "devicemotion" : "deviceorientation", d = navigator.userAgent;
    if (/Android/.test(d) || /Adr/.test(d) && cc.sys.browserType === cc.BROWSER_TYPE_UC)this._minus = -1;
    a.addEventListener(b, this.didAccelerate.bind(this),
        !1)
};
_p.didAccelerate = function (a) {
    var b = window;
    if (this._accelEnabled) {
        var d = this._acceleration, e, f, g;
        this._accelDeviceEvent === window.DeviceMotionEvent ? (g = a.accelerationIncludingGravity, e = this._accelMinus * g.x * 0.1, f = this._accelMinus * g.y * 0.1, g = 0.1 * g.z) : (e = a.gamma / 90 * 0.981, f = 0.981 * -(a.beta / 90), g = a.alpha / 90 * 0.981);
        d.x = e;
        d.y = f;
        d.z = g;
        d.timestamp = a.timeStamp || Date.now();
        a = d.x;
        b.orientation === cc.UIInterfaceOrientationLandscapeRight ? (d.x = -d.y, d.y = a) : b.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (d.x = d.y,
            d.y = -a) : b.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (d.x = -d.x, d.y = -d.y)
    }
};
delete _p;
cc.AffineTransform = function (a, b, d, e, f, g) {
    this.a = a;
    this.b = b;
    this.c = d;
    this.d = e;
    this.tx = f;
    this.ty = g
};
cc.affineTransformMake = function (a, b, d, e, f, g) {
    return {a: a, b: b, c: d, d: e, tx: f, ty: g}
};
cc.pointApplyAffineTransform = function (a, b, d) {
    var e;
    void 0 === d ? (d = b, e = a.x, a = a.y) : (e = a, a = b);
    return {x: d.a * e + d.c * a + d.tx, y: d.b * e + d.d * a + d.ty}
};
cc._pointApplyAffineTransform = function (a, b, d) {
    return cc.pointApplyAffineTransform(a, b, d)
};
cc.sizeApplyAffineTransform = function (a, b) {
    return {width: b.a * a.width + b.c * a.height, height: b.b * a.width + b.d * a.height}
};
cc.affineTransformMakeIdentity = function () {
    return {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0}
};
cc.affineTransformIdentity = function () {
    return {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0}
};
cc.rectApplyAffineTransform = function (a, b) {
    var d = cc.rectGetMinY(a), e = cc.rectGetMinX(a), f = cc.rectGetMaxX(a), g = cc.rectGetMaxY(a), h = cc.pointApplyAffineTransform(e, d, b), d = cc.pointApplyAffineTransform(f, d, b), e = cc.pointApplyAffineTransform(e, g, b), n = cc.pointApplyAffineTransform(f, g, b), f = Math.min(h.x, d.x, e.x, n.x), g = Math.max(h.x, d.x, e.x, n.x), p = Math.min(h.y, d.y, e.y, n.y), h = Math.max(h.y, d.y, e.y, n.y);
    return cc.rect(f, p, g - f, h - p)
};
cc._rectApplyAffineTransformIn = function (a, b) {
    var d = cc.rectGetMinY(a), e = cc.rectGetMinX(a), f = cc.rectGetMaxX(a), g = cc.rectGetMaxY(a), h = cc.pointApplyAffineTransform(e, d, b), d = cc.pointApplyAffineTransform(f, d, b), e = cc.pointApplyAffineTransform(e, g, b), n = cc.pointApplyAffineTransform(f, g, b), f = Math.min(h.x, d.x, e.x, n.x), g = Math.max(h.x, d.x, e.x, n.x), p = Math.min(h.y, d.y, e.y, n.y), h = Math.max(h.y, d.y, e.y, n.y);
    a.x = f;
    a.y = p;
    a.width = g - f;
    a.height = h - p;
    return a
};
cc.affineTransformTranslate = function (a, b, d) {
    return {a: a.a, b: a.b, c: a.c, d: a.d, tx: a.tx + a.a * b + a.c * d, ty: a.ty + a.b * b + a.d * d}
};
cc.affineTransformScale = function (a, b, d) {
    return {a: a.a * b, b: a.b * b, c: a.c * d, d: a.d * d, tx: a.tx, ty: a.ty}
};
cc.affineTransformRotate = function (a, b) {
    var d = Math.sin(b), e = Math.cos(b);
    return {a: a.a * e + a.c * d, b: a.b * e + a.d * d, c: a.c * e - a.a * d, d: a.d * e - a.b * d, tx: a.tx, ty: a.ty}
};
cc.affineTransformConcat = function (a, b) {
    return {
        a: a.a * b.a + a.b * b.c,
        b: a.a * b.b + a.b * b.d,
        c: a.c * b.a + a.d * b.c,
        d: a.c * b.b + a.d * b.d,
        tx: a.tx * b.a + a.ty * b.c + b.tx,
        ty: a.tx * b.b + a.ty * b.d + b.ty
    }
};
cc.affineTransformConcatIn = function (a, b) {
    var d = a.a, e = a.b, f = a.c, g = a.d, h = a.tx, n = a.ty;
    a.a = d * b.a + e * b.c;
    a.b = d * b.b + e * b.d;
    a.c = f * b.a + g * b.c;
    a.d = f * b.b + g * b.d;
    a.tx = h * b.a + n * b.c + b.tx;
    a.ty = h * b.b + n * b.d + b.ty;
    return a
};
cc.affineTransformEqualToTransform = function (a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
};
cc.affineTransformInvert = function (a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: b * a.d,
        b: -b * a.b,
        c: -b * a.c,
        d: b * a.a,
        tx: b * (a.c * a.ty - a.d * a.tx),
        ty: b * (a.b * a.tx - a.a * a.ty)
    }
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function (a) {
    return cc.p(-a.x, -a.y)
};
cc.pAdd = function (a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
};
cc.pSub = function (a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
};
cc.pMult = function (a, b) {
    return cc.p(a.x * b, a.y * b)
};
cc.pMidpoint = function (a, b) {
    return cc.pMult(cc.pAdd(a, b), 0.5)
};
cc.pDot = function (a, b) {
    return a.x * b.x + a.y * b.y
};
cc.pCross = function (a, b) {
    return a.x * b.y - a.y * b.x
};
cc.pPerp = function (a) {
    return cc.p(-a.y, a.x)
};
cc.pRPerp = function (a) {
    return cc.p(a.y, -a.x)
};
cc.pProject = function (a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
};
cc.pRotate = function (a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
};
cc.pUnrotate = function (a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
};
cc.pLengthSQ = function (a) {
    return cc.pDot(a, a)
};
cc.pDistanceSQ = function (a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
};
cc.pLength = function (a) {
    return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function (a, b) {
    return cc.pLength(cc.pSub(a, b))
};
cc.pNormalize = function (a) {
    var b = cc.pLength(a);
    return 0 === b ? cc.p(a) : cc.pMult(a, 1 / b)
};
cc.pForAngle = function (a) {
    return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function (a) {
    return Math.atan2(a.y, a.x)
};
cc.clampf = function (a, b, d) {
    if (b > d) {
        var e = b;
        b = d;
        d = e
    }
    return a < b ? b : a < d ? a : d
};
cc.pClamp = function (a, b, d) {
    return cc.p(cc.clampf(a.x, b.x, d.x), cc.clampf(a.y, b.y, d.y))
};
cc.pFromSize = function (a) {
    return cc.p(a.width, a.height)
};
cc.pCompOp = function (a, b) {
    return cc.p(b(a.x), b(a.y))
};
cc.pLerp = function (a, b, d) {
    return cc.pAdd(cc.pMult(a, 1 - d), cc.pMult(b, d))
};
cc.pFuzzyEqual = function (a, b, d) {
    return a.x - d <= b.x && b.x <= a.x + d && a.y - d <= b.y && b.y <= a.y + d ? !0 : !1
};
cc.pCompMult = function (a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function (a, b) {
    var d = cc.pNormalize(a), e = cc.pNormalize(b), d = Math.atan2(d.x * e.y - d.y * e.x, cc.pDot(d, e));
    return Math.abs(d) < cc.POINT_EPSILON ? 0 : d
};
cc.pAngle = function (a, b) {
    var d = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(d) < cc.POINT_EPSILON ? 0 : d
};
cc.pRotateByAngle = function (a, b, d) {
    a = cc.pSub(a, b);
    var e = Math.cos(d);
    d = Math.sin(d);
    var f = a.x;
    a.x = f * e - a.y * d + b.x;
    a.y = f * d + a.y * e + b.y;
    return a
};
cc.pLineIntersect = function (a, b, d, e, f) {
    if (a.x === b.x && a.y === b.y || d.x === e.x && d.y === e.y)return !1;
    var g = b.x - a.x;
    b = b.y - a.y;
    var h = e.x - d.x;
    e = e.y - d.y;
    var n = a.x - d.x;
    a = a.y - d.y;
    d = e * g - h * b;
    f.x = h * a - e * n;
    f.y = g * a - b * n;
    if (0 === d)return 0 === f.x || 0 === f.y ? !0 : !1;
    f.x /= d;
    f.y /= d;
    return !0
};
cc.pSegmentIntersect = function (a, b, d, e) {
    var f = cc.p(0, 0);
    return cc.pLineIntersect(a, b, d, e, f) && 0 <= f.x && 1 >= f.x && 0 <= f.y && 1 >= f.y ? !0 : !1
};
cc.pIntersectPoint = function (a, b, d, e) {
    var f = cc.p(0, 0);
    return cc.pLineIntersect(a, b, d, e, f) ? (d = cc.p(0, 0), d.x = a.x + f.x * (b.x - a.x), d.y = a.y + f.x * (b.y - a.y), d) : cc.p(0, 0)
};
cc.pSameAs = function (a, b) {
    return null != a && null != b ? a.x === b.x && a.y === b.y : !1
};
cc.pZeroIn = function (a) {
    a.x = 0;
    a.y = 0
};
cc.pIn = function (a, b) {
    a.x = b.x;
    a.y = b.y
};
cc.pMultIn = function (a, b) {
    a.x *= b;
    a.y *= b
};
cc.pSubIn = function (a, b) {
    a.x -= b.x;
    a.y -= b.y
};
cc.pAddIn = function (a, b) {
    a.x += b.x;
    a.y += b.y
};
cc.pNormalizeIn = function (a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function (a, b, d, e, f) {
    f += e;
    if (!(1 >= f)) {
        b *= 0.5;
        for (var g, h = f - 1, n = e; n < f; n++) {
            g = 2 * n;
            var p = cc.p(a[2 * n], a[2 * n + 1]), r;
            if (0 === n)r = cc.pPerp(cc.pNormalize(cc.pSub(p, cc.p(a[2 * (n + 1)], a[2 * (n + 1) + 1])))); else if (n === h)r = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (n - 1)], a[2 * (n - 1) + 1]), p))); else {
                r = cc.p(a[2 * (n - 1)], a[2 * (n - 1) + 1]);
                var s = cc.p(a[2 * (n + 1)], a[2 * (n + 1) + 1]), t = cc.pNormalize(cc.pSub(s, p)), v = cc.pNormalize(cc.pSub(r, p)), u = Math.acos(cc.pDot(t, v));
                r = u < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(t,
                    v))) : u < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(t, v)) : cc.pPerp(cc.pNormalize(cc.pSub(s, r)))
            }
            r = cc.pMult(r, b);
            d[2 * g] = p.x + r.x;
            d[2 * g + 1] = p.y + r.y;
            d[2 * (g + 1)] = p.x - r.x;
            d[2 * (g + 1) + 1] = p.y - r.y
        }
        for (n = 0 === e ? 0 : e - 1; n < h; n++)g = 2 * n, a = g + 2, b = cc.vertex2(d[2 * g], d[2 * g + 1]), f = cc.vertex2(d[2 * (g + 1)], d[2 * (g + 1) + 1]), g = cc.vertex2(d[2 * a], d[2 * a]), e = cc.vertex2(d[2 * (a + 1)], d[2 * (a + 1) + 1]), b = !cc.vertexLineIntersect(b.x, b.y, e.x, e.y, f.x, f.y, g.x, g.y), !b.isSuccess && (0 > b.value || 1 < b.value) && (b.isSuccess = !0), b.isSuccess && (d[2 * a] = e.x,
            d[2 * a + 1] = e.y, d[2 * (a + 1)] = g.x, d[2 * (a + 1) + 1] = g.y)
    }
};
cc.vertexLineIntersect = function (a, b, d, e, f, g, h, n) {
    if (a === d && b === e || f === h && g === n)return {isSuccess: !1, value: 0};
    d -= a;
    e -= b;
    f -= a;
    g -= b;
    h -= a;
    n -= b;
    a = Math.sqrt(d * d + e * e);
    d /= a;
    e /= a;
    b = f * d + g * e;
    g = g * d - f * e;
    f = b;
    b = h * d + n * e;
    n = n * d - h * e;
    h = b;
    return g === n ? {isSuccess: !1, value: 0} : {isSuccess: !0, value: (h + (f - h) * n / (n - g)) / a}
};
cc.vertexListIsClockwise = function (a) {
    for (var b = 0, d = a.length; b < d; b++) {
        var e = a[(b + 1) % d], f = a[(b + 2) % d];
        if (0 < cc.pCross(cc.pSub(e, a[b]), cc.pSub(f, e)))return !1
    }
    return !0
};
cc.CGAffineToGL = function (a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
    b[10] = b[15] = 1;
    b[0] = a.a;
    b[4] = a.c;
    b[12] = a.tx;
    b[1] = a.b;
    b[5] = a.d;
    b[13] = a.ty
};
cc.GLToCGAffine = function (a, b) {
    b.a = a[0];
    b.c = a[4];
    b.tx = a[12];
    b.b = a[1];
    b.d = a[5];
    b.ty = a[13]
};
cc.Touch = cc.Class.extend({
    _point: null, _prevPoint: null, _id: 0, _startPointCaptured: !1, _startPoint: null, ctor: function (a, b, d) {
        this.setTouchInfo(d, a, b)
    }, getLocation: function () {
        return {x: this._point.x, y: this._point.y}
    }, getLocationX: function () {
        return this._point.x
    }, getLocationY: function () {
        return this._point.y
    }, getPreviousLocation: function () {
        return {x: this._prevPoint.x, y: this._prevPoint.y}
    }, getStartLocation: function () {
        return {x: this._startPoint.x, y: this._startPoint.y}
    }, getDelta: function () {
        return cc.pSub(this._point,
            this._prevPoint)
    }, getLocationInView: function () {
        return {x: this._point.x, y: this._point.y}
    }, getPreviousLocationInView: function () {
        return {x: this._prevPoint.x, y: this._prevPoint.y}
    }, getStartLocationInView: function () {
        return {x: this._startPoint.x, y: this._startPoint.y}
    }, getID: function () {
        return this._id
    }, getId: function () {
        cc.log("getId is deprecated. Please use getID instead.");
        return this._id
    }, setTouchInfo: function (a, b, d) {
        this._prevPoint = this._point;
        this._point = cc.p(b || 0, d || 0);
        this._id = a;
        this._startPointCaptured ||
        (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    }, _setPoint: function (a, b) {
        void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
    }, _setPrevPoint: function (a, b) {
        this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
    }
});
cc.Event = cc.Class.extend({
    _type: 0, _isStopped: !1, _currentTarget: null, _setCurrentTarget: function (a) {
        this._currentTarget = a
    }, ctor: function (a) {
        this._type = a
    }, getType: function () {
        return this._type
    }, stopPropagation: function () {
        this._isStopped = !0
    }, isStopped: function () {
        return this._isStopped
    }, getCurrentTarget: function () {
        return this._currentTarget
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.FOCUS = 4;
cc.Event.CUSTOM = 6;
cc.EventCustom = cc.Event.extend({
    _eventName: null, _userData: null, ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = a
    }, setUserData: function (a) {
        this._userData = a
    }, getUserData: function () {
        return this._userData
    }, getEventName: function () {
        return this._eventName
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0, _button: 0, _x: 0, _y: 0, _prevX: 0, _prevY: 0, _scrollX: 0, _scrollY: 0, ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = a
    }, setScrollData: function (a, b) {
        this._scrollX = a;
        this._scrollY = b
    }, getScrollX: function () {
        return this._scrollX
    }, getScrollY: function () {
        return this._scrollY
    }, setLocation: function (a, b) {
        this._x = a;
        this._y = b
    }, getLocation: function () {
        return {x: this._x, y: this._y}
    }, getLocationInView: function () {
        return {
            x: this._x, y: cc.view._designResolutionSize.height -
            this._y
        }
    }, _setPrevCursor: function (a, b) {
        this._prevX = a;
        this._prevY = b
    }, getDelta: function () {
        return {x: this._x - this._prevX, y: this._y - this._prevY}
    }, getDeltaX: function () {
        return this._x - this._prevX
    }, getDeltaY: function () {
        return this._y - this._prevY
    }, setButton: function (a) {
        this._button = a
    }, getButton: function () {
        return this._button
    }, getLocationX: function () {
        return this._x
    }, getLocationY: function () {
        return this._y
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0, _touches: null, ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = a || []
    }, getEventCode: function () {
        return this._eventCode
    }, getTouches: function () {
        return this._touches
    }, _setEventCode: function (a) {
        this._eventCode = a
    }, _setTouches: function (a) {
        this._touches = a
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {BEGAN: 0, MOVED: 1, ENDED: 2, CANCELLED: 3};
cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null, _widgetLoseFocus: null, ctor: function (a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.FOCUS);
        this._widgetGetFocus = b;
        this._widgetLoseFocus = a
    }
});
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !0,
    _isEnabled: !0,
    ctor: function (a, b, d) {
        this._onEvent = d;
        this._type = a || 0;
        this._listenerID = b || ""
    },
    _setPaused: function (a) {
        this._paused = a
    },
    _isPaused: function () {
        return this._paused
    },
    _setRegistered: function (a) {
        this._registered = a
    },
    _isRegistered: function () {
        return this._registered
    },
    _getType: function () {
        return this._type
    },
    _getListenerID: function () {
        return this._listenerID
    },
    _setFixedPriority: function (a) {
        this._fixedPriority =
            a
    },
    _getFixedPriority: function () {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function (a) {
        this._node = a
    },
    _getSceneGraphPriority: function () {
        return this._node
    },
    checkAvailable: function () {
        return null !== this._onEvent
    },
    clone: function () {
        return null
    },
    setEnabled: function (a) {
        this._isEnabled = a
    },
    isEnabled: function () {
        return this._isEnabled
    },
    retain: function () {
    },
    release: function () {
    }
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 6;
cc.EventListener.FOCUS = 7;
cc.EventListener.CUSTOM = 8;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null, ctor: function (a, b) {
        this._onCustomEvent = b;
        var d = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function (a) {
            null !== d._onCustomEvent && d._onCustomEvent(a)
        })
    }, checkAvailable: function () {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent
    }, clone: function () {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
});
cc._EventListenerCustom.create = function (a, b) {
    return new cc._EventListenerCustom(a, b)
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null, onMouseUp: null, onMouseMove: null, onMouseScroll: null, ctor: function () {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function (b) {
            var d = cc.EventMouse;
            switch (b._eventType) {
                case d.DOWN:
                    if (a.onMouseDown)a.onMouseDown(b);
                    break;
                case d.UP:
                    if (a.onMouseUp)a.onMouseUp(b);
                    break;
                case d.MOVE:
                    if (a.onMouseMove)a.onMouseMove(b);
                    break;
                case d.SCROLL:
                    if (a.onMouseScroll)a.onMouseScroll(b)
            }
        })
    },
    clone: function () {
        var a = new cc._EventListenerMouse;
        a.onMouseDown = this.onMouseDown;
        a.onMouseUp = this.onMouseUp;
        a.onMouseMove = this.onMouseMove;
        a.onMouseScroll = this.onMouseScroll;
        return a
    }, checkAvailable: function () {
        return !0
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function () {
    return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function () {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = []
    },
    setSwallowTouches: function (a) {
        this.swallowTouches = a
    },
    isSwallowTouches: function () {
        return this.swallowTouches
    },
    clone: function () {
        var a = new cc._EventListenerTouchOneByOne;
        a.onTouchBegan = this.onTouchBegan;
        a.onTouchMoved = this.onTouchMoved;
        a.onTouchEnded = this.onTouchEnded;
        a.onTouchCancelled = this.onTouchCancelled;
        a.swallowTouches = this.swallowTouches;
        return a
    },
    checkAvailable: function () {
        return this.onTouchBegan ? !0 : (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1)
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function () {
    return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null, onTouchesMoved: null, onTouchesEnded: null, onTouchesCancelled: null, ctor: function () {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    }, clone: function () {
        var a = new cc._EventListenerTouchAllAtOnce;
        a.onTouchesBegan = this.onTouchesBegan;
        a.onTouchesMoved = this.onTouchesMoved;
        a.onTouchesEnded = this.onTouchesEnded;
        a.onTouchesCancelled = this.onTouchesCancelled;
        return a
    },
    checkAvailable: function () {
        return null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function () {
    return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function (a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var b = a.event;
    delete a.event;
    var d = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? d = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? d = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? d = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (d = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? d = new cc._EventListenerKeyboard :
        b === cc.EventListener.ACCELERATION ? (d = new cc._EventListenerAcceleration(a.callback), delete a.callback) : b === cc.EventListener.FOCUS && (d = new cc._EventListenerFocus);
    for (var e in a)d[e] = a[e];
    return d
};
cc._EventListenerFocus = cc.EventListener.extend({
    clone: function () {
        var a = new cc._EventListenerFocus;
        a.onFocusChanged = this.onFocusChanged;
        return a
    }, checkAvailable: function () {
        return this.onFocusChanged ? !0 : (cc.log("Invalid EventListenerFocus!"), !1)
    }, onFocusChanged: null, ctor: function () {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, function (a) {
            if (this.onFocusChanged)this.onFocusChanged(a._widgetLoseFocus, a._widgetGetFocus)
        })
    }
});
cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event";
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null, _sceneGraphListeners: null, gt0Index: 0, ctor: function () {
        this._fixedListeners = [];
        this._sceneGraphListeners = []
    }, size: function () {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    }, empty: function () {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    }, push: function (a) {
        0 === a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    }, clearSceneGraphListeners: function () {
        this._sceneGraphListeners.length =
            0
    }, clearFixedListeners: function () {
        this._fixedListeners.length = 0
    }, clear: function () {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0
    }, getFixedPriorityListeners: function () {
        return this._fixedListeners
    }, getSceneGraphPriorityListeners: function () {
        return this._sceneGraphListeners
    }
});
cc.__getListenerID = function (a) {
    var b = cc.Event, d = a.getType();
    if (d === b.ACCELERATION)return cc._EventListenerAcceleration.LISTENER_ID;
    if (d === b.CUSTOM)return a.getEventName();
    if (d === b.KEYBOARD)return cc._EventListenerKeyboard.LISTENER_ID;
    if (d === b.MOUSE)return cc._EventListenerMouse.LISTENER_ID;
    if (d === b.FOCUS)return cc._EventListenerFocus.LISTENER_ID;
    d === b.TOUCH && cc.log(cc._LogInfos.__getListenerID);
    return ""
};
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _toRemovedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function (a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
        a = a.getChildren();
        for (var b =
            0, d = a.length; b < d; b++)this._setDirtyForNode(a[b])
    },
    pauseTarget: function (a, b) {
        var d = this._nodeListenersMap[a.__instanceId], e, f;
        if (d)for (e = 0, f = d.length; e < f; e++)d[e]._setPaused(!0);
        if (!0 === b)for (d = a.getChildren(), e = 0, f = d.length; e < f; e++)this.pauseTarget(d[e], !0)
    },
    resumeTarget: function (a, b) {
        var d = this._nodeListenersMap[a.__instanceId], e, f;
        if (d)for (e = 0, f = d.length; e < f; e++)d[e]._setPaused(!1);
        this._setDirtyForNode(a);
        if (!0 === b)for (d = a.getChildren(), e = 0, f = d.length; e < f; e++)this.resumeTarget(d[e], !0)
    },
    _addListener: function (a) {
        0 ===
        this._inDispatch ? this._forceAddEventListener(a) : this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function (a) {
        var b = a._getListenerID(), d = this._listenersMap[b];
        d || (d = new cc._EventListenerVector, this._listenersMap[b] = d);
        d.push(a);
        0 === a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null === b && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b,
            this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function (a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function () {
        if (0 !== this._dirtyNodes.length) {
            for (var a = this._dirtyNodes, b, d, e = this._nodeListenersMap, f = 0, g = a.length; f < g; f++)if (b = e[a[f].__instanceId])for (var h = 0, n = b.length; h < n; h++)(d = b[h]) && this._setDirty(d._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function (a) {
        if (a)for (var b, d = 0; d < a.length;)b = a[d], b._setRegistered(!1), null !=
        b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(), b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++d
    },
    _removeListenersForListenerID: function (a) {
        var b = this._listenersMap[a];
        if (b) {
            var d = b.getFixedPriorityListeners(), e = b.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(e);
            this._removeAllListenersInVector(d);
            delete this._priorityDirtyFlagMap[a];
            this._inDispatch || (b.clear(), delete this._listenersMap[a])
        }
        d = this._toAddedListeners;
        for (b = 0; b < d.length;)(e = d[b]) && e._getListenerID() === a ? cc.arrayRemoveObject(d, e) : ++b
    },
    _sortEventListeners: function (a) {
        var b = this.DIRTY_NONE, d = this._priorityDirtyFlagMap;
        d[a] && (b = d[a]);
        b !== this.DIRTY_NONE && (d[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && ((b = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, b) : d[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    },
    _sortListenersOfSceneGraphPriority: function (a, b) {
        var d =
            this._getListeners(a);
        if (d) {
            var e = d.getSceneGraphPriorityListeners();
            e && 0 !== e.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), d.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function (a, b) {
        var d = cc.eventManager._nodePriorityMap, e = a._getSceneGraphPriority(), f = b._getSceneGraphPriority();
        return b && f && d[f.__instanceId] ? a && e && d[e.__instanceId] ? d[b._getSceneGraphPriority().__instanceId] -
        d[a._getSceneGraphPriority().__instanceId] : 1 : -1
    },
    _sortListenersOfFixedPriority: function (a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners();
            if (b && 0 !== b.length) {
                b.sort(this._sortListenersOfFixedPriorityAsc);
                for (var d = 0, e = b.length; d < e && !(0 <= b[d]._getFixedPriority());)++d;
                a.gt0Index = d
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function (a, b) {
        return a._getFixedPriority() - b._getFixedPriority()
    },
    _onUpdateListeners: function (a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners(), d = a.getSceneGraphPriorityListeners(),
                e, f, g = this._toRemovedListeners;
            if (d)for (e = 0; e < d.length;)f = d[e], f._isRegistered() ? ++e : (cc.arrayRemoveObject(d, f), f = g.indexOf(f), -1 !== f && g.splice(f, 1));
            if (b)for (e = 0; e < b.length;)f = b[e], f._isRegistered() ? ++e : (cc.arrayRemoveObject(b, f), f = g.indexOf(f), -1 !== f && g.splice(f, 1));
            d && 0 === d.length && a.clearSceneGraphListeners();
            b && 0 === b.length && a.clearFixedListeners()
        }
    },
    _updateListeners: function (a) {
        var b = this._inDispatch;
        cc.assert(0 < b, cc._LogInfos.EventManager__updateListeners);
        if (!(1 < b)) {
            a.getType() === cc.Event.TOUCH ?
                (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
            cc.assert(1 === b, cc._LogInfos.EventManager__updateListeners_2);
            a = this._listenersMap;
            var b = this._priorityDirtyFlagMap, d;
            for (d in a)a[d].empty() && (delete b[d], delete a[d]);
            d = this._toAddedListeners;
            if (0 !== d.length) {
                a = 0;
                for (b = d.length; a < b; a++)this._forceAddEventListener(d[a]);
                this._toAddedListeners.length = 0
            }
            0 !== this._toRemovedListeners.length &&
            this._cleanToRemovedListeners()
        }
    },
    _cleanToRemovedListeners: function () {
        for (var a = this._toRemovedListeners, b = 0; b < a.length; b++) {
            var d = a[b], e = this._listenersMap[d._getListenerID()];
            if (e) {
                var f = e.getFixedPriorityListeners(), g = e.getSceneGraphPriorityListeners();
                g && (e = g.indexOf(d), -1 !== e && g.splice(e, 1));
                f && (e = f.indexOf(d), -1 !== e && f.splice(e, 1))
            }
        }
        a.length = 0
    },
    _onTouchEventCallback: function (a, b) {
        if (!a._isRegistered)return !1;
        var d = b.event, e = b.selTouch;
        d._setCurrentTarget(a._node);
        var f = !1, g, h = d.getEventCode(),
            n = cc.EventTouch.EventCode;
        if (h === n.BEGAN)a.onTouchBegan && (f = a.onTouchBegan(e, d)) && a._registered && a._claimedTouches.push(e); else if (0 < a._claimedTouches.length && -1 !== (g = a._claimedTouches.indexOf(e)))if (f = !0, h === n.MOVED && a.onTouchMoved)a.onTouchMoved(e, d); else if (h === n.ENDED) {
            if (a.onTouchEnded)a.onTouchEnded(e, d);
            a._registered && a._claimedTouches.splice(g, 1)
        } else if (h === n.CANCELLED) {
            if (a.onTouchCancelled)a.onTouchCancelled(e, d);
            a._registered && a._claimedTouches.splice(g, 1)
        }
        return d.isStopped() ? (cc.eventManager._updateListeners(d),
            !0) : f && a._registered && a.swallowTouches ? (b.needsMutableSet && b.touches.splice(e, 1), !0) : !1
    },
    _dispatchTouchEvent: function (a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), d = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null !== b || null !== d) {
            var e = a.getTouches(), f = cc.copyArray(e), g = {
                event: a,
                needsMutableSet: b && d,
                touches: f,
                selTouch: null
            };
            if (b)for (var h = 0; h < e.length; h++)if (g.selTouch = e[h], this._dispatchEventToListeners(b, this._onTouchEventCallback, g), a.isStopped())return;
            if (d && 0 < f.length && (this._dispatchEventToListeners(d, this._onTouchesEventCallback, {
                    event: a,
                    touches: f
                }), a.isStopped()))return;
            this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function (a, b) {
        if (!a._registered)return !1;
        var d = cc.EventTouch.EventCode, e = b.event, f = b.touches, g = e.getEventCode();
        e._setCurrentTarget(a._node);
        if (g === d.BEGAN && a.onTouchesBegan)a.onTouchesBegan(f,
            e); else if (g === d.MOVED && a.onTouchesMoved)a.onTouchesMoved(f, e); else if (g === d.ENDED && a.onTouchesEnded)a.onTouchesEnded(f, e); else if (g === d.CANCELLED && a.onTouchesCancelled)a.onTouchesCancelled(f, e);
        return e.isStopped() ? (cc.eventManager._updateListeners(e), !0) : !1
    },
    _associateNodeAndEventListener: function (a, b) {
        var d = this._nodeListenersMap[a.__instanceId];
        d || (d = [], this._nodeListenersMap[a.__instanceId] = d);
        d.push(b)
    },
    _dissociateNodeAndEventListener: function (a, b) {
        var d = this._nodeListenersMap[a.__instanceId];
        d && (cc.arrayRemoveObject(d, b), 0 === d.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function (a, b, d) {
        var e = !1, f = a.getFixedPriorityListeners(), g = a.getSceneGraphPriorityListeners(), h = 0, n;
        if (f && 0 !== f.length)for (; h < a.gt0Index; ++h)if (n = f[h], n.isEnabled() && !n._isPaused() && n._isRegistered() && b(n, d)) {
            e = !0;
            break
        }
        if (g && !e)for (a = 0; a < g.length; a++)if (n = g[a], n.isEnabled() && !n._isPaused() && n._isRegistered() && b(n, d)) {
            e = !0;
            break
        }
        if (f && !e)for (; h < f.length && (n = f[h], !n.isEnabled() || n._isPaused() || !n._isRegistered() || !b(n, d)); ++h);
    },
    _setDirty: function (a, b) {
        var d = this._priorityDirtyFlagMap;
        d[a] = null == d[a] ? b : b | d[a]
    },
    _visitTarget: function (a, b) {
        var d = a.getChildren(), e = 0, f = d.length, g = this._globalZOrderNodeMap, h = this._nodeListenersMap;
        if (0 < f) {
            for (var n; e < f; e++)if ((n = d[e]) && 0 > n.getLocalZOrder())this._visitTarget(n, !1); else break;
            null != h[a.__instanceId] && (g[a.getGlobalZOrder()] || (g[a.getGlobalZOrder()] = []), g[a.getGlobalZOrder()].push(a.__instanceId));
            for (; e < f; e++)(n = d[e]) && this._visitTarget(n, !1)
        } else null !=
        h[a.__instanceId] && (g[a.getGlobalZOrder()] || (g[a.getGlobalZOrder()] = []), g[a.getGlobalZOrder()].push(a.__instanceId));
        if (b) {
            var d = [], p;
            for (p in g)d.push(p);
            d.sort(this._sortNumberAsc);
            p = d.length;
            n = this._nodePriorityMap;
            for (e = 0; e < p; e++)for (f = g[d[e]], h = 0; h < f.length; h++)n[f[h]] = ++this._nodePriorityIndex;
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function (a, b) {
        return a - b
    },
    addListener: function (a, b) {
        cc.assert(a && b, cc._LogInfos.eventManager_addListener_2);
        if (!(a instanceof cc.EventListener))cc.assert(!cc.isNumber(b),
            cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a); else if (a._isRegistered()) {
            cc.log(cc._LogInfos.eventManager_addListener_4);
            return
        }
        if (a.checkAvailable()) {
            if (cc.isNumber(b)) {
                if (0 === b) {
                    cc.log(cc._LogInfos.eventManager_addListener);
                    return
                }
                a._setSceneGraphPriority(null);
                a._setFixedPriority(b);
                a._setRegistered(!0);
                a._setPaused(!1)
            } else a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0);
            this._addListener(a);
            return a
        }
    },
    addCustomListener: function (a, b) {
        var d = new cc._EventListenerCustom(a,
            b);
        this.addListener(d, 1);
        return d
    },
    removeListener: function (a) {
        if (null != a) {
            var b, d = this._listenersMap, e;
            for (e in d) {
                var f = d[e], g = f.getFixedPriorityListeners();
                b = f.getSceneGraphPriorityListeners();
                (b = this._removeListenerInVector(b, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (b = this._removeListenerInVector(g, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                f.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete d[e]);
                if (b)break
            }
            if (!b)for (d =
                            this._toAddedListeners, e = 0, f = d.length; e < f; e++)if (g = d[e], g === a) {
                cc.arrayRemoveObject(d, g);
                g._setRegistered(!1);
                break
            }
        }
    },
    _removeListenerInCallback: function (a, b) {
        if (null == a)return !1;
        for (var d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f._onCustomEvent === b || f._onEvent === b)return f._setRegistered(!1), null != f._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(f._getSceneGraphPriority(), f), f._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, f), !0
        }
        return !1
    },
    _removeListenerInVector: function (a,
                                       b) {
        if (null == a)return !1;
        for (var d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f === b)return f._setRegistered(!1), null != f._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(f._getSceneGraphPriority(), f), f._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, f) : this._toRemovedListeners.push(f), !0
        }
        return !1
    },
    removeListeners: function (a, b) {
        if (a instanceof cc.Node) {
            delete this._nodePriorityMap[a.__instanceId];
            cc.arrayRemoveObject(this._dirtyNodes, a);
            var d = this._nodeListenersMap[a.__instanceId];
            if (d) {
                for (var e = cc.copyArray(d), d = 0; d < e.length; d++)this.removeListener(e[d]);
                e.length = 0
            }
            e = this._toAddedListeners;
            for (d = 0; d < e.length;) {
                var f = e[d];
                f._getSceneGraphPriority() === a ? (f._setSceneGraphPriority(null), f._setRegistered(!1), e.splice(d, 1)) : ++d
            }
            if (!0 === b)for (e = a.getChildren(), d = 0, f = e.length; d < f; d++)this.removeListeners(e[d], !0)
        } else a === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) :
            a === cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function (a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function () {
        var a = this._listenersMap, b = this._internalCustomListenerIDs,
            d;
        for (d in a)-1 === b.indexOf(d) && this._removeListenersForListenerID(d)
    },
    setPriority: function (a, b) {
        if (null != a) {
            var d = this._listenersMap, e;
            for (e in d) {
                var f = d[e].getFixedPriorityListeners();
                if (f && -1 !== f.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
                    a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function (a) {
        this._isEnabled = a
    },
    isEnabled: function () {
        return this._isEnabled
    },
    dispatchEvent: function (a) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (!a || !a.getType)throw Error("event is undefined");
            if (a.getType() === cc.Event.TOUCH)this._dispatchTouchEvent(a); else {
                var b = cc.__getListenerID(a);
                this._sortEventListeners(b);
                b = this._listenersMap[b];
                null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a);
                this._updateListeners(a)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function (a, b) {
        b._setCurrentTarget(a._getSceneGraphPriority());
        a._onEvent(b);
        return b.isStopped()
    },
    dispatchCustomEvent: function (a, b) {
        var d = new cc.EventCustom(a);
        d.setUserData(b);
        this.dispatchEvent(d)
    }
};
cc.EventAcceleration = cc.Event.extend({
    _acc: null, ctor: function (a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
        this._acc = a
    }
});
cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0, _isPressed: !1, ctor: function (a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
        this._keyCode = a;
        this._isPressed = b
    }
});
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null, ctor: function (a) {
        this._onAccelerationEvent = a;
        var b = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function (a) {
            b._onAccelerationEvent(a._acc, a)
        })
    }, checkAvailable: function () {
        cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
        return !0
    }, clone: function () {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function (a) {
    return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null, onKeyReleased: null, ctor: function () {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function (b) {
            if (b._isPressed) {
                if (a.onKeyPressed)a.onKeyPressed(b._keyCode, b)
            } else if (a.onKeyReleased)a.onKeyReleased(b._keyCode, b)
        })
    }, clone: function () {
        var a = new cc._EventListenerKeyboard;
        a.onKeyPressed = this.onKeyPressed;
        a.onKeyReleased = this.onKeyReleased;
        return a
    }, checkAvailable: function () {
        return null ===
        this.onKeyPressed && null === this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
    }
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function () {
    return new cc._EventListenerKeyboard
};
var GlobalVertexBuffer = function () {
    var a = function (a) {
        this.gl = a;
        this.vertexBuffer = a.createBuffer();
        this.size = 888;
        this.byteLength = 3552 * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this.data = new ArrayBuffer(this.byteLength);
        this.dataArray = new Float32Array(this.data);
        a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
        a.bufferData(a.ARRAY_BUFFER, this.dataArray, a.DYNAMIC_DRAW);
        this._dirty = !1;
        this._spaces = {0: this.byteLength}
    };
    a.prototype = {
        constructor: a, allocBuffer: function (a, d) {
            var e = this._spaces[a];
            return e && e >= d ?
                (delete this._spaces[a], e > d && (this._spaces[a + d] = e - d), !0) : !1
        }, requestBuffer: function (a) {
            var d, e, f;
            for (d in this._spaces)if (e = parseInt(d), f = this._spaces[d], f >= a && this.allocBuffer(e, a))return {
                buffer: this,
                offset: e,
                size: a
            };
            return null
        }, freeBuffer: function (a, d) {
            var e = this._spaces, f, g;
            for (g in e) {
                f = parseInt(g);
                if (f > a)break;
                if (f + e[g] >= a) {
                    d = d + a - f;
                    a = f;
                    break
                }
            }
            e = a + d;
            this._spaces[e] && (d += this._spaces[e], delete this._spaces[e]);
            this._spaces[a] = d
        }, setDirty: function () {
            this._dirty = !0
        }, update: function () {
            this._dirty &&
            (this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), this.gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dataArray), this._dirty = !1)
        }, destroy: function () {
            this.gl.deleteBuffer(this.vertexBuffer);
            this.vertexBuffer = this.texCoords = this.colors = this.positions = this.data = null
        }
    };
    return a
}();
cc.rendererCanvas = {
    childrenOrderDirty: !0,
    assignedZ: 0,
    assignedZStep: 1E-4,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToCanvasOn: !1,
    _cacheToCanvasCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    _clearFillStyle: "rgb(0, 0, 0)",
    getRenderCmd: function (a) {
        return a._createRenderCmd()
    },
    rendering: function (a) {
        var b = this._renderCmds, d, e = cc.view.getScaleX(), f = cc.view.getScaleY(), g = a || cc._renderContext;
        g.computeRealOffsetY();
        a = 0;
        for (d = b.length; a < d; a++)b[a].rendering(g, e, f)
    },
    _renderingToCacheCanvas: function (a,
                                       b, d, e) {
        a || cc.log("The context of RenderTexture is invalid.");
        d = cc.isUndefined(d) ? 1 : d;
        e = cc.isUndefined(e) ? 1 : e;
        b = b || this._currentID;
        var f = this._cacheToCanvasCmds[b], g, h;
        a.computeRealOffsetY();
        g = 0;
        for (h = f.length; g < h; g++)f[g].rendering(a, d, e);
        this._removeCache(b);
        a = this._cacheInstanceIds;
        0 === a.length ? this._isCacheToCanvasOn = !1 : this._currentID = a[a.length - 1]
    },
    _turnToCacheMode: function (a) {
        this._isCacheToCanvasOn = !0;
        a = a || 0;
        this._cacheToCanvasCmds[a] = [];
        -1 === this._cacheInstanceIds.indexOf(a) && this._cacheInstanceIds.push(a);
        this._currentID = a
    },
    _turnToNormalMode: function () {
        this._isCacheToCanvasOn = !1
    },
    _removeCache: function (a) {
        a = a || this._currentID;
        var b = this._cacheToCanvasCmds[a];
        b && (b.length = 0, delete this._cacheToCanvasCmds[a]);
        cc.arrayRemoveObject(this._cacheInstanceIds, a)
    },
    resetFlag: function () {
        this.childrenOrderDirty = !1;
        this._transformNodePool.length = 0
    },
    transform: function () {
        var a = this._transformNodePool;
        a.sort(this._sortNodeByLevelAsc);
        for (var b = 0, d = a.length; b < d; b++)0 !== a[b]._dirtyFlag && a[b].updateStatus();
        a.length = 0
    },
    transformDirty: function () {
        return 0 < this._transformNodePool.length
    },
    _sortNodeByLevelAsc: function (a, b) {
        return a._curLevel - b._curLevel
    },
    pushDirtyNode: function (a) {
        this._transformNodePool.push(a)
    },
    clear: function () {
        var a = cc._canvas, b = cc._renderContext, d = b.getContext();
        d.setTransform(1, 0, 0, 1, 0, 0);
        d.clearRect(0, 0, a.width, a.height);
        if (0 !== this._clearColor.r || 0 !== this._clearColor.g || 0 !== this._clearColor.b)b.setFillStyle(this._clearFillStyle), b.setGlobalAlpha(this._clearColor.a), d.fillRect(0, 0, a.width, a.height)
    },
    clearRenderCommands: function () {
        this._renderCmds.length = 0;
        this._cacheInstanceIds.length = 0;
        this._isCacheToCanvasOn = !1
    },
    pushRenderCommand: function (a) {
        if (a.needDraw())if (this._isCacheToCanvasOn) {
            var b = this._cacheToCanvasCmds[this._currentID];
            -1 === b.indexOf(a) && b.push(a)
        } else-1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
    }
};
(function () {
    cc.CanvasContextWrapper = function (a) {
        this._context = a;
        this._saveCount = 0;
        this._currentAlpha = a.globalAlpha;
        this._currentCompositeOperation = a.globalCompositeOperation;
        this._currentFillStyle = a.fillStyle;
        this._currentStrokeStyle = a.strokeStyle;
        this._offsetY = this._offsetX = 0;
        this._realOffsetY = this.height;
        this._armatureMode = 0
    };
    var a = cc.CanvasContextWrapper.prototype;
    a.resetCache = function () {
        var a = this._context;
        this._currentAlpha = a.globalAlpha;
        this._currentCompositeOperation = a.globalCompositeOperation;
        this._currentFillStyle = a.fillStyle;
        this._currentStrokeStyle = a.strokeStyle;
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.setOffset = function (a, d) {
        this._offsetX = a;
        this._offsetY = d;
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.computeRealOffsetY = function () {
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.setViewScale = function (a, d) {
        this._scaleX = a;
        this._scaleY = d
    };
    a.getContext = function () {
        return this._context
    };
    a.save = function () {
        this._context.save();
        this._saveCount++
    };
    a.restore = function () {
        this._context.restore();
        this._saveCount--
    };
    a.setGlobalAlpha = function (a) {
        0 < this._saveCount ? this._context.globalAlpha = a : this._currentAlpha !== a && (this._currentAlpha = a, this._context.globalAlpha = a)
    };
    a.setCompositeOperation = function (a) {
        0 < this._saveCount ? this._context.globalCompositeOperation = a : this._currentCompositeOperation !== a && (this._currentCompositeOperation = a, this._context.globalCompositeOperation = a)
    };
    a.setFillStyle = function (a) {
        0 < this._saveCount ? this._context.fillStyle = a : this._currentFillStyle !==
        a && (this._currentFillStyle = a, this._context.fillStyle = a)
    };
    a.setStrokeStyle = function (a) {
        0 < this._saveCount ? this._context.strokeStyle = a : this._currentStrokeStyle !== a && (this._currentStrokeStyle = a, this._context.strokeStyle = a)
    };
    a.setTransform = function (a, d, e) {
        0 < this._armatureMode ? (this.restore(), this.save(), this._context.transform(a.a, -a.b, -a.c, a.d, a.tx * d, -(a.ty * e))) : this._context.setTransform(a.a, -a.b, -a.c, a.d, this._offsetX + a.tx * d, this._realOffsetY - a.ty * e)
    };
    a._switchToArmatureMode = function (a, d, e, f) {
        a ? (this._armatureMode++,
            this._context.setTransform(d.a, d.c, d.b, d.d, this._offsetX + d.tx * e, this._realOffsetY - d.ty * f), this.save()) : (this._armatureMode--, this.restore())
    }
})();
cc.rendererWebGL = function () {
    function a(a) {
        null === s.buffer && (s.buffer = cc._renderContext.createBuffer());
        if (s.maxQuads < a && s.buffer) {
            var b = cc._renderContext;
            b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, s.buffer);
            for (var d = new Uint16Array(6 * a), e = 0, f = 0, g = 6 * a; f < g; f += 6)d[f] = e + 0, d[f + 1] = e + 1, d[f + 2] = e + 2, d[f + 3] = e + 1, d[f + 4] = e + 2, d[f + 5] = e + 3, e += 4;
            b.bufferData(b.ELEMENT_ARRAY_BUFFER, d, b.STATIC_DRAW);
            s.maxQuads = a
        }
        return s.buffer
    }

    function b(a, b, d, e, f) {
        var g;
        f ? (g = new Float32Array(f, b, d / 4), f = new Uint32Array(f, b, d / 4)) : (g = new Float32Array(d /
            4), f = new Uint32Array(g.buffer));
        return {buffer: a, float32View: g, uint32View: f, vertexOffset: b, totalBufferSize: d, count: e, valid: !0}
    }

    var d = [], e = {texture: null, blendSrc: null, blendDst: null, shader: null}, f = {
        texture: null,
        blendSrc: null,
        blendDst: null,
        shader: null
    }, g = null, h = new cc.SimplePool, n = !1, p = !1, r = [], s = {buffer: null, maxQuads: 0};
    return {
        mat4Identity: null,
        childrenOrderDirty: !0,
        assignedZ: 0,
        assignedZStep: 1E-4,
        _transformNodePool: [],
        _renderCmds: [],
        _isCacheToBufferOn: !1,
        _cacheToBufferCmds: {},
        _cacheInstanceIds: [],
        _currentID: 0,
        _clearColor: cc.color(),
        init: function () {
            this.mat4Identity = new cc.math.Matrix4;
            this.mat4Identity.identity();
            a(1E3)
        },
        requestBuffer: function (a) {
            var b, e = d.length, f, g = cc._renderContext, h;
            for (b = 0; b < e; ++b)if (f = d[b], f.gl === g && (h = f.requestBuffer(a)))return h;
            h || (f = new GlobalVertexBuffer(g), d.push(f), h = f.requestBuffer(a));
            h || cc.error("Request WebGL buffer failed");
            return h
        },
        getRenderCmd: function (a) {
            return a._createRenderCmd()
        },
        _turnToCacheMode: function (a) {
            this._isCacheToBufferOn = !0;
            a = a || 0;
            this._cacheToBufferCmds[a] =
                [];
            this._cacheInstanceIds.push(a);
            this._currentID = a
        },
        _turnToNormalMode: function () {
            this._isCacheToBufferOn = !1
        },
        _removeCache: function (a) {
            a = a || this._currentID;
            var b = this._cacheToBufferCmds[a];
            b && (b.length = 0, delete this._cacheToBufferCmds[a]);
            cc.arrayRemoveObject(this._cacheInstanceIds, a)
        },
        _renderingToBuffer: function (a) {
            a = a || this._currentID;
            var b = this._cacheToBufferCmds[a], e, f, g = cc._renderContext;
            e = 0;
            for (f = d.length; e < f; ++e)d[e].update();
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            e = 0;
            for (f = b.length; e < f; e++)b[e].rendering(g);
            this._removeCache(a);
            a = this._cacheInstanceIds;
            0 === a.length ? this._isCacheToBufferOn = !1 : this._currentID = a[a.length - 1]
        },
        resetFlag: function () {
            this.childrenOrderDirty && (n = !0, this.childrenOrderDirty = !1);
            this._transformNodePool.length = 0
        },
        transform: function () {
            var a = this._transformNodePool;
            a.sort(this._sortNodeByLevelAsc);
            var b, d, e;
            b = 0;
            for (d = a.length; b < d; b++)e = a[b], e.updateStatus();
            a.length = 0
        },
        transformDirty: function () {
            return 0 < this._transformNodePool.length
        },
        _sortNodeByLevelAsc: function (a, b) {
            return a._curLevel -
                b._curLevel
        },
        pushDirtyNode: function (a) {
            this._transformNodePool.push(a)
        },
        clearRenderCommands: function () {
            var a = this._renderCmds, b, d = a.length, e;
            for (b = 0; b < d; ++b)e = a[b], e._currId = -1, r[b] = e;
            r.length = d;
            this._renderCmds.length = 0
        },
        clear: function () {
            var a = cc._renderContext;
            a.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
            a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
        },
        setDepthTest: function (a) {
            var b = cc._renderContext;
            a ? (b.clearDepth(1), b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL)) :
                b.disable(b.DEPTH_TEST)
        },
        pushRenderCommand: function (a) {
            if (a.needDraw())if (this._isCacheToBufferOn) {
                var b = this._cacheToBufferCmds[this._currentID];
                -1 === b.indexOf(a) && b.push(a)
            } else-1 === this._renderCmds.indexOf(a) && (a._currId = this._renderCmds.length, this._renderCmds.push(a))
        },
        createBatchBuffer: function (a) {
            var b = gl.createBuffer();
            this.initBatchBuffers(b, a);
            return {arrayBuffer: b, bufferSize: a}
        },
        initBatchBuffers: function (a, b) {
            gl.bindBuffer(gl.ARRAY_BUFFER, a);
            gl.bufferData(gl.ARRAY_BUFFER, b, gl.DYNAMIC_DRAW)
        },
        getBatchBuffer: function (a) {
            if (0 < h.size()) {
                var b = Number.MAX_VALUE, d = -1, e = h.find(function (e, f) {
                    if (f.bufferSize >= a)return !0;
                    f.bufferSize < b && (b = f.bufferSize, d = e)
                }, function () {
                    return d
                });
                if (e)return this.initBatchBuffers(e.arrayBuffer, a), e.bufferSize = a, e
            }
            return this.createBatchBuffer(a)
        },
        _refreshVirtualBuffers: function () {
            for (var a = this._renderCmds, d = r.length, g = a.length, h = 0, n = 0, s, A, D, G; h < d; ++h)if (s = r[h], D = s._vBuffer, matched = !1, D && D.valid)if (n = s._currId, 0 > n || n >= g)s._vBuffer = null; else {
                s.getBatchInfo(e);
                G =
                    0;
                for (A = a[n]; s && s === A && s._vBuffer === D;)++G, ++n, s = r[h + G], A = a[n];
                n = h + G;
                if (1 >= G)s = r[h], s._vBuffer = null, A && (A._vBuffer = null); else {
                    if (A && A._supportBatch && (A.getBatchInfo(f), f.texture === e.texture && f.blendSrc === e.blendSrc && f.blendDst === e.blendDst && f.shader === e.shader)) {
                        for (; h < n; ++h)r[h]._vBuffer = null;
                        h--;
                        continue
                    }
                    if (D.count === G)h = h + G - 1; else if (1 < G) {
                        s = r[h];
                        A = G * s.bytesPerUnit;
                        for (s = b(D.buffer, 4 * s._vertexOffset, A, G, D.float32View.buffer); h < n; ++h)r[h]._vBuffer = s;
                        h--
                    }
                }
            }
            d = a.length;
            for (h = 0; h < d; ++h)s = a[h], s._vBuffer ||
            (g = a[h + 1], s._supportBatch && g && g._supportBatch && (G = this._forwardBatch(h), 1 < G && (h += G - 1)));
            r.length = 0;
            p = !1
        },
        _forwardCheck: function (a) {
            var b = this._renderCmds, d = b[a], f = a, h = b.length, n = d._vBuffer;
            d.getBatchInfo(e);
            g = null;
            if (d._vertexOffset !== n.vertexOffset || !n.valid || !n.buffer)return p = !0, 0;
            for (var r; f < h; ++f) {
                d = b[f];
                if (n !== d._vBuffer)break;
                d._bufferDirty && (r || (r = n, gl.bindBuffer(gl.ARRAY_BUFFER, r.buffer.arrayBuffer)), d.batchVertexBuffer(r.float32View, r.uint32View, d._vertexOffset), d._bufferDirty = !1)
            }
            r && gl.bufferSubData(gl.ARRAY_BUFFER,
                0, r.float32View);
            h = f - a;
            if (n.count === h)return g = n, h;
            for (f = a; f < a + h; ++f)d = b[f], d._vBuffer = null;
            p = !0;
            return 0
        },
        _forwardBatch: function (a) {
            var d = this._renderCmds, h = d[a], n = a + 1;
            if (!h || !h._supportBatch)return 0;
            h.getBatchInfo(e);
            if (!e.texture)return 0;
            for (var p = h.bytesPerUnit, h = d[n]; h;) {
                if (h._supportBatch)h.getBatchInfo(f); else break;
                if (f.texture !== e.texture || f.blendSrc !== e.blendSrc || f.blendDst !== e.blendDst || f.shader !== e.shader)break; else p += h.bytesPerUnit;
                ++n;
                h = d[n]
            }
            var r = n - a;
            if (1 >= r)return r;
            h = this.getBatchBuffer(p);
            g = p = b(h, 0, p, r);
            var s = p.float32View, D = 0;
            for (gl.bindBuffer(gl.ARRAY_BUFFER, p.buffer.arrayBuffer); a < n; ++a)h = d[a], h.batchVertexBuffer(s, p.uint32View, D), h._vBuffer = p, h._vertexOffset = D, h._savedDirtyFlag && (h._savedDirtyFlag = !1), D += h.vertexBytesPerUnit / 4;
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, s);
            return r
        },
        _batchRendering: function () {
            var b = e.texture, d = e.shader, f = g.count;
            d.use();
            d._updateProjectionUniform();
            cc.glBlendFunc(e.blendSrc, e.blendDst);
            cc.glBindTexture2DN(0, b);
            gl.bindBuffer(gl.ARRAY_BUFFER, g.buffer.arrayBuffer);
            gl.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
            gl.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
            gl.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
            b = g.vertexOffset;
            gl.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, !1, 24, b);
            gl.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, !0, 24, b + 12);
            gl.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, !1, 24, b + 16);
            b = a(f);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b);
            gl.drawElements(gl.TRIANGLES, 6 * f, gl.UNSIGNED_SHORT, 0);
            cc.g_NumberOfDraws++
        },
        rendering: function (a) {
            var b = this._renderCmds, e, f, g, h = a || cc._renderContext;
            a = 0;
            for (e = d.length; a < e; ++a)d[a].update();
            (n || p) && this._refreshVirtualBuffers();
            h.bindBuffer(gl.ARRAY_BUFFER, null);
            a = 0;
            for (e = b.length; a < e; ++a) {
                f = b[a];
                if (f._vBuffer && (g = this._forwardCheck(a), 1 < g)) {
                    this._batchRendering();
                    a += g - 1;
                    continue
                }
                f.rendering(h)
            }
            n && (n = !1)
        }
    }
}();
cc._tmp.PrototypeCCNode = function () {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
    cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
    cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
    cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
    cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
    cc.defineGetterSetter(a, "skewY",
        a.getSkewY, a.setSkewY);
    cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
    cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
    cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
    cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
    cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
    cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
    cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
    cc.defineGetterSetter(a, "scaleY", a.getScaleY,
        a.setScaleY);
    cc.defineGetterSetter(a, "children", a.getChildren);
    cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
    cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
    cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
    cc.defineGetterSetter(a, "running", a.isRunning);
    cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
    cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
    cc.defineGetterSetter(a, "scheduler",
        a.getScheduler, a.setScheduler);
    cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB);
    cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _customZ: NaN,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _normalizedPosition: null,
    _usingNormalizedPosition: !1,
    _normalizedPositionDirty: !1,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _realOpacity: 255,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _renderCmd: null,
    _camera: null,
    ctor: function () {
        this._initNode();
        this._initRendererCmd()
    },
    _initNode: function () {
        this._anchorPoint = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._normalizedPosition = cc.p(0, 0);
        this._children = [];
        var a =
            cc.director;
        this._actionManager = a.getActionManager();
        this._scheduler = a.getScheduler();
        this._additionalTransform = cc.affineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
        this._realOpacity = 255;
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    init: function () {
        return !0
    },
    _arrayMakeObjectsPerformSelector: function (a, b) {
        if (a && 0 !== a.length) {
            var d, e = a.length, f;
            d = cc.Node._stateCallbackType;
            switch (b) {
                case d.onEnter:
                    for (d =
                             0; d < e; d++)if (f = a[d])f.onEnter();
                    break;
                case d.onExit:
                    for (d = 0; d < e; d++)if (f = a[d])f.onExit();
                    break;
                case d.onEnterTransitionDidFinish:
                    for (d = 0; d < e; d++)if (f = a[d])f.onEnterTransitionDidFinish();
                    break;
                case d.cleanup:
                    for (d = 0; d < e; d++)(f = a[d]) && f.cleanup();
                    break;
                case d.updateTransform:
                    for (d = 0; d < e; d++)(f = a[d]) && f.updateTransform();
                    break;
                case d.onExitTransitionDidStart:
                    for (d = 0; d < e; d++)if (f = a[d])f.onExitTransitionDidStart();
                    break;
                case d.sortAllChildren:
                    for (d = 0; d < e; d++)(f = a[d]) && f.sortAllChildren();
                    break;
                default:
                    cc.assert(0,
                        cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    attr: function (a) {
        for (var b in a)this[b] = a[b]
    },
    getSkewX: function () {
        return this._skewX
    },
    setSkewX: function (a) {
        this._skewX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getSkewY: function () {
        return this._skewY
    },
    setSkewY: function (a) {
        this._skewY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setLocalZOrder: function (a) {
        this._localZOrder = a;
        this._parent && this._parent.reorderChild(this, a);
        cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function (a) {
        this._localZOrder = a
    },
    getLocalZOrder: function () {
        return this._localZOrder
    },
    getZOrder: function () {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder()
    },
    setZOrder: function (a) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(a)
    },
    setGlobalZOrder: function (a) {
        this._globalZOrder !== a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function () {
        return this._globalZOrder
    },
    getVertexZ: function () {
        return this._vertexZ
    },
    setVertexZ: function (a) {
        this._customZ =
            this._vertexZ = a
    },
    getRotation: function () {
        this._rotationX !== this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX
    },
    setRotation: function (a) {
        this._rotationX = this._rotationY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationX: function () {
        return this._rotationX
    },
    setRotationX: function (a) {
        this._rotationX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationY: function () {
        return this._rotationY
    },
    setRotationY: function (a) {
        this._rotationY =
            a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScale: function () {
        this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX
    },
    setScale: function (a, b) {
        this._scaleX = a;
        this._scaleY = b || 0 === b ? b : a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleX: function () {
        return this._scaleX
    },
    setScaleX: function (a) {
        this._scaleX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleY: function () {
        return this._scaleY
    },
    setScaleY: function (a) {
        this._scaleY =
            a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setPosition: function (a, b) {
        var d = this._position;
        if (void 0 === b) {
            if (d.x === a.x && d.y === a.y)return;
            d.x = a.x;
            d.y = a.y
        } else {
            if (d.x === a && d.y === b)return;
            d.x = a;
            d.y = b
        }
        this._usingNormalizedPosition = !1;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setNormalizedPosition: function (a, b) {
        var d = this._normalizedPosition;
        void 0 === b ? (d.x = a.x, d.y = a.y) : (d.x = a, d.y = b);
        this._normalizedPositionDirty = this._usingNormalizedPosition = !0;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPosition: function () {
        return cc.p(this._position)
    },
    getNormalizedPosition: function () {
        return cc.p(this._normalizedPosition)
    },
    getPositionX: function () {
        return this._position.x
    },
    setPositionX: function (a) {
        this._position.x = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionY: function () {
        return this._position.y
    },
    setPositionY: function (a) {
        this._position.y = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getChildrenCount: function () {
        return this._children.length
    },
    getChildren: function () {
        return this._children
    },
    isVisible: function () {
        return this._visible
    },
    setVisible: function (a) {
        this._visible !== a && (this._visible = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0)
    },
    getAnchorPoint: function () {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function (a, b) {
        var d = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === d.x && a.y === d.y)return;
            d.x = a.x;
            d.y = a.y
        } else {
            if (a === d.x && b === d.y)return;
            d.x = a;
            d.y = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getAnchorX: function () {
        return this._anchorPoint.x
    },
    _setAnchorX: function (a) {
        this._anchorPoint.x !== a && (this._anchorPoint.x = a, this._renderCmd._updateAnchorPointInPoint())
    },
    _getAnchorY: function () {
        return this._anchorPoint.y
    },
    _setAnchorY: function (a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._renderCmd._updateAnchorPointInPoint())
    },
    getAnchorPointInPoints: function () {
        return this._renderCmd.getAnchorPointInPoints()
    },
    _getWidth: function () {
        return this._contentSize.width
    },
    _setWidth: function (a) {
        this._contentSize.width = a;
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getHeight: function () {
        return this._contentSize.height
    },
    _setHeight: function (a) {
        this._contentSize.height = a;
        this._renderCmd._updateAnchorPointInPoint()
    },
    getContentSize: function () {
        return cc.size(this._contentSize)
    },
    setContentSize: function (a, b) {
        var d = this._contentSize;
        if (void 0 === b) {
            if (a.width === d.width && a.height === d.height)return;
            d.width = a.width;
            d.height = a.height
        } else {
            if (a === d.width && b === d.height)return;
            d.width = a;
            d.height = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    isRunning: function () {
        return this._running
    },
    getParent: function () {
        return this._parent
    },
    setParent: function (a) {
        this._parent = a
    },
    isIgnoreAnchorPointForPosition: function () {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function (a) {
        a !== this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    getTag: function () {
        return this.tag
    },
    setTag: function (a) {
        this.tag = a
    },
    setName: function (a) {
        this._name = a
    },
    getName: function () {
        return this._name
    },
    getUserData: function () {
        return this.userData
    },
    setUserData: function (a) {
        this.userData = a
    },
    getUserObject: function () {
        return this.userObject
    },
    setUserObject: function (a) {
        this.userObject !== a && (this.userObject = a)
    },
    getOrderOfArrival: function () {
        return this.arrivalOrder
    },
    setOrderOfArrival: function (a) {
        this.arrivalOrder = a
    },
    getActionManager: function () {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager
    },
    setActionManager: function (a) {
        this._actionManager !== a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function () {
        this._scheduler ||
        (this._scheduler = cc.director.getScheduler());
        return this._scheduler
    },
    setScheduler: function (a) {
        this._scheduler !== a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    boundingBox: function () {
        cc.log(cc._LogInfos.Node_boundingBox);
        return this.getBoundingBox()
    },
    getBoundingBox: function () {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    },
    cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup)
    },
    getChildByTag: function (a) {
        var b = this._children;
        if (null !== b)for (var d = 0; d < b.length; d++) {
            var e = b[d];
            if (e && e.tag === a)return e
        }
        return null
    },
    getChildByName: function (a) {
        if (!a)return cc.log("Invalid name"), null;
        for (var b = this._children, d = 0, e = b.length; d < e; d++)if (b[d]._name === a)return b[d];
        return null
    },
    addChild: function (a, b, d) {
        b = void 0 === b ? a._localZOrder : b;
        var e, f = !1;
        cc.isUndefined(d) ? (d = void 0, e = a._name) : cc.isString(d) ?
            (e = d, d = void 0) : cc.isNumber(d) && (f = !0, e = "");
        cc.assert(a, cc._LogInfos.Node_addChild_3);
        cc.assert(null === a._parent, "child already added. It can't be added again");
        this._addChildHelper(a, b, d, e, f)
    },
    _addChildHelper: function (a, b, d, e, f) {
        this._children || (this._children = []);
        this._insertChild(a, b);
        f ? a.setTag(d) : a.setName(e);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        if (this._running && (a.onEnter(), this._isTransitionFinished))a.onEnterTransitionDidFinish();
        a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._cascadeColorEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        this._cascadeOpacityEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    removeFromParent: function (a) {
        this._parent && (void 0 === a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function (a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(a)
    },
    removeChild: function (a, b) {
        0 !== this._children.length && (void 0 === b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a,
            b), cc.renderer.childrenOrderDirty = !0)
    },
    removeChildByTag: function (a, b) {
        a === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var d = this.getChildByTag(a);
        d ? this.removeChild(d, b) : cc.log(cc._LogInfos.Node_removeChildByTag_2, a)
    },
    removeAllChildrenWithCleanup: function (a) {
        this.removeAllChildren(a)
    },
    removeAllChildren: function (a) {
        var b = this._children;
        if (null !== b) {
            void 0 === a && (a = !0);
            for (var d = 0; d < b.length; d++) {
                var e = b[d];
                e && (this._running && (e.onExitTransitionDidStart(), e.onExit()), a && e.cleanup(),
                    e.parent = null, e._renderCmd.detachFromParent())
            }
            this._children.length = 0;
            cc.renderer.childrenOrderDirty = !0
        }
    },
    _detachChild: function (a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit());
        b && a.cleanup();
        a.parent = null;
        a._renderCmd.detachFromParent();
        cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function (a, b) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        this._children.push(a);
        a._setLocalZOrder(b)
    },
    setNodeDirty: function () {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    reorderChild: function (a, b) {
        cc.assert(a, cc._LogInfos.Node_reorderChild);
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        a.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        a._setLocalZOrder(b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.orderDirty)
    },
    sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var a = this._children, b = a.length, d, e, f;
            for (d = 1; d < b; d++) {
                f = a[d];
                for (e = d - 1; 0 <= e;) {
                    if (f._localZOrder < a[e]._localZOrder)a[e + 1] = a[e]; else if (f._localZOrder === a[e]._localZOrder &&
                        f.arrivalOrder < a[e].arrivalOrder)a[e + 1] = a[e]; else break;
                    e--
                }
                a[e + 1] = f
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function (a) {
    },
    transformAncestors: function () {
        null !== this._parent && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function () {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter);
        this.resume()
    },
    onEnterTransitionDidFinish: function () {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node._stateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExitTransitionDidStart)
    },
    onExit: function () {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit);
        this.removeAllComponents()
    },
    runAction: function (a) {
        cc.assert(a, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(a, this, !this._running);
        return a
    },
    stopAllActions: function () {
        this.actionManager &&
        this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function (a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function (a) {
        a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function (a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function () {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function () {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function (a) {
        this.scheduler.scheduleUpdate(this, a, !this._running)
    },
    unscheduleUpdate: function () {
        this.scheduler.unscheduleUpdate(this)
    },
    schedule: function (a, b, d, e, f) {
        var g = arguments.length;
        "function" === typeof a ? 1 === g ? (b = 0, d = cc.REPEAT_FOREVER, e = 0, f = this.__instanceId) : 2 === g ? "number" === typeof b ? (d = cc.REPEAT_FOREVER, e = 0, f = this.__instanceId) : (f = b, b = 0, d = cc.REPEAT_FOREVER, e = 0) : 3 === g ? ("string" === typeof d ? (f = d, d = cc.REPEAT_FOREVER) :
            f = this.__instanceId, e = 0) : 4 === g && (f = this.__instanceId) : 1 === g ? (b = 0, d = cc.REPEAT_FOREVER, e = 0) : 2 === g && (d = cc.REPEAT_FOREVER, e = 0);
        cc.assert(a, cc._LogInfos.Node_schedule);
        cc.assert(0 <= b, cc._LogInfos.Node_schedule_2);
        d = null == d ? cc.REPEAT_FOREVER : d;
        this.scheduler.schedule(a, this, b || 0, d, e || 0, !this._running, f)
    },
    scheduleOnce: function (a, b, d) {
        void 0 === d && (d = this.__instanceId);
        this.schedule(a, 0, 0, b, d)
    },
    unschedule: function (a) {
        a && this.scheduler.unschedule(a, this)
    },
    unscheduleAllCallbacks: function () {
        this.scheduler.unscheduleAllForTarget(this)
    },
    resumeSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume()
    },
    resume: function () {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function () {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause()
    },
    pause: function () {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function (a) {
        if (void 0 ===
            a)return this._additionalTransformDirty = !1;
        this._additionalTransform = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._additionalTransformDirty = !0
    },
    getParentToNodeTransform: function () {
        this._renderCmd.getParentToNodeTransform()
    },
    parentToNodeTransform: function () {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function () {
        for (var a = this.getNodeToParentTransform(), b = this._parent; null !== b; b = b.parent)a = cc.affineTransformConcat(a, b.getNodeToParentTransform());
        return a
    },
    nodeToWorldTransform: function () {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function () {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function () {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function (a) {
        return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function (a) {
        a = a || cc.p(0, 0);
        return cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function (a) {
        return cc.pSub(this.convertToNodeSpace(a),
            this._renderCmd.getAnchorPointInPoints())
    },
    convertToWorldSpaceAR: function (a) {
        a = a || cc.p(0, 0);
        a = cc.pAdd(a, this._renderCmd.getAnchorPointInPoints());
        return this.convertToWorldSpace(a)
    },
    _convertToWindowSpace: function (a) {
        a = this.convertToWorldSpace(a);
        return cc.director.convertToUI(a)
    },
    convertTouchToNodeSpace: function (a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    convertTouchToNodeSpaceAR: function (a) {
        a = cc.director.convertToGL(a.getLocation());
        return this.convertToNodeSpaceAR(a)
    },
    update: function (a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.updateTransform)
    },
    retain: function () {
    },
    release: function () {
    },
    getComponent: function (a) {
        return this._componentContainer ? this._componentContainer.getComponent(a) : null
    },
    addComponent: function (a) {
        this._componentContainer && this._componentContainer.add(a)
    },
    removeComponent: function (a) {
        return this._componentContainer ? this._componentContainer.remove(a) :
            !1
    },
    removeAllComponents: function () {
        this._componentContainer && this._componentContainer.removeAll()
    },
    grid: null,
    visit: function (a) {
        this._renderCmd.visit(a)
    },
    transform: function (a, b) {
        this._renderCmd.transform(a, b)
    },
    nodeToParentTransform: function () {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: function (a) {
        var b = this._renderCmd.getNodeToParentTransform();
        if (a)for (var b = {
            a: b.a,
            b: b.b,
            c: b.c,
            d: b.d,
            tx: b.tx,
            ty: b.ty
        }, d = this._parent; null != d && d != a; d = d.getParent())cc.affineTransformConcatIn(b, d.getNodeToParentTransform());
        return b
    },
    getNodeToParentAffineTransform: function (a) {
        return this.getNodeToParentTransform(a)
    },
    getCamera: function () {
        this._camera || (this._camera = new cc.Camera);
        return this._camera
    },
    getGrid: function () {
        return this.grid
    },
    setGrid: function (a) {
        this.grid = a
    },
    getShaderProgram: function () {
        return this._renderCmd.getShaderProgram()
    },
    setShaderProgram: function (a) {
        this._renderCmd.setShaderProgram(a)
    },
    getGLServerState: function () {
        return 0
    },
    setGLServerState: function (a) {
    },
    getBoundingBoxToWorld: function () {
        var a = cc.rect(0,
            0, this._contentSize.width, this._contentSize.height), b = this.getNodeToWorldTransform(), a = cc.rectApplyAffineTransform(a, b);
        if (!this._children)return a;
        for (var d = this._children, e = 0; e < d.length; e++) {
            var f = d[e];
            f && f._visible && (f = f._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a, f))
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function (a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        a = void 0 === a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(),
            a);
        b = cc.rectApplyAffineTransform(b, a);
        if (!this._children)return b;
        for (var d = this._children, e = 0; e < d.length; e++) {
            var f = d[e];
            f && f._visible && (f = f._getBoundingBoxToCurrentNode(a)) && (b = cc.rectUnion(b, f))
        }
        return b
    },
    getOpacity: function () {
        return this._realOpacity
    },
    getDisplayedOpacity: function () {
        return this._renderCmd.getDisplayedOpacity()
    },
    setOpacity: function (a) {
        this._realOpacity = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    updateDisplayedOpacity: function (a) {
        this._renderCmd._updateDisplayOpacity(a)
    },
    isCascadeOpacityEnabled: function () {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function (a) {
        this._cascadeOpacityEnabled !== a && (this._cascadeOpacityEnabled = a, this._renderCmd.setCascadeOpacityEnabledDirty())
    },
    getColor: function () {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function () {
        return this._renderCmd.getDisplayedColor()
    },
    setColor: function (a) {
        var b = this._realColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    updateDisplayedColor: function (a) {
        this._renderCmd._updateDisplayColor(a)
    },
    isCascadeColorEnabled: function () {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function (a) {
        this._cascadeColorEnabled !== a && (this._cascadeColorEnabled = a, this._renderCmd.setCascadeColorEnabledDirty())
    },
    setOpacityModifyRGB: function (a) {
    },
    isOpacityModifyRGB: function () {
        return !1
    },
    _initRendererCmd: function () {
        this._renderCmd = cc.renderer.getRenderCmd(this)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
    },
    enumerateChildren: function (a, b) {
        cc.assert(a && 0 != a.length, "Invalid name");
        cc.assert(null != b, "Invalid callback function");
        var d = a.length, e = 0, f = d, g = !1;
        2 < d && "/" === a[0] && "/" === a[1] && (g = !0, e = 2, f -= 2);
        var h = !1;
        3 < d && "/" === a[d - 3] && "." === a[d - 2] && "." === a[d - 1] && (h = !0, f -= 3);
        d = a.substr(e, f);
        h && (d = "[[:alnum:]]+/" + d);
        g ? this.doEnumerateRecursive(this, d, b) : this.doEnumerate(d, b)
    },
    doEnumerateRecursive: function (a, b, d) {
        if (!a.doEnumerate(b, d))for (var e = a.getChildren(), f = e.length, g = 0; g < f && (a = e[g], !this.doEnumerateRecursive(a,
            b, d)); g++);
    },
    doEnumerate: function (a, b) {
        var d = a.indexOf("/"), e = a, f = !1;
        -1 !== d && (e = a.substr(0, d), f = !0);
        for (var d = !1, g, h = this._children, n = h.length, p = 0; p < n; p++)if (g = h[p], -1 !== g._name.indexOf(e))if (f) {
            if (d = g.doEnumerate(a, b))break
        } else if (b(g)) {
            d = !0;
            break
        }
        return d
    }
});
cc.Node.create = function () {
    return new cc.Node
};
cc.Node._stateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
};
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.CustomRenderCmd = function (a, b) {
    this._needDraw = !0;
    this._target = a;
    this._callback = b;
    this.rendering = function (a, b, f) {
        this._callback && this._callback.call(this._target, a, b, f)
    };
    this.needDraw = function () {
        return this._needDraw
    }
};
cc.Node._dirtyFlags = {
    transformDirty: 1,
    visibleDirty: 2,
    colorDirty: 4,
    opacityDirty: 8,
    cacheDirty: 16,
    orderDirty: 32,
    textDirty: 64,
    gradientDirty: 128,
    textureDirty: 256,
    all: 511
};
cc.Node.RenderCmd = function (a) {
    this._dirtyFlag = 1;
    this._savedDirtyFlag = !0;
    this._node = a;
    this._needDraw = !1;
    this._anchorPointInPoints = new cc.Point(0, 0);
    this._transform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
    this._worldTransform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
    this._inverse = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
    this._displayedOpacity = 255;
    this._displayedColor = cc.color(255, 255, 255, 255);
    this._cascadeOpacityEnabledDirty = this._cascadeColorEnabledDirty = !1;
    this._curLevel = -1
};
cc.Node.RenderCmd.prototype = {
    constructor: cc.Node.RenderCmd, needDraw: function () {
        return this._needDraw
    }, getAnchorPointInPoints: function () {
        return cc.p(this._anchorPointInPoints)
    }, getDisplayedColor: function () {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    }, getDisplayedOpacity: function () {
        return this._displayedOpacity
    }, setCascadeColorEnabledDirty: function () {
        this._cascadeColorEnabledDirty = !0;
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    }, setCascadeOpacityEnabledDirty: function () {
        this._cascadeOpacityEnabledDirty = !0;
        this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    }, getParentToNodeTransform: function () {
        this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()));
        return this._inverse
    }, detachFromParent: function () {
    }, _updateAnchorPointInPoint: function () {
        var a = this._anchorPointInPoints, b = this._node._contentSize, d = this._node._anchorPoint;
        a.x = b.width * d.x;
        a.y = b.height * d.y;
        this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    }, setDirtyFlag: function (a) {
        0 ===
        this._dirtyFlag && 0 !== a && cc.renderer.pushDirtyNode(this);
        this._dirtyFlag |= a
    }, getParentRenderCmd: function () {
        return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
    }, _updateDisplayColor: function (a) {
        var b = this._node, d = this._displayedColor, e = b._realColor, f;
        if (this._cascadeColorEnabledDirty && !b._cascadeColorEnabled) {
            d.r = e.r;
            d.g = e.g;
            d.b = e.b;
            d = new cc.Color(255, 255, 255, 255);
            a = b._children;
            b = 0;
            for (e = a.length; b < e; b++)(f = a[b]) && f._renderCmd && f._renderCmd._updateDisplayColor(d);
            this._cascadeColorEnabledDirty = !1
        } else if (void 0 === a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE), d.r = 0 | e.r * a.r / 255, d.g = 0 | e.g * a.g / 255, d.b = 0 | e.b * a.b / 255, b._cascadeColorEnabled)for (a = b._children, b = 0, e = a.length; b < e; b++)(f = a[b]) && f._renderCmd && (f._renderCmd._updateDisplayColor(d), f._renderCmd._updateColor());
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
    }, _updateDisplayOpacity: function (a) {
        var b = this._node, d, e;
        if (this._cascadeOpacityEnabledDirty && !b._cascadeOpacityEnabled) {
            this._displayedOpacity =
                b._realOpacity;
            d = b._children;
            a = 0;
            for (b = d.length; a < b; a++)(e = d[a]) && e._renderCmd && e._renderCmd._updateDisplayOpacity(255);
            this._cascadeOpacityEnabledDirty = !1
        } else if (void 0 === a && (d = b._parent, a = 255, d && d._cascadeOpacityEnabled && (a = d.getDisplayedOpacity())), this._displayedOpacity = b._realOpacity * a / 255, b._cascadeOpacityEnabled)for (d = b._children, a = 0, b = d.length; a < b; a++)(e = d[a]) && e._renderCmd && (e._renderCmd._updateDisplayOpacity(this._displayedOpacity), e._renderCmd._updateColor());
        this._dirtyFlag ^= this._dirtyFlag &
            cc.Node._dirtyFlags.opacityDirty
    }, _syncDisplayColor: function (a) {
        var b = this._node, d = this._displayedColor, e = b._realColor;
        void 0 === a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE);
        d.r = 0 | e.r * a.r / 255;
        d.g = 0 | e.g * a.g / 255;
        d.b = 0 | e.b * a.b / 255
    }, _syncDisplayOpacity: function (a) {
        var b = this._node;
        if (void 0 === a) {
            var d = b._parent;
            a = 255;
            d && d._cascadeOpacityEnabled && (a = d.getDisplayedOpacity())
        }
        this._displayedOpacity = b._realOpacity * a / 255
    }, _updateColor: function () {
    }, updateStatus: function () {
        var a =
            cc.Node._dirtyFlags, b = this._dirtyFlag, d = b & a.colorDirty, e = b & a.opacityDirty;
        this._savedDirtyFlag = this._savedDirtyFlag || b;
        d && this._updateDisplayColor();
        e && this._updateDisplayOpacity();
        (d || e) && this._updateColor();
        b & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & a.transformDirty);
        b & a.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & a.orderDirty)
    }, getNodeToParentTransform: function () {
        var a = this._node;
        if (a._usingNormalizedPosition && a._parent) {
            var b = a._parent._contentSize;
            a._position.x = a._normalizedPosition.x * b.width;
            a._position.y = a._normalizedPosition.y * b.height;
            a._normalizedPositionDirty = !1;
            this._dirtyFlag |= cc.Node._dirtyFlags.transformDirty
        }
        if (this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
            b = this._transform;
            b.tx = a._position.x;
            b.ty = a._position.y;
            var d = 1, e = 0, f = 0, g = 1;
            a._rotationX && (g = 0.017453292519943295 * a._rotationX, f = Math.sin(g), g = Math.cos(g));
            a._rotationY && (e = 0.017453292519943295 * a._rotationY, d = Math.cos(e), e = -Math.sin(e));
            b.a = d;
            b.b = e;
            b.c = f;
            b.d = g;
            var h = a._scaleX,
                n = a._scaleY, p = this._anchorPointInPoints.x, r = this._anchorPointInPoints.y, s = 1E-6 > h && -1E-6 < h ? 1E-6 : h, t = 1E-6 > n && -1E-6 < n ? 1E-6 : n;
            if (1 !== h || 1 !== n)d = b.a *= s, e = b.b *= s, f = b.c *= t, g = b.d *= t;
            if (a._skewX || a._skewY)h = Math.tan(-a._skewX * Math.PI / 180), n = Math.tan(-a._skewY * Math.PI / 180), Infinity === h && (h = 99999999), Infinity === n && (n = 99999999), s = r * h, t = p * n, b.a = d - f * n, b.b = e - g * n, b.c = f - d * h, b.d = g - e * h, b.tx += d * s + f * t, b.ty += e * s + g * t;
            b.tx -= d * p + f * r;
            b.ty -= e * p + g * r;
            a._ignoreAnchorPointForPosition && (b.tx += p, b.ty += r);
            a._additionalTransformDirty &&
            (this._transform = cc.affineTransformConcat(b, a._additionalTransform))
        }
        return this._transform
    }, _syncStatus: function (a) {
        var b = cc.Node._dirtyFlags, d = this._dirtyFlag, e = null;
        a ? (e = a._node, this._savedDirtyFlag = this._savedDirtyFlag || a._savedDirtyFlag || d) : this._savedDirtyFlag = this._savedDirtyFlag || d;
        e && e._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (d |= b.colorDirty);
        e && e._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (d |= b.opacityDirty);
        a && a._dirtyFlag & b.transformDirty && (d |= b.transformDirty);
        var e =
            d & b.colorDirty, f = d & b.opacityDirty;
        this._dirtyFlag = d;
        e && this._syncDisplayColor();
        f && this._syncDisplayOpacity();
        (e || f) && this._updateColor();
        d & b.transformDirty && this.transform(a, !0);
        d & b.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & b.orderDirty)
    }, visitChildren: function () {
        var a = cc.renderer, b = this._node, d, e = b._children, f, g = e.length;
        if (0 < g) {
            b.sortAllChildren();
            for (d = 0; d < g; d++)if (f = e[d], 0 > f._localZOrder)f = f._renderCmd, f.visit(this); else break;
            isNaN(b._customZ) && (b._vertexZ = a.assignedZ, a.assignedZ += a.assignedZStep);
            for (a.pushRenderCommand(this); d < g; d++)f = e[d], f._renderCmd.visit(this)
        } else isNaN(b._customZ) && (b._vertexZ = a.assignedZ, a.assignedZ += a.assignedZStep), a.pushRenderCommand(this);
        this._dirtyFlag = 0
    }
};
(function () {
    cc.Node.CanvasRenderCmd = function (a) {
        cc.Node.RenderCmd.call(this, a);
        this._cachedParent = null;
        this._cacheDirty = !1
    };
    var a = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    a.constructor = cc.Node.CanvasRenderCmd;
    a.transform = function (a, d) {
        var e = this.getNodeToParentTransform(), f = this._worldTransform;
        this._cacheDirty = !0;
        if (a) {
            var g = a._worldTransform;
            f.a = e.a * g.a + e.b * g.c;
            f.b = e.a * g.b + e.b * g.d;
            f.c = e.c * g.a + e.d * g.c;
            f.d = e.c * g.b + e.d * g.d;
            f.tx = g.a * e.tx + g.c * e.ty + g.tx;
            f.ty = g.d * e.ty +
                g.ty + g.b * e.tx
        } else f.a = e.a, f.b = e.b, f.c = e.c, f.d = e.d, f.tx = e.tx, f.ty = e.ty;
        if (d && (e = this._node._children) && 0 !== e.length)for (f = 0, g = e.length; f < g; f++)e[f]._renderCmd.transform(this, d)
    };
    a.visit = function (a) {
        if (this._node._visible) {
            if (a = a || this.getParentRenderCmd())this._curLevel = a._curLevel + 1;
            this._syncStatus(a);
            this.visitChildren()
        }
    };
    a.setDirtyFlag = function (a, d) {
        cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, a, d);
        this._setCacheDirty(d);
        this._cachedParent && this._cachedParent.setDirtyFlag(a, !0)
    };
    a._setCacheDirty =
        function () {
            if (!1 === this._cacheDirty) {
                this._cacheDirty = !0;
                var a = this._cachedParent;
                a && a !== this && a._setNodeDirtyForCache && a._setNodeDirtyForCache()
            }
        };
    a._setCachedParent = function (a) {
        if (this._cachedParent !== a) {
            this._cachedParent = a;
            for (var d = this._node._children, e = 0, f = d.length; e < f; e++)d[e]._renderCmd._setCachedParent(a)
        }
    };
    a.detachFromParent = function () {
        this._cachedParent = null;
        for (var a = this._node._children, d, e = 0, f = a.length; e < f; e++)(d = a[e]) && d._renderCmd && d._renderCmd.detachFromParent()
    };
    a.setShaderProgram =
        function (a) {
        };
    a.getShaderProgram = function () {
        return null
    };
    cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function (a) {
        return a ? a.src === cc.SRC_ALPHA && a.dst === cc.ONE || a.src === cc.ONE && a.dst === cc.ONE ? "lighter" : a.src === cc.ZERO && a.dst === cc.SRC_ALPHA ? "destination-in" : a.src === cc.ZERO && a.dst === cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
    }
})();
(function () {
    cc.Node.WebGLRenderCmd = function (a) {
        cc.Node.RenderCmd.call(this, a);
        a = new cc.math.Matrix4;
        var d = a.mat;
        d[2] = d[3] = d[6] = d[7] = d[8] = d[9] = d[11] = d[14] = 0;
        d[10] = d[15] = 1;
        this._transform4x4 = a;
        this._stackMatrix = new cc.math.Matrix4;
        this._camera = this._shaderProgram = null;
        this._currId = -1
    };
    var a = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    a.constructor = cc.Node.WebGLRenderCmd;
    a._updateColor = function () {
    };
    a.visit = function (a) {
        var d = this._node;
        d._visible && (a = a || this.getParentRenderCmd(),
        d._parent && d._parent._renderCmd && (this._curLevel = d._parent._renderCmd._curLevel + 1), d = cc.current_stack, d.stack.push(d.top), this._syncStatus(a), d.top = this._stackMatrix, this.visitChildren(), d.top = d.stack.pop())
    };
    a.transform = function (a, d) {
        var e = this._transform4x4, f = this._stackMatrix, g = this._node, h = (a = a || this.getParentRenderCmd()) ? a._stackMatrix : cc.current_stack.top, n = this.getNodeToParentTransform();
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
        var p = e.mat;
        p[0] = n.a;
        p[4] = n.c;
        p[12] =
            n.tx;
        p[1] = n.b;
        p[5] = n.d;
        p[13] = n.ty;
        cc.kmMat4Multiply(f, h, e);
        p[14] = g._vertexZ;
        null === g._camera || null !== g.grid && g.grid.isActive() || (h = this._anchorPointInPoints.x, n = this._anchorPointInPoints.y, 0 !== h || 0 !== n ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (h |= 0, n |= 0), p = cc.math.Matrix4.createByTranslation(h, n, 0, e), f.multiply(p), g._camera._locateForRenderer(f), p = cc.math.Matrix4.createByTranslation(-h, -n, 0, p), f.multiply(p), e.identity()) : g._camera._locateForRenderer(f));
        if (d && g._children)for (g = g._children, e = 0, f = g.length; e <
        f; e++)g[e]._renderCmd.transform(this, d)
    };
    a.setShaderProgram = function (a) {
        this._shaderProgram = a
    };
    a.getShaderProgram = function () {
        return this._shaderProgram
    }
})();
cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    _texture: null,
    _textureForCanvas: null,
    ctor: function (a, b, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        this._ignoreContentScaleFactor = !1;
        void 0 !== e && this.initWithTileFile(a, b, d, e)
    },
    _createRenderCmd: function () {
        this._renderCmd = cc._renderType === cc.game.RENDER_TYPE_CANVAS ?
            new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
    },
    updateAtlasValues: function () {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function () {
        return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function (a) {
        var b = this.color;
        this._opacityModifyRGB = a;
        this.setColor(b)
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a,
                            b) {
        this._blendFunc = void 0 === b ? a : {src: a, dst: b}
    },
    setTextureAtlas: function (a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function () {
        return this.textureAtlas
    },
    getQuadsToDraw: function () {
        return this.quadsToDraw
    },
    setQuadsToDraw: function (a) {
        this.quadsToDraw = a
    },
    initWithTileFile: function (a, b, d, e) {
        if (!a)throw Error("cc.AtlasNode.initWithTileFile(): title should not be null");
        a = cc.textureCache.addImage(a);
        return this.initWithTexture(a, b, d, e)
    },
    initWithTexture: function (a, b, d, e) {
        return this._renderCmd.initWithTexture(a,
            b, d, e)
    },
    setColor: function (a) {
        this._renderCmd.setColor(a)
    },
    setOpacity: function (a) {
        this._renderCmd.setOpacity(a)
    },
    getTexture: function () {
        return this._texture
    },
    setTexture: function (a) {
        this._texture = a
    },
    _setIgnoreContentScaleFactor: function (a) {
        this._ignoreContentScaleFactor = a
    }
});
_p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.EventHelper.prototype.apply(_p);
cc.AtlasNode.create = function (a, b, d, e) {
    return new cc.AtlasNode(a, b, d, e)
};
(function () {
    cc.AtlasNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1;
        this._colorUnmodified = cc.color.WHITE;
        this._textureToRender = null
    };
    var a = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.AtlasNode.CanvasRenderCmd;
    a.initWithTexture = function (a, d, e, f) {
        var g = this._node;
        g._itemWidth = d;
        g._itemHeight = e;
        g._opacityModifyRGB = !0;
        g._texture = a;
        if (!g._texture)return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._textureToRender = a;
        this._calculateMaxItems();
        g.quadsToDraw = f;
        return !0
    };
    a.setColor = function (a) {
        var d = this._node._realColor;
        if (d.r !== a.r || d.g !== a.g || d.b !== a.b)this._colorUnmodified = a, this._changeTextureColor()
    };
    a._changeTextureColor = function () {
        var a = this._node._texture, d = this._colorUnmodified, e = a.getHtmlElementObj(), e = cc.rect(0, 0, e.width, e.height);
        a === this._textureToRender ? this._textureToRender = a._generateColorTexture(d.r, d.g, d.b, e) : a._generateColorTexture(d.r, d.g, d.b, e, this._textureToRender.getHtmlElementObj())
    };
    a.setOpacity = function (a) {
        cc.Node.prototype.setOpacity.call(this._node, a)
    };
    a._calculateMaxItems = function () {
        var a = this._node, d = a._texture.getContentSize();
        a._itemsPerColumn = 0 | d.height / a._itemHeight;
        a._itemsPerRow = 0 | d.width / a._itemWidth
    }
})();
(function () {
    cc.AtlasNode.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureAtlas = null;
        this._colorUnmodified = cc.color.WHITE;
        this._uniformColor = this._colorF32Array = null;
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this._shaderProgram.getProgram(), "u_color")
    };
    var a = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor =
        cc.AtlasNode.WebGLRenderCmd;
    a._updateBlendFunc = function () {
        var a = this._node;
        this._textureAtlas.texture.hasPremultipliedAlpha() || (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    };
    a._updateOpacityModifyRGB = function () {
        this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
    };
    a.rendering = function (a) {
        a = a || cc._renderContext;
        var d = this._node;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        cc.glBlendFunc(d._blendFunc.src,
            d._blendFunc.dst);
        this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(d.quadsToDraw, 0))
    };
    a.initWithTexture = function (a, d, e, f) {
        var g = this._node;
        g._itemWidth = d;
        g._itemHeight = e;
        this._colorUnmodified = cc.color.WHITE;
        g._opacityModifyRGB = !0;
        g._blendFunc.src = cc.BLEND_SRC;
        g._blendFunc.dst = cc.BLEND_DST;
        d = g._realColor;
        this._colorF32Array = new Float32Array([d.r / 255, d.g / 255, d.b / 255, g._realOpacity / 255]);
        this._textureAtlas = new cc.TextureAtlas;
        this._textureAtlas.initWithTexture(a, f);
        if (!this._textureAtlas)return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        g.quadsToDraw = f;
        return !0
    };
    a.setColor = function (a) {
        var d = cc.color(a.r, a.g, a.b), e = this._node;
        this._colorUnmodified = a;
        a = this._displayedOpacity;
        e._opacityModifyRGB && (d.r = d.r * a / 255, d.g = d.g * a / 255, d.b = d.b * a / 255);
        cc.Node.prototype.setColor.call(e, d)
    };
    a.setOpacity = function (a) {
        var d = this._node;
        cc.Node.prototype.setOpacity.call(d,
            a);
        d._opacityModifyRGB && (d.color = this._colorUnmodified)
    };
    a._updateColor = function () {
        var a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255])
    };
    a.getTexture = function () {
        return this._textureAtlas.texture
    };
    a.setTexture = function (a) {
        this._textureAtlas.texture = a;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB()
    };
    a._calculateMaxItems = function () {
        var a = this._node, d = this._textureAtlas.texture, e = d.getContentSize();
        a._ignoreContentScaleFactor && (e =
            d.getContentSizeInPixels());
        a._itemsPerColumn = 0 | e.height / a._itemHeight;
        a._itemsPerRow = 0 | e.width / a._itemWidth
    }
})();
cc._tmp.WebGLTexture2D = function () {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _textureLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        ctor: function () {
            this._contentSize = cc.size(0, 0);
            this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function () {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
            cc.loader.release(this.url)
        },
        getPixelFormat: function () {
            return this._pixelFormat
        },
        getPixelsWide: function () {
            return this._pixelsWide
        },
        getPixelsHigh: function () {
            return this._pixelsHigh
        },
        getName: function () {
            return this._webTextureObj
        },
        getContentSize: function () {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function () {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function () {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function () {
            return this._contentSize
        },
        getMaxS: function () {
            return this.maxS
        },
        setMaxS: function (a) {
            this.maxS = a
        },
        getMaxT: function () {
            return this.maxT
        },
        setMaxT: function (a) {
            this.maxT = a
        },
        getShaderProgram: function () {
            return this.shaderProgram
        },
        setShaderProgram: function (a) {
            this.shaderProgram = a
        },
        hasPremultipliedAlpha: function () {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function () {
            return this._hasMipmaps
        },
        description: function () {
            return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " +
                this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
        },
        releaseData: function (a) {
        },
        keepData: function (a, b) {
            return a
        },
        initWithData: function (a, b, d, e, f) {
            var g = cc.Texture2D, h = cc._renderContext, n = h.RGBA, p = h.UNSIGNED_BYTE, r = d * cc.Texture2D._B[b] / 8;
            0 === r % 8 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 8) : 0 === r % 4 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 4) : 0 === r % 2 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 2) : h.pixelStorei(h.UNPACK_ALIGNMENT, 1);
            this._webTextureObj = h.createTexture();
            cc.glBindTexture2D(this);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE);
            switch (b) {
                case g.PIXEL_FORMAT_RGBA8888:
                    n = h.RGBA;
                    break;
                case g.PIXEL_FORMAT_RGB888:
                    n = h.RGB;
                    break;
                case g.PIXEL_FORMAT_RGBA4444:
                    p = h.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case g.PIXEL_FORMAT_RGB5A1:
                    p = h.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case g.PIXEL_FORMAT_RGB565:
                    p = h.UNSIGNED_SHORT_5_6_5;
                    break;
                case g.PIXEL_FORMAT_AI88:
                    n = h.LUMINANCE_ALPHA;
                    break;
                case g.PIXEL_FORMAT_A8:
                    n = h.ALPHA;
                    break;
                case g.PIXEL_FORMAT_I8:
                    n = h.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            h.texImage2D(h.TEXTURE_2D, 0, n, d, e, 0, n, p, a);
            this._contentSize.width = f.width;
            this._contentSize.height = f.height;
            this._pixelsWide = d;
            this._pixelsHigh = e;
            this._pixelFormat = b;
            this.maxS = f.width / d;
            this.maxT = f.height / e;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            return this._textureLoaded = !0
        },
        drawAtPoint: function (a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0], d = this._pixelsWide * this.maxS, e = this._pixelsHigh * this.maxT;
            a = [a.x, a.y, 0, d + a.x, a.y, 0, a.x, e + a.y, 0, d + a.x, e + a.y, 0];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            d = cc._renderContext;
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, a);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, d.FLOAT, !1, 0, b);
            d.drawArrays(d.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function (a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            var d = cc._renderContext;
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, a);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, d.FLOAT, !1, 0, b);
            d.drawArrays(d.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function (a) {
            if (null == a)return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var b = a.getWidth(), d = a.getHeight(), e = cc.configuration.getMaxTextureSize();
            if (b > e || d > e)return cc.log(cc._LogInfos.Texture2D_initWithImage_2, b, d, e, e), !1;
            this._textureLoaded = !0;
            return this._initPremultipliedATextureWithImage(a, b, d)
        },
        initWithElement: function (a) {
            a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a, this._textureLoaded = !0)
        },
        getHtmlElementObj: function () {
            return this._htmlElementObj
        },
        isLoaded: function () {
            return this._textureLoaded
        },
        handleLoadedTexture: function (a) {
            a = void 0 === a ? !1 : a;
            if (cc.game._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var b = cc.loader.getRes(this.url);
                    if (!b)return;
                    this.initWithElement(b)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (b = cc._renderContext, cc.glBindTexture2D(this), b.pixelStorei(b.UNPACK_ALIGNMENT, 4), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), b.texImage2D(b.TEXTURE_2D,
                    0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, this._htmlElementObj), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), b = this._htmlElementObj.height, this._pixelsWide =
                    this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = b, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasPremultipliedAlpha = a, this._hasMipmaps = !1, this.dispatchEvent("load"))
            }
        },
        initWithString: function (a, b, d, e, f, g) {
            cc.log(cc._LogInfos.Texture2D_initWithString);
            return null
        },
        initWithETCFile: function (a) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
            return !1
        },
        initWithPVRFile: function (a) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
            return !1
        },
        initWithPVRTCData: function (a, b, d, e, f, g) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
            return !1
        },
        setTexParameters: function (a, b, d, e) {
            var f = cc._renderContext;
            void 0 !== b && (a = {minFilter: a, magFilter: b, wrapS: d, wrapT: e});
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh) || a.wrapS === f.CLAMP_TO_EDGE && a.wrapT === f.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
            cc.glBindTexture2D(this);
            f.texParameteri(f.TEXTURE_2D,
                f.TEXTURE_MIN_FILTER, a.minFilter);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, a.magFilter);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, a.wrapS);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, a.wrapT)
        },
        setAntiAliasTexParameters: function () {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR)
        },
        setAliasTexParameters: function () {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        generateMipmap: function () {
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
            cc.glBindTexture2D(this);
            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
            this._hasMipmaps = !0
        },
        stringForFormat: function () {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function (a) {
            a = a || this._pixelFormat;
            var b = cc.Texture2D._B[a];
            if (null != b)return b;
            cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a);
            return -1
        },
        _initPremultipliedATextureWithImage: function (a, b, d) {
            var e = cc.Texture2D, f = a.getData(), g = null, g = null, h = a.hasAlpha(), n = cc.size(a.getWidth(), a.getHeight()), p = e.defaultPixelFormat, r = a.getBitsPerComponent();
            h || (8 <= r ? p = e.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), p = e.PIXEL_FORMAT_RGB565));
            var s = b * d;
            if (p === e.PIXEL_FORMAT_RGB565)if (h)for (f = new Uint16Array(b * d), g = a.getData(), r = 0; r < s; ++r)f[r] = (g[r] >> 0 & 255) >> 3 << 11 | (g[r] >> 8 & 255) >> 2 << 5 | (g[r] >> 16 & 255) >> 3 << 0; else for (f = new Uint16Array(b * d), g = a.getData(), r = 0; r < s; ++r)f[r] = (g[r] & 255) >> 3 << 11 | (g[r] & 255) >> 2 << 5 | (g[r] & 255) >> 3 << 0; else if (p === e.PIXEL_FORMAT_RGBA4444)for (f = new Uint16Array(b * d), g = a.getData(), r = 0; r < s; ++r)f[r] = (g[r] >>
                0 & 255) >> 4 << 12 | (g[r] >> 8 & 255) >> 4 << 8 | (g[r] >> 16 & 255) >> 4 << 4 | (g[r] >> 24 & 255) >> 4 << 0; else if (p === e.PIXEL_FORMAT_RGB5A1)for (f = new Uint16Array(b * d), g = a.getData(), r = 0; r < s; ++r)f[r] = (g[r] >> 0 & 255) >> 3 << 11 | (g[r] >> 8 & 255) >> 3 << 6 | (g[r] >> 16 & 255) >> 3 << 1 | (g[r] >> 24 & 255) >> 7 << 0; else if (p === e.PIXEL_FORMAT_A8)for (f = new Uint8Array(b * d), g = a.getData(), r = 0; r < s; ++r)f[r] = g >> 24 & 255;
            if (h && p === e.PIXEL_FORMAT_RGB888)for (g = a.getData(), f = new Uint8Array(b * d * 3), r = 0; r < s; ++r)f[3 * r] = g >> 0 & 255, f[3 * r + 1] = g >> 8 & 255, f[3 * r + 2] = g >> 16 & 255;
            this.initWithData(f,
                p, b, d, n);
            a.getData();
            this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
            return !0
        },
        addLoadedEventListener: function (a, b) {
            this.addEventListener("load", a, b)
        },
        removeLoadedEventListener: function (a) {
            this.removeEventListener("load", a)
        }
    })
};
cc._tmp.WebGLTextureAtlas = function () {
    var a = cc.TextureAtlas.prototype;
    a._setupVBO = function () {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    };
    a._mapBuffers = function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER,
            this._indices, a.STATIC_DRAW)
    };
    a.drawNumberOfQuads = function (a, d) {
        d = d || 0;
        if (0 !== a && this.texture && this.texture.isLoaded()) {
            var e = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            e.bindBuffer(e.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && (e.bufferData(e.ARRAY_BUFFER, this._quadsArrayBuffer, e.DYNAMIC_DRAW), this.dirty = !1);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, e.FLOAT, !1, 24, 0);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, e.UNSIGNED_BYTE,
                !0, 24, 12);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, e.FLOAT, !1, 24, 16);
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? e.drawElements(e.TRIANGLE_STRIP, 6 * a, e.UNSIGNED_SHORT, 6 * d * this._indices.BYTES_PER_ELEMENT) : e.drawElements(e.TRIANGLES, 6 * a, e.UNSIGNED_SHORT, 6 * d * this._indices.BYTES_PER_ELEMENT);
            cc.g_NumberOfDraws++
        }
    }
};
cc._tmp.WebGLTextureCache = function () {
    var a = cc.textureCache;
    a.handleLoadedTexture = function (a) {
        var d = this._textures, e;
        cc.game._rendererInitialized || (d = this._loadedTexturesBefore);
        e = d[a];
        e || (e = d[a] = new cc.Texture2D, e.url = a);
        if (".png" === cc.path.extname(a)) {
            if (e.handleLoadedTexture(!0), MW.isStoreImageData && a == res.gameScene_1_png && "undefined" !== typeof document && (a = document.createElement("canvas"), d = e._htmlElementObj, a.width = d.width, a.height = d.height, a.getContext)) {
                var f = a.getContext("2d");
                f.drawImage(d,
                    0, 0);
                a = f.getImageData(0, 0, a.width, a.height);
                e = e._htmlElementObj.width * e._htmlElementObj.height * 4;
                MW.imageData = [];
                for (d = 3; d < e; d += 4)MW.imageData.push(a.data[d])
            }
        } else e.handleLoadedTexture()
    };
    a.addImage = function (a, d, e) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var f = this._textures;
        cc.game._rendererInitialized || (f = this._loadedTexturesBefore);
        var g = f[a] || f[cc.loader._getAliase(a)];
        if (g)return g.isLoaded() ? d && d.call(e, g) : g.addEventListener("load", function () {
            d && d.call(e, g)
        }, e), g;
        g = f[a] = new cc.Texture2D;
        g.url = a;
        (cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function (g, n) {
            if (g)return d && d.call(e, g);
            cc.textureCache.handleLoadedTexture(a);
            var p = f[a];
            d && d.call(e, p)
        });
        return g
    };
    a.addImageAsync = a.addImage;
    a = null
};
cc._tmp.PrototypeTexture2D = function () {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function (a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    };
    a.PIXEL_FORMAT_RGBA8888 = 2;
    a.PIXEL_FORMAT_RGB888 = 3;
    a.PIXEL_FORMAT_RGB565 = 4;
    a.PIXEL_FORMAT_A8 = 5;
    a.PIXEL_FORMAT_I8 = 6;
    a.PIXEL_FORMAT_AI88 = 7;
    a.PIXEL_FORMAT_RGBA4444 = 8;
    a.PIXEL_FORMAT_RGB5A1 = 7;
    a.PIXEL_FORMAT_PVRTC4 = 9;
    a.PIXEL_FORMAT_PVRTC2 = 10;
    a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT;
    var b = cc.Texture2D._M = {};
    b[a.PIXEL_FORMAT_RGBA8888] =
        "RGBA8888";
    b[a.PIXEL_FORMAT_RGB888] = "RGB888";
    b[a.PIXEL_FORMAT_RGB565] = "RGB565";
    b[a.PIXEL_FORMAT_A8] = "A8";
    b[a.PIXEL_FORMAT_I8] = "I8";
    b[a.PIXEL_FORMAT_AI88] = "AI88";
    b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    b = cc.Texture2D._B = {};
    b[a.PIXEL_FORMAT_RGBA8888] = 32;
    b[a.PIXEL_FORMAT_RGB888] = 24;
    b[a.PIXEL_FORMAT_RGB565] = 16;
    b[a.PIXEL_FORMAT_A8] = 8;
    b[a.PIXEL_FORMAT_I8] = 8;
    b[a.PIXEL_FORMAT_AI88] = 16;
    b[a.PIXEL_FORMAT_RGBA4444] =
        16;
    b[a.PIXEL_FORMAT_RGB5A1] = 16;
    b[a.PIXEL_FORMAT_PVRTC4] = 4;
    b[a.PIXEL_FORMAT_PVRTC2] = 3;
    a = cc.Texture2D.prototype;
    cc.defineGetterSetter(a, "name", a.getName);
    cc.defineGetterSetter(a, "pixelFormat", a.getPixelFormat);
    cc.defineGetterSetter(a, "pixelsWidth", a.getPixelsWide);
    cc.defineGetterSetter(a, "pixelsHeight", a.getPixelsHigh);
    cc.defineGetterSetter(a, "width", a._getWidth);
    cc.defineGetterSetter(a, "height", a._getHeight)
};
cc._tmp.PrototypeTextureAtlas = function () {
    var a = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
    cc.defineGetterSetter(a, "capacity", a.getCapacity);
    cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var a = {
            _contentSize: null,
            _textureLoaded: !1,
            _htmlElementObj: null,
            url: null,
            _pattern: null,
            ctor: function () {
                this._contentSize = cc.size(0, 0);
                this._textureLoaded = !1;
                this._htmlElementObj = null;
                this._pattern = ""
            },
            getPixelsWide: function () {
                return this._contentSize.width
            },
            getPixelsHigh: function () {
                return this._contentSize.height
            },
            getContentSize: function () {
                var a = cc.contentScaleFactor();
                return cc.size(this._contentSize.width /
                    a, this._contentSize.height / a)
            },
            _getWidth: function () {
                return this._contentSize.width / cc.contentScaleFactor()
            },
            _getHeight: function () {
                return this._contentSize.height / cc.contentScaleFactor()
            },
            getContentSizeInPixels: function () {
                return this._contentSize
            },
            initWithElement: function (a) {
                a && (this._htmlElementObj = a, this._contentSize.width = a.width, this._contentSize.height = a.height, this._textureLoaded = !0)
            },
            getHtmlElementObj: function () {
                return this._htmlElementObj
            },
            isLoaded: function () {
                return this._textureLoaded
            },
            handleLoadedTexture: function () {
                if (!this._textureLoaded) {
                    if (!this._htmlElementObj) {
                        var a =
                            cc.loader.getRes(this.url);
                        if (!a)return;
                        this.initWithElement(a)
                    }
                    a = this._htmlElementObj;
                    this._contentSize.width = a.width;
                    this._contentSize.height = a.height;
                    this.dispatchEvent("load")
                }
            },
            description: function () {
                return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
            },
            initWithData: function (a, d, e, f, g) {
                return !1
            },
            initWithImage: function (a) {
                return !1
            },
            initWithString: function (a, d, e, f, g, h) {
                return !1
            },
            releaseTexture: function () {
                cc.loader.release(this.url)
            },
            getName: function () {
                return null
            },
            getMaxS: function () {
                return 1
            },
            setMaxS: function (a) {
            },
            getMaxT: function () {
                return 1
            },
            setMaxT: function (a) {
            },
            getPixelFormat: function () {
                return null
            },
            getShaderProgram: function () {
                return null
            },
            setShaderProgram: function (a) {
            },
            hasPremultipliedAlpha: function () {
                return !1
            },
            hasMipmaps: function () {
                return !1
            },
            releaseData: function (a) {
            },
            keepData: function (a, d) {
                return a
            },
            drawAtPoint: function (a) {
            },
            drawInRect: function (a) {
            },
            initWithETCFile: function (a) {
                cc.log(cc._LogInfos.Texture2D_initWithETCFile);
                return !1
            },
            initWithPVRFile: function (a) {
                cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
                return !1
            },
            initWithPVRTCData: function (a, d, e, f, g, h) {
                cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
                return !1
            },
            setTexParameters: function (a, d, e, f) {
                void 0 !== d && (a = {minFilter: a, magFilter: d, wrapS: e, wrapT: f});
                this._pattern = a.wrapS === cc.REPEAT && a.wrapT === cc.REPEAT ? "repeat" : a.wrapS === cc.REPEAT ? "repeat-x" : a.wrapT === cc.REPEAT ? "repeat-y" : ""
            },
            setAntiAliasTexParameters: function () {
            },
            setAliasTexParameters: function () {
            },
            generateMipmap: function () {
            },
            stringForFormat: function () {
                return ""
            },
            bitsPerPixelForFormat: function (a) {
                return -1
            },
            addLoadedEventListener: function (a, d) {
                this.addEventListener("load", a, d)
            },
            removeLoadedEventListener: function (a) {
                this.removeEventListener("load", a)
            },
            _generateColorTexture: function () {
            },
            _generateTextureCacheForColor: function () {
                if (this.channelCache)return this.channelCache;
                var a = [document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas")], d = this._htmlElementObj, e = d.width, f = d.height;
                a[0].width = e;
                a[0].height = f;
                a[1].width = e;
                a[1].height =
                    f;
                a[2].width = e;
                a[2].height = f;
                a[3].width = e;
                a[3].height = f;
                var g = a[3].getContext("2d");
                g.drawImage(d, 0, 0);
                for (var g = g.getImageData(0, 0, e, f).data, h, n = 0; 4 > n; n++) {
                    h = a[n].getContext("2d");
                    for (var p = h.getImageData(0, 0, e, f), r = p.data, s = 0; s < g.length; s += 4)r[s] = 0 === n ? g[s] : 0, r[s + 1] = 1 === n ? g[s + 1] : 0, r[s + 2] = 2 === n ? g[s + 2] : 0, r[s + 3] = g[s + 3];
                    h.putImageData(p, 0, 0)
                }
                d.onload = null;
                return this.channelCache = a
            },
            _grayElementObj: null,
            _backupElement: null,
            _isGray: !1,
            _switchToGray: function (a) {
                this._textureLoaded && this._isGray !== a &&
                ((this._isGray = a) ? (this._backupElement = this._htmlElementObj, this._grayElementObj || (this._grayElementObj = cc.Texture2D._generateGrayTexture(this._htmlElementObj)), this._htmlElementObj = this._grayElementObj) : null !== this._backupElement && (this._htmlElementObj = this._backupElement))
            }
        };
        a._generateColorTexture = cc.sys._supportCanvasNewBlendModes ? function (a, d, e, f, g) {
            var h = !1;
            g ? h = !0 : g = document.createElement("canvas");
            var n = this._htmlElementObj;
            f || (f = cc.rect(0, 0, n.width, n.height));
            g.width = f.width;
            g.height = f.height;
            var p = g.getContext("2d");
            p.globalCompositeOperation = "source-over";
            p.fillStyle = "rgb(" + (a | 0) + "," + (d | 0) + "," + (e | 0) + ")";
            p.fillRect(0, 0, f.width, f.height);
            p.globalCompositeOperation = "multiply";
            p.drawImage(n, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
            p.globalCompositeOperation = "destination-atop";
            p.drawImage(n, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height);
            if (h)return g;
            a = new cc.Texture2D;
            a.initWithElement(g);
            a.handleLoadedTexture();
            return a
        } : function (a, d, e, f, g) {
            var h = !1;
            g ? h = !0 : g = document.createElement("canvas");
            var n = this._htmlElementObj;
            f || (f = cc.rect(0, 0, n.width, n.height));
            var p, r, n = f.x;
            p = f.y;
            r = f.width;
            f = f.height;
            if (r && f) {
                g.width = r;
                g.height = f;
                var s = g.getContext("2d"), t = cc.textureCache.getTextureColors(this);
                s.globalCompositeOperation = "lighter";
                s.drawImage(t[3], n, p, r, f, 0, 0, r, f);
                0 < a && (s.globalAlpha = a / 255, s.drawImage(t[0], n, p, r, f, 0, 0, r, f));
                0 < d && (s.globalAlpha = d / 255, s.drawImage(t[1], n, p, r, f, 0, 0, r, f));
                0 < e && (s.globalAlpha = e / 255, s.drawImage(t[2], n, p, r, f, 0, 0, r, f));
                if (h)return g;
                a = new cc.Texture2D;
                a.initWithElement(g);
                a.handleLoadedTexture();
                return a
            }
        };
        cc.Texture2D = cc.Class.extend(a);
        cc.Texture2D._generateGrayTexture = function (a, d, e) {
            if (null === a)return null;
            e = e || document.createElement("canvas");
            d = d || cc.rect(0, 0, a.width, a.height);
            e.width = d.width;
            e.height = d.height;
            var f = e.getContext("2d");
            f.drawImage(a, d.x, d.y, d.width, d.height, 0, 0, d.width, d.height);
            a = f.getImageData(0, 0, d.width, d.height);
            d = a.data;
            for (var g = 0, h = d.length; g < h; g += 4)d[g] = d[g + 1] = d[g + 2] = 0.34 * d[g] + 0.5 * d[g + 1] + 0.16 * d[g + 2];
            f.putImageData(a, 0, 0);
            return e
        }
    } else cc._renderType ===
    cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
    cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
    cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
    cc._tmp.PrototypeTexture2D();
    delete cc._tmp.PrototypeTexture2D
});
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1E3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function () {
        var a, b = this._loadedTexturesBefore, d = this._textures;
        for (a in b) {
            var e = b[a];
            e.handleLoadedTexture();
            d[a] = e
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function (a) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function (a) {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function () {
        return "\x3cTextureCache | Number of textures \x3d " +
            this._textures.length + "\x3e"
    },
    textureForKey: function (a) {
        cc.log(cc._LogInfos.textureCache_textureForKey);
        return this.getTextureForKey(a)
    },
    getTextureForKey: function (a) {
        return this._textures[a] || this._textures[cc.loader._getAliase(a)]
    },
    getKeyByTexture: function (a) {
        for (var b in this._textures)if (this._textures[b] === a)return b;
        return null
    },
    _generalTextureKey: function (a) {
        return "_textureKey_" + a
    },
    getTextureColors: function (a) {
        var b = a._htmlElementObj, d = this.getKeyByTexture(b);
        d || (d = b instanceof HTMLImageElement ?
            b.src : this._generalTextureKey(a.__instanceId));
        this._textureColorsCache[d] || (this._textureColorsCache[d] = a._generateTextureCacheForColor());
        return this._textureColorsCache[d]
    },
    addPVRImage: function (a) {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function () {
        var a = this._textures, b;
        for (b in a)a[b] && a[b].releaseTexture();
        this._textures = {}
    },
    removeTexture: function (a) {
        if (a) {
            var b = this._textures, d;
            for (d in b)b[d] === a && (b[d].releaseTexture(), delete b[d])
        }
    },
    removeTextureForKey: function (a) {
        null !=
        a && this._textures[a] && delete this._textures[a]
    },
    cacheImage: function (a, b) {
        if (b instanceof cc.Texture2D)this._textures[a] = b; else {
            var d = new cc.Texture2D;
            d.initWithElement(b);
            d.handleLoadedTexture();
            this._textures[a] = d
        }
    },
    addUIImage: function (a, b) {
        cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
        if (b && this._textures[b])return this._textures[b];
        var d = new cc.Texture2D;
        d.initWithImage(a);
        null != b ? this._textures[b] = d : cc.log(cc._LogInfos.textureCache_addUIImage);
        return d
    },
    dumpCachedTextureInfo: function () {
        var a =
            0, b = 0, d = this._textures, e;
        for (e in d) {
            var f = d[e];
            a++;
            f.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, e, f.getHtmlElementObj().src, f.pixelsWidth, f.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, e, f.pixelsWidth, f.pixelsHeight);
            b += f.pixelsWidth * f.pixelsHeight * 4
        }
        d = this._textureColorsCache;
        for (e in d) {
            var f = d[e], g;
            for (g in f) {
                var h = f[g];
                a++;
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, e, h.width, h.height);
                b += h.width *
                    h.height * 4
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, b / 1024, (b / 1048576).toFixed(2))
    },
    _clear: function () {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = 0 | 1E3 * Math.random();
        this._loadedTexturesBefore = {}
    }
};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var a = cc.textureCache;
        a.handleLoadedTexture = function (a) {
            var d = this._textures, e = d[a];
            e || (e = d[a] = new cc.Texture2D, e.url = a);
            e.handleLoadedTexture()
        };
        a.addImage = function (a, d, e) {
            cc.assert(a, cc._LogInfos.Texture2D_addImage);
            var f = this._textures, g = f[a] || f[cc.loader._getAliase(a)];
            if (g)return g.isLoaded() ? d && d.call(e, g) : g.addEventListener("load", function () {
                d && d.call(e, g)
            }, e), g;
            g = f[a] = new cc.Texture2D;
            g.url = a;
            (cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function (g, n) {
                if (g)return d && d.call(e, g);
                cc.textureCache.handleLoadedTexture(a);
                var p = f[a];
                d && d.call(e, p)
            });
            return g
        };
        a.addImageAsync = a.addImage;
        a = null
    } else cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache)
});
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function (a, b) {
        this._buffersVBO = [];
        cc.isString(a) ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    getTotalQuads: function () {
        return this._totalQuads
    },
    getCapacity: function () {
        return this._capacity
    },
    getTexture: function () {
        return this.texture
    },
    setTexture: function (a) {
        this.texture = a
    },
    setDirty: function (a) {
        this.dirty =
            a
    },
    isDirty: function () {
        return this.dirty
    },
    getQuads: function () {
        return this._quads
    },
    setQuads: function (a) {
        this._quads = a
    },
    _copyQuadsToTextureAtlas: function (a, b) {
        if (a)for (var d = 0; d < a.length; d++)this._setQuadToArray(a[d], b + d)
    },
    _setQuadToArray: function (a, b) {
        var d = this._quads;
        d[b] ? (d[b].bl = a.bl, d[b].br = a.br, d[b].tl = a.tl, d[b].tr = a.tr) : d[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function () {
        return "\x3ccc.TextureAtlas | totalQuads \x3d" +
            this._totalQuads + "\x3e"
    },
    _setupIndices: function () {
        if (0 !== this._capacity)for (var a = this._indices, b = this._capacity, d = 0; d < b; d++)cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * d + 0] = 4 * d + 0, a[6 * d + 1] = 4 * d + 0, a[6 * d + 2] = 4 * d + 2, a[6 * d + 3] = 4 * d + 1, a[6 * d + 4] = 4 * d + 3, a[6 * d + 5] = 4 * d + 3) : (a[6 * d + 0] = 4 * d + 0, a[6 * d + 1] = 4 * d + 1, a[6 * d + 2] = 4 * d + 2, a[6 * d + 3] = 4 * d + 3, a[6 * d + 4] = 4 * d + 2, a[6 * d + 5] = 4 * d + 1)
    },
    _setupVBO: function () {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    },
    _mapBuffers: function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    },
    initWithFile: function (a, b) {
        var d = cc.textureCache.addImage(a);
        if (d)return this.initWithTexture(d, b);
        cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
        return !1
    },
    initWithTexture: function (a, b) {
        cc.assert(a,
            cc._LogInfos.TextureAtlas_initWithTexture);
        this._capacity = b |= 0;
        this._totalQuads = 0;
        this.texture = a;
        this._quads = [];
        this._indices = new Uint16Array(6 * b);
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._quadsArrayBuffer = new ArrayBuffer(d * b);
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        if ((!this._quads || !this._indices) && 0 < b)return !1;
        for (var e = this._quads, f = 0; f < b; f++)e[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, f * d);
        this._setupIndices();
        this._setupVBO();
        return this.dirty = !0
    },
    updateQuad: function (a, b) {
        cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
        cc.assert(0 <= b && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
        this._totalQuads = Math.max(b + 1, this._totalQuads);
        this._setQuadToArray(a, b);
        this.dirty = !0
    },
    insertQuad: function (a, b) {
        cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
        this._totalQuads++;
        if (this._totalQuads > this._capacity)cc.log(cc._LogInfos.TextureAtlas_insertQuad); else {
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, e = b * d, f = (this._totalQuads -
                1 - b) * d;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d);
            this._setQuadToArray(a, b);
            this.dirty = !0
        }
    },
    insertQuads: function (a, b, d) {
        d = d || a.length;
        cc.assert(b + d <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads += d;
        if (this._totalQuads > this._capacity)cc.log(cc._LogInfos.TextureAtlas_insertQuad); else {
            var f = b *
                e, g = (this._totalQuads - 1 - b - d) * e, h = this._totalQuads - 1 - d, n;
            for (n = 0; n < d; n++)this._quads[h + n] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * e);
            this._quadsReader.set(this._quadsReader.subarray(f, f + g), f + e * d);
            for (n = 0; n < d; n++)this._setQuadToArray(a[n], b + n);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function (a, b) {
        if (a !== b) {
            cc.assert(0 <= b || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
            cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, e = this._quadsReader, f = e.subarray(a * d, d), g;
            a > b ? (g = b * d, e.set(e.subarray(g, g + (a - b) * d), g + d), e.set(f, g)) : (g = (a + 1) * d, e.set(e.subarray(g, g + (b - a) * d), g - d), e.set(f, b * d));
            this.dirty = !0
        }
    },
    removeQuadAtIndex: function (a) {
        cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads--;
        this._quads.length = this._totalQuads;
        if (a !== this._totalQuads) {
            var d = (a + 1) * b;
            this._quadsReader.set(this._quadsReader.subarray(d,
                d + (this._totalQuads - a) * b), d - b)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function (a, b) {
        cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
        this._totalQuads -= b;
        if (a !== this._totalQuads) {
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, e = (a + b) * d, f = a * d;
            this._quadsReader.set(this._quadsReader.subarray(e, e + (this._totalQuads - a) * d), f)
        }
        this.dirty = !0
    },
    removeAllQuads: function () {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function (a) {
        this.dirty = a
    },
    resizeCapacity: function (a) {
        if (a === this._capacity)return !0;
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, a);
        var e = this._capacity = 0 | a, f = this._totalQuads;
        if (null === this._quads)for (this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(b * e), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), a = 0; a < e; a++)this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b); else {
            var g, h, n = this._quads;
            if (e > d) {
                g = [];
                h = new ArrayBuffer(b * e);
                for (a = 0; a < f; a++)g[a] = new cc.V3F_C4B_T2F_Quad(n[a].tl,
                    n[a].bl, n[a].tr, n[a].br, h, a * b);
                for (; a < e; a++)g[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, h, a * b)
            } else for (f = Math.max(f, e), g = [], h = new ArrayBuffer(b * e), a = 0; a < f; a++)g[a] = new cc.V3F_C4B_T2F_Quad(n[a].tl, n[a].bl, n[a].tr, n[a].br, h, a * b);
            this._quadsReader = new Uint8Array(h);
            this._quads = g;
            this._quadsArrayBuffer = h
        }
        null === this._indices ? this._indices = new Uint16Array(6 * e) : e > d ? (b = new Uint16Array(6 * e), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * e);
        this._setupIndices();
        this._mapBuffers();
        return this.dirty = !0
    },
    increaseTotalQuadsWith: function (a) {
        this._totalQuads += a
    },
    moveQuadsFromIndex: function (a, b, d) {
        if (void 0 === d) {
            if (d = b, b = this._totalQuads - a, cc.assert(d + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b)return
        } else if (cc.assert(d + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a === d)return;
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, f = a * e, g = b * e, h = this._quadsReader,
            n = h.subarray(f, f + g), p = d * e;
        d < a ? (b = d * e, h.set(h.subarray(b, b + (a - d) * e), b + g)) : (b = (a + b) * e, h.set(h.subarray(b, b + (d - a) * e), f));
        h.set(n, p);
        this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function (a, b) {
        for (var d = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, e = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d), f = 0; f < d; f++)e[f] = 0
    },
    drawQuads: function () {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function () {
        var a = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]),
        this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
        this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
    }
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function (a, b) {
    return new cc.TextureAtlas(a, b)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas)
});
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
    _className: "Scene", ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize())
    }
});
cc.Scene.create = function () {
    return new cc.Scene
};
var customImageData1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAREAAABcCAYAAABJJYGIAAAABHNCSVQICAgIfAhkiAAAEnFJREFUeJztne11HLcVht8lOaBk2bJpR7IdOzknVAlMCVQJUgl0CWIJVAliCWIJZglRCeJPO8lJIlvWBwlwd/NjABIEAczFx2CwKzzn8HB3BwNgMLgvLi4wuzOsGILzPQD78u0R4ZRjAGcAzjrGTkarWKNRGYLzAwA7APYAPCGccij/v+oYO6WWMxOc7wJ4HV7FG5x2jD1OzMOJrOMT0ERjiGMAJyGNREFw/hK0GxXD0xQBFJwvc1ZG49B4H9T5fGSoM6lPJpRz2DH23JLfAYAXMRl2jM0i66KXvwfgQP6l8hy9rbzyJdrKUNCoCM5fIE+DKA4AHAjOTwH81DF2linf3Uz5lM47hVuiLjgHgFP0ne+4eI3KsY/eyKpAcL6DXrxyDmTPADwTnB+jF803tkQbGQvMiuB8T3D+GnkFRGcfwGvBea5GH9PQd0bMewz2AbwQnOds39rYl4Y7OYLzfQD/wHie8AE8tlKliGiNUmIEfik4f5aSgexMY3aovRHzHpNd9O2bYxpaI2MNcGSkrfyM8W1lBw5bqU5EZPzjZeFijxJHzLGNvNbpDJVnqUJdKfvDScZDE5CSHJn3sjoRQS8gU7iJL6SAxTC2ke/W4joncCQ7/Tox2ZRmosFWcWPQrUpEpMJN5bqrwFTsuWOz6t4IEN++NTNVzOcI08bKjpSAViMiskJTu7z7kaNlCQNfBxHZXUdvpHSBchl36oC12nZRj4igr1ANLnvMzWkiQmfdROTJBFOaqQVEcQDUJSK1dK6YG1RiCraqKzQmtdznnJQ26lr6wp7gfGfdROQQgHd3HYEd6S6SKLC8q1gXT2RdrkOntDDmEJGn6DcFprJfhYhkMsQTuQ05xy7CkJtUyiimNL4z9J0uVaCBOqasuSm2SpPRVk5w+7GFGHarEBHkMRDVwXNsYw+5SaWMeydhCToZ2eme5shrDZarTXZQzhupzlZqEZEcneqN8b8UJQ170qmAfM6oeSN2SsVFstmK61mYQKrxRHJ2qiwNE5C2pEHUEFArLdKrQqkpTe4yUu/nWnkiALKpawglvYMaRvDS08VVodSUpjYRqcYTWWVKegfrsrKxjiICrOfy9SBNROyEGGtJw65hOtNwUyIuUp0A1yIi1TUMhQlWS9bFE1lXSq7SVEMtIrKqFDfqkI1wjUloItIIYgrPoHkjdbOSXnUKTUTSSDHo2Kh4E5FGVVT/Rc2Vk2LQJ4j7er0mIo1sdIw9Ss2jeSJpxBr0GeI9kRYTaVRFE5E0phCR5ok0qqKJSCSJT1OmiMjOGj7A1lhhWkwknhSP4Axp28f3kOe7IBqfJk/kj8Ll4Kx5IvGkxCbeIE1E2pSmUQ1NROJJmVKcJf58ZxORRjU0EYkndToDtOBqYw1oIhJPtCFrXkisN9KWeRvV0EQknpTlXdvrEmU3GtlpIhKBXGKdUkTag3iNamgiEkeOeAiQ9q1SzRtpVEETkThyPXjXRKSx8jQRiSOXiLRl3sYUnHSMzTrGZsjw2zNNROJI2SPSRKSxVjQRiSPFgF8IzpeC8yWA1wn5tMBqowqaiMRRgwG3B/EaVdBEJI5aphK11ONTJMcvAa4FtYjIyvyq2pS/h2uhBo/oU6U9RS2pRURqwxfwrElEaqrLp0au3yVeedZORAp4CjUZbvu2+WmZwhupzmuvRUSqaxgPNRnRFHVpwdxrmieCJiIuVmU6M0VMJMf113a/o+gYO0H5a8ldXvL9XCcRUSPkpzSdKRroFZzvI48nshYiIik9pclpK0BFIrKvNlB5/n72nJ+yc1OxZ/xPwXejqhIRFPJGBOfPAOT6Xs51orSIZLMVuc8ouf9U4Yl0jL1BusLuC84PEPeDUCbWuW7iN7yPRQlR2wVwlLGsdfJETkoWlvi1moongvMn6AeF5P5chYhIUhV9B32jpHb0Nx1jroBZshGpB5+0B6AeJ2ZZm6gNIgeNtUBeS+kAa47yXgJ4kiGftRKRXPhGljGmDqkjy6ptOMsxktZGUW9kgvK81CQiU0S6bfhuUI2j/qqJyDoui5YeAJuI2JBu4fOJq3HaMebrEMlTpcTzbazag3hrJyJy+lvMw5JxkeNS5Q1RjYgAQMfYc0zbyX4aOF6jiAD1rRj5qGoUzUjp65p6wL2iKhGRPMU005qfCJHv7MaaKdq+KlOa40zXWyNFBz/ZjsnfSpaD6kRENs5jlBWSw44xr3uY+A3virGuaRWmM69QSacfiVMUHvyk5z65R1KdiABXc8zHKDPPfCpvxhA1b/eu3RM5BfB4nZZ2TeS1FV9h7Bg7xMTiXKWIAL2QdIw9wnhKewrgkXz+gULNcYda63aGfpq41gKiMUk8Tw6COQbdN4iYBVQrIgqptF8jn9oeox8VHwfOz8ecMqTe/FqmM6fo79MheoF+NDRNXDMmu9aOsVM56B4izuM9BfB3uToZdB2ziMImRf7y2758e0Q45Ri9kb75xDp04xNGbmvfRf8YiMtTfYV+VenUs0u70Wg0Go1Go2JmgvNNAA8LlHXRMfa/mBMF5x2AuwDuAdgCwOShzwEs0U/L1H/I14pzAHMAC/n66q9jTE9Hqcc9APdjrkHD2g6C84cANhPynXeM/dt2QHD+fUK+IXD5BwAXAC47xhYxGWWoM6m/JZTze8fYByOvDQDfRuaHjrFfY8/Vyr8H4DP09rIJ4A7c/Uqgv08CwAcAf3SMccH5fZkPhcst9EapLlw3Rp+B6cfN17C8B4D3AMgiIjjfBvAleqP9DPEGZmuMJYALwflbAL91jL0n5rUJ4LvIeihc7fCDUT/A3rYw0qnPPwCwighudmzXvfV9DscxH0sAl4Lz9wD+QN/O84Dzo41R8gG0/vYthvs7cLv9L2UZOt+hH5CHbMJlY1EiIjj/AsBX6G2lCzh1W/4BwDcA5oLz39AvZFDjpZdbxgfqohaeTJZwj/pmo+jvSR1Ieh0P0F+ULhyhndj0Tky2ZTkPpJj8iyAm79Bfh21Vi9IR4TgXjnN9bWt+PmQwro67NI77yrLl56rPDH2H/kr+PRSc/zNyqdd3H11cBuZvK8vXJjc8LMH5HQB/sqTztbftOBkpHg/Qi4fNI6fkr1/fBnoB0c/z9esZgPkWrkXBZKjwmJHJi+D8cwB/wfV0hdogvs5Mqed9APcF57+4pgQA0DG2kILzladuQ57cLY9KcM6I9fTxu+eYeY9txjEz0g0JCqV/6OUwAH8VnM87xt4OnGvmb+ZlpktZZaSIt80bNM/780B6X5nUAegKwfnXAH408tP/U8XQlU4/bvZp/fVyS0s4KTLe8Df4R0sbM1x7Tqkd6nvB+aJj7D+eNO/QT7N8dXIJM2CflunpXTfSd10fO8a457hNUNVIOtPeU6azekfSPVab+NjyeQggRkR89zlmEBxK5zOoGwjOv8R1fA4YFmDbMbINSg/kB9jvq6ssal0og8YNsYoRkVhDHTpHBbhiPZw5+s75Ofo4TyzfC85/7xgTjuNvcXPUcdXHNKCr94Jzc77fYfhG+tplyChtI5N+bGak09PYztGvzSYk+muzv9wRnG8QAq5mnc30ugjaRnYqer4+4zenC+pebqDvDzZDHRrl9TqE1FkJiEv0XW2mH/8N/ZT+Lvz3Wn1u69czeETEpvS+DshlpXw4R0rpzt+x1MNWN8B+Uf/tGPtVPij3o5HedwNtx+4D+K8tsYxecwwHsGxTCMUDR3rz9ZABK4ZERHUmyihjlr9AH73/Bb1Af+NIb06H9HzM9Fvw9IeBOlNG8CXcBmRLS83bdj0P0McSbAI8lP+NaQGlsjL2YoYhQr0aZSsb6DeiqeBqiBeiXl+JiG008VXMfH3uiyUQ2MZ1o5jq6ot36K/P5f/3uD262K7JdwOHPJm36LeaB89lcXvkoEwdfJ9ddox9JJQZw5W30TH2DsA76UrbBDSkDIqIxNY59PzotpEriF/D7oWMVfY2bi5SUPugnu4jcCPG901EPRQ3PJEgRTQzSqgE0McJzJHHZ/i+gNGlcU6MWg8tJ7/DdXDVBfWYT0Ao1/uHt6Y9UXs1jLooPgD4wpImRFAprnvOOo9VzgPEC0gsyutRDJVtm+7or0170c9x5aW/Xyi3KKQhqVOOEJTbrF5T8rXO36S6mtfjik+4yqKIiB7kCyEkPUVQKUHKofvr8vquPBHtM4GbXqOe1iV8ejlUzJiHL7+UPmkrxyXc+vu76Pcv+UQkZKmVim4rVIbKtuVH9Y6tnkgMqaOGmQdlpcXnWZhRfNvKgz6dAIbLu0IK1Qf0cRydkFUNPV3M09RK/M0NTzZMgTbraE6vVBpX+jluX6s54vn6FKWvmaJk1pWyOkTBJpR6Ofp7aGnv4bYAuYgZbFyEDvr6eba2WUTmd3W+EhFbp7BVQoeyHEjFbJjQjmCm1W/ukAHZ3DxKo75Dv/eBcv16B1+iD9qqfR3buF7toaDn9Z64dd8UTZ9A2NDbQ90rm5HZ2s3WT6hl2upM8RzMOvuw9f2Y0b4UsSKizgVwtaoEpF/rQvdEQjNSHckcVaMr4/ic6gK7PBF1LMTjoLTFR2I6M98ZgJla4pQ7dENWEvTrom7XjwnE6ZgioveXsUZh1a9sqz5DZYUYRmmxSB10U0REcQd9TE/hyo9kKyomQtmS7rvw1IuiulTU6Y0tvuJbgfIFnlycow9KUaciep7b2mubiFA9PMpUBpb8Q1kYr0OegbFBad9U4QuNiawKOUTEJEREbsWI9CXeIXwdO3dMxEWIV2KbfrlGz2BXuGNsKeMin3nq4GJL23C1rZUXYig84IG2nCIyRiceKnPM89dNRFyxIb3P+wYCl427Yk+LIREJDU7FEtoxh/aO+IzLFlg1g3jU6znH7eCqr14624LzC/k6RkSoXoiefyy5RSQ0DjNWGTnKKQ1FRGxCYL53PebgijWZMcurPmtb4g0NupkFxBDSMSnLwVSvxhUsptbl3JN2qO3Mtg912c+Hk1yR0yBTo/lUmidih9I/h/oRR1j/8eH0RELjA6U9EcAfxygyinWMXQrOBW5/ZQFFhFUsRB8RqLGQecdYyKPuzRMZr5zS5Gh/3jGWS0RAiYlQOnZJEaEYqC8vl+tGPd/kHP3GIx2KCG/i+sE738qSq8wQahOR0DJjaCJCQHB+F2GbAE2sD+DZGn/ohow5naHua6B4Ii7vZWj+6IPj5mqLC1ue+nZ/avlLDD93EpKfmcYXkFOf++6BK14VunszdWAKWTbPidmOrs9S6hGzUuVq/zvymG1ANRcfrIsVPk/EFXBxVTIFJSK+gKmvDOoS7RiBYg6a95CjLABYer6mwEWIyNsE1WxbyuoA9XMXq+qJqGB7zGBMIdYTcZW9wM3ncULu3xLaPhGXAYbGRmJRG4tcZQy5W7bIs4+hJV7yPgi51Cvgf/I3Z9tdDCfJXj7VE9HTpI66KXWm1DFHOSYfA8uOIUf+offTm1fIPhFvRhnOD4m5OD0WwXnINnTX+9D2cAVXc4080PILCajqebimKzouw9fTup4ipXqD1N2koe597Lw+l8HPO8YuMn3VpY9cO8R1UvK7TPl6REqcgso8MA/bXE0Z8Wam+oRge5w65fkGW1xC5ZcqIkNibd1jIH9aZBO9iJh7Bmx5u0SUOvKZ7TcUEB8aGFxQBxxXTECl+ai9HlNEQm3FxgZw4/mZlPzmqd+xSumYg8inYi8R97MQquwtGWnOISKhMQf1uzap+OajS/SjXa64i2v0Nh8PUK9dUfyFJe0SnvwzXANVEEPzDU2nPjN3D48mItJWXL84QM5GcA7ksRXnT0ZMwQVuL5X6sHXQTaRPIy5COzkxLhKCq/wYL8SXH+XzkLgYxRugriyV6oup5Sw6xsw41dh1v8DwTukhcnxJu+gYs3oiPvfNRXKjdYzNBecf0S+X2gTC9iBQ7rpcRKx8KOawi0hMe7rILSKlEQHtmzN4OGY55p6dsaczapPjBa6/isIs37WdXT+eilDi6VOj4h1PE5IOfd1C9xbEMkfvkqZMSYbmqpRR3LzeG08hR04DfOVQOpTZCV15+c5dQI5a1EquCCKxz0TTMSbktEbZio5tuhfiUfqYw7iXaolXZZxrRSEaaShci5GoYJ7Ctcs0FPUkY/TvxerIuWru0VN/H+uFDOWbOmLbPlcrCAv0cZyc+xpyEx0P9PzWT5G6y3a90B69MG0FsHsjIVzdRzjupVKw0B2QtoKyIiu7ACDksu2G/FO76wBag+lLYirP5UgjyIWlTrlIGcVjp2hD2J65WmbymFLrTK1DyvTVxiIhzygMW1E2ouwF2vuhNlHXpKZkJFv5P+Ss3FKjAcm1AAAAAElFTkSuQmCC",
    customImageData2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAABICAYAAADGScSgAAAABHNCSVQICAgIfAhkiAAAAEhJREFUWIXty6EVwEAIREHIu75AXke0x1ZGREws/o8fv/dOZtpGd9uJCKuqVZwZe1bjh0gkEolEIpFIJBKJROLnSDJ3XyVJ9gKchA8TPV7TZAAAAABJRU5ErkJggg\x3d\x3d";
cc.LoaderScene = cc.Scene.extend({
    _interval: null, _className: "LoaderScene", cb: null, target: null, init: function () {
        function a() {
            for (var b = f.length - 1; 0 <= b; b--) {
                var d = f[b], e = new cc.scaleBy(0.5, 2), p = new cc.scaleBy(0.5, 0.5), e = 0 == b ? new cc.sequence(new cc.delayTime(0.5 * (9 - b)), e, p, new cc.callFunc(a)) : new cc.sequence(new cc.delayTime(0.5 * (9 - b)), e, p);
                d.runAction(e)
            }
        }

        function b(e) {
            10 <= e ? a(f) : cc.loader.loadImg(customImageData2, {isCrossOrigin: !1}, function (a, n) {
                var p = d._initStage(n, cc.pSub(cc.visibleRect.center, cc.p(30 *
                    e - 135, 60)));
                f.push(p);
                p.setScale(0.4);
                b(e + 1)
            })
        }

        var d = this, e = d._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        d.addChild(e, 0);
        cc.loader.loadImg(customImageData1, {isCrossOrigin: !1}, function (a, b) {
            d._initStage(b, cc.visibleRect.center)
        });
        var f = [];
        b(0);
        return !0
    }, _initStage: function (a, b) {
        var d = this._texture2d = new cc.Texture2D;
        d.initWithElement(a);
        d.handleLoadedTexture();
        d = new cc.Sprite(d);
        d.setScale(cc.contentScaleFactor());
        d.x = b.x;
        d.y = b.y;
        this._bgLayer.addChild(d);
        return d
    }, onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    }, onExit: function () {
        cc.Node.prototype.onExit.call(this)
    }, initWithResources: function (a, b, d) {
        cc.isString(a) && (a = [a]);
        this.resources = a || [];
        this.cb = b;
        this.target = d
    }, _startLoading: function () {
        var a = this;
        a.unschedule(a._startLoading);
        cc.loader.load(a.resources, function (a, d, e) {
        }, function () {
            a.cb && a.cb.call(a.target)
        })
    }, _updateTransform: function () {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._bgLayer._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    }
});
cc.LoaderScene.preload = function (a, b, d) {
    var e = cc;
    e.loaderScene || (e.loaderScene = new cc.LoaderScene, e.loaderScene.init(), cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function () {
        e.loaderScene._updateTransform()
    }));
    e.loaderScene.initWithResources(a, b, d);
    cc.director.runScene(e.loaderScene);
    return e.loaderScene
};
cc.Layer = cc.Node.extend({
    _className: "Layer", ctor: function () {
        var a = cc.Node.prototype;
        a.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        a.setAnchorPoint.call(this, 0.5, 0.5);
        a.setContentSize.call(this, cc.winSize)
    }, init: function () {
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.winSize);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1;
        return !0
    }, bake: function () {
        this._renderCmd.bake()
    }, unbake: function () {
        this._renderCmd.unbake()
    }, isBaked: function () {
        return this._renderCmd._isBaked
    },
    addChild: function (a, b, d) {
        cc.Node.prototype.addChild.call(this, a, b, d);
        this._renderCmd._bakeForAddChild(a)
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
    }
});
cc.Layer.create = function () {
    return new cc.Layer
};
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null, _className: "LayerColor", getBlendFunc: function () {
        return this._blendFunc
    }, changeWidthAndHeight: function (a, b) {
        this.width = a;
        this.height = b
    }, changeWidth: function (a) {
        this.width = a
    }, changeHeight: function (a) {
        this.height = a
    }, setOpacityModifyRGB: function (a) {
    }, isOpacityModifyRGB: function () {
        return !1
    }, ctor: function (a, b, d) {
        cc.Layer.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        cc.LayerColor.prototype.init.call(this, a,
            b, d)
    }, init: function (a, b, d) {
        cc._renderType !== cc.game.RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var e = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255);
        b = void 0 === b ? e.width : b;
        d = void 0 === d ? e.height : d;
        e = this._realColor;
        e.r = a.r;
        e.g = a.g;
        e.b = a.b;
        this._realOpacity = a.a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty);
        cc.LayerColor.prototype.setContentSize.call(this, b, d);
        return !0
    }, setBlendFunc: function (a, b) {
        var d =
            this._blendFunc;
        void 0 === b ? (d.src = a.src, d.dst = a.dst) : (d.src = a, d.dst = b);
        this._renderCmd.updateBlendFunc(d)
    }, _setWidth: function (a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._renderCmd._updateSquareVerticesWidth(a)
    }, _setHeight: function (a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._renderCmd._updateSquareVerticesHeight(a)
    }, setContentSize: function (a, b) {
        cc.Layer.prototype.setContentSize.call(this, a, b);
        this._renderCmd._updateSquareVertices(a, b)
    }, _createRenderCmd: function () {
        return cc._renderType ===
        cc.game.RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
    }
});
cc.LayerColor.create = function (a, b, d) {
    return new cc.LayerColor(a, b, d)
};
(function () {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
})();
cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _className: "LayerGradient",
    _colorStops: [],
    ctor: function (a, b, d, e) {
        cc.LayerColor.prototype.ctor.call(this);
        this._endColor = cc.color(0, 0, 0, 255);
        this._alongVector = cc.p(0, -1);
        this._endOpacity = this._startOpacity = 255;
        e && e instanceof Array ? (this._colorStops = e, e.splice(0, 0, {
            p: 0,
            color: a || cc.color.BLACK
        }), e.push({p: 1, color: b || cc.color.BLACK})) : this._colorStops = [{p: 0, color: a || cc.color.BLACK},
            {p: 1, color: b || cc.color.BLACK}];
        cc.LayerGradient.prototype.init.call(this, a, b, d, e)
    },
    init: function (a, b, d, e) {
        a = a || cc.color(0, 0, 0, 255);
        b = b || cc.color(0, 0, 0, 255);
        d = d || cc.p(0, -1);
        e = this._endColor;
        this._startOpacity = a.a;
        e.r = b.r;
        e.g = b.g;
        e.b = b.b;
        this._endOpacity = b.a;
        this._alongVector = d;
        this._compressedInterpolation = !0;
        cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty);
        return !0
    },
    setContentSize: function (a, b) {
        cc.LayerColor.prototype.setContentSize.call(this, a, b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setWidth: function (a) {
        cc.LayerColor.prototype._setWidth.call(this, a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setHeight: function (a) {
        cc.LayerColor.prototype._setHeight.call(this, a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getStartColor: function () {
        return cc.color(this._realColor)
    },
    setStartColor: function (a) {
        this.color =
            a;
        var b = this._colorStops;
        b && 0 < b.length && (b = b[0].color, b.r = a.r, b.g = a.g, b.b = a.b)
    },
    setEndColor: function (a) {
        var b = this._endColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        (b = this._colorStops) && 0 < b.length && (b = b[b.length - 1].color, b.r = a.r, b.g = a.g, b.b = a.b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    getEndColor: function () {
        return cc.color(this._endColor)
    },
    setStartOpacity: function (a) {
        this._startOpacity = a;
        var b = this._colorStops;
        b && 0 < b.length && (b[0].color.a = a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getStartOpacity: function () {
        return this._startOpacity
    },
    setEndOpacity: function (a) {
        this._endOpacity = a;
        var b = this._colorStops;
        b && 0 < b.length && (b[b.length - 1].color.a = a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getEndOpacity: function () {
        return this._endOpacity
    },
    setVector: function (a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getVector: function () {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function () {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function (a) {
        this._compressedInterpolation = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getColorStops: function () {
        return this._colorStops
    },
    setColorStops: function (a) {
        this._colorStops = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
    }
});
cc.LayerGradient.create = function (a, b, d, e) {
    return new cc.LayerGradient(a, b, d, e)
};
(function () {
    var a = cc.LayerGradient.prototype;
    cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
    cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
    cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
    cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
    cc.defineGetterSetter(a, "vector", a.getVector, a.setVector);
    cc.defineGetterSetter(a, "colorStops", a.getColorStops, a.setColorStops)
})();
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0, _layers: null, _className: "LayerMultiplex", ctor: function (a) {
        cc.Layer.prototype.ctor.call(this);
        a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    }, initWithLayers: function (a) {
        0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
        this._layers = a;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return !0
    }, switchTo: function (a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
    }, switchToAndReleaseMe: function (a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
    }, addLayer: function (a) {
        a ? this._layers.push(a) :
            cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
});
cc.LayerMultiplex.create = function () {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
(function () {
    cc.Layer.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._isBaked = !1;
        this._bakeSprite = null;
        this._updateCache = 2
    };
    var a = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Layer.CanvasRenderCmd;
    a._setCacheDirty = function (a) {
        a && 0 === this._updateCache && (this._updateCache = 2);
        !1 === this._cacheDirty && (this._cacheDirty = !0, (a = this._cachedParent) && a !== this && a._setNodeDirtyForCache && a._setNodeDirtyForCache())
    };
    a.updateStatus = function () {
        var a =
            cc.Node._dirtyFlags;
        this._dirtyFlag & a.orderDirty && (this._cacheDirty = !0, 0 === this._updateCache && (this._updateCache = 2), this._dirtyFlag ^= this._dirtyFlag & a.orderDirty);
        cc.Node.RenderCmd.prototype.updateStatus.call(this)
    };
    a._syncStatus = function (a) {
        var d = cc.Node._dirtyFlags;
        this._dirtyFlag & d.orderDirty && (this._cacheDirty = !0, 0 === this._updateCache && (this._updateCache = 2), this._dirtyFlag ^= this._dirtyFlag & d.orderDirty);
        cc.Node.RenderCmd.prototype._syncStatus.call(this, a)
    };
    a.transform = function (a, d) {
        var e = this._worldTransform,
            f = e.a, g = e.b, h = e.c, n = e.d;
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, d);
        e.a === f && e.b === g && e.c === h && e.d === n || 0 !== this._updateCache || (this._updateCache = 2)
    };
    a.bake = function () {
        if (!this._isBaked) {
            this._needDraw = !0;
            this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0;
            0 === this._updateCache && (this._updateCache = 2);
            for (var a = this._node._children, d = 0, e = a.length; d < e; d++)a[d]._renderCmd._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite, this._bakeSprite.setAnchorPoint(0,
                0))
        }
    };
    a.unbake = function () {
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = !0;
            this._isBaked = this._needDraw = !1;
            this._cacheDirty = !0;
            0 === this._updateCache && (this._updateCache = 2);
            for (var a = this._node._children, d = 0, e = a.length; d < e; d++)a[d]._renderCmd._setCachedParent(null)
        }
    };
    a.isBaked = function () {
        return this._isBaked
    };
    a.rendering = function () {
        if (this._cacheDirty) {
            var a = this._node, d = a._children, e = this._bakeSprite;
            this.transform(this.getParentRenderCmd(), !0);
            var f = this._getBoundingBoxForBake();
            f.width = 0 | f.width +
                0.5;
            f.height = 0 | f.height + 0.5;
            var g = e.getCacheContext(), h = g.getContext();
            e.setPosition(f.x, f.y);
            if (0 < this._updateCache) {
                e.resetCanvasSize(f.width, f.height);
                g.setOffset(0 - f.x, h.canvas.height - f.height + f.y);
                a.sortAllChildren();
                cc.renderer._turnToCacheMode(this.__instanceId);
                a = 0;
                for (f = d.length; a < f; a++)d[a].visit(this);
                cc.renderer._renderingToCacheCanvas(g, this.__instanceId);
                e.transform();
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    };
    a.visit = function (a) {
        if (this._isBaked) {
            var d = this._node, e = d._children.length;
            d._visible && 0 !== e && (this._syncStatus(a), cc.renderer.pushRenderCommand(this), this._bakeSprite.visit(this), this._dirtyFlag = 0)
        } else cc.Node.CanvasRenderCmd.prototype.visit.call(this, a)
    };
    a._bakeForAddChild = function (a) {
        a._parent === this._node && this._isBaked && a._renderCmd._setCachedParent(this)
    };
    a._getBoundingBoxForBake = function () {
        var a = null, d = this._node;
        if (!d._children || 0 === d._children.length)return cc.rect(0, 0, 10, 10);
        for (var e = d.getNodeToWorldTransform(), d = d._children, f = 0, g = d.length; f < g; f++) {
            var h = d[f];
            h && h._visible && (a ? (h = h._getBoundingBoxToCurrentNode(e)) && (a = cc.rectUnion(a, h)) : a = h._getBoundingBoxToCurrentNode(e))
        }
        return a
    }
})();
(function () {
    cc.LayerColor.CanvasRenderCmd = function (a) {
        cc.Layer.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._blendFuncStr = "source-over";
        this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering)
    };
    var a = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
    a.constructor = cc.LayerColor.CanvasRenderCmd;
    a.unbake = function () {
        cc.Layer.CanvasRenderCmd.prototype.unbake.call(this);
        this._needDraw = !0
    };
    a.rendering = function (a, d, e) {
        a = a || cc._renderContext;
        var f =
            a.getContext(), g = this._node, h = this._displayedColor, n = this._displayedOpacity / 255, p = g._contentSize.width, g = g._contentSize.height;
        0 !== n && (a.setCompositeOperation(this._blendFuncStr), a.setGlobalAlpha(n), a.setFillStyle("rgba(" + (0 | h.r) + "," + (0 | h.g) + "," + (0 | h.b) + ", 1)"), a.setTransform(this._worldTransform, d, e), f.fillRect(0, 0, p * d, -g * e), cc.g_NumberOfDraws++)
    };
    a.updateBlendFunc = function (a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    };
    a._updateSquareVertices = a._updateSquareVerticesWidth =
        a._updateSquareVerticesHeight = function () {
        };
    a._bakeRendering = function () {
        if (this._cacheDirty) {
            var a = this._node, d = this._bakeSprite, e = a._children, f = e.length;
            this.transform(this.getParentRenderCmd(), !0);
            var g = this._getBoundingBoxForBake();
            g.width = 0 | g.width + 0.5;
            g.height = 0 | g.height + 0.5;
            var h = d.getCacheContext(), n = h.getContext();
            d.setPosition(g.x, g.y);
            if (0 < this._updateCache) {
                n.fillStyle = h._currentFillStyle;
                d.resetCanvasSize(g.width, g.height);
                h.setOffset(0 - g.x, n.canvas.height - g.height + g.y);
                cc.renderer._turnToCacheMode(this.__instanceId);
                if (0 < f) {
                    a.sortAllChildren();
                    for (a = 0; a < f; a++)if (g = e[a], 0 > g._localZOrder)g._renderCmd.visit(this); else break;
                    for (cc.renderer.pushRenderCommand(this); a < f; a++)e[a]._renderCmd.visit(this)
                } else cc.renderer.pushRenderCommand(this);
                cc.renderer._renderingToCacheCanvas(h, this.__instanceId);
                d.transform();
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    };
    a.visit = function (a) {
        this._isBaked ? this._node._visible && (this._syncStatus(a), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
            this._bakeSprite.visit(this), this._dirtyFlag = 0) : cc.Node.CanvasRenderCmd.prototype.visit.call(this)
    };
    a._getBoundingBoxForBake = function () {
        var a = this._node, d = cc.rect(0, 0, a._contentSize.width, a._contentSize.height), e = a.getNodeToWorldTransform(), d = cc.rectApplyAffineTransform(d, a.getNodeToWorldTransform());
        if (!a._children || 0 === a._children.length)return d;
        for (var a = a._children, f = 0; f < a.length; f++) {
            var g = a[f];
            g && g._visible && (g = g._getBoundingBoxToCurrentNode(e), d = cc.rectUnion(d, g))
        }
        return d
    }
})();
(function () {
    cc.LayerGradient.RenderCmd = {
        updateStatus: function () {
            var a = cc.Node._dirtyFlags;
            this._dirtyFlag & a.gradientDirty && (this._dirtyFlag |= a.colorDirty, this._dirtyFlag ^= this._dirtyFlag & a.gradientDirty);
            cc.Node.RenderCmd.prototype.updateStatus.call(this)
        }
    };
    cc.LayerGradient.CanvasRenderCmd = function (a) {
        cc.LayerColor.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._startPoint = cc.p(0, 0);
        this._endPoint = cc.p(0, 0);
        this._endStopStr = this._startStopStr = null
    };
    var a = cc.LayerGradient.CanvasRenderCmd.prototype =
        Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, a);
    a.constructor = cc.LayerGradient.CanvasRenderCmd;
    a.rendering = function (a, d, e) {
        a = a || cc._renderContext;
        var f = a.getContext(), g = this._node, h = this._displayedOpacity / 255;
        if (0 !== h) {
            var n = g._contentSize.width, p = g._contentSize.height;
            a.setCompositeOperation(this._blendFuncStr);
            a.setGlobalAlpha(h);
            h = f.createLinearGradient(this._startPoint.x * d, this._startPoint.y * e, this._endPoint.x * d, this._endPoint.y * e);
            if (g._colorStops)for (var r =
                0; r < g._colorStops.length; r++)h.addColorStop(g._colorStops[r].p, this._colorStopsStr[r]); else h.addColorStop(0, this._startStopStr), h.addColorStop(1, this._endStopStr);
            a.setFillStyle(h);
            a.setTransform(this._worldTransform, d, e);
            f.fillRect(0, 0, n * d, -p * e);
            cc.g_NumberOfDraws++
        }
    };
    a._syncStatus = function (a) {
        var d = cc.Node._dirtyFlags, e = this._dirtyFlag;
        e & d.gradientDirty && (this._dirtyFlag |= d.colorDirty, this._dirtyFlag = e & d.gradientDirty ^ e);
        cc.Node.RenderCmd.prototype._syncStatus.call(this, a)
    };
    a._updateColor = function () {
        var a =
            this._node, d = a._contentSize, e = 0.5 * d.width, d = 0.5 * d.height;
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var f = cc.pAngleSigned(cc.p(0, -1), a._alongVector), f = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), f), g = Math.min(Math.abs(1 / f.x), Math.abs(1 / f.y));
        this._startPoint.x = e * -f.x * g + e;
        this._startPoint.y = d * f.y * g - d;
        this._endPoint.x = e * f.x * g + e;
        this._endPoint.y = d * -f.y * g - d;
        e = this._displayedColor;
        d = a._endColor;
        f = a._startOpacity / 255;
        g = a._endOpacity / 255;
        this._startStopStr = "rgba(" + Math.round(e.r) + "," +
            Math.round(e.g) + "," + Math.round(e.b) + "," + f.toFixed(4) + ")";
        this._endStopStr = "rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + g.toFixed(4) + ")";
        if (a._colorStops)for (this._endOpacity = this._startOpacity = 0, this._colorStopsStr = [], e = 0; e < a._colorStops.length; e++)d = a._colorStops[e].color, f = null == d.a ? 1 : d.a / 255, this._colorStopsStr.push("rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + f.toFixed(4) + ")")
    }
})();
(function () {
    cc.Layer.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a)
    };
    var a = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.Layer.WebGLRenderCmd;
    a.bake = function () {
    };
    a.unbake = function () {
    };
    a._bakeForAddChild = function () {
    }
})();
(function () {
    cc.LayerColor.WebGLRenderCmd = function (a) {
        cc.Layer.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._squareVerticesAB = new ArrayBuffer(32);
        this._squareColorsAB = new ArrayBuffer(16);
        a = this._squareVerticesAB;
        var d = this._squareColorsAB, e = cc.Vertex2F.BYTES_PER_ELEMENT, f = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, a, 0), new cc.Vertex2F(0, 0, a, e), new cc.Vertex2F(0, 0, a, 2 * e), new cc.Vertex2F(0, 0, a, 3 * e)];
        this._squareColors = [cc.color(0, 0, 0, 255, d, 0), cc.color(0, 0, 0, 255, d, f), cc.color(0,
            0, 0, 255, d, 2 * f), cc.color(0, 0, 0, 255, d, 3 * f)];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer()
    };
    var a = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
    a.constructor = cc.LayerColor.WebGLRenderCmd;
    a.rendering = function (a) {
        a = a || cc._renderContext;
        var d = this._node;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
        cc.glBlendFunc(d._blendFunc.src, d._blendFunc.dst);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length)
    };
    a._updateSquareVertices = function (a, d) {
        var e = this._squareVertices;
        void 0 === d ? (e[1].x = a.width,
            e[2].y = a.height, e[3].x = a.width, e[3].y = a.height) : (e[1].x = a, e[2].y = d, e[3].x = a, e[3].y = d);
        this._bindLayerVerticesBufferData()
    };
    a._updateSquareVerticesWidth = function (a) {
        var d = this._squareVertices;
        d[1].x = a;
        d[3].x = a;
        this._bindLayerVerticesBufferData()
    };
    a._updateSquareVerticesHeight = function (a) {
        var d = this._squareVertices;
        d[2].y = a;
        d[3].y = a;
        this._bindLayerVerticesBufferData()
    };
    a._updateColor = function () {
        for (var a = this._displayedColor, d = this._displayedOpacity, e = this._squareColors, f = 0; 4 > f; f++)e[f].r = a.r, e[f].g =
            a.g, e[f].b = a.b, e[f].a = d;
        this._bindLayerColorsBufferData()
    };
    a._bindLayerVerticesBufferData = function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    };
    a._bindLayerColorsBufferData = function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
    };
    a.updateBlendFunc = function (a) {
    }
})();
(function () {
    cc.LayerGradient.WebGLRenderCmd = function (a) {
        cc.LayerColor.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._clipRect = new cc.Rect;
        this._clippingRectDirty = !1
    };
    var a = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, a);
    a.constructor = cc.LayerGradient.WebGLRenderCmd;
    a._syncStatus = function (a) {
        var d = cc.Node._dirtyFlags, e = this._dirtyFlag, f = a ? a._node : null;
        f && f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty && (e |=
            d.colorDirty);
        f && f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty && (e |= d.opacityDirty);
        a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
        var f = e & d.colorDirty, g = e & d.opacityDirty;
        this._dirtyFlag = e;
        f && this._syncDisplayColor();
        g && this._syncDisplayOpacity();
        this.transform(a);
        (f || g || e & d.gradientDirty) && this._updateColor()
    };
    a._updateColor = function () {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var a = this._node, d = a._colorStops;
        if (d && !(2 > d.length)) {
            this._clippingRectDirty = !0;
            var e = d.length, f = 2 * e, g, h = a._contentSize;
            this._squareVerticesAB = new ArrayBuffer(8 * f);
            this._squareColorsAB = new ArrayBuffer(4 * f);
            var n = this._squareVertices, p = this._squareColors;
            n.length = 0;
            p.length = 0;
            var r = this._squareVerticesAB, s = this._squareColorsAB, t = cc.Vertex2F.BYTES_PER_ELEMENT, v = cc.Color.BYTES_PER_ELEMENT;
            for (g = 0; g < f; g++)n.push(new cc.Vertex2F(0, 0, r, t * g)), p.push(cc.color(0, 0, 0, 255, s, v * g));
            s = Math.PI + cc.pAngleSigned(cc.p(0, -1), a._alongVector);
            a = cc.p(h.width / 2, h.height / 2);
            g = Math.round(cc.radiansToDegrees(s));
            f = cc.affineTransformMake(1, 0, 0, 1, a.x, a.y);
            f = cc.affineTransformRotate(f, s);
            90 > g ? (t = cc.p(-a.x, a.y), g = cc.p(a.x, a.y)) : 180 > g ? (t = cc.p(a.x, a.y), g = cc.p(a.x, -a.y)) : 270 > g ? (t = cc.p(a.x, -a.y), g = cc.p(-a.x, -a.y)) : (t = cc.p(-a.x, -a.y), g = cc.p(-a.x, a.y));
            r = Math.sin(s);
            s = Math.cos(s);
            t = Math.abs((t.x * s - t.y * r) / a.x);
            g = Math.abs((g.x * r + g.y * s) / a.y);
            f = cc.affineTransformScale(f, t, g);
            for (g = 0; g < e; g++)r = d[g].p * h.height, s = cc.pointApplyAffineTransform(-a.x, r - a.y, f), n[2 * g].x = s.x, n[2 * g].y = s.y, r = cc.pointApplyAffineTransform(h.width - a.x,
                r - a.y, f), n[2 * g + 1].x = r.x, n[2 * g + 1].y = r.y;
            h = this._displayedOpacity / 255;
            for (g = 0; g < e; g++)n = d[g].color, a = p[2 * g], f = p[2 * g + 1], a.r = n.r, a.g = n.g, a.b = n.b, a.a = n.a * h, f.r = n.r, f.g = n.g, f.b = n.b, f.a = n.a * h;
            this._bindLayerVerticesBufferData();
            this._bindLayerColorsBufferData()
        }
    };
    a.rendering = function (a) {
        a = a || cc._renderContext;
        var d = this._node, e = this._getClippingRect();
        a.enable(a.SCISSOR_TEST);
        cc.view.setScissorInPoints(e.x, e.y, e.width, e.height);
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
        cc.glBlendFunc(d._blendFunc.src, d._blendFunc.dst);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length);
        a.disable(a.SCISSOR_TEST)
    };
    a._getClippingRect =
        function () {
            if (this._clippingRectDirty) {
                var a = this._node, d = cc.rect(0, 0, a._contentSize.width, a._contentSize.height), a = a.getNodeToWorldTransform();
                this._clipRect = cc._rectApplyAffineTransformIn(d, a)
            }
            return this._clipRect
        }
})();
cc._tmp.PrototypeSprite = function () {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
    cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
    cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
    cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
    cc.defineGetterSetter(a,
        "texture", a.getTexture, a.setTexture);
    cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
    cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
    cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _className: "Sprite",
    ctor: function (a, b, d) {
        cc.Node.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter =
            cc.p(0, 0);
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        this._rect = cc.rect(0, 0, 0, 0);
        this._softInit(a, b, d)
    },
    onEnter: function () {
        this._super();
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._renderCmd.updateBuffer()
    },
    cleanup: function () {
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._renderCmd.freeBuffer();
        this._super()
    },
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a, b) {
        this.addEventListener("load", a, b)
    },
    isDirty: function () {
        return this.dirty
    },
    setDirty: function (a) {
        this.dirty =
            a
    },
    isTextureRectRotated: function () {
        return this._rectRotated
    },
    getAtlasIndex: function () {
        return this.atlasIndex
    },
    setAtlasIndex: function (a) {
        this.atlasIndex = a
    },
    getTextureRect: function () {
        return cc.rect(this._rect)
    },
    getTextureAtlas: function () {
        return this.textureAtlas
    },
    setTextureAtlas: function (a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function () {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function () {
        return this._offsetPosition.x
    },
    _getOffsetY: function () {
        return this._offsetPosition.y
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    initWithSpriteFrame: function (a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame);
        a.textureLoaded() || (this._textureLoaded = !1, a.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback, this));
        var b = cc._renderType === cc.game.RENDER_TYPE_CANVAS ? !1 : a._rotated, b = this.initWithTexture(a.getTexture(), a.getRect(), b);
        this.setSpriteFrame(a);
        return b
    },
    initWithSpriteFrameName: function (a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var b = cc.spriteFrameCache.getSpriteFrame(a);
        cc.assert(b,
            a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(b)
    },
    useBatchNode: function (a) {
        this.textureAtlas = a.getTextureAtlas();
        this._batchNode = a
    },
    setVertexRect: function (a) {
        var b = this._rect;
        b.x = a.x;
        b.y = a.y;
        b.width = a.width;
        b.height = a.height
    },
    sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var a = this._children;
            cc.Node.prototype.sortAllChildren.call(this);
            this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node._stateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    reorderChild: function (a, b) {
        cc.assert(a, cc._LogInfos.Sprite_reorderChild_2);
        -1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
    },
    removeChild: function (a, b) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
        cc.Node.prototype.removeChild.call(this, a, b)
    },
    setVisible: function (a) {
        cc.Node.prototype.setVisible.call(this,
            a);
        this._renderCmd.setDirtyRecursively(!0)
    },
    removeAllChildren: function (a) {
        var b = this._children, d = this._batchNode;
        if (d && null != b)for (var e = 0, f = b.length; e < f; e++)d.removeSpriteFromAtlas(b[e]);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._hasChildren = !1
    },
    ignoreAnchorPointForPosition: function (a) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    },
    setFlippedX: function (a) {
        this._flippedX !== a && (this._flippedX = a, this.setTextureRect(this._rect,
            this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function (a) {
        this._flippedY !== a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function () {
        return this._flippedX
    },
    isFlippedY: function () {
        return this._flippedY
    },
    setOpacityModifyRGB: function (a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this._renderCmd._setColorDirty())
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    setDisplayFrameWithAnimationName: function (a,
                                                b) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var d = cc.animationCache.getAnimation(a);
        d ? (d = d.getFrames()[b]) ? this.setSpriteFrame(d.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    },
    getBatchNode: function () {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function () {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a !== this._batchNode;)a._setReorderChildDirtyRecursively(),
                a = a.parent
        }
    },
    getTexture: function () {
        return this._texture
    },
    _softInit: function (a, b, d) {
        if (void 0 === a)cc.Sprite.prototype.init.call(this); else if (cc.isString(a))"#" === a[0] ? (b = a.substr(1, a.length - 1), (b = cc.spriteFrameCache.getSpriteFrame(b)) ? this.initWithSpriteFrame(b) : cc.log("%s does not exist", a)) : cc.Sprite.prototype.init.call(this, a, b); else if ("object" === typeof a)if (a instanceof cc.Texture2D)this.initWithTexture(a, b, d); else if (a instanceof cc.SpriteFrame)this.initWithSpriteFrame(a); else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement)b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.initWithTexture(b)
    },
    getQuad: function () {
        return this._renderCmd.getQuad()
    },
    setBlendFunc: function (a, b) {
        var d = this._blendFunc;
        void 0 === b ? (d.src = a.src, d.dst = a.dst) : (d.src = a, d.dst = b);
        this._renderCmd.updateBlendFunc(d)
    },
    init: function () {
        if (0 < arguments.length)return this.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._blendFunc.src =
            cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this._renderCmd._init();
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    },
    initWithFile: function (a, b) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var d = cc.textureCache.getTextureForKey(a);
        if (d) {
            if (!b) {
                var e = d.getContentSize();
                b = cc.rect(0, 0, e.width, e.height)
            }
            return this.initWithTexture(d,
                b)
        }
        d = cc.textureCache.addImage(a);
        return this.initWithTexture(d, b || cc.rect(0, 0, d._contentSize.width, d._contentSize.height))
    },
    initWithTexture: function (a, b, d, e) {
        cc.assert(0 !== arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
        d = d || !1;
        a = this._renderCmd._handleTextureForRotatedTexture(a, b, d, e);
        if (!cc.Node.prototype.init.call(this))return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX =
            this._flippedY = !1;
        this.setAnchorPoint(0.5, 0.5);
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this._renderCmd._init();
        var f = a.isLoaded();
        this._textureLoaded = f;
        if (!f)return this._rectRotated = d, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), this.texture && this.texture.removeEventListener("load", this), a.addEventListener("load", this._renderCmd._textureLoadedCallback, this), this.setTexture(a), !0;
        b || (b = cc.rect(0, 0, a.width, a.height));
        this._renderCmd._checkTextureBoundary(a,
            b, d);
        this.setTexture(a);
        this.setTextureRect(b, d);
        this.setBatchNode(null);
        return !0
    },
    setTextureRect: function (a, b, d, e) {
        this._rectRotated = b || !1;
        this.setContentSize(d || a);
        this.setVertexRect(a);
        this._renderCmd._setTextureCoords(a, e);
        a = this._unflippedOffsetPositionFromCenter.x;
        b = this._unflippedOffsetPositionFromCenter.y;
        this._flippedX && (a = -a);
        this._flippedY && (b = -b);
        d = this._rect;
        this._offsetPosition.x = a + (this._contentSize.width - d.width) / 2;
        this._offsetPosition.y = b + (this._contentSize.height - d.height) / 2;
        this._batchNode ?
            this.dirty = !0 : this._renderCmd._resetForBatchNode()
    },
    updateTransform: function () {
        this._renderCmd.updateTransform()
    },
    addChild: function (a, b, d) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
        null == b && (b = a._localZOrder);
        null == d && (d = a.tag);
        this._renderCmd._setBatchNodeForAddChild(a) && (cc.Node.prototype.addChild.call(this, a, b, d), this._hasChildren = !0)
    },
    setSpriteFrame: function (a) {
        var b = this;
        cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
        this.setNodeDirty(!0);
        var d = a.getOffset();
        b._unflippedOffsetPositionFromCenter.x = d.x;
        b._unflippedOffsetPositionFromCenter.y = d.y;
        d = a.getTexture();
        a.textureLoaded() ? (b._textureLoaded = !0, d !== b._texture && (b._setTexture(d), b.setColor(b._realColor)), b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize())) : (b._textureLoaded = !1, a.addEventListener("load", function (a) {
            b._textureLoaded = !0;
            var d = a.getTexture();
            d !== b._texture && b._setTexture(d);
            b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            b.dispatchEvent("load");
            b.setColor(b._realColor)
        }, b));
        this._renderCmd._updateForSetSpriteFrame(d)
    },
    setDisplayFrame: function (a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(a)
    },
    isFrameDisplayed: function (a) {
        return this._renderCmd.isFrameDisplayed(a)
    },
    displayFrame: function () {
        return this.getSpriteFrame()
    },
    getSpriteFrame: function () {
        return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: function (a) {
        (this._batchNode = a) ? (this._transformToBatch = cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.getTextureAtlas()) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1, this._renderCmd._resetForBatchNode())
    },
    setTexture: function (a) {
        if (!a)return this._renderCmd._setTexture(null);
        var b = cc.isString(a);
        b && (a = cc.textureCache.addImage(a));
        a._textureLoaded ? (this._setTexture(a, b), this.setColor(this._realColor), this._textureLoaded = !0) : (this._renderCmd._setTexture(null), a.addEventListener("load", function () {
            this._setTexture(a, b);
            this.setColor(this._realColor);
            this._textureLoaded = !0
        }, this))
    },
    _setTexture: function (a, b) {
        this._renderCmd._setTexture(a);
        b && this._changeRectWithTexture(a)
    },
    _changeRectWithTexture: function (a) {
        a = a._contentSize;
        a = cc.rect(0, 0, a.width, a.height);
        this.setTextureRect(a)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
    }
});
cc.Sprite.create = function (a, b, d) {
    return new cc.Sprite(a, b, d)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
(function () {
    cc.Sprite.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureCoord = {renderX: 0, renderY: 0, x: 0, y: 0, width: 0, height: 0, validRect: !1};
        this._blendFuncStr = "source-over";
        this._colorized = !1;
        this._textureToRender = null
    };
    var a = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Sprite.CanvasRenderCmd;
    a._init = function () {
    };
    a.setDirtyRecursively = function (a) {
    };
    a._resetForBatchNode = function () {
    };
    a._setTexture = function (a) {
        var d =
            this._node;
        d._texture !== a && (d._textureLoaded = a ? a._textureLoaded : !1, d._texture = a, this._updateColor())
    };
    a._setColorDirty = function () {
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
    };
    a.isFrameDisplayed = function (a) {
        var d = this._node;
        return a.getTexture() !== d._texture ? !1 : cc.rectEqualToRect(a.getRect(), d._rect)
    };
    a.updateBlendFunc = function (a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    };
    a._setBatchNodeForAddChild = function (a) {
        return !0
    };
    a._handleTextureForRotatedTexture = function (a, d, e, f) {
        e && a.isLoaded() && (a = a.getHtmlElementObj(), a = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(a, d, f), f = new cc.Texture2D, f.initWithElement(a), f.handleLoadedTexture(), a = f, d.x = d.y = 0, this._node._rect = cc.rect(0, 0, d.width, d.height));
        return a
    };
    a._checkTextureBoundary = function (a, d, e) {
        a && a.url && (e = d.y + d.height, d.x + d.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), e > a.height && cc.error(cc._LogInfos.RectHeight, a.url))
    };
    a.rendering = function (a, d, e) {
        var f =
            this._node, g = this._textureCoord, h = this._displayedOpacity / 255, n = this._textureToRender || f._texture;
        if ((!n || 0 !== g.width && 0 !== g.height && n._textureLoaded) && 0 !== h) {
            a = a || cc._renderContext;
            var p = a.getContext(), r = f._offsetPosition.x, s = f._rect.height, t = f._rect.width, v = -f._offsetPosition.y - s;
            a.setTransform(this._worldTransform, d, e);
            a.setCompositeOperation(this._blendFuncStr);
            a.setGlobalAlpha(h);
            (f._flippedX || f._flippedY) && a.save();
            f._flippedX && (r = -r - t, p.scale(-1, 1));
            f._flippedY && (v = f._offsetPosition.y, p.scale(1,
                -1));
            var u, x, w;
            this._colorized ? u = h = 0 : (h = g.renderX, u = g.renderY);
            x = g.width;
            w = g.height;
            r *= d;
            v *= e;
            t *= d;
            s *= e;
            n && n._htmlElementObj ? (d = n._htmlElementObj, "" !== n._pattern ? (a.setFillStyle(p.createPattern(d, n._pattern)), p.fillRect(r, v, t, s)) : p.drawImage(d, h, u, x, w, r, v, t, s)) : (n = f._contentSize, g.validRect && (g = this._displayedColor, a.setFillStyle("rgba(" + g.r + "," + g.g + "," + g.b + ",1)"), p.fillRect(r, v, n.width * d, n.height * e)));
            (f._flippedX || f._flippedY) && a.restore();
            cc.g_NumberOfDraws++
        }
    };
    a._updateColor = function () {
        var a =
            this._node._texture, d = this._textureCoord, e = this._displayedColor;
        a && (255 !== e.r || 255 !== e.g || 255 !== e.b ? (this._textureToRender = a._generateColorTexture(e.r, e.g, e.b, d), this._colorized = !0) : a && (this._textureToRender = a, this._colorized = !1))
    };
    a.getQuad = function () {
        return null
    };
    a._updateForSetSpriteFrame = function (a, d) {
        this._colorized = !1;
        this._textureCoord.renderX = this._textureCoord.x;
        this._textureCoord.renderY = this._textureCoord.y;
        if (d = d || a._textureLoaded) {
            var e = this._node.getColor();
            255 === e.r && 255 === e.g && 255 ===
            e.b || this._updateColor()
        }
    };
    a.updateTransform = function () {
        var a = this._node;
        if (a.dirty) {
            var d = a._parent;
            !a._visible || d && d !== a._batchNode && d._shouldBeHidden ? a._shouldBeHidden = !0 : (a._shouldBeHidden = !1, a._transformToBatch = d && d !== a._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), d._transformToBatch) : this.getNodeToParentTransform());
            a._recursiveDirty = !1;
            a.dirty = !1
        }
        a._hasChildren && a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
    };
    a._spriteFrameLoadedCallback =
        function (a) {
            this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            this._renderCmd._updateColor();
            this.dispatchEvent("load")
        };
    a._textureLoadedCallback = function (a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var d = this._rect, e = this._renderCmd;
            d ? cc._rectEqualToZero(d) && (d.width = a.width, d.height = a.height) : d = cc.rect(0, 0, a.width, a.height);
            this.texture = a;
            this.setTextureRect(d, this._rectRotated);
            a = e._displayedColor;
            255 === a.r && 255 === a.g && 255 === a.b || e._updateColor();
            this.setBatchNode(this._batchNode);
            this.dispatchEvent("load")
        }
    };
    a._setTextureCoords = function (a, d) {
        void 0 === d && (d = !0);
        var e = this._textureCoord, f = d ? cc.contentScaleFactor() : 1;
        e.renderX = e.x = 0 | a.x * f;
        e.renderY = e.y = 0 | a.y * f;
        e.width = 0 | a.width * f;
        e.height = 0 | a.height * f;
        e.validRect = !(0 === e.width || 0 === e.height || 0 > e.x || 0 > e.y)
    };
    cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function (a, d, e) {
        if (!a)return null;
        if (!d)return a;
        e = null == e ? !0 : e;
        var f = document.createElement("canvas");
        f.width = d.width;
        f.height = d.height;
        var g = f.getContext("2d");
        g.translate(f.width /
            2, f.height / 2);
        e ? g.rotate(-1.5707963267948966) : g.rotate(1.5707963267948966);
        g.drawImage(a, d.x, d.y, d.height, d.width, -d.height / 2, -d.width / 2, d.height, d.width);
        return f
    }
})();
(function () {
    var a = !0;
    cc.Sprite.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._vertices = [{x: 0, y: 0, z: 0}, {x: 0, y: 0, z: 0}, {x: 0, y: 0, z: 0}, {x: 0, y: 0, z: 0}];
        a = this.vertexBytesPerUnit;
        var e = cc.renderer.requestBuffer(a);
        this._buffer = e.buffer;
        this._bufferOffset = e.offset;
        this._quad = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._buffer.data, this._bufferOffset);
        this._float32View = new Float32Array(this._buffer.data, this._bufferOffset, a / 4);
        this._uint32View = new Uint32Array(this._buffer.data,
            this._bufferOffset, a / 4);
        this._recursiveDirty = this._bufferDirty = this._dirty = !1;
        this._vBuffer = null;
        this._vertexOffset = 0;
        b.batchShader || (b.batchShader = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST))
    };
    var b = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    b.constructor = cc.Sprite.WebGLRenderCmd;
    b.vertexBytesPerUnit = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    b.bytesPerUnit = b.vertexBytesPerUnit;
    b.indicesPerUnit = 6;
    b.verticesPerUnit = 4;
    b._supportBatch = !0;
    b.batchShader = null;
    b.getBatchInfo = function (a) {
        a.texture = this._node._texture;
        a.blendSrc = this._node._blendFunc.src;
        a.blendDst = this._node._blendFunc.dst;
        a.shader = this.batchShader
    };
    b._invalidBatch = function () {
        this._vBuffer && (this._vBuffer.valid = !1)
    };
    b.updateBuffer = function () {
        if (!this._buffer) {
            var a = this.vertexBytesPerUnit, b = cc.renderer.requestBuffer(a);
            this._buffer = b.buffer;
            this._bufferOffset = b.offset;
            this._quad = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._buffer.data, this._bufferOffset);
            this._float32View =
                new Float32Array(this._quad.arrayBuffer, this._bufferOffset, a / 4);
            this._uint32View = new Uint32Array(this._quad.arrayBuffer, this._bufferOffset, a / 4);
            this._setTextureCoords(this._node._rect);
            this._updateColor();
            this._updateVertexBuffer()
        }
    };
    b.freeBuffer = function () {
        this._buffer && (this._buffer.freeBuffer(this._bufferOffset, this.vertexBytesPerUnit), this._buffer = null, this._bufferOffset = 0, this._float32View = this._quad = null)
    };
    b.updateBlendFunc = function (a) {
    };
    b.setDirtyFlag = function (a) {
        cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this,
            a);
        this._dirty = !0
    };
    b.setDirtyRecursively = function (a) {
        this._dirty = this._recursiveDirty = a;
        for (var b = this._node._children, f, g = b ? b.length : 0, h = 0; h < g; h++)f = b[h], f instanceof cc.Sprite && f._renderCmd.setDirtyRecursively(a)
    };
    b._setBatchNodeForAddChild = function (a) {
        var b = this._node;
        if (b._batchNode) {
            if (!(a instanceof cc.Sprite))return cc.log(cc._LogInfos.Sprite_addChild), !1;
            a.texture._webTextureObj !== b.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
            b._batchNode.appendChild(a);
            b._reorderChildDirty ||
            b._setReorderChildDirtyRecursively()
        }
        return !0
    };
    b._handleTextureForRotatedTexture = function (a) {
        return a
    };
    b.isFrameDisplayed = function (a) {
        var b = this._node;
        return cc.rectEqualToRect(a.getRect(), b._rect) && a.getTexture().getName() === b._texture.getName() && cc.pointEqualToPoint(a.getOffset(), b._unflippedOffsetPositionFromCenter)
    };
    b._init = function () {
        this.updateBuffer();
        var a = {r: 255, g: 255, b: 255, a: 255}, b = this._quad;
        b.bl.colors = a;
        b.br.colors = a;
        b.tl.colors = a;
        b.tr.colors = a;
        this._bufferDirty = !0;
        this._buffer.setDirty()
    };
    b._resetForBatchNode = function () {
        var a = this._node, b = a._offsetPosition.x, f = a._offsetPosition.y, g = b + a._rect.width, a = f + a._rect.height, h = this._vertices;
        h[0].x = b;
        h[0].y = a;
        h[1].x = b;
        h[1].y = f;
        h[2].x = g;
        h[2].y = a;
        h[3].x = g;
        h[3].y = f;
        this._bufferDirty = !0;
        this._buffer && this._buffer.setDirty()
    };
    b.getQuad = function () {
        return this._quad
    };
    b._updateForSetSpriteFrame = function () {
    };
    b._spriteFrameLoadedCallback = function (a) {
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this.dispatchEvent("load")
    };
    b._textureLoadedCallback =
        function (a) {
            if (!this._textureLoaded) {
                this._textureLoaded = !0;
                var b = this._rect;
                b ? cc._rectEqualToZero(b) && (b.width = a.width, b.height = a.height) : b = cc.rect(0, 0, a.width, a.height);
                this.texture = a;
                this.setTextureRect(b, this._rectRotated);
                this.setBatchNode(this._batchNode);
                this.dispatchEvent("load")
            }
        };
    b._setTextureCoords = function (a, b) {
        void 0 === b && (b = !0);
        b && (a = cc.rectPointsToPixels(a));
        var f = this._node, g = this._quad, h = f._batchNode ? f.textureAtlas.texture : f._texture;
        if (h && g) {
            var n = h.pixelsWidth, p = h.pixelsHeight,
                r, s;
            f._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (h = (2 * a.x + 1) / (2 * n), n = h + (2 * a.height - 2) / (2 * n), r = (2 * a.y + 1) / (2 * p), p = r + (2 * a.width - 2) / (2 * p)) : (h = a.x / n, n = (a.x + a.height) / n, r = a.y / p, p = (a.y + a.width) / p), f._flippedX && (s = r, r = p, p = s), f._flippedY && (s = h, h = n, n = s), g.bl.texCoords.u = h, g.bl.texCoords.v = r, g.br.texCoords.u = h, g.br.texCoords.v = p, g.tl.texCoords.u = n, g.tl.texCoords.v = r, g.tr.texCoords.u = n, g.tr.texCoords.v = p) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (h = (2 * a.x + 1) / (2 * n), n = h + (2 * a.width - 2) / (2 * n), r = (2 * a.y + 1) / (2 * p),
                p = r + (2 * a.height - 2) / (2 * p)) : (h = a.x / n, n = (a.x + a.width) / n, r = a.y / p, p = (a.y + a.height) / p), f._flippedX && (s = h, h = n, n = s), f._flippedY && (s = r, r = p, p = s), g.bl.texCoords.u = h, g.bl.texCoords.v = p, g.br.texCoords.u = n, g.br.texCoords.v = p, g.tl.texCoords.u = h, g.tl.texCoords.v = r, g.tr.texCoords.u = n, g.tr.texCoords.v = r);
            this._bufferDirty = !0;
            this._buffer.setDirty()
        }
    };
    b._updateVertexBuffer = function () {
        if (this._buffer) {
            var a = this._stackMatrix.mat, b = this._vertices, f = this._float32View, g, h, n, p = 0, r = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT / 16;
            for (g = 0; 4 > g; ++g)h = b[g].x, n = b[g].y, f[p] = h * a[0] + n * a[4] + a[12], f[p + 1] = h * a[1] + n * a[5] + a[13], f[p + 2] = a[14], p += r;
            this._bufferDirty = !0;
            this._buffer.setDirty()
        }
    };
    b.transform = function (a, b) {
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, b);
        this._updateVertexBuffer();
        this._savedDirtyFlag = this._dirty = !0
    };
    b._setColorDirty = function () {
    };
    b._updateColor = function () {
        var a = this._displayedColor, b = this._displayedOpacity, f = this._node, a = {r: a.r, g: a.g, b: a.b, a: b};
        f._opacityModifyRGB && (a.r *= b / 255, a.g *= b / 255, a.b *= b / 255);
        if (b = this._quad)b.bl.colors = a, b.br.colors = a, b.tl.colors = a, b.tr.colors = a, this._buffer.setDirty();
        f._batchNode && (f.atlasIndex !== cc.Sprite.INDEX_NOT_INITIALIZED ? f.textureAtlas.updateQuad(b, f.atlasIndex) : this._dirty = !0);
        this._bufferDirty = !0
    };
    b._updateBlendFunc = function () {
        if (this._batchNode)cc.log(cc._LogInfos.Sprite__updateBlendFunc); else {
            var a = this._node, b = a._blendFunc;
            a._texture && a._texture.hasPremultipliedAlpha() ? (b.src === cc.SRC_ALPHA && b.dst === cc.BLEND_DST && (b.src = cc.ONE), a.opacityModifyRGB = !0) : (b.src ===
            cc.ONE && b.dst === cc.BLEND_DST && (b.src = cc.SRC_ALPHA), a.opacityModifyRGB = !1);
            this._invalidBatch()
        }
    };
    b._setTexture = function (a) {
        var b = this._node;
        if (b._batchNode) {
            if (b._batchNode.texture !== a) {
                cc.log(cc._LogInfos.Sprite_setTexture);
                return
            }
        } else b._texture !== a && (b._textureLoaded = a ? a._textureLoaded : !1, b._texture = a, this._updateBlendFunc());
        this._shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST) : cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_COLOR)
    };
    b.updateTransform =
        function () {
            var a = this._node;
            if (this._dirty) {
                var b = this._quad, f = a._parent;
                if (!a._visible || f && f !== a._batchNode && f._shouldBeHidden)b.br.vertices = b.tl.vertices = b.tr.vertices = b.bl.vertices = {
                    x: 0,
                    y: 0,
                    z: 0
                }, a._shouldBeHidden = !0; else {
                    a._shouldBeHidden = !1;
                    0 !== this._dirtyFlag && (this.updateStatus(), this._dirtyFlag = 0);
                    a._transformToBatch = f && f !== a._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), f._transformToBatch) : this.getNodeToParentTransform();
                    var g = a._transformToBatch, h = a._rect, f = a._offsetPosition.x,
                        n = a._offsetPosition.y, p = f + h.width, r = n + h.height, s = g.tx, t = g.ty, v = g.a, u = g.b, x = g.d, w = -g.c, g = f * v - n * w + s, h = f * u + n * x + t, y = p * v - n * w + s, n = p * u + n * x + t, A = p * v - r * w + s, p = p * u + r * x + t, s = f * v - r * w + s, f = f * u + r * x + t, r = a._vertexZ;
                    cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (g |= 0, h |= 0, y |= 0, n |= 0, A |= 0, p |= 0, s |= 0, f |= 0);
                    b.bl.vertices = {x: g, y: h, z: r};
                    b.br.vertices = {x: y, y: n, z: r};
                    b.tl.vertices = {x: s, y: f, z: r};
                    b.tr.vertices = {x: A, y: p, z: r}
                }
                a.textureAtlas.updateQuad(b, a.atlasIndex);
                this._dirty = a._recursiveDirty = !1
            }
            a._hasChildren && a._arrayMakeObjectsPerformSelector(a._children,
                cc.Node._stateCallbackType.updateTransform)
        };
    b._checkTextureBoundary = function (a, b, f) {
        a && a.url && (f ? (f = b.x + b.height, b = b.y + b.width) : (f = b.x + b.width, b = b.y + b.height), f > a.width && cc.error(cc._LogInfos.RectWidth, a.url), b > a.height && cc.error(cc._LogInfos.RectHeight, a.url))
    };
    b.needDraw = function () {
        return this._buffer && this._node._texture
    };
    b.rendering = function (b) {
        var e = this._node, f = e._texture;
        if (this._buffer && (!f || f._textureLoaded && e._rect.width && e._rect.height) && this._displayedOpacity) {
            b = b || cc._renderContext;
            var g = this._shaderProgram;
            if (f) {
                if (f._textureLoaded) {
                    g.use();
                    g._updateProjectionUniform();
                    cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst);
                    cc.glBindTexture2DN(0, f);
                    f = !b.bindBuffer(b.ARRAY_BUFFER, this._buffer.vertexBuffer);
                    if (a || f)b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 24, 0), b.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR,
                        4, b.UNSIGNED_BYTE, !0, 24, 12), b.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, b.FLOAT, !1, 24, 16), a = !1;
                    b.drawArrays(b.TRIANGLE_STRIP, this._bufferOffset / (this.vertexBytesPerUnit / 4), 4)
                }
            } else g.use(), g._updateProjectionUniform(), cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst), b.bindBuffer(b.ARRAY_BUFFER, this._buffer.vertexBuffer), b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, b.FLOAT, !1, 24, 0),
                b.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, b.UNSIGNED_BYTE, !0, 24, 12), b.drawArrays(b.TRIANGLE_STRIP, this._bufferOffset / (this.vertexBytesPerUnit / 4), 4), a = !0;
            cc.g_NumberOfDraws++;
            if (0 !== cc.SPRITE_DEBUG_DRAW || e._showNode)cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix, 1 === cc.SPRITE_DEBUG_DRAW || e._showNode ? (e = this._vertices, e = [cc.p(e[0].x, e[0].y), cc.p(e[2].x, e[2].y), cc.p(e[3].x, e[3].y), cc.p(e[1].x, e[1].y)], cc._drawingUtil.drawPoly(e,
                4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (f = e.getTextureRect(), e = e.getOffsetPosition(), e = [cc.p(e.x, e.y), cc.p(e.x + f.width, e.y), cc.p(e.x + f.width, e.y + f.height), cc.p(e.x, e.y + f.height)], cc._drawingUtil.drawPoly(e, 4, !0)), cc.current_stack.top = cc.current_stack.stack.pop()
        }
    };
    b.batchVertexBuffer = function (a, b, f) {
        var g = this._float32View, h = this._uint32View, n, p = g.length, r = 3;
        for (n = 0; n < p; ++n)n === r ? (b[f + n] = h[n], r += 6) : a[f + n] = g[n]
    }
})();
cc.SpriteBatchNode = cc.Node.extend({
    _blendFunc: null, _descendants: null, _className: "SpriteBatchNode", ctor: function (a, b) {
        cc.Node.prototype.ctor.call(this);
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        var d;
        b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
        cc.isString(a) ? (d = cc.textureCache.getTextureForKey(a)) || (d = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (d = a);
        d && this.initWithTexture(d, b)
    }, addSpriteWithoutQuad: function (a, b, d) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
        if (!(a instanceof cc.Sprite))return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
        a.atlasIndex = b;
        var e = 0, f, g = this._descendants;
        if (g && 0 < g.length)for (e = 0, f = g.length; e < f; e++) {
            var h = g[e];
            if (h && h.atlasIndex >= b)break
        }
        g.splice(e, 0, a);
        cc.Node.prototype.addChild.call(this, a, b, d);
        this.reorderBatch(!1);
        return this
    }, getTextureAtlas: function () {
        return this._renderCmd.getTextureAtlas()
    }, setTextureAtlas: function (a) {
        this._renderCmd.getTextureAtlas(a)
    }, getDescendants: function () {
        return this._descendants
    },
    initWithFile: function (a, b) {
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        return this.initWithTexture(d, b)
    }, _setNodeDirtyForCache: function () {
        this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
    }, init: function (a, b) {
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        return this.initWithTexture(d, b)
    }, increaseAtlasCapacity: function () {
        this._renderCmd.increaseAtlasCapacity()
    }, removeChildAtIndex: function (a,
                                     b) {
        this.removeChild(this._children[a], b)
    }, rebuildIndexInOrder: function (a, b) {
        var d = a.children;
        if (d && 0 < d.length)for (var e = 0; e < d.length; e++) {
            var f = d[e];
            f && 0 > f.zIndex && (b = this.rebuildIndexInOrder(f, b))
        }
        !a === this && (a.atlasIndex = b, b++);
        if (d && 0 < d.length)for (e = 0; e < d.length; e++)(f = d[e]) && 0 <= f.zIndex && (b = this.rebuildIndexInOrder(f, b));
        return b
    }, highestAtlasIndexInChild: function (a) {
        var b = a.children;
        return b && 0 !== b.length ? this.highestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    }, lowestAtlasIndexInChild: function (a) {
        var b =
            a.children;
        return b && 0 !== b.length ? this.lowestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    }, atlasIndexForChild: function (a, b) {
        var d = a.parent, e = d.children, f = e.indexOf(a), g = null;
        0 < f && f < cc.UINT_MAX && (g = e[f - 1]);
        return d === this ? 0 === f ? 0 : this.highestAtlasIndexInChild(g) + 1 : 0 === f ? 0 > b ? d.atlasIndex : d.atlasIndex + 1 : 0 > g.zIndex && 0 > b || 0 <= g.zIndex && 0 <= b ? this.highestAtlasIndexInChild(g) + 1 : d.atlasIndex + 1
    }, reorderBatch: function (a) {
        this._reorderChildDirty = a
    }, setBlendFunc: function (a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    }, getBlendFunc: function () {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    }, reorderChild: function (a, b) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2);
        -1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : b !== a.zIndex && cc.Node.prototype.reorderChild.call(this, a, b)
    }, removeChild: function (a, b) {
        null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this,
            a, b)))
    }, updateQuadFromSprite: function (a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
        a instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    }, insertQuadFromSprite: function (a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
        a instanceof cc.Sprite ? (this._renderCmd.insertQuad(a, b), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(),
            this._renderCmd.cutting(a, b)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    }, initWithTexture: function (a, b) {
        this._children.length = 0;
        this._descendants.length = 0;
        b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
        this._renderCmd.initWithTexture(a, b);
        return !0
    }, insertChild: function (a, b) {
        a.batchNode = this;
        a.atlasIndex = b;
        a.dirty = !0;
        this._renderCmd.insertQuad(a, b);
        this._descendants.splice(b, 0, a);
        var d = b + 1, e = this._descendants;
        if (e && 0 < e.length)for (; d < e.length; d++)e[d].atlasIndex++;
        var e = a.children, f, g;
        if (e)for (d =
                       0, g = e.length || 0; d < g; d++)if (f = e[d]) {
            var h = this.atlasIndexForChild(f, f.zIndex);
            this.insertChild(f, h)
        }
    }, appendChild: function (a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        var b = this._descendants.length - 1;
        a.atlasIndex = b;
        this._renderCmd.insertQuad(a, b);
        a = a.children;
        for (var b = 0, d = a.length || 0; b < d; b++)this.appendChild(a[b])
    }, removeSpriteFromAtlas: function (a) {
        this._renderCmd.removeQuadAtIndex(a.atlasIndex);
        a.batchNode = null;
        var b = this._descendants, d = b.indexOf(a);
        if (-1 !==
            d) {
            b.splice(d, 1);
            for (var e = b.length; d < e; ++d)b[d].atlasIndex--
        }
        if (a = a.children)for (b = 0, d = a.length || 0; b < d; b++)a[b] && this.removeSpriteFromAtlas(a[b])
    }, getTexture: function () {
        return this._renderCmd.getTexture()
    }, setTexture: function (a) {
        this._renderCmd.setTexture(a)
    }, addChild: function (a, b, d) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
        this._renderCmd.isValidChild(a) && (b = null == b ? a.zIndex : b, d = null == d ? a.tag : d, cc.Node.prototype.addChild.call(this, a, b, d), this.appendChild(a))
    }, removeAllChildren: function (a) {
        var b =
            this._descendants;
        if (b && 0 < b.length)for (var d = 0, e = b.length; d < e; d++)b[d] && (b[d].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0;
        this._renderCmd.removeAllQuads()
    }, sortAllChildren: function () {
        if (this._reorderChildDirty) {
            var a = this._children, b, d = 0, e = a.length, f;
            for (b = 1; b < e; b++) {
                var g = a[b], d = b - 1;
                for (f = a[d]; 0 <= d && (g._localZOrder < f._localZOrder || g._localZOrder === f._localZOrder && g.arrivalOrder < f.arrivalOrder);)a[d + 1] = f, d -= 1, f = a[d];
                a[d + 1] = g
            }
            0 < a.length && (this._arrayMakeObjectsPerformSelector(a,
                cc.Node._stateCallbackType.sortAllChildren), this._renderCmd.updateChildrenAtlasIndex(a));
            this._reorderChildDirty = !1
        }
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
    }
});
_p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.DEFAULT_CAPACITY = 29;
cc.SpriteBatchNode.create = function (a, b) {
    return new cc.SpriteBatchNode(a, b)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
(function () {
    cc.SpriteBatchNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._textureToRender = this._texture = null
    };
    var a = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.SpriteBatchNode.CanvasRenderCmd;
    a.checkAtlasCapacity = function () {
    };
    a.isValidChild = function (a) {
        return a instanceof cc.Sprite ? !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
    };
    a.initWithTexture = function (a, d) {
        this._textureToRender = this._texture = a
    };
    a.insertQuad =
        function (a, d) {
        };
    a.increaseAtlasCapacity = function () {
    };
    a.removeQuadAtIndex = function () {
    };
    a.removeAllQuads = function () {
    };
    a.getTexture = function () {
        return this._texture
    };
    a.setTexture = function (a) {
        this._texture = a;
        for (var d = this._node._children, e = 0; e < d.length; e++)d[e].setTexture(a)
    };
    a.updateChildrenAtlasIndex = function (a) {
        for (var d = this._node._descendants.length = 0, e = a.length; d < e; d++)this._updateAtlasIndex(a[d])
    };
    a._updateAtlasIndex = function (a) {
        var d = this._node._descendants, e = a.children, f, g = e.length;
        for (f = 0; f <
        g; f++)if (0 > e[f]._localZOrder)d.push(e[f]); else break;
        for (d.push(a); f < g; f++)d.push(e[f])
    };
    a.getTextureAtlas = function () {
    };
    a.setTextureAtlas = function (a) {
    };
    a.cutting = function (a, d) {
        this._node._children.splice(d, 0, a)
    }
})();
(function () {
    cc.SpriteBatchNode.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureAtlas = null
    };
    var a = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.SpriteBatchNode.WebGLRenderCmd;
    a.isValidChild = function (a) {
        return a instanceof cc.Sprite ? a.texture != this.getTexture() ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
    };
    a.rendering = function () {
        var a = this._node;
        0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._textureAtlas.drawQuads())
    };
    a.visit = function (a) {
        var d = this._node;
        if (d._visible) {
            d._parent && d._parent._renderCmd && (this._curLevel = d._parent._renderCmd._curLevel + 1);
            var e = cc.current_stack;
            e.stack.push(e.top);
            this._dirtyFlag &
            cc.Node._dirtyFlags.transformDirty || this.transform(a);
            this.updateStatus(a);
            e.top = this._stackMatrix;
            d.sortAllChildren();
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0;
            e.top = e.stack.pop()
        }
    };
    a.checkAtlasCapacity = function (a) {
        for (var d = this._textureAtlas; a >= d.capacity || d.capacity === d.totalQuads;)this.increaseAtlasCapacity()
    };
    a.increaseAtlasCapacity = function () {
        var a = this._textureAtlas.capacity, d = Math.floor(4 * (a + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, d);
        this._textureAtlas.resizeCapacity(d) ||
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    };
    a.initWithTexture = function (a, d) {
        this._textureAtlas = new cc.TextureAtlas;
        this._textureAtlas.initWithTexture(a, d);
        this._updateBlendFunc();
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a.insertQuad = function (a, d) {
        var e = this._textureAtlas;
        e.totalQuads >= e.capacity && this.increaseAtlasCapacity();
        e.insertQuad(a.quad, d)
    };
    a.removeQuadAtIndex = function (a) {
        this._textureAtlas.removeQuadAtIndex(a)
    };
    a.getTexture = function () {
        return this._textureAtlas.texture
    };
    a.setTexture = function (a) {
        this._textureAtlas.setTexture(a);
        a && this._updateBlendFunc()
    };
    a.removeAllQuads = function () {
        this._textureAtlas.removeAllQuads()
    };
    a._swap = function (a, d) {
        var e = this._node._descendants, f = this._textureAtlas, g = f.quads, h = e[a], n = cc.V3F_C4B_T2F_QuadCopy(g[a]);
        e[d].atlasIndex = a;
        e[a] = e[d];
        f.updateQuad(g[d], a);
        e[d] = h;
        f.updateQuad(n, d)
    };
    a._updateAtlasIndex = function (a, d) {
        var e = 0, f = a.children;
        f && (e = f.length);
        var g = 0;
        if (0 === e)g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g,
            d), d++; else {
            g = !0;
            0 <= f[0].zIndex && (g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g, d), d++, g = !1);
            for (e = 0; e < f.length; e++) {
                var h = f[e];
                g && 0 <= h.zIndex && (g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g, d), d++, g = !1);
                d = this._updateAtlasIndex(h, d)
            }
            g && (g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g, d), d++)
        }
        return d
    };
    a.updateChildrenAtlasIndex = function (a) {
        for (var d = 0, e = 0; e < a.length; e++)d = this._updateAtlasIndex(a[e], d)
    };
    a._updateBlendFunc = function () {
        if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
            var a =
                this._node._blendFunc;
            a.src = cc.SRC_ALPHA;
            a.dst = cc.ONE_MINUS_SRC_ALPHA
        }
    };
    a.getTextureAtlas = function () {
        return this._textureAtlas
    };
    a.setTextureAtlas = function (a) {
        a !== this._textureAtlas && (this._textureAtlas = a)
    };
    a.cutting = function () {
    }
})();
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null, _cacheContext: null, ctor: function () {
        cc.Sprite.prototype.ctor.call(this);
        var a = document.createElement("canvas");
        a.width = a.height = 10;
        this._cacheCanvas = a;
        this._cacheContext = new cc.CanvasContextWrapper(a.getContext("2d"));
        var b = new cc.Texture2D;
        b.initWithElement(a);
        b.handleLoadedTexture();
        this.setTexture(b)
    }, getCacheContext: function () {
        return this._cacheContext
    }, getCacheCanvas: function () {
        return this._cacheCanvas
    }, resetCanvasSize: function (a, b) {
        var d = this._cacheCanvas,
            e = this._cacheContext, f = e._context.strokeStyle, g = e._context.fillStyle;
        void 0 === b && (b = a.height, a = a.width);
        d.width = a;
        d.height = b;
        f !== e._context.strokeStyle && (e._context.strokeStyle = f);
        g !== e._context.fillStyle && (e._context.fillStyle = g);
        this.getTexture().handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, a, b), !1, null, !1)
    }
});
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null, _delayPerUnit: 0, _userInfo: null, ctor: function (a, b, d) {
        this._spriteFrame = a || null;
        this._delayPerUnit = b || 0;
        this._userInfo = d || null
    }, clone: function () {
        var a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    }, copyWithZone: function (a) {
        return cc.clone(this)
    }, copy: function (a) {
        a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    }, initWithSpriteFrame: function (a,
                                      b, d) {
        this._spriteFrame = a;
        this._delayPerUnit = b;
        this._userInfo = d;
        return !0
    }, getSpriteFrame: function () {
        return this._spriteFrame
    }, setSpriteFrame: function (a) {
        this._spriteFrame = a
    }, getDelayUnits: function () {
        return this._delayPerUnit
    }, setDelayUnits: function (a) {
        this._delayPerUnit = a
    }, getUserInfo: function () {
        return this._userInfo
    }, setUserInfo: function (a) {
        this._userInfo = a
    }
});
cc.AnimationFrame.create = function (a, b, d) {
    return new cc.AnimationFrame(a, b, d)
};
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function (a, b, d) {
        this._frames = [];
        if (void 0 === a)this.initWithSpriteFrames(null, 0); else {
            var e = a[0];
            e && (e instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, d) : e instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, d))
        }
    },
    getFrames: function () {
        return this._frames
    },
    setFrames: function (a) {
        this._frames = a
    },
    addSpriteFrame: function (a) {
        var b = new cc.AnimationFrame;
        b.initWithSpriteFrame(a,
            1, null);
        this._frames.push(b);
        this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function (a) {
        a = cc.textureCache.addImage(a);
        var b = cc.rect(0, 0, 0, 0);
        b.width = a.width;
        b.height = a.height;
        a = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(a)
    },
    addSpriteFrameWithTexture: function (a, b) {
        var d = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(d)
    },
    initWithAnimationFrames: function (a, b, d) {
        cc.arrayVerifyType(a, cc.AnimationFrame);
        this._delayPerUnit = b;
        this._loops = void 0 === d ? 1 : d;
        this._totalDelayUnits = 0;
        b = this._frames;
        for (d = b.length =
            0; d < a.length; d++) {
            var e = a[d];
            b.push(e);
            this._totalDelayUnits += e.getDelayUnits()
        }
        return !0
    },
    clone: function () {
        var a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    copyWithZone: function (a) {
        a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    _copyFrames: function () {
        for (var a = [], b = 0; b < this._frames.length; b++)a.push(this._frames[b].clone());
        return a
    },
    copy: function (a) {
        return this.copyWithZone(null)
    },
    getLoops: function () {
        return this._loops
    },
    setLoops: function (a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function (a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function () {
        return this._restoreOriginalFrame
    },
    getDuration: function () {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function () {
        return this._delayPerUnit
    },
    setDelayPerUnit: function (a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function () {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function (a, b, d) {
        cc.arrayVerifyType(a, cc.SpriteFrame);
        this._loops = void 0 === d ? 1 : d;
        this._delayPerUnit = b || 0;
        this._totalDelayUnits = 0;
        b = this._frames;
        b.length = 0;
        if (a) {
            for (d = 0; d < a.length; d++) {
                var e = a[d], f = new cc.AnimationFrame;
                f.initWithSpriteFrame(e, 1, null);
                b.push(f)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function () {
    },
    release: function () {
    }
});
cc.Animation.create = function (a, b, d) {
    return new cc.Animation(a, b, d)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
    _animations: {}, addAnimation: function (a, b) {
        this._animations[b] = a
    }, removeAnimation: function (a) {
        a && this._animations[a] && delete this._animations[a]
    }, getAnimation: function (a) {
        return this._animations[a] ? this._animations[a] : null
    }, _addAnimationsWithDictionary: function (a, b) {
        var d = a.animations;
        if (d) {
            var e = 1, f = a.properties;
            if (f)for (var e = null != f.format ? parseInt(f.format) : e, f = f.spritesheets, g = cc.spriteFrameCache, h = cc.path, n = 0; n < f.length; n++)g.addSpriteFrames(h.changeBasename(b, f[n]));
            switch (e) {
                case 1:
                    this._parseVersion1(d);
                    break;
                case 2:
                    this._parseVersion2(d);
                    break;
                default:
                    cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
            }
        } else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
    }, addAnimations: function (a) {
        cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
        var b = cc.loader.getRes(a);
        b ? this._addAnimationsWithDictionary(b, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
    }, _parseVersion1: function (a) {
        var b = cc.spriteFrameCache, d;
        for (d in a) {
            var e = a[d], f = e.frames, e = parseFloat(e.delay) ||
                0, g = null;
            if (f) {
                for (var g = [], h = 0; h < f.length; h++) {
                    var n = b.getSpriteFrame(f[h]);
                    if (n) {
                        var p = new cc.AnimationFrame;
                        p.initWithSpriteFrame(n, 1, null);
                        g.push(p)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, d, f[h])
                }
                0 === g.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, d) : (g.length !== f.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, d), g = new cc.Animation(g, e, 1), cc.animationCache.addAnimation(g, d))
            } else cc.log(cc._LogInfos.animationCache__parseVersion1, d)
        }
    }, _parseVersion2: function (a) {
        var b =
            cc.spriteFrameCache, d;
        for (d in a) {
            var e = a[d], f = e.loop, g = parseInt(e.loops), f = f ? cc.REPEAT_FOREVER : isNaN(g) ? 1 : g, g = e.restoreOriginalFrame && !0 == e.restoreOriginalFrame ? !0 : !1, h = e.frames;
            if (h) {
                for (var n = [], p = 0; p < h.length; p++) {
                    var r = h[p], s = r.spriteframe, t = b.getSpriteFrame(s);
                    if (t) {
                        var s = parseFloat(r.delayUnits) || 0, r = r.notification, v = new cc.AnimationFrame;
                        v.initWithSpriteFrame(t, s, r);
                        n.push(v)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, d, s)
                }
                e = parseFloat(e.delayPerUnit) || 0;
                h = new cc.Animation;
                h.initWithAnimationFrames(n,
                    e, f);
                h.setRestoreOriginalFrame(g);
                cc.animationCache.addAnimation(h, d)
            } else cc.log(cc._LogInfos.animationCache__parseVersion2, d)
        }
    }, _clear: function () {
        this._animations = {}
    }
};
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    ctor: function (a, b, d, e, f) {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = !1;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = !1;
        void 0 !== a && void 0 !== b && (void 0 === d || void 0 === e || void 0 === f ?
            this.initWithTexture(a, b) : this.initWithTexture(a, b, d, e, f))
    },
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a, b) {
        this.addEventListener("load", a, b)
    },
    getRectInPixels: function () {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function (a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
        this._rectInPixels.x = a.x;
        this._rectInPixels.y = a.y;
        this._rectInPixels.width = a.width;
        this._rectInPixels.height = a.height;
        this._rect = cc.rectPixelsToPoints(a)
    },
    isRotated: function () {
        return this._rotated
    },
    setRotated: function (a) {
        this._rotated = a
    },
    getRect: function () {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function (a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0));
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height;
        this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function () {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function (a) {
        this._offsetInPixels.x = a.x;
        this._offsetInPixels.y =
            a.y;
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function () {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function (a) {
        this._originalSizeInPixels.width = a.width;
        this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function () {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function (a) {
        this._originalSize.width = a.width;
        this._originalSize.height = a.height
    },
    getTexture: function () {
        if (this._texture)return this._texture;
        if ("" !== this._textureFilename) {
            var a =
                cc.textureCache.addImage(this._textureFilename);
            a && (this._textureLoaded = a.isLoaded());
            return a
        }
        return null
    },
    setTexture: function (a) {
        if (this._texture !== a) {
            var b = a.isLoaded();
            this._textureLoaded = b;
            this._texture = a;
            b || a.addEventListener("load", function (a) {
                this._textureLoaded = !0;
                if (this._rotated && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                    var b = a.getHtmlElementObj(), b = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(b, this.getRect()), f = new cc.Texture2D;
                    f.initWithElement(b);
                    f.handleLoadedTexture();
                    this.setTexture(f);
                    b = this.getRect();
                    this.setRect(cc.rect(0, 0, b.width, b.height))
                }
                b = this._rect;
                0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height = a);
                this.dispatchEvent("load")
            }, this)
        }
    },
    getOffset: function () {
        return cc.p(this._offset)
    },
    setOffset: function (a) {
        this._offset.x =
            a.x;
        this._offset.y = a.y
    },
    clone: function () {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copyWithZone: function () {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copy: function () {
        return this.copyWithZone()
    },
    initWithTexture: function (a,
                               b, d, e, f) {
        2 === arguments.length && (b = cc.rectPointsToPixels(b));
        e = e || cc.p(0, 0);
        f = f || b;
        d = d || !1;
        cc.isString(a) ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
        a = this.getTexture();
        this._rectInPixels = b;
        this._rect = cc.rectPixelsToPoints(b);
        if (a && a.url && a.isLoaded()) {
            var g, h;
            d ? (g = b.x + b.height, h = b.y + b.width) : (g = b.x + b.width, h = b.y + b.height);
            g > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url);
            h > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        this._offsetInPixels.x =
            e.x;
        this._offsetInPixels.y = e.y;
        cc._pointPixelsToPointsOut(e, this._offset);
        this._originalSizeInPixels.width = f.width;
        this._originalSizeInPixels.height = f.height;
        cc._sizePixelsToPointsOut(f, this._originalSize);
        this._rotated = d;
        return !0
    }
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function (a, b, d, e, f) {
    return new cc.SpriteFrame(a, b, d, e, f)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function (a, b, d, e, f) {
    var g = new cc.SpriteFrame;
    g._texture = a;
    g._rectInPixels = b;
    g._rect = cc.rectPixelsToPoints(b);
    g._offsetInPixels.x = e.x;
    g._offsetInPixels.y = e.y;
    cc._pointPixelsToPointsOut(g._offsetInPixels, g._offset);
    g._originalSizeInPixels.width = f.width;
    g._originalSizeInPixels.height = f.height;
    cc._sizePixelsToPointsOut(g._originalSizeInPixels, g._originalSize);
    g._rotated = d;
    return g
};
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function (a) {
        return (a = this._CCNS_REG2.exec(a)) ? cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4])) : cc.rect(0, 0, 0, 0)
    },
    _pointFromString: function (a) {
        return (a = this._CCNS_REG1.exec(a)) ?
            cc.p(parseFloat(a[1]), parseFloat(a[2])) : cc.p(0, 0)
    },
    _sizeFromString: function (a) {
        return (a = this._CCNS_REG1.exec(a)) ? cc.size(parseFloat(a[1]), parseFloat(a[2])) : cc.size(0, 0)
    },
    _getFrameConfig: function (a) {
        var b = cc.loader.getRes(a);
        cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
        cc.loader.release(a);
        if (b._inited)return this._frameConfigCache[a] = b;
        this._frameConfigCache[a] = this._parseFrameConfig(b);
        return this._frameConfigCache[a]
    },
    _getFrameConfigByJsonObject: function (a, b) {
        cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2,
            a);
        this._frameConfigCache[a] = this._parseFrameConfig(b);
        return this._frameConfigCache[a]
    },
    _parseFrameConfig: function (a) {
        var b = a.frames, d = a.metadata || a.meta;
        a = {};
        var e = {}, f = 0;
        d && (f = d.format, f = 1 >= f.length ? parseInt(f) : f, e.image = d.textureFileName || d.textureFileName || d.image);
        for (var g in b) {
            var h = b[g];
            if (h) {
                d = {};
                if (0 == f) {
                    d.rect = cc.rect(h.x, h.y, h.width, h.height);
                    d.rotated = !1;
                    d.offset = cc.p(h.offsetX, h.offsetY);
                    var n = h.originalWidth, h = h.originalHeight;
                    n && h || cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                    n = Math.abs(n);
                    h = Math.abs(h);
                    d.size = cc.size(n, h)
                } else if (1 == f || 2 == f)d.rect = this._rectFromString(h.frame), d.rotated = h.rotated || !1, d.offset = this._pointFromString(h.offset), d.size = this._sizeFromString(h.sourceSize); else if (3 == f) {
                    var n = this._sizeFromString(h.spriteSize), p = this._rectFromString(h.textureRect);
                    n && (p = cc.rect(p.x, p.y, n.width, n.height));
                    d.rect = p;
                    d.rotated = h.textureRotated || !1;
                    d.offset = this._pointFromString(h.spriteOffset);
                    d.size = this._sizeFromString(h.spriteSourceSize);
                    d.aliases = h.aliases
                } else n =
                    h.frame, p = h.sourceSize, g = h.filename || g, d.rect = cc.rect(n.x, n.y, n.w, n.h), d.rotated = h.rotated || !1, d.offset = cc.p(0, 0), d.size = cc.size(p.w, p.h);
                a[g] = d
            }
        }
        return {_inited: !0, frames: a, meta: e}
    },
    _addSpriteFramesByObject: function (a, b, d) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        b && b.frames && (b = this._frameConfigCache[a] || this._getFrameConfigByJsonObject(a, b), this._createSpriteFrames(a, b, d))
    },
    _createSpriteFrames: function (a, b, d) {
        var e = b.frames;
        b = b.meta;
        d ? d instanceof cc.Texture2D || (cc.isString(d) ?
            d = cc.textureCache.addImage(d) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (d = cc.path.changeBasename(a, b.image || ".png"), d = cc.textureCache.addImage(d));
        a = this._spriteFramesAliases;
        b = this._spriteFrames;
        for (var f in e) {
            var g = e[f], h = b[f];
            if (!h) {
                h = new cc.SpriteFrame(d, g.rect, g.rotated, g.offset, g.size);
                if (g = g.aliases)for (var n = 0, p = g.length; n < p; n++) {
                    var r = g[n];
                    a[r] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, r);
                    a[r] = f
                }
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && h.isRotated() &&
                h.getTexture().isLoaded() && (g = h.getTexture().getHtmlElementObj(), g = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(g, h.getRectInPixels()), n = new cc.Texture2D, n.initWithElement(g), n.handleLoadedTexture(), h.setTexture(n), g = h._rect, h.setRect(cc.rect(0, 0, g.width, g.height)));
                b[f] = h
            }
        }
    },
    addSpriteFrames: function (a, b) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var d = this._frameConfigCache[a] || cc.loader.getRes(a);
        d && d.frames && (d = this._frameConfigCache[a] || this._getFrameConfig(a), this._createSpriteFrames(a,
            d, b))
    },
    _checkConflict: function (a) {
        a = a.frames;
        for (var b in a)this._spriteFrames[b] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, b)
    },
    addSpriteFrame: function (a, b) {
        this._spriteFrames[b] = a
    },
    removeSpriteFrames: function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function (a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function (a) {
        var b = this._spriteFrames, d =
            this._spriteFramesAliases;
        if (a = this._frameConfigCache[a]) {
            a = a.frames;
            for (var e in a)if (b[e]) {
                delete b[e];
                for (var f in d)d[f] === e && delete d[f]
            }
        }
    },
    removeSpriteFramesFromTexture: function (a) {
        var b = this._spriteFrames, d = this._spriteFramesAliases, e;
        for (e in b) {
            var f = b[e];
            if (f && f.getTexture() === a) {
                delete b[e];
                for (var g in d)d[g] === e && delete d[g]
            }
        }
    },
    getSpriteFrame: function (a) {
        var b = this._spriteFrames[a];
        if (!b) {
            var d = this._spriteFramesAliases[a];
            d && ((b = this._spriteFrames[d.toString()]) || delete this._spriteFramesAliases[a])
        }
        return b
    },
    _clear: function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._frameConfigCache = {}
    }
};
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function () {
        var a = this._valueDict;
        a["cocos2d.x.version"] = cc.ENGINE_VERSION;
        a["cocos2d.x.compiled_with_profiler"] = !1;
        a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
        this._inited = !0
    },
    getMaxTextureSize: function () {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function () {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function () {
        return this._maxTextureUnits
    },
    supportsNPOT: function () {
        return this._supportsNPOT
    },
    supportsPVRTC: function () {
        return this._supportsPVRTC
    },
    supportsETC: function () {
        return !1
    },
    supportsS3TC: function () {
        return !1
    },
    supportsATITC: function () {
        return !1
    },
    supportsBGRA8888: function () {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function () {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function () {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function (a) {
        return -1 < this._GlExtensions.indexOf(a)
    },
    getValue: function (a, b) {
        this._inited || this._init();
        var d = this._valueDict;
        return d[a] ? d[a] : b
    },
    setValue: function (a, b) {
        this._valueDict[a] = b
    },
    dumpInfo: function () {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
    },
    gatherGPUInfo: function () {
        if (cc._renderType !== cc.game.RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a =
                cc._renderContext, b = this._valueDict;
            b["gl.vendor"] = a.getParameter(a.VENDOR);
            b["gl.renderer"] = a.getParameter(a.RENDERER);
            b["gl.version"] = a.getParameter(a.VERSION);
            this._GlExtensions = "";
            for (var d = a.getSupportedExtensions(), e = 0; e < d.length; e++)this._GlExtensions += d[e] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            b["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            b["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC =
                this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            b["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            b["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            b["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            b["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
            cc.checkGLErrorDebug()
        }
    },
    loadConfigFile: function (a) {
        this._inited || this._init();
        var b = cc.loader.getRes(a);
        if (!b)throw Error("Please load the resource first : " + a);
        cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a);
        if (b = b.data)for (var d in b)this._valueDict[d] = b[d]; else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
    }
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function (a) {
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
    var b = new cc.math.Matrix4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
    a.multiply(b)
};
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _contentScaleFactor: 1,
    _deltaTime: 0,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterUpdate: null,
    _eventAfterVisit: null,
    _eventAfterDraw: null,
    ctor: function () {
        var a = this;
        a._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
            a._lastUpdate = Date.now()
        })
    },
    init: function () {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._totalFrames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView =
            null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        cc.ActionManager ? (this._actionManager = new cc.ActionManager, this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1)) : this._actionManager = null;
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return !0
    },
    calculateDeltaTime: function () {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (a - this._lastUpdate) / 1E3;
        0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
        this._lastUpdate = a
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function () {
        var a =
            cc.renderer;
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (!0 === a.childrenOrderDirty ? (cc.renderer.clearRenderCommands(), cc.renderer.assignedZ = 0, this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), a.resetFlag()) : !0 === a.transformDirty() && a.transform());
        a.clear();
        this._notificationNode && this._notificationNode.visit();
        cc.eventManager.dispatchEvent(this._eventAfterVisit);
        cc.g_NumberOfDraws = 0;
        this._afterVisitScene && this._afterVisitScene();
        a.rendering(cc._renderContext);
        this._totalFrames++;
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function () {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function () {
        return this._contentScaleFactor
    },
    getNotificationNode: function () {
        return this._notificationNode
    },
    getWinSize: function () {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function () {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function () {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0)
    },
    popScene: function () {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 === a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function () {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear()
    },
    purgeDirector: function () {
        this.getScheduler().unscheduleAll();
        cc.eventManager && cc.eventManager.setEnabled(!1);
        this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug()
    },
    pushScene: function (a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = !1;
        this._scenesStack.push(a);
        this._nextScene = a
    },
    runScene: function (a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        if (this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] = a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a);
            this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function () {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval),
        (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    },
    setContentScaleFactor: function (a) {
        a !== this._contentScaleFactor && (this._contentScaleFactor = a)
    },
    setDepthTest: null,
    setClearColor: null,
    setDefaultValues: function () {
    },
    setNextDeltaTimeZero: function (a) {
        this._nextDeltaTimeZero = a
    },
    setNextScene: function () {
        var a = !1, b = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!b) {
            if (b = this._runningScene)b.onExitTransitionDidStart(), b.onExit();
            this._sendCleanupToScene && b && b.cleanup()
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = !0;
        this._nextScene = null;
        a || null === this._runningScene || (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function (a) {
        cc.renderer.childrenOrderDirty = !0;
        this._notificationNode && (this._notificationNode.onExitTransitionDidStart(), this._notificationNode.onExit(),
            this._notificationNode.cleanup());
        if (this._notificationNode = a)this._notificationNode.onEnter(), this._notificationNode.onEnterTransitionDidFinish()
    },
    getDelegate: function () {
        return this._projectionDelegate
    },
    setDelegate: function (a) {
        this._projectionDelegate = a
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    isSendCleanupToScene: function () {
        return this._sendCleanupToScene
    },
    getRunningScene: function () {
        return this._runningScene
    },
    getAnimationInterval: function () {
        return this._animationInterval
    },
    isDisplayStats: function () {
        return cc.profiler ? cc.profiler.isShowingStats() : !1
    },
    setDisplayStats: function (a) {
        cc.profiler && (a ? cc.profiler.showStats() : cc.profiler.hideStats())
    },
    getSecondsPerFrame: function () {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function () {
        return this._nextDeltaTimeZero
    },
    isPaused: function () {
        return this._paused
    },
    getTotalFrames: function () {
        return this._totalFrames
    },
    popToRootScene: function () {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function (a) {
        cc.assert(this._runningScene,
            cc._LogInfos.Director_popToSceneStackLevel_2);
        var b = this._scenesStack, d = b.length;
        if (0 === a)this.end(); else if (!(a >= d)) {
            for (; d > a;) {
                var e = b.pop();
                e.running && (e.onExitTransitionDidStart(), e.onExit());
                e.cleanup();
                d--
            }
            this._nextScene = b[b.length - 1];
            this._sendCleanupToScene = !0
        }
    },
    getScheduler: function () {
        return this._scheduler
    },
    setScheduler: function (a) {
        this._scheduler !== a && (this._scheduler = a)
    },
    getActionManager: function () {
        return this._actionManager
    },
    setActionManager: function (a) {
        this._actionManager !== a && (this._actionManager =
            a)
    },
    getDeltaTime: function () {
        return this._deltaTime
    },
    _calculateMPF: function () {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
    }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1, startAnimation: function () {
        this._nextDeltaTimeZero = !0;
        this.invalid = !1
    }, mainLoop: function () {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    }, stopAnimation: function () {
        this.invalid = !0
    }, setAnimationInterval: function (a) {
        this._animationInterval = a;
        this.invalid || (this.stopAnimation(), this.startAnimation())
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function () {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var a = cc.Director.prototype;
        a.getProjection = function (a) {
            return this._projection
        };
        a.setProjection = function (a) {
            this._projection = a;
            cc.eventManager.dispatchEvent(this._eventProjectionChanged)
        };
        a.setDepthTest = function () {
        };
        a.setClearColor = function (a) {
            cc.renderer._clearColor = a;
            cc.renderer._clearFillStyle = "rgb(" + a.r + "," + a.g + "," + a.b + ")"
        };
        a.setOpenGLView = function (a) {
            this._winSizeInPoints.width =
                cc._canvas.width;
            this._winSizeInPoints.height = cc._canvas.height;
            this._openGLView = a || cc.view;
            cc.eventManager && cc.eventManager.setEnabled(!0)
        };
        a.getVisibleSize = function () {
            return this.getWinSize()
        };
        a.getVisibleOrigin = function () {
            return cc.p(0, 0)
        }
    } else cc.Director._fpsImage = new Image, cc.Director._fpsImage.addEventListener("load", function () {
        cc.Director._fpsImageLoaded = !0
    }), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage)
});
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.DirectorDelegate = cc.Class.extend({
            updateProjection: function () {
            }
        });
        var a = cc.Director.prototype, b = function (a) {
            if (a && a._renderCmd) {
                a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
                var e = a._children;
                for (a = 0; a < e.length; a++)b(e[a])
            }
        };
        cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function () {
            for (var a = cc.director._scenesStack, e = 0; e < a.length; e++)b(a[e])
        });
        a.setProjection = function (a) {
            var b = this._winSizeInPoints;
            this.setViewport();
            var f = this._openGLView, g = f._viewPortRect.x / f._scaleX, h = f._viewPortRect.y / f._scaleY;
            switch (a) {
                case cc.Director.PROJECTION_2D:
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLLoadIdentity();
                    f = cc.math.Matrix4.createOrthographicProjection(-g, b.width - g, -h, b.height - h, -1024, 1024);
                    cc.kmGLMultMatrix(f);
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLLoadIdentity();
                    break;
                case cc.Director.PROJECTION_3D:
                    var n = this.getZEye(), p = new cc.math.Matrix4,
                        f = new cc.math.Matrix4;
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLLoadIdentity();
                    p = cc.math.Matrix4.createPerspectiveProjection(60, b.width / b.height, 0.1, 2 * n);
                    cc.kmGLMultMatrix(p);
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLLoadIdentity();
                    n = new cc.math.Vec3(-g + b.width / 2, -h + b.height / 2, n);
                    b = new cc.math.Vec3(-g + b.width / 2, -h + b.height / 2, 0);
                    g = new cc.math.Vec3(0, 1, 0);
                    f.lookAt(n, b, g);
                    cc.kmGLMultMatrix(f);
                    break;
                case cc.Director.PROJECTION_CUSTOM:
                    this._projectionDelegate && this._projectionDelegate.updateProjection();
                    break;
                default:
                    cc.log(cc._LogInfos.Director_setProjection)
            }
            this._projection = a;
            cc.eventManager.dispatchEvent(this._eventProjectionChanged);
            cc.setProjectionMatrixDirty();
            cc.renderer.childrenOrderDirty = !0
        };
        a.setDepthTest = function (a) {
            cc.renderer.setDepthTest(a)
        };
        a.setClearColor = function (a) {
            cc.renderer._clearColor = a
        };
        a.setOpenGLView = function (a) {
            this._winSizeInPoints.width = cc._canvas.width;
            this._winSizeInPoints.height = cc._canvas.height;
            this._openGLView = a || cc.view;
            a = cc.configuration;
            a.gatherGPUInfo();
            a.dumpInfo();
            this.setGLDefaultValues();
            cc.eventManager && cc.eventManager.setEnabled(!0)
        };
        a._clear = function () {
            var a = cc._renderContext;
            a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
        };
        a._beforeVisitScene = function () {
            cc.kmGLPushMatrix()
        };
        a._afterVisitScene = function () {
            cc.kmGLPopMatrix()
        };
        a.convertToGL = function (a) {
            var b = new cc.math.Matrix4;
            cc.GLToClipTransform(b);
            var f = b.inverse(), b = b.mat[14] / b.mat[15], g = this._openGLView.getDesignResolutionSize();
            a = new cc.math.Vec3(2 * a.x / g.width - 1, 1 - 2 * a.y / g.height, b);
            a.transformCoord(f);
            return cc.p(a.x, a.y)
        };
        a.convertToUI = function (a) {
            var b = new cc.math.Matrix4;
            cc.GLToClipTransform(b);
            a = new cc.math.Vec3(a.x, a.y, 0);
            a.transformCoord(b);
            b = this._openGLView.getDesignResolutionSize();
            return cc.p(b.width * (0.5 * a.x + 0.5), b.height * (0.5 * -a.y + 0.5))
        };
        a.getVisibleSize = function () {
            return this._openGLView.getVisibleSize()
        };
        a.getVisibleOrigin = function () {
            return this._openGLView.getVisibleOrigin()
        };
        a.getZEye = function () {
            return this._winSizeInPoints.height / 1.1566
        };
        a.setViewport = function () {
            var a = this._openGLView;
            if (a) {
                var b = this._winSizeInPoints;
                a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, b.width, b.height)
            }
        };
        a.getOpenGLView = function () {
            return this._openGLView
        };
        a.getProjection = function () {
            return this._projection
        };
        a.setAlphaBlending = function (a) {
            a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
        };
        a.setGLDefaultValues = function () {
            this.setAlphaBlending(!0);
            this.setDepthTest(!1);
            this.setProjection(this._projection);
            cc._renderContext.clearColor(0,
                0, 0, 0)
        }
    }
});
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: !1,
    _lookupMatrix: null,
    ctor: function () {
        this._lookupMatrix = new cc.math.Matrix4;
        this.restore()
    },
    description: function () {
        return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
    },
    setDirty: function (a) {
        this._dirty = a
    },
    isDirty: function () {
        return this._dirty
    },
    restore: function () {
        this._eyeX = this._eyeY = 0;
        this._eyeZ = cc.Camera.getZEye();
        this._upX =
            this._centerX = this._centerY = this._centerZ = 0;
        this._upY = 1;
        this._upZ = 0;
        this._lookupMatrix.identity();
        this._dirty = !1
    },
    locate: function () {
        if (this._dirty) {
            var a = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ), b = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ), d = new cc.math.Vec3(this._upX, this._upY, this._upZ);
            this._lookupMatrix.lookAt(a, b, d);
            this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    _locateForRenderer: function (a) {
        if (this._dirty) {
            var b = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
                d = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ), e = new cc.math.Vec3(this._upX, this._upY, this._upZ);
            this._lookupMatrix.lookAt(b, d, e);
            this._dirty = !1
        }
        a.multiply(this._lookupMatrix)
    },
    setEyeXYZ: function (a, b, d) {
        this.setEye(a, b, d)
    },
    setEye: function (a, b, d) {
        this._eyeX = a;
        this._eyeY = b;
        this._eyeZ = d;
        this._dirty = !0
    },
    setCenterXYZ: function (a, b, d) {
        this.setCenter(a, b, d)
    },
    setCenter: function (a, b, d) {
        this._centerX = a;
        this._centerY = b;
        this._centerZ = d;
        this._dirty = !0
    },
    setUpXYZ: function (a, b, d) {
        this.setUp(a, b, d)
    },
    setUp: function (a, b, d) {
        this._upX = a;
        this._upY = b;
        this._upZ = d;
        this._dirty = !0
    },
    getEyeXYZ: function (a, b, d) {
        return {x: this._eyeX, y: this._eyeY, z: this._eyeZ}
    },
    getEye: function () {
        return {x: this._eyeX, y: this._eyeY, z: this._eyeZ}
    },
    getCenterXYZ: function (a, b, d) {
        return {x: this._centerX, y: this._centerY, z: this._centerZ}
    },
    getCenter: function () {
        return {x: this._centerX, y: this._centerY, z: this._centerZ}
    },
    getUpXYZ: function (a, b, d) {
        return {x: this._upX, y: this._upY, z: this._upZ}
    },
    getUp: function () {
        return {x: this._upX, y: this._upY, z: this._upZ}
    },
    _DISALLOW_COPY_AND_ASSIGN: function (a) {
    }
});
cc.Camera.getZEye = function () {
    return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function (a, b, d, e, f, g, h) {
    this.prev = a;
    this.next = b;
    this.callback = d;
    this.target = e;
    this.priority = f;
    this.paused = g;
    this.markedForDeletion = h
};
cc.HashUpdateEntry = function (a, b, d, e, f) {
    this.list = a;
    this.entry = b;
    this.target = d;
    this.callback = e;
    this.hh = f
};
cc.HashTimerEntry = cc.hashSelectorEntry = function (a, b, d, e, f, g, h) {
    this.timers = a;
    this.target = b;
    this.timerIndex = d;
    this.currentTimer = e;
    this.currentTimerSalvaged = f;
    this.paused = g;
    this.hh = h
};
cc.Timer = cc.Class.extend({
    _scheduler: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    _interval: 0,
    getInterval: function () {
        return this._interval
    },
    setInterval: function (a) {
        this._interval = a
    },
    setupTimerWithInterval: function (a, b, d) {
        this._elapsed = -1;
        this._interval = a;
        this._delay = d;
        this._useDelay = 0 < this._delay;
        this._repeat = b;
        this._runForever = this._repeat === cc.REPEAT_FOREVER
    },
    trigger: function () {
        return 0
    },
    cancel: function () {
        return 0
    },
    ctor: function () {
        this._scheduler = null;
        this._elapsed = -1;
        this._useDelay = this._runForever = !1;
        this._interval = this._delay = this._repeat = this._timesExecuted = 0
    },
    update: function (a) {
        -1 === this._elapsed ? this._timesExecuted = this._elapsed = 0 : (this._elapsed += a, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted +=
            1), !this._runForever && this._timesExecuted > this._repeat && this.cancel()))
    }
});
cc.TimerTargetSelector = cc.Timer.extend({
    _target: null, _selector: null, ctor: function () {
        this._selector = this._target = null
    }, initWithSelector: function (a, b, d, e, f, g) {
        this._scheduler = a;
        this._target = d;
        this._selector = b;
        this.setupTimerWithInterval(e, f, g);
        return !0
    }, getSelector: function () {
        return this._selector
    }, trigger: function () {
        this._target && this._selector && this._target.call(this._selector, this._elapsed)
    }, cancel: function () {
        this._scheduler.unschedule(this._selector, this._target)
    }
});
cc.TimerTargetCallback = cc.Timer.extend({
    _target: null, _callback: null, _key: null, ctor: function () {
        this._callback = this._target = null
    }, initWithCallback: function (a, b, d, e, f, g, h) {
        this._scheduler = a;
        this._target = d;
        this._callback = b;
        this._key = e;
        this.setupTimerWithInterval(f, g, h);
        return !0
    }, getCallback: function () {
        return this._callback
    }, getKey: function () {
        return this._key
    }, trigger: function () {
        this._callback && this._callback.call(this._target, this._elapsed)
    }, cancel: function () {
        this._scheduler.unschedule(this._callback,
            this._target)
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updatesNegList: null,
    _updates0List: null,
    _updatesPosList: null,
    _hashForTimers: null,
    _arrayForTimers: null,
    _hashForUpdates: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function () {
        this._timeScale = 1;
        this._updatesNegList = [];
        this._updates0List = [];
        this._updatesPosList = [];
        this._hashForUpdates = {};
        this._hashForTimers = {};
        this._currentTarget = null;
        this._updateHashLocked = this._currentTargetSalvaged = !1;
        this._arrayForTimers = []
    },
    _schedulePerFrame: function (a,
                                 b, d, e) {
        var f = this._hashForUpdates[b.__instanceId];
        if (f && f.entry)if (f.entry.priority !== d) {
            if (this._updateHashLocked) {
                cc.log("warning: you CANNOT change update priority in scheduled function");
                f.entry.markedForDeletion = !1;
                f.entry.paused = e;
                return
            }
            this.unscheduleUpdate(b)
        } else {
            f.entry.markedForDeletion = !1;
            f.entry.paused = e;
            return
        }
        0 === d ? this._appendIn(this._updates0List, a, b, e) : 0 > d ? this._priorityIn(this._updatesNegList, a, b, d, e) : this._priorityIn(this._updatesPosList, a, b, d, e)
    },
    _removeHashElement: function (a) {
        delete this._hashForTimers[a.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, a);
        a.Timer = null;
        a.target = null
    },
    _removeUpdateFromHash: function (a) {
        if (a = this._hashForUpdates[a.target.__instanceId])cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], a.entry = null, a.target = null
    },
    _priorityIn: function (a, b, d, e, f) {
        b = new cc.ListEntry(null, null, b, d, e, f, !1);
        if (a) {
            f = a.length - 1;
            for (var g = 0; g <= f && !(e < a[g].priority); g++);
            a.splice(g, 0, b)
        } else a = [], a.push(b);
        this._hashForUpdates[d.__instanceId] = new cc.HashUpdateEntry(a,
            b, d, null);
        return a
    },
    _appendIn: function (a, b, d, e) {
        b = new cc.ListEntry(null, null, b, d, 0, e, !1);
        a.push(b);
        this._hashForUpdates[d.__instanceId] = new cc.HashUpdateEntry(a, b, d, null, null)
    },
    setTimeScale: function (a) {
        this._timeScale = a
    },
    getTimeScale: function () {
        return this._timeScale
    },
    update: function (a) {
        this._updateHashLocked = !0;
        1 !== this._timeScale && (a *= this._timeScale);
        var b, d, e, f;
        b = 0;
        d = this._updatesNegList;
        for (e = d.length; b < e; b++)f = d[b], f.paused || f.markedForDeletion || f.callback(a);
        b = 0;
        d = this._updates0List;
        for (e =
                 d.length; b < e; b++)f = d[b], f.paused || f.markedForDeletion || f.callback(a);
        b = 0;
        d = this._updatesPosList;
        for (e = d.length; b < e; b++)f = d[b], f.paused || f.markedForDeletion || f.callback(a);
        e = this._arrayForTimers;
        for (b = 0; b < e.length; b++) {
            this._currentTarget = d = e[b];
            this._currentTargetSalvaged = !1;
            if (!d.paused)for (d.timerIndex = 0; d.timerIndex < d.timers.length; ++d.timerIndex)d.currentTimer = d.timers[d.timerIndex], d.currentTimerSalvaged = !1, d.currentTimer.update(a), d.currentTimer = null;
            this._currentTargetSalvaged && 0 === this._currentTarget.timers.length &&
            this._removeHashElement(this._currentTarget)
        }
        b = 0;
        for (d = this._updatesNegList; b < d.length;)f = d[b], f.markedForDeletion ? this._removeUpdateFromHash(f) : b++;
        b = 0;
        for (d = this._updates0List; b < d.length;)f = d[b], f.markedForDeletion ? this._removeUpdateFromHash(f) : b++;
        b = 0;
        for (d = this._updatesPosList; b < d.length;)f = d[b], f.markedForDeletion ? this._removeUpdateFromHash(f) : b++;
        this._updateHashLocked = !1;
        this._currentTarget = null
    },
    scheduleCallbackForTarget: function (a, b, d, e, f, g) {
        this.schedule(b, a, d, e, f, g, a.__instanceId + "")
    },
    schedule: function (a, b, d, e, f, g, h) {
        var n = !1;
        if ("function" !== typeof a)var p = a, n = !0;
        if (!1 === n) {
            if (4 === arguments.length || 5 === arguments.length)h = f, g = e, f = 0, e = cc.REPEAT_FOREVER
        } else 4 === arguments.length && (g = e, e = cc.REPEAT_FOREVER, f = 0);
        void 0 === h && (h = b.__instanceId + "");
        cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        var r = this._hashForTimers[b.__instanceId];
        r ? cc.assert(r.paused === g, "") : (r = new cc.HashTimerEntry(null, b, 0, null, null, g, null), this._arrayForTimers.push(r), this._hashForTimers[b.__instanceId] =
            r);
        var s, t;
        if (null == r.timers)r.timers = []; else if (!1 === n)for (t = 0; t < r.timers.length; t++) {
            if (s = r.timers[t], a === s._callback) {
                cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, s.getInterval().toFixed(4), d.toFixed(4));
                s._interval = d;
                return
            }
        } else for (t = 0; t < r.timers.length; ++t)if ((s = r.timers[t]) && p === s.getSelector()) {
            cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", s.getInterval(), d);
            s.setInterval(d);
            return
        }
        !1 === n ? (s = new cc.TimerTargetCallback, s.initWithCallback(this,
            a, b, h, d, e, f)) : (s = new cc.TimerTargetSelector, s.initWithSelector(this, p, b, d, e, f));
        r.timers.push(s)
    },
    scheduleUpdate: function (a, b, d) {
        this._schedulePerFrame(function (b) {
            a.update(b)
        }, a, b, d)
    },
    _getUnscheduleMark: function (a, b) {
        switch (typeof a) {
            case "number":
            case "string":
                return a === b.getKey();
            case "function":
                return a === b._callback;
            default:
                return a === b.getSelector()
        }
    },
    unschedule: function (a, b) {
        if (b && a) {
            var d = this._hashForTimers[b.__instanceId];
            if (d)for (var e = d.timers, f = 0, g = e.length; f < g; f++) {
                var h = e[f];
                if (this._getUnscheduleMark(a,
                        h)) {
                    h !== d.currentTimer || d.currentTimerSalvaged || (d.currentTimerSalvaged = !0);
                    e.splice(f, 1);
                    d.timerIndex >= f && d.timerIndex--;
                    0 === e.length && (this._currentTarget === d ? this._currentTargetSalvaged = !0 : this._removeHashElement(d));
                    break
                }
            }
        }
    },
    unscheduleUpdate: function (a) {
        null != a && (a = this._hashForUpdates[a.__instanceId]) && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry))
    },
    unscheduleAllForTarget: function (a) {
        if (null != a) {
            var b = this._hashForTimers[a.__instanceId];
            b && (-1 < b.timers.indexOf(b.currentTimer) && !b.currentTimerSalvaged && (b.currentTimerSalvaged = !0), b.timers.length = 0, this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b));
            this.unscheduleUpdate(a)
        }
    },
    unscheduleAll: function () {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllWithMinPriority: function (a) {
        var b, d, e = this._arrayForTimers;
        for (b = e.length - 1; 0 <= b; b--)d = e[b], this.unscheduleAllForTarget(d.target);
        e = 0;
        if (0 > a)for (b = 0; b < this._updatesNegList.length;)e = this._updatesNegList.length, (d = this._updatesNegList[b]) &&
        d.priority >= a && this.unscheduleUpdate(d.target), e == this._updatesNegList.length && b++;
        if (0 >= a)for (b = 0; b < this._updates0List.length;)e = this._updates0List.length, (d = this._updates0List[b]) && this.unscheduleUpdate(d.target), e == this._updates0List.length && b++;
        for (b = 0; b < this._updatesPosList.length;)e = this._updatesPosList.length, (d = this._updatesPosList[b]) && d.priority >= a && this.unscheduleUpdate(d.target), e == this._updatesPosList.length && b++
    },
    isScheduled: function (a, b) {
        cc.assert(a, "Argument key must not be empty");
        cc.assert(b, "Argument target must be non-nullptr");
        var d = this._hashForUpdates[b.__instanceId];
        if (!d)return !1;
        if (null != d.timers)for (var d = d.timers, e = 0; e < d.length; ++e)if (a === d[e].getKey())return !0;
        return !1
    },
    pauseAllTargets: function () {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function (a) {
        var b = [], d, e = this._arrayForTimers, f, g;
        f = 0;
        for (g = e.length; f < g; f++)if (d = e[f])d.paused = !0, b.push(d.target);
        if (0 > a)for (f = 0; f < this._updatesNegList.length; f++)(d =
            this._updatesNegList[f]) && d.priority >= a && (d.paused = !0, b.push(d.target));
        if (0 >= a)for (f = 0; f < this._updates0List.length; f++)if (d = this._updates0List[f])d.paused = !0, b.push(d.target);
        for (f = 0; f < this._updatesPosList.length; f++)(d = this._updatesPosList[f]) && d.priority >= a && (d.paused = !0, b.push(d.target));
        return b
    },
    resumeTargets: function (a) {
        if (a)for (var b = 0; b < a.length; b++)this.resumeTarget(a[b])
    },
    pauseTarget: function (a) {
        cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
        var b = this._hashForTimers[a.__instanceId];
        b &&
        (b.paused = !0);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !0)
    },
    resumeTarget: function (a) {
        cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !1);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !1)
    },
    isTargetPaused: function (a) {
        cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
        var b = this._hashForTimers[a.__instanceId];
        return b ? b.paused : (a = this._hashForUpdates[a.__instanceId]) ? a.entry.paused : !1
    },
    scheduleUpdateForTarget: function (a,
                                       b, d) {
        this.scheduleUpdate(a, b, d)
    },
    unscheduleCallbackForTarget: function (a, b) {
        this.unschedule(b, a)
    },
    unscheduleUpdateForTarget: function (a) {
        this.unscheduleUpdate(a)
    },
    unscheduleAllCallbacksForTarget: function (a) {
        this.unschedule(a.__instanceId + "", a)
    },
    unscheduleAllCallbacks: function () {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function (a) {
        this.unscheduleAllWithMinPriority(a)
    }
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [], _renderContext: null, ctor: function (a) {
        this._renderContext = a
    }, drawPoint: function (a, b) {
        b || (b = 1);
        var d = cc.view.getScaleX(), e = cc.view.getScaleY(), e = cc.p(a.x * d, a.y * e), f = this._renderContext.getContext();
        f.beginPath();
        f.arc(e.x, -e.y, b * d, 0, 2 * Math.PI, !1);
        f.closePath();
        f.fill()
    }, drawPoints: function (a, b, d) {
        if (null != a) {
            d || (d = 1);
            b = this._renderContext.getContext();
            var e = cc.view.getScaleX(), f = cc.view.getScaleY();
            b.beginPath();
            for (var g = 0, h = a.length; g < h; g++)b.arc(a[g].x *
                e, -a[g].y * f, d * e, 0, 2 * Math.PI, !1);
            b.closePath();
            b.fill()
        }
    }, drawLine: function (a, b) {
        var d = this._renderContext.getContext(), e = cc.view.getScaleX(), f = cc.view.getScaleY();
        d.beginPath();
        d.moveTo(a.x * e, -a.y * f);
        d.lineTo(b.x * e, -b.y * f);
        d.closePath();
        d.stroke()
    }, drawRect: function (a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    }, drawSolidRect: function (a, b, d) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x,
            b.y)];
        this.drawSolidPoly(a, 4, d)
    }, drawPoly: function (a, b, d, e) {
        e = e || !1;
        if (null != a) {
            if (3 > a.length)throw Error("Polygon's point must greater than 2");
            var f = a[0];
            b = this._renderContext.getContext();
            var g = cc.view.getScaleX(), h = cc.view.getScaleY();
            b.beginPath();
            b.moveTo(f.x * g, -f.y * h);
            for (var f = 1, n = a.length; f < n; f++)b.lineTo(a[f].x * g, -a[f].y * h);
            d && b.closePath();
            e ? b.fill() : b.stroke()
        }
    }, drawSolidPoly: function (a, b, d) {
        this.setDrawColor(d.r, d.g, d.b, d.a);
        this.drawPoly(a, b, !0, !0)
    }, drawCircle: function (a, b, d, e, f) {
        f =
            f || !1;
        e = this._renderContext.getContext();
        var g = cc.view.getScaleX(), h = cc.view.getScaleY();
        e.beginPath();
        e.arc(0 | a.x * g, 0 | -(a.y * h), b * g, -d, -(d - 2 * Math.PI), !1);
        f && e.lineTo(0 | a.x * g, 0 | -(a.y * h));
        e.stroke()
    }, drawQuadBezier: function (a, b, d, e) {
        for (var f = this._cacheArray, g = f.length = 0, h = 0; h < e; h++) {
            var n = Math.pow(1 - g, 2) * a.x + 2 * (1 - g) * g * b.x + g * g * d.x, p = Math.pow(1 - g, 2) * a.y + 2 * (1 - g) * g * b.y + g * g * d.y;
            f.push(cc.p(n, p));
            g += 1 / e
        }
        f.push(cc.p(d.x, d.y));
        this.drawPoly(f, e + 1, !1, !1)
    }, drawCubicBezier: function (a, b, d, e, f) {
        for (var g = this._cacheArray,
                 h = g.length = 0, n = 0; n < f; n++) {
            var p = Math.pow(1 - h, 3) * a.x + 3 * Math.pow(1 - h, 2) * h * b.x + 3 * (1 - h) * h * h * d.x + h * h * h * e.x, r = Math.pow(1 - h, 3) * a.y + 3 * Math.pow(1 - h, 2) * h * b.y + 3 * (1 - h) * h * h * d.y + h * h * h * e.y;
            g.push(cc.p(p, r));
            h += 1 / f
        }
        g.push(cc.p(e.x, e.y));
        this.drawPoly(g, f + 1, !1, !1)
    }, drawCatmullRom: function (a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    }, drawCardinalSpline: function (a, b, d) {
        cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
        var e = this._cacheArray;
        e.length = 0;
        for (var f, g, h = 1 / a.length, n = 0; n < d + 1; n++)g = n / d, 1 === g ? (f = a.length - 1,
            g = 1) : (f = 0 | g / h, g = (g - h * f) / h), f = cc.CardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f - 0), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g), e.push(f);
        this.drawPoly(e, d + 1, !1, !1)
    }, drawImage: function (a, b, d, e, f) {
        var g = arguments.length, h = this._renderContext.getContext();
        switch (g) {
            case 2:
                h.drawImage(a, b.x, -(b.y + a.height));
                break;
            case 3:
                h.drawImage(a, b.x, -(b.y + d.height), d.width, d.height);
                break;
            case 5:
                h.drawImage(a, b.x, b.y, d.width, d.height, e.x, -(e.y + f.height), f.width, f.height);
                break;
            default:
                throw Error("Argument must be non-nil");
        }
    }, drawStar: function (a, b, d) {
        a = a || this._renderContext;
        var e = a.getContext();
        b *= cc.view.getScaleX();
        d = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b);
        a.setFillStyle(d + ",1)");
        var f = b / 10;
        e.beginPath();
        e.moveTo(-b, b);
        e.lineTo(0, f);
        e.lineTo(b, b);
        e.lineTo(f, 0);
        e.lineTo(b, -b);
        e.lineTo(0, -f);
        e.lineTo(-b, -b);
        e.lineTo(-f, 0);
        e.lineTo(-b, b);
        e.closePath();
        e.fill();
        var g = e.createRadialGradient(0, 0, f, 0, 0, b);
        g.addColorStop(0, d + ", 1)");
        g.addColorStop(0.3, d + ", 0.8)");
        g.addColorStop(1,
            d + ", 0.0)");
        a.setFillStyle(g);
        e.beginPath();
        e.arc(0, 0, b - f, 0, cc.PI2, !1);
        e.closePath();
        e.fill()
    }, drawColorBall: function (a, b, d) {
        a = a || this._renderContext;
        var e = a.getContext();
        b *= cc.view.getScaleX();
        d = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b);
        var f = e.createRadialGradient(0, 0, b / 10, 0, 0, b);
        f.addColorStop(0, d + ", 1)");
        f.addColorStop(0.3, d + ", 0.8)");
        f.addColorStop(0.6, d + ", 0.4)");
        f.addColorStop(1, d + ", 0.0)");
        a.setFillStyle(f);
        e.beginPath();
        e.arc(0, 0, b, 0, cc.PI2, !1);
        e.closePath();
        e.fill()
    }, fillText: function (a, b,
                           d) {
        this._renderContext.getContext().fillText(a, b, -d)
    }, setDrawColor: function (a, b, d, e) {
        this._renderContext.setFillStyle("rgba(" + a + "," + b + "," + d + "," + e / 255 + ")");
        this._renderContext.setStrokeStyle("rgba(" + a + "," + b + "," + d + "," + e / 255 + ")")
    }, setPointSize: function (a) {
    }, setLineWidth: function (a) {
        this._renderContext.getContext().lineWidth = a * cc.view.getScaleX()
    }
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: "u_color",
    _colorArray: null,
    _pointSizeLocation: "u_pointSize",
    _pointSize: -1,
    ctor: function (a) {
        null == a && (a = cc._renderContext);
        if (!a instanceof WebGLRenderingContext)throw Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
        this._renderContext = a;
        this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function () {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
            this._shader._addUniformLocation(this._colorLocation), this._shader._addUniformLocation(this._pointSizeLocation), this._initialized = !0)
    },
    drawInit: function () {
        this._initialized = !1
    },
    drawPoint: function (a) {
        this.lazy_init();
        var b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation,
            this._pointSize);
        var d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d);
        b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.POINTS, 0, 1);
        b.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawPoints: function (a, b) {
        if (a && 0 !== a.length) {
            this.lazy_init();
            var d = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            d.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
            this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var e = d.createBuffer();
            d.bindBuffer(d.ARRAY_BUFFER, e);
            d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray(a), d.STATIC_DRAW);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, 0);
            d.drawArrays(d.POINTS, 0, a.length);
            d.deleteBuffer(e);
            cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function (a) {
        for (var b = new Float32Array(2 * a.length), d = 0; d < a.length; d++)b[2 *
        d] = a[d].x, b[2 * d + 1] = a[d].y;
        return b
    },
    drawLine: function (a, b) {
        this.lazy_init();
        var d = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        d.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var e = d.createBuffer();
        d.bindBuffer(d.ARRAY_BUFFER, e);
        d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), d.STATIC_DRAW);
        d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT,
            !1, 0, 0);
        d.drawArrays(d.LINES, 0, 2);
        d.deleteBuffer(e);
        cc.incrementGLDraws(1)
    },
    drawRect: function (a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function (a, b, d) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(a, 4, d)
    },
    drawPoly: function (a, b, d) {
        this.lazy_init();
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var e = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, e);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        d ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length);
        b.deleteBuffer(e);
        cc.incrementGLDraws(1)
    },
    drawSolidPoly: function (a, b, d) {
        this.lazy_init();
        d && this.setDrawColor(d.r,
            d.g, d.b, d.a);
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.TRIANGLE_FAN, 0, a.length);
        b.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawCircle: function (a, b, d, e, f) {
        this.lazy_init();
        var g = 1;
        f && g++;
        var h = 2 * Math.PI / e;
        if (f = new Float32Array(2 * (e + 2))) {
            for (var n = 0; n <= e; n++) {
                var p = n * h, r = b * Math.cos(p + d) + a.x, p = b * Math.sin(p + d) + a.y;
                f[2 * n] = r;
                f[2 * n + 1] = p
            }
            f[2 * (e + 1)] = a.x;
            f[2 * (e + 1) + 1] = a.y;
            a = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
            this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
            b = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER,
                b);
            a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
            a.drawArrays(a.LINE_STRIP, 0, e + g);
            a.deleteBuffer(b);
            cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function (a, b, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++)f[2 * h] = Math.pow(1 - g, 2) * a.x + 2 * (1 - g) * g * b.x + g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 2) * a.y + 2 * (1 - g) * g * b.y + g * g * d.y, g += 1 / e;
        f[2 * e] = d.x;
        f[2 * e + 1] = d.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, e + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCubicBezier: function (a, b, d, e, f) {
        this.lazy_init();
        for (var g = new Float32Array(2 * (f + 1)), h = 0, n = 0; n < f; n++)g[2 * n] = Math.pow(1 - h, 3) * a.x + 3 * Math.pow(1 -
                h, 2) * h * b.x + 3 * (1 - h) * h * h * d.x + h * h * h * e.x, g[2 * n + 1] = Math.pow(1 - h, 3) * a.y + 3 * Math.pow(1 - h, 2) * h * b.y + 3 * (1 - h) * h * h * d.y + h * h * h * e.y, h += 1 / f;
        g[2 * f] = e.x;
        g[2 * f + 1] = e.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, g, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, f + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCatmullRom: function (a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function (a, b, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f, g, h = 1 / a.length, n = 0; n < d + 1; n++)g = n / d, 1 === g ? (f = a.length - 1, g = 1) : (f = 0 | g / h, g = (g - h * f) / h), f = cc.cardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g), e[2 * n] = f.x, e[2 * n + 1] = f.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, d + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    setDrawColor: function (a, b, d, e) {
        this._colorArray[0] =
            a / 255;
        this._colorArray[1] = b / 255;
        this._colorArray[2] = d / 255;
        this._colorArray[3] = e / 255
    },
    setPointSize: function (a) {
        this._pointSize = a * cc.contentScaleFactor()
    },
    setLineWidth: function (a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
});
cc._tmp.PrototypeLabelTTF = function () {
    var a = cc.LabelTTF.prototype;
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "string", a.getString, a.setString);
    cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
    cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
    cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
    cc.defineGetterSetter(a,
        "fontName", a.getFontName, a.setFontName);
    cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
    cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
    cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
    cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
    cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
    cc.defineGetterSetter(a, "shadowOffsetX",
        a._getShadowOffsetX, a._setShadowOffsetX);
    cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
    cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
    cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _onCacheCanvasMode: !0,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColor: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _textFillColor: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _lineWidths: null,
    _className: "LabelTTF",
    _fontStyle: "normal",
    _fontWeight: "normal",
    _lineHeight: "normal",
    initWithString: function (a, b, d, e, f, g) {
        a = a ? a + "" : "";
        d = d || 16;
        e = e || cc.size(0, 0);
        f = f || cc.TEXT_ALIGNMENT_LEFT;
        g = g || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._dimensions = cc.size(e.width, e.height);
        this._fontName = b || "Arial";
        this._hAlignment = f;
        this._vAlignment = g;
        this._fontSize = d;
        this._renderCmd._setFontStyle(this._fontName, d, this._fontStyle, this._fontWeight);
        this.string = a;
        this._renderCmd._setColorsString();
        this._renderCmd._updateTexture();
        this._setUpdateTextureDirty();
        return !0
    },
    _setUpdateTextureDirty: function () {
        this._needUpdateTexture = !0;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
    },
    ctor: function (a, b, d, e, f, g) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontName = "Arial";
        this._shadowEnabled = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur = this._shadowOpacity = 0;
        this._strokeEnabled = !1;
        this._strokeColor = cc.color(255,
            255, 255, 255);
        this._strokeSize = 0;
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._renderCmd._setColorsString();
        this._textureLoaded = !0;
        b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this, a, b, d, e, f, g)
    },
    init: function () {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    description: function () {
        return "\x3ccc.LabelTTF | FontName \x3d" +
            this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) + "\x3e"
    },
    getLineHeight: function () {
        return !this._lineHeight || this._lineHeight.charAt ? this._renderCmd._getFontClientHeight() : this._lineHeight || this._renderCmd._getFontClientHeight()
    },
    setLineHeight: function (a) {
        this._lineHeight = a
    },
    getString: function () {
        return this._string
    },
    getHorizontalAlignment: function () {
        return this._hAlignment
    },
    getVerticalAlignment: function () {
        return this._vAlignment
    },
    getDimensions: function () {
        return cc.size(this._dimensions)
    },
    getFontSize: function () {
        return this._fontSize
    },
    getFontName: function () {
        return this._fontName
    },
    initWithStringAndTextDefinition: function (a, b) {
        this._updateWithTextDefinition(b, !1);
        this.string = a;
        return !0
    },
    setTextDefinition: function (a) {
        a && this._updateWithTextDefinition(a, !0)
    },
    getTextDefinition: function () {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function (a, b, d, e) {
        null != a.r && null != a.g && null != a.b && null != a.a ? this._enableShadow(a, b, d) : this._enableShadowNoneColor(a, b, d, e)
    },
    _enableShadowNoneColor: function (a,
                                      b, d, e) {
        d = d || 0.5;
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var f = this._shadowOffset;
        if (f && f.x !== a || f._y !== b)f.x = a, f.y = b;
        this._shadowOpacity !== d && (this._shadowOpacity = d);
        this._renderCmd._setColorsString();
        this._shadowBlur !== e && (this._shadowBlur = e);
        this._setUpdateTextureDirty()
    },
    _enableShadow: function (a, b, d) {
        this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128));
        this._shadowColor.r = a.r;
        this._shadowColor.g = a.g;
        this._shadowColor.b = a.b;
        this._enableShadowNoneColor(b.width || b.x || 0, b.height ||
            b.y || 0, null != a.a ? a.a / 255 : 0.5, d)
    },
    _getShadowOffsetX: function () {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset.x !== a && (this._shadowOffset.x = a, this._setUpdateTextureDirty())
    },
    _getShadowOffsetY: function () {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset._y !== a && (this._shadowOffset._y = a, this._setUpdateTextureDirty())
    },
    _getShadowOffset: function () {
        return cc.p(this._shadowOffset.x,
            this._shadowOffset.y)
    },
    _setShadowOffset: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x !== a.x || this._shadowOffset.y !== a.y)this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._setUpdateTextureDirty()
    },
    _getShadowOpacity: function () {
        return this._shadowOpacity
    },
    _setShadowOpacity: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOpacity !== a && (this._shadowOpacity = a, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
    },
    _getShadowBlur: function () {
        return this._shadowBlur
    },
    _setShadowBlur: function (a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowBlur !== a && (this._shadowBlur = a, this._setUpdateTextureDirty())
    },
    disableShadow: function () {
        this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
    },
    enableStroke: function (a, b) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var d = this._strokeColor;
        if (d.r !== a.r || d.g !== a.g || d.b !== a.b)d.r = a.r, d.g = a.g, d.b = a.b, this._renderCmd._setColorsString();
        this._strokeSize !== b && (this._strokeSize = b || 0);
        this._setUpdateTextureDirty()
    },
    _getStrokeStyle: function () {
        return this._strokeColor
    },
    _setStrokeStyle: function (a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var b = this._strokeColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b)b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty()
    },
    _getLineWidth: function () {
        return this._strokeSize
    },
    _setLineWidth: function (a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        this._strokeSize !== a && (this._strokeSize = a || 0, this._setUpdateTextureDirty())
    },
    disableStroke: function () {
        this._strokeEnabled &&
        (this._strokeEnabled = !1, this._setUpdateTextureDirty())
    },
    setFontFillColor: function (a) {
        var b = this._textFillColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b)b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0
    },
    _getFillStyle: function () {
        return this._textFillColor
    },
    _updateWithTextDefinition: function (a, b) {
        a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
        this._hAlignment = a.textAlign;
        this._vAlignment = a.verticalAlign;
        this._fontName = a.fontName;
        this._fontSize = a.fontSize || 12;
        this._lineHeight = a.lineHeight ? a.lineHeight : this._fontSize;
        this._renderCmd._setFontStyle(a);
        a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
        a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
        this.setFontFillColor(a.fillStyle);
        b && this._renderCmd._updateTexture();
        var d = cc.Node._dirtyFlags;
        this._renderCmd.setDirtyFlag(d.colorDirty | d.opacityDirty | d.textDirty)
    },
    _prepareTextDefinition: function (a) {
        var b = new cc.FontDefinition;
        a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height);
        b.fontName = this._fontName;
        b.textAlign = this._hAlignment;
        b.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            b.strokeEnabled = !0;
            var d = this._strokeColor;
            b.strokeStyle = cc.color(d.r,
                d.g, d.b);
            b.lineWidth = this._strokeSize
        } else b.strokeEnabled = !1;
        this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
        a = this._textFillColor;
        b.fillStyle = cc.color(a.r, a.g, a.b);
        return b
    },
    setString: function (a) {
        a = String(a);
        this._originalText !== a && (this._originalText = a + "", this._updateString(), this._setUpdateTextureDirty(),
            this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    _updateString: function () {
        this._string && "" !== this._string || this._string === this._originalText || (cc.renderer.childrenOrderDirty = !0);
        this._string = this._originalText
    },
    setHorizontalAlignment: function (a) {
        a !== this._hAlignment && (this._hAlignment = a, this._setUpdateTextureDirty())
    },
    setVerticalAlignment: function (a) {
        a !== this._vAlignment && (this._vAlignment = a, this._setUpdateTextureDirty())
    },
    setDimensions: function (a, b) {
        var d;
        void 0 === b ? (d = a.width,
            b = a.height) : d = a;
        if (d !== this._dimensions.width || b !== this._dimensions.height)this._dimensions.width = d, this._dimensions.height = b, this._updateString(), this._setUpdateTextureDirty()
    },
    _getBoundingWidth: function () {
        return this._dimensions.width
    },
    _setBoundingWidth: function (a) {
        a !== this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._setUpdateTextureDirty())
    },
    _getBoundingHeight: function () {
        return this._dimensions.height
    },
    _setBoundingHeight: function (a) {
        a !== this._dimensions.height && (this._dimensions.height =
            a, this._updateString(), this._setUpdateTextureDirty())
    },
    setFontSize: function (a) {
        this._fontSize !== a && (this._fontSize = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    setFontName: function (a) {
        this._fontName && this._fontName !== a && (this._fontName = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFont: function () {
        return this._renderCmd._getFontStyle()
    },
    _setFont: function (a) {
        if (a = cc.LabelTTF._fontStyleRE.exec(a))this._fontSize = parseInt(a[1]), this._fontName = a[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty()
    },
    getContentSize: function () {
        this._needUpdateTexture && this._renderCmd._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function () {
        this._needUpdateTexture && this._renderCmd._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function () {
        this._needUpdateTexture &&
        this._renderCmd._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this)
    },
    setTextureRect: function (a, b, d) {
        cc.Sprite.prototype.setTextureRect.call(this, a, b, d, !1)
    },
    setDrawMode: function (a) {
        this._onCacheCanvasMode = a
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelTTF.WebGLRenderCmd(this) : this._onCacheCanvasMode ? new cc.LabelTTF.CacheCanvasRenderCmd(this) : new cc.LabelTTF.CanvasRenderCmd(this)
    },
    _setFontStyle: function (a) {
        this._fontStyle !== a && (this._fontStyle =
            a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFontStyle: function () {
        return this._fontStyle
    },
    _setFontWeight: function (a) {
        this._fontWeight !== a && (this._fontWeight = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFontWeight: function () {
        return this._fontWeight
    }
});
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function (a, b, d, e, f, g) {
    return new cc.LabelTTF(a, b, d, e, f, g)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = document.createElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : window.addEventListener("load", function () {
    this.removeEventListener("load", arguments.callee, !1);
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function (a, b) {
    if (a instanceof cc.FontDefinition) {
        var d = cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()];
        if (0 < d)return d;
        var e = cc.LabelTTF.__labelHeightDiv;
        e.innerHTML = "ajghl~!";
        e.style.fontFamily = a.fontName;
        e.style.fontSize = a.fontSize + "px";
        e.style.fontStyle = a.fontStyle;
        e.style.fontWeight = a.fontWeight;
        d = e.clientHeight;
        cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()] = d;
        e.innerHTML = "";
        return d
    }
    d = cc.LabelTTF.__fontHeightCache[a + "." + b];
    if (0 < d)return d;
    e = cc.LabelTTF.__labelHeightDiv;
    e.innerHTML = "ajghl~!";
    e.style.fontFamily = a;
    e.style.fontSize = b + "px";
    d = e.clientHeight;
    cc.LabelTTF.__fontHeightCache[a + "." + b] = d;
    e.innerHTML = "";
    return d
};
cc.LabelTTF.__fontHeightCache = {};
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/;
(function () {
    cc.LabelTTF.RenderCmd = function () {
        this._fontClientHeight = 18;
        this._fontStyleStr = "";
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeColorStr = "";
        this._fillColorStr = "rgba(255,255,255,1)";
        this._labelContext = this._labelCanvas = null;
        this._lineWidths = [];
        this._strings = [];
        this._isMultiLine = !1;
        this._status = [];
        this._renderingIndex = 0
    };
    var a = cc.LabelTTF.RenderCmd.prototype;
    a.constructor = cc.LabelTTF.RenderCmd;
    a._setFontStyle = function (a, d, e, f) {
        a instanceof cc.FontDefinition ? (this._fontStyleStr =
            a._getCanvasFontStr(), this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a)) : (this._fontStyleStr = e + " " + f + " " + d + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, d))
    };
    a._getFontStyle = function () {
        return this._fontStyleStr
    };
    a._getFontClientHeight = function () {
        return this._fontClientHeight
    };
    a._updateColor = function () {
        this._setColorsString();
        this._updateTexture()
    };
    a._setColorsString = function () {
        var a = this._displayedColor, d = this._node, e = d._shadowColor || this._displayedColor, f = d._strokeColor,
            g = d._textFillColor, h = a.r / 255, n = a.g / 255, a = a.b / 255;
        this._shadowColorStr = "rgba(" + (0 | h * e.r) + "," + (0 | n * e.g) + "," + (0 | a * e.b) + "," + d._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | h * g.r) + "," + (0 | n * g.g) + "," + (0 | a * g.b) + ", 1)";
        this._strokeColorStr = "rgba(" + (0 | h * f.r) + "," + (0 | n * f.g) + "," + (0 | a * f.b) + ", 1)"
    };
    a._updateTTF = function () {
        var a = this._node, d = a._dimensions.width, e, f, g = this._lineWidths;
        g.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (0 !== d)for (this._strings = a._string.split("\n"), e = 0; e < this._strings.length; e++)this._checkWarp(this._strings,
            e, d); else for (this._strings = a._string.split("\n"), e = 0, f = this._strings.length; e < f; e++)g.push(this._measure(this._strings[e]));
        1 < this._strings.length && (this._isMultiLine = !0);
        f = e = 0;
        a._strokeEnabled && (e = f = 2 * a._strokeSize);
        if (a._shadowEnabled) {
            var h = a._shadowOffset;
            e += 2 * Math.abs(h.x);
            f += 2 * Math.abs(h.y)
        }
        d = 0 === d ? this._isMultiLine ? cc.size(Math.ceil(Math.max.apply(Math, g) + e), Math.ceil(this._fontClientHeight * this._strings.length + f)) : cc.size(Math.ceil(this._measure(a._string) + e), Math.ceil(this._fontClientHeight +
            f)) : 0 === a._dimensions.height ? this._isMultiLine ? cc.size(Math.ceil(d + e), Math.ceil(a.getLineHeight() * this._strings.length + f)) : cc.size(Math.ceil(d + e), Math.ceil(a.getLineHeight() + f)) : cc.size(Math.ceil(d + e), Math.ceil(a._dimensions.height + f));
        "normal" !== a._getFontStyle() && (d.width = Math.ceil(d.width + 0.3 * a._fontSize));
        a.setContentSize(d);
        a._strokeShadowOffsetX = e;
        a._strokeShadowOffsetY = f;
        a = a._anchorPoint;
        this._anchorPointInPoints.x = 0.5 * e + (d.width - e) * a.x;
        this._anchorPointInPoints.y = 0.5 * f + (d.height - f) * a.y
    };
    a._saveStatus =
        function () {
            var a = this._node, d = a._strokeShadowOffsetX, e = a._strokeShadowOffsetY, f = a._contentSize.height - e, g = a._vAlignment, h = a._hAlignment, n = 0.5 * d, e = f + 0.5 * e, p = 0, r = 0, s = [], t = a._contentSize.width - d, a = a.getLineHeight(), d = (a - this._fontClientHeight) / 2, p = h === cc.TEXT_ALIGNMENT_RIGHT ? p + t : h === cc.TEXT_ALIGNMENT_CENTER ? p + t / 2 : p + 0;
            if (this._isMultiLine)for (h = this._strings.length, g === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? r = a - 2 * d + f - a * h : g === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (r = (a - 2 * d) / 2 + (f - a * h) / 2), g = 0; g < h; g++)s.push(-f +
                (a * g + d) + r); else g !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (r = g === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? r - f : r - 0.5 * f), s.push(r);
            f = {contextTransform: cc.p(n, e), xOffset: p, OffsetYArray: s};
            this._status.push(f)
        };
    a._drawTTFInCanvas = function (a) {
        if (a) {
            var d = this._status.pop();
            a.setTransform(1, 0, 0, 1, d.contextTransform.x, d.contextTransform.y);
            this.drawLabels(a, d.xOffset, d.OffsetYArray)
        }
    };
    a._checkWarp = function (a, d, e) {
        var f = a[d], g = this._measure(f);
        if (g > e && 1 < f.length) {
            for (var h = e / g * f.length | 0, n = f.substr(h), p = g - this._measure(n),
                     r, s = 0, t = 0; p > e && 100 > t++;)h *= e / p, h |= 0, n = f.substr(h), p = g - this._measure(n);
            for (t = 0; p < e && 100 > t++;)n && (s = (r = cc.LabelTTF._wordRex.exec(n)) ? r[0].length : 1, r = n), h += s, n = f.substr(h), p = g - this._measure(n);
            h -= s;
            0 === h && (h = 1, r = r.substr(1));
            e = f.substr(0, h);
            cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(r || n) && (g = cc.LabelTTF._lastWordRex.exec(e), h -= g ? g[0].length : 0, 0 === h && (h = 1), r = f.substr(h), e = f.substr(0, h));
            cc.LabelTTF._firsrEnglish.test(r) && (g = cc.LabelTTF._lastEnglish.exec(e)) && e !== g[0] && (h -= g[0].length, r =
                f.substr(h), e = f.substr(0, h));
            a[d] = r || n;
            a.splice(d, 0, e)
        }
    };
    a.updateStatus = function () {
        var a = cc.Node._dirtyFlags, d = this._dirtyFlag;
        cc.Node.RenderCmd.prototype.updateStatus.call(this);
        d & a.textDirty && this._updateTexture();
        this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    };
    a._syncStatus = function (a) {
        var d = cc.Node._dirtyFlags, e = this._dirtyFlag;
        cc.Node.RenderCmd.prototype._syncStatus.call(this, a);
        e & d.textDirty &&
        this._updateTexture();
        (cc._renderType === cc.game.RENDER_TYPE_WEBGL || e & d.transformDirty) && this.transform(a)
    };
    a.drawLabels = function (a, d, e) {
        var f = this._node;
        if (f._shadowEnabled) {
            var g = f._shadowOffset;
            a.shadowColor = this._shadowColorStr;
            a.shadowOffsetX = g.x;
            a.shadowOffsetY = -g.y;
            a.shadowBlur = f._shadowBlur
        }
        var g = f._hAlignment, h = f._vAlignment, n = f._strokeSize;
        a.font !== this._fontStyleStr && (a.font = this._fontStyleStr);
        a.fillStyle = this._fillColorStr;
        if (f = f._strokeEnabled)a.lineWidth = 2 * n, a.strokeStyle = this._strokeColorStr;
        a.textBaseline = cc.LabelTTF._textBaseline[h];
        a.textAlign = cc.LabelTTF._textAlign[g];
        g = this._strings.length;
        for (h = 0; h < g; h++)n = this._strings[h], f && a.strokeText(n, d, e[h]), a.fillText(n, d, e[h]);
        cc.g_NumberOfDraws++
    }
})();
(function () {
    cc.LabelTTF.CacheRenderCmd = function (a) {
        cc.LabelTTF.RenderCmd.call(this, a);
        a = this._labelCanvas = document.createElement("canvas");
        a.width = 1;
        a.height = 1;
        this._labelContext = a.getContext("2d")
    };
    cc.LabelTTF.CacheRenderCmd.prototype = Object.create(cc.LabelTTF.RenderCmd.prototype);
    cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CacheRenderCmd.prototype);
    var a = cc.LabelTTF.CacheRenderCmd.prototype;
    a.constructor = cc.LabelTTF.CacheRenderCmd;
    a._updateTexture = function () {
        this._dirtyFlag ^= this._dirtyFlag &
            cc.Node._dirtyFlags.textDirty;
        var a = this._node, d = a._contentSize;
        this._updateTTF();
        var e = d.width, f = d.height, g = this._labelContext, h = this._labelCanvas;
        if (!a._texture) {
            var n = new cc.Texture2D;
            n.initWithElement(this._labelCanvas);
            a.setTexture(n)
        }
        if (0 === a._string.length)return h.width = 1, h.height = d.height || 1, a._texture && a._texture.handleLoadedTexture(), a.setTextureRect(cc.rect(0, 0, 1, d.height)), !0;
        g.font = this._fontStyleStr;
        d = h.width === e && h.height === f;
        h.width = e;
        h.height = f;
        d && g.clearRect(0, 0, e, f);
        this._saveStatus();
        this._drawTTFInCanvas(g);
        a._texture && a._texture.handleLoadedTexture();
        a.setTextureRect(cc.rect(0, 0, e, f));
        return !0
    };
    a._measureConfig = function () {
        this._labelContext.font = this._fontStyleStr
    };
    a._measure = function (a) {
        return this._labelContext.measureText(a).width
    }
})();
(function () {
    cc.LabelTTF.CacheCanvasRenderCmd = function (a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        cc.LabelTTF.CacheRenderCmd.call(this)
    };
    var a = cc.LabelTTF.CacheCanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, a);
    a.constructor = cc.LabelTTF.CacheCanvasRenderCmd
})();
(function () {
    cc.LabelTTF.CanvasRenderCmd = function (a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        cc.LabelTTF.RenderCmd.call(this)
    };
    cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
    var a = cc.LabelTTF.CanvasRenderCmd.prototype;
    a.constructor = cc.LabelTTF.CanvasRenderCmd;
    a._measureConfig = function () {
    };
    a._measure = function (a) {
        var d = cc._renderContext.getContext();
        d.font = this._fontStyleStr;
        return d.measureText(a).width
    };
    a._updateTexture = function () {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
        var a = this._node, d = a._contentSize;
        this._updateTTF();
        var e = d.width, f = d.height;
        if (0 === a._string.length)return a.setTextureRect(cc.rect(0, 0, 1, d.height)), !0;
        this._saveStatus();
        a.setTextureRect(cc.rect(0, 0, e, f));
        return !0
    };
    a.rendering = function (a) {
        var d = cc.view.getScaleX(), e = cc.view.getScaleY();
        a = a || cc._renderContext;
        var f = a.getContext();
        if (f) {
            var g = this._node;
            a.computeRealOffsetY();
            if (!(0 >= this._status.length)) {
                var h =
                    this._renderingIndex >= this._status.length ? this._renderingIndex - this._status.length : this._renderingIndex, n = this._status[h];
                this._renderingIndex = h + 1;
                var p = g._offsetPosition.x, h = -g._offsetPosition.y - g._rect.height, r = this._displayedOpacity / 255;
                a.setTransform(this._worldTransform, d, e);
                a.setCompositeOperation(this._blendFuncStr);
                a.setGlobalAlpha(r);
                a.save();
                g._flippedX && (p = -p - g._rect.width, f.scale(-1, 1));
                g._flippedY && (h = g._offsetPosition.y, f.scale(1, -1));
                d = n.xOffset + n.contextTransform.x + p * d;
                g = [];
                p = this._strings.length;
                for (r = 0; r < p; r++)g.push(n.OffsetYArray[r] + n.contextTransform.y + h * e);
                this.drawLabels(f, d, g);
                a.restore()
            }
        }
    }
})();
(function () {
    cc.LabelTTF.WebGLRenderCmd = function (a) {
        cc.Sprite.WebGLRenderCmd.call(this, a);
        cc.LabelTTF.CacheRenderCmd.call(this);
        this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
    };
    var a = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    a._supportBatch = !1;
    cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, a);
    a.constructor = cc.LabelTTF.WebGLRenderCmd;
    a._updateColor = function () {
        this._updateTexture();
        cc.Sprite.WebGLRenderCmd.prototype._updateColor.call(this)
    }
})();
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function () {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = this.currentActionSalvaged = !1;
        this.hh = null
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function (a, b) {
        for (var d = 0; d < a.length; d++)if (b === a[d].target)return a[d];
        return null
    },
    ctor: function () {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = !1
    },
    addAction: function (a, b, d) {
        if (!a)throw Error("cc.ActionManager.addAction(): action must be non-null");
        if (!b)throw Error("cc.ActionManager.addAction(): action must be non-null");
        var e = this._hashTargets[b.__instanceId];
        e || (e = new cc.HashElement, e.paused = d, e.target = b, this._hashTargets[b.__instanceId] = e, this._arrayTargets.push(e));
        this._actionAllocWithHashElement(e);
        e.actions.push(a);
        a.startWithTarget(b)
    },
    removeAllActions: function () {
        for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
            var d = a[b];
            d && this.removeAllActionsFromTarget(d.target, !0)
        }
    },
    removeAllActionsFromTarget: function (a, b) {
        if (null != a) {
            var d = this._hashTargets[a.__instanceId];
            d && (-1 === d.actions.indexOf(d.currentAction) ||
            d.currentActionSalvaged || (d.currentActionSalvaged = !0), d.actions.length = 0, this._currentTarget !== d || b ? this._deleteHashElement(d) : this._currentTargetSalvaged = !0)
        }
    },
    removeAction: function (a) {
        if (null != a) {
            var b = a.getOriginalTarget();
            if (b = this._hashTargets[b.__instanceId])for (var d = 0; d < b.actions.length; d++) {
                if (b.actions[d] === a) {
                    b.actions.splice(d, 1);
                    break
                }
            } else cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function (a, b) {
        a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
        cc.assert(b, cc._LogInfos.ActionManager_addAction);
        var d = this._hashTargets[b.__instanceId];
        if (d)for (var e = d.actions.length, f = 0; f < e; ++f) {
            var g = d.actions[f];
            if (g && g.getTag() === a && g.getOriginalTarget() === b) {
                this._removeActionAtIndex(f, d);
                break
            }
        }
    },
    getActionByTag: function (a, b) {
        a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var d = this._hashTargets[b.__instanceId];
        if (d) {
            if (null != d.actions)for (var e = 0; e < d.actions.length; ++e) {
                var f = d.actions[e];
                if (f && f.getTag() === a)return f
            }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2,
                a)
        }
        return null
    },
    numberOfRunningActionsInTarget: function (a) {
        return (a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
    },
    pauseTarget: function (a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !0)
    },
    resumeTarget: function (a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !1)
    },
    pauseAllRunningActions: function () {
        for (var a = [], b = this._arrayTargets, d = 0; d < b.length; d++) {
            var e = b[d];
            e && !e.paused && (e.paused = !0, a.push(e.target))
        }
        return a
    },
    resumeTargets: function (a) {
        if (a)for (var b = 0; b < a.length; b++)a[b] &&
        this.resumeTarget(a[b])
    },
    purgeSharedManager: function () {
        cc.director.getScheduler().unscheduleUpdate(this)
    },
    _removeActionAtIndex: function (a, b) {
        b.actions[a] !== b.currentAction || b.currentActionSalvaged || (b.currentActionSalvaged = !0);
        b.actions.splice(a, 1);
        b.actionIndex >= a && b.actionIndex--;
        0 === b.actions.length && (this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    },
    _deleteHashElement: function (a) {
        var b = !1;
        a && (this._hashTargets[a.target.__instanceId] && (delete this._hashTargets[a.target.__instanceId],
            cc.arrayRemoveObject(this._arrayTargets, a), b = !0), a.actions = null, a.target = null);
        return b
    },
    _actionAllocWithHashElement: function (a) {
        null == a.actions && (a.actions = [])
    },
    update: function (a) {
        for (var b = this._arrayTargets, d, e = 0; e < b.length; e++) {
            d = this._currentTarget = b[e];
            if (!d.paused)for (d.actionIndex = 0; d.actionIndex < (d.actions ? d.actions.length : 0); d.actionIndex++)if (d.currentAction = d.actions[d.actionIndex], d.currentAction) {
                d.currentActionSalvaged = !1;
                d.currentAction.step(a * (d.currentAction._speedMethod ? d.currentAction._speed :
                        1));
                if (d.currentActionSalvaged)d.currentAction = null; else if (d.currentAction.isDone()) {
                    d.currentAction.stop();
                    var f = d.currentAction;
                    d.currentAction = null;
                    this.removeAction(f)
                }
                d.currentAction = null
            }
            this._currentTargetSalvaged && 0 === d.actions.length && this._deleteHashElement(d) && e--
        }
    }
});
cc.profiler = function () {
    var a = !1, b = !1, d = 0, e = 0, f = 0, g = 0, h = null, n = document.createElement("div"), p = document.createElement("div"), r = document.createElement("div"), s = document.createElement("div"), t = 10, v = [0, 10, 20, 30], u = [0, 0, 0, 0], x = 3, w = 0, y = 0;
    s.id = "fps";
    s.style.position = "absolute";
    s.style.padding = "3px";
    s.style.textAlign = "left";
    s.style.backgroundColor = "rgb(0, 0, 34)";
    s.style.bottom = cc.DIRECTOR_STATS_POSITION.y + "0px";
    s.style.left = cc.DIRECTOR_STATS_POSITION.x + "px";
    s.style.width = "45px";
    s.style.height = "60px";
    for (var A =
        [r, p, n], D = 0; 3 > D; ++D) {
        var G = A[D].style;
        G.color = "rgb(0, 255, 255)";
        G.font = "bold 12px Helvetica, Arial";
        G.lineHeight = "20px";
        G.width = "100%";
        s.appendChild(A[D])
    }
    var B = function () {
        f = cc.director.getSecondsPerFrame();
        d++;
        g += cc.director.getDeltaTime();
        if (g > cc.DIRECTOR_FPS_INTERVAL) {
            e = d / g;
            g = d = 0;
            if (C.onFrameRateChange) {
                var a = e, h = v.length - 1, s = h, A = 0;
                w++;
                for (y += a; 0 <= s; s--)if (a >= v[s]) {
                    u[s]++;
                    break
                }
                if (w >= t) {
                    A = y / t;
                    for (s = h; 0 < s; s--)if (a = u[s] / t, 0.6 <= a && A >= v[s]) {
                        s != x && (x = s, C.onFrameRateChange && C.onFrameRateChange(A.toFixed(2)));
                        break
                    }
                    y = w = _changeCount = 0;
                    for (s = h; 0 < s; s--)u[s] = 0
                }
            }
            b && (p.innerText = f.toFixed(3), n.innerText = e.toFixed(1), r.innerText = (0 | cc.g_NumberOfDraws).toString())
        }
    }, C = {
        onFrameRateChange: null, getSecondsPerFrame: function () {
            return f
        }, getFrameRate: function () {
            return e
        }, setProfileDuration: function (a) {
            !isNaN(a) && 0 < a && (t = a / cc.DIRECTOR_FPS_INTERVAL)
        }, resumeProfiling: function () {
            cc.eventManager.addListener(h, 1)
        }, stopProfiling: function () {
            cc.eventManager.removeListener(h)
        }, isShowingStats: function () {
            return b
        }, showStats: function () {
            a ||
            this.init();
            null === s.parentElement && cc.container.appendChild(s);
            b = !0
        }, hideStats: function () {
            b = !1;
            s.parentElement === cc.container && cc.container.removeChild(s)
        }, init: function () {
            a || (h = cc.eventManager.addCustomListener(cc.Director.EVENT_AFTER_VISIT, B), a = !0)
        }
    };
    return C
}();
cc.math = cc.math || {};
cc.math.EPSILON = 0.015625;
cc.math.square = function (a) {
    return a * a
};
cc.math.almostEqual = function (a, b) {
    return a + cc.math.EPSILON > b && a - cc.math.EPSILON < b
};
(function (a) {
    a.math.Vec2 = function (a, b) {
        void 0 === b ? (this.x = a.x, this.y = a.y) : (this.x = a || 0, this.y = b || 0)
    };
    var b = a.math.Vec2.prototype;
    b.fill = function (a, b) {
        this.x = a;
        this.y = b
    };
    b.length = function () {
        return Math.sqrt(a.math.square(this.x) + a.math.square(this.y))
    };
    b.lengthSq = function () {
        return a.math.square(this.x) + a.math.square(this.y)
    };
    b.normalize = function () {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        return this
    };
    a.math.Vec2.add = function (a, b, f) {
        a.x = b.x + f.x;
        a.y = b.y + f.y;
        return a
    };
    b.add = function (a) {
        this.x += a.x;
        this.y +=
            a.y;
        return this
    };
    b.dot = function (a) {
        return this.x * a.x + this.y * a.y
    };
    a.math.Vec2.subtract = function (a, b, f) {
        a.x = b.x - f.x;
        a.y = b.y - f.y;
        return a
    };
    b.subtract = function (a) {
        this.x -= a.x;
        this.y -= a.y;
        return this
    };
    b.transform = function (a) {
        var b = this.x, f = this.y;
        this.x = b * a.mat[0] + f * a.mat[3] + a.mat[6];
        this.y = b * a.mat[1] + f * a.mat[4] + a.mat[7];
        return this
    };
    a.math.Vec2.scale = function (a, b, f) {
        a.x = b.x * f;
        a.y = b.y * f;
        return a
    };
    b.scale = function (a) {
        this.x *= a;
        this.y *= a;
        return this
    };
    b.equals = function (b) {
        return this.x < b.x + a.math.EPSILON &&
            this.x > b.x - a.math.EPSILON && this.y < b.y + a.math.EPSILON && this.y > b.y - a.math.EPSILON
    }
})(cc);
(function (a) {
    a.math.Vec3 = a.kmVec3 = function (a, b, f) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a || 0, this.y = b || 0, this.z = f || 0)
    };
    a.math.vec3 = function (b, e, f) {
        return new a.math.Vec3(b, e, f)
    };
    var b = a.math.Vec3.prototype;
    b.fill = function (a, b, f) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a, this.y = b, this.z = f);
        return this
    };
    b.length = function () {
        return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z))
    };
    b.lengthSq = function () {
        return a.math.square(this.x) + a.math.square(this.y) +
            a.math.square(this.z)
    };
    b.normalize = function () {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    };
    b.cross = function (a) {
        var b = this.x, f = this.y, g = this.z;
        this.x = f * a.z - g * a.y;
        this.y = g * a.x - b * a.z;
        this.z = b * a.y - f * a.x;
        return this
    };
    b.dot = function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    };
    b.add = function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this
    };
    b.subtract = function (a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this
    };
    b.transform = function (a) {
        var b = this.x, f = this.y, g = this.z;
        a = a.mat;
        this.x = b *
            a[0] + f * a[4] + g * a[8] + a[12];
        this.y = b * a[1] + f * a[5] + g * a[9] + a[13];
        this.z = b * a[2] + f * a[6] + g * a[10] + a[14];
        return this
    };
    b.transformNormal = function (a) {
        var b = this.x, f = this.y, g = this.z;
        a = a.mat;
        this.x = b * a[0] + f * a[4] + g * a[8];
        this.y = b * a[1] + f * a[5] + g * a[9];
        this.z = b * a[2] + f * a[6] + g * a[10];
        return this
    };
    b.transformCoord = function (b) {
        var e = new a.math.Vec4(this.x, this.y, this.z, 1);
        e.transform(b);
        this.x = e.x / e.w;
        this.y = e.y / e.w;
        this.z = e.z / e.w;
        return this
    };
    b.scale = function (a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    };
    b.equals = function (b) {
        var e =
            a.math.EPSILON;
        return this.x < b.x + e && this.x > b.x - e && this.y < b.y + e && this.y > b.y - e && this.z < b.z + e && this.z > b.z - e
    };
    b.inverseTransform = function (b) {
        b = b.mat;
        var e = new a.math.Vec3(this.x - b[12], this.y - b[13], this.z - b[14]);
        this.x = e.x * b[0] + e.y * b[1] + e.z * b[2];
        this.y = e.x * b[4] + e.y * b[5] + e.z * b[6];
        this.z = e.x * b[8] + e.y * b[9] + e.z * b[10];
        return this
    };
    b.inverseTransformNormal = function (a) {
        var b = this.x, f = this.y, g = this.z;
        a = a.mat;
        this.x = b * a[0] + f * a[1] + g * a[2];
        this.y = b * a[4] + f * a[5] + g * a[6];
        this.z = b * a[8] + f * a[9] + g * a[10];
        return this
    };
    b.assignFrom =
        function (a) {
            if (!a)return this;
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        };
    a.math.Vec3.zero = function (a) {
        a.x = a.y = a.z = 0;
        return a
    };
    b.toTypeArray = function () {
        var a = new Float32Array(3);
        a[0] = this.x;
        a[1] = this.y;
        a[2] = this.z;
        return a
    }
})(cc);
(function (a) {
    a.math.Vec4 = function (a, b, f, g) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = f || 0, this.w = g || 0)
    };
    a.kmVec4 = a.math.Vec4;
    var b = a.math.Vec4.prototype;
    b.fill = function (a, b, f, g) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a, this.y = b, this.z = f, this.w = g)
    };
    b.add = function (a) {
        if (!a)return this;
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    };
    b.dot = function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    };
    b.length =
        function () {
            return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w))
        };
    b.lengthSq = function () {
        return a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w)
    };
    b.lerp = function (a, b) {
        return this
    };
    b.normalize = function () {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.scale = function (a) {
        this.normalize();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.subtract = function (a) {
        this.x -= a.x;
        this.y -=
            a.y;
        this.z -= a.z;
        this.w -= a.w
    };
    b.transform = function (a) {
        var b = this.x, f = this.y, g = this.z, h = this.w;
        a = a.mat;
        this.x = b * a[0] + f * a[4] + g * a[8] + h * a[12];
        this.y = b * a[1] + f * a[5] + g * a[9] + h * a[13];
        this.z = b * a[2] + f * a[6] + g * a[10] + h * a[14];
        this.w = b * a[3] + f * a[7] + g * a[11] + h * a[15];
        return this
    };
    a.math.Vec4.transformArray = function (b, e) {
        for (var f = [], g = 0; g < b.length; g++) {
            var h = new a.math.Vec4(b[g]);
            h.transform(e);
            f.push(h)
        }
        return f
    };
    b.equals = function (b) {
        var e = a.math.EPSILON;
        return this.x < b.x + e && this.x > b.x - e && this.y < b.y + e && this.y > b.y - e &&
            this.z < b.z + e && this.z > b.z - e && this.w < b.w + e && this.w > b.w - e
    };
    b.assignFrom = function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = a.w;
        return this
    };
    b.toTypeArray = function () {
        var a = new Float32Array(4);
        a[0] = this.x;
        a[1] = this.y;
        a[2] = this.z;
        a[3] = this.w;
        return a
    }
})(cc);
(function (a) {
    function b(b, e, f) {
        e = new a.math.Vec2(e);
        e.subtract(b);
        f.x = -e.y;
        f.y = e.x;
        f.normalize()
    }

    a.math.Ray2 = function (b, e) {
        this.start = b || new a.math.Vec2;
        this.dir = e || new a.math.Vec2
    };
    a.math.Ray2.prototype.fill = function (a, b, f, g) {
        this.start.x = a;
        this.start.y = b;
        this.dir.x = f;
        this.dir.y = g
    };
    a.math.Ray2.prototype.intersectLineSegment = function (b, e, f) {
        var g = this.start.x, h = this.start.y, n = this.start.x + this.dir.x, p = this.start.y + this.dir.y, r = b.x, s = b.y, t = e.x, v = e.y, u = (v - s) * (n - g) - (t - r) * (p - h);
        if (u > -a.math.EPSILON &&
            u < a.math.EPSILON)return !1;
        s = ((t - r) * (h - s) - (v - s) * (g - r)) / u;
        r = g + s * (n - g);
        s = h + s * (p - h);
        if (r < Math.min(b.x, e.x) - a.math.EPSILON || r > Math.max(b.x, e.x) + a.math.EPSILON || s < Math.min(b.y, e.y) - a.math.EPSILON || s > Math.max(b.y, e.y) + a.math.EPSILON || r < Math.min(g, n) - a.math.EPSILON || r > Math.max(g, n) + a.math.EPSILON || s < Math.min(h, p) - a.math.EPSILON || s > Math.max(h, p) + a.math.EPSILON)return !1;
        f.x = r;
        f.y = s;
        return !0
    };
    a.math.Ray2.prototype.intersectTriangle = function (d, e, f, g, h) {
        var n = new a.math.Vec2, p = new a.math.Vec2, r = new a.math.Vec2,
            s = 1E4, t = !1, v;
        this.intersectLineSegment(d, e, n) && (t = !0, v = n.subtract(this.start).length(), v < s && (p.x = n.x, p.y = n.y, s = v, b(d, e, r)));
        this.intersectLineSegment(e, f, n) && (t = !0, v = n.subtract(this.start).length(), v < s && (p.x = n.x, p.y = n.y, s = v, b(e, f, r)));
        this.intersectLineSegment(f, d, n) && (t = !0, v = n.subtract(this.start).length(), v < s && (p.x = n.x, p.y = n.y, b(f, d, r)));
        t && (g.x = p.x, g.y = p.y, h && (h.x = r.x, h.y = r.y));
        return t
    }
})(cc);
window.Uint16Array = window.Uint16Array || window.Array;
window.Float32Array = window.Float32Array || window.Array;
(function (a) {
    a.math.Matrix3 = function (a) {
        this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(9)
    };
    a.kmMat3 = a.math.Matrix3;
    var b = a.math.Matrix3.prototype;
    b.fill = function (a) {
        var b = this.mat;
        a = a.mat;
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        return this
    };
    b.adjugate = function () {
        var a = this.mat, b = a[0], d = a[1], h = a[2], n = a[3], p = a[4], r = a[5], s = a[6], t = a[7], v = a[8];
        a[0] = p * v - r * t;
        a[1] = h * t - d * v;
        a[2] = d * r - h * p;
        a[3] = r * s - n * v;
        a[4] = b * v - h * s;
        a[5] = h * n - b * r;
        a[6] = n * t - p * s;
        a[8] = b *
            p - d * n;
        return this
    };
    b.identity = function () {
        var a = this.mat;
        a[1] = a[2] = a[3] = a[5] = a[6] = a[7] = 0;
        a[0] = a[4] = a[8] = 1;
        return this
    };
    var d = new a.math.Matrix3;
    b.inverse = function (a) {
        if (0 === a)return this;
        d.assignFrom(this);
        a = 1 / a;
        this.adjugate();
        this.multiplyScalar(a);
        return this
    };
    b.isIdentity = function () {
        var a = this.mat;
        return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 1 === a[4] && 0 === a[5] && 0 === a[6] && 0 === a[7] && 1 === a[8]
    };
    b.transpose = function () {
        var a = this.mat, b = a[1], d = a[2], h = a[5], n = a[6], p = a[7];
        a[1] = a[3];
        a[2] = n;
        a[3] = b;
        a[5] =
            p;
        a[6] = d;
        a[7] = h;
        return this
    };
    b.determinant = function () {
        var a = this.mat, b = a[0] * a[4] * a[8] + a[1] * a[5] * a[6] + a[2] * a[3] * a[7];
        return b -= a[2] * a[4] * a[6] + a[0] * a[5] * a[7] + a[1] * a[3] * a[8]
    };
    b.multiply = function (a) {
        var b = this.mat, d = a.mat;
        a = b[0];
        var h = b[1], n = b[2], p = b[3], r = b[4], s = b[5], t = b[6], v = b[7], u = b[8], x = d[0], w = d[1], y = d[2], A = d[3], D = d[4], G = d[5], B = d[6], C = d[7], d = d[8];
        b[0] = a * x + p * w + t * y;
        b[1] = h * x + r * w + v * y;
        b[2] = n * x + s * w + u * y;
        b[3] = n * x + s * w + u * y;
        b[4] = h * A + r * D + v * G;
        b[5] = n * A + s * D + u * G;
        b[6] = a * B + p * C + t * d;
        b[7] = h * B + r * C + v * d;
        b[8] = n * B + s * C + u * d;
        return this
    };
    b.multiplyScalar = function (a) {
        var b = this.mat;
        b[0] *= a;
        b[1] *= a;
        b[2] *= a;
        b[3] *= a;
        b[4] *= a;
        b[5] *= a;
        b[6] *= a;
        b[7] *= a;
        b[8] *= a;
        return this
    };
    a.math.Matrix3.rotationAxisAngle = function (b, d) {
        var g = Math.cos(d), h = Math.sin(d), n = new a.math.Matrix3, p = n.mat;
        p[0] = g + b.x * b.x * (1 - g);
        p[1] = b.z * h + b.y * b.x * (1 - g);
        p[2] = -b.y * h + b.z * b.x * (1 - g);
        p[3] = -b.z * h + b.x * b.y * (1 - g);
        p[4] = g + b.y * b.y * (1 - g);
        p[5] = b.x * h + b.z * b.y * (1 - g);
        p[6] = b.y * h + b.x * b.z * (1 - g);
        p[7] = -b.x * h + b.y * b.z * (1 - g);
        p[8] = g + b.z * b.z * (1 - g);
        return n
    };
    b.assignFrom = function (b) {
        if (this ===
            b)return a.log("cc.math.Matrix3.assign(): current matrix equals matIn"), this;
        var d = this.mat;
        b = b.mat;
        d[0] = b[0];
        d[1] = b[1];
        d[2] = b[2];
        d[3] = b[3];
        d[4] = b[4];
        d[5] = b[5];
        d[6] = b[6];
        d[7] = b[7];
        d[8] = b[8];
        return this
    };
    b.equals = function (b) {
        if (this === b)return !0;
        var d = a.math.EPSILON, g = this.mat;
        b = b.mat;
        for (var h = 0; 9 > h; ++h)if (!(g[h] + d > b[h] && g[h] - d < b[h]))return !1;
        return !0
    };
    a.math.Matrix3.createByRotationX = function (b) {
        var d = new a.math.Matrix3, g = d.mat;
        g[0] = 1;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = Math.cos(b);
        g[5] = Math.sin(b);
        g[6] = 0;
        g[7] = -Math.sin(b);
        g[8] = Math.cos(b);
        return d
    };
    a.math.Matrix3.createByRotationY = function (b) {
        var d = new a.math.Matrix3, g = d.mat;
        g[0] = Math.cos(b);
        g[1] = 0;
        g[2] = -Math.sin(b);
        g[3] = 0;
        g[4] = 1;
        g[5] = 0;
        g[6] = Math.sin(b);
        g[7] = 0;
        g[8] = Math.cos(b);
        return d
    };
    a.math.Matrix3.createByRotationZ = function (b) {
        var d = new a.math.Matrix3, g = d.mat;
        g[0] = Math.cos(b);
        g[1] = -Math.sin(b);
        g[2] = 0;
        g[3] = Math.sin(b);
        g[4] = Math.cos(b);
        g[5] = 0;
        g[6] = 0;
        g[7] = 0;
        g[8] = 1;
        return d
    };
    a.math.Matrix3.createByRotation = function (b) {
        var d = new a.math.Matrix3, g = d.mat;
        g[0] = Math.cos(b);
        g[1] = Math.sin(b);
        g[2] = 0;
        g[3] = -Math.sin(b);
        g[4] = Math.cos(b);
        g[5] = 0;
        g[6] = 0;
        g[7] = 0;
        g[8] = 1;
        return d
    };
    a.math.Matrix3.createByScale = function (b, d) {
        var g = new a.math.Matrix3;
        g.identity();
        g.mat[0] = b;
        g.mat[4] = d;
        return g
    };
    a.math.Matrix3.createByTranslation = function (b, d) {
        var g = new a.math.Matrix3;
        g.identity();
        g.mat[6] = b;
        g.mat[7] = d;
        return g
    };
    a.math.Matrix3.createByQuaternion = function (b) {
        if (!b)return null;
        var d = new a.math.Matrix3, g = d.mat;
        g[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
        g[1] = 2 * (b.x * b.y - b.w * b.z);
        g[2] = 2 *
            (b.x * b.z + b.w * b.y);
        g[3] = 2 * (b.x * b.y + b.w * b.z);
        g[4] = 1 - 2 * (b.x * b.x + b.z * b.z);
        g[5] = 2 * (b.y * b.z - b.w * b.x);
        g[6] = 2 * (b.x * b.z - b.w * b.y);
        g[7] = 2 * (b.y * b.z + b.w * b.x);
        g[8] = 1 - 2 * (b.x * b.x + b.y * b.y);
        return d
    };
    b.rotationToAxisAngle = function () {
        return a.math.Quaternion.rotationMatrix(this).toAxisAndAngle()
    }
})(cc);
(function (a) {
    a.math.Matrix4 = function (a) {
        this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(16)
    };
    a.kmMat4 = a.math.Matrix4;
    var b = a.math.Matrix4.prototype;
    b.fill = function (a) {
        for (var b = this.mat, d = 0; 16 > d; d++)b[d] = a[d];
        return this
    };
    a.kmMat4Identity = function (a) {
        var b = a.mat;
        b[1] = b[2] = b[3] = b[4] = b[6] = b[7] = b[8] = b[9] = b[11] = b[12] = b[13] = b[14] = 0;
        b[0] = b[5] = b[10] = b[15] = 1;
        return a
    };
    b.identity = function () {
        var a = this.mat;
        a[1] = a[2] = a[3] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[12] = a[13] = a[14] = 0;
        a[0] = a[5] = a[10] = a[15] = 1;
        return this
    };
    b.get = function (a, b) {
        return this.mat[a + 4 * b]
    };
    b.set = function (a, b, d) {
        this.mat[a + 4 * b] = d
    };
    b.swap = function (a, b, d, e) {
        var p = this.mat, r = p[a + 4 * b];
        p[a + 4 * b] = p[d + 4 * e];
        p[d + 4 * e] = r
    };
    a.math.Matrix4._gaussj = function (a, b) {
        var d, e = 0, p = 0, r, s, t, v, u = [0, 0, 0, 0], x = [0, 0, 0, 0], w = [0, 0, 0, 0];
        for (d = 0; 4 > d; d++) {
            for (r = v = 0; 4 > r; r++)if (1 !== w[r])for (s = 0; 4 > s; s++)0 === w[s] && (t = Math.abs(a.get(r, s)), t >= v && (v = t, p = r, e = s));
            ++w[e];
            if (p !== e) {
                for (r = 0; 4 > r; r++)a.swap(p, r, e, r);
                for (r = 0; 4 > r; r++)b.swap(p, r, e, r)
            }
            x[d] = p;
            u[d] = e;
            if (0 === a.get(e,
                    e))return !1;
            s = 1 / a.get(e, e);
            a.set(e, e, 1);
            for (r = 0; 4 > r; r++)a.set(e, r, a.get(e, r) * s);
            for (r = 0; 4 > r; r++)b.set(e, r, b.get(e, r) * s);
            for (s = 0; 4 > s; s++)if (s !== e) {
                t = a.get(s, e);
                a.set(s, e, 0);
                for (r = 0; 4 > r; r++)a.set(s, r, a.get(s, r) - a.get(e, r) * t);
                for (r = 0; 4 > r; r++)b.set(s, r, a.get(s, r) - b.get(e, r) * t)
            }
        }
        for (r = 3; 0 <= r; r--)if (x[r] !== u[r])for (s = 0; 4 > s; s++)a.swap(s, x[r], s, u[r]);
        return !0
    };
    var d = (new a.math.Matrix4).identity();
    a.kmMat4Inverse = function (b, e) {
        var h = new a.math.Matrix4(e), n = new a.math.Matrix4(d);
        if (!1 === a.math.Matrix4._gaussj(h,
                n))return null;
        b.assignFrom(h);
        return b
    };
    b.inverse = function () {
        var b = new a.math.Matrix4(this), e = new a.math.Matrix4(d);
        return !1 === a.math.Matrix4._gaussj(b, e) ? null : b
    };
    b.isIdentity = function () {
        var a = this.mat;
        return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 0 === a[4] && 1 === a[5] && 0 === a[6] && 0 === a[7] && 0 === a[8] && 0 === a[9] && 1 === a[10] && 0 === a[11] && 0 === a[12] && 0 === a[13] && 0 === a[14] && 1 === a[15]
    };
    b.transpose = function () {
        var a = this.mat, b = a[1], d = a[2], e = a[3], p = a[6], r = a[7], s = a[8], t = a[9], v = a[11], u = a[12], x = a[13], w = a[14];
        a[1] = a[4];
        a[2] = s;
        a[3] = u;
        a[4] = b;
        a[6] = t;
        a[7] = x;
        a[8] = d;
        a[9] = p;
        a[11] = w;
        a[12] = e;
        a[13] = r;
        a[14] = v;
        return this
    };
    a.kmMat4Multiply = function (a, b, d) {
        var e = a.mat, p = b.mat, r = d.mat;
        d = p[0];
        b = p[1];
        var s = p[2], t = p[3], v = p[4], u = p[5], x = p[6], w = p[7], y = p[8], A = p[9], D = p[10], G = p[11], B = p[12], C = p[13], E = p[14], p = p[15], I = r[0], L = r[1], J = r[2], Q = r[3], M = r[4], K = r[5], H = r[6], P = r[7], U = r[8], O = r[9], Y = r[10], V = r[11], F = r[12], N = r[13], W = r[14], r = r[15];
        e[0] = I * d + L * v + J * y + Q * B;
        e[1] = I * b + L * u + J * A + Q * C;
        e[2] = I * s + L * x + J * D + Q * E;
        e[3] = I * t + L * w + J * G + Q * p;
        e[4] = M * d + K * v + H * y + P * B;
        e[5] =
            M * b + K * u + H * A + P * C;
        e[6] = M * s + K * x + H * D + P * E;
        e[7] = M * t + K * w + H * G + P * p;
        e[8] = U * d + O * v + Y * y + V * B;
        e[9] = U * b + O * u + Y * A + V * C;
        e[10] = U * s + O * x + Y * D + V * E;
        e[11] = U * t + O * w + Y * G + V * p;
        e[12] = F * d + N * v + W * y + r * B;
        e[13] = F * b + N * u + W * A + r * C;
        e[14] = F * s + N * x + W * D + r * E;
        e[15] = F * t + N * w + W * G + r * p;
        return a
    };
    b.multiply = function (a) {
        var b = this.mat, d = a.mat;
        a = b[0];
        var e = b[1], p = b[2], r = b[3], s = b[4], t = b[5], v = b[6], u = b[7], x = b[8], w = b[9], y = b[10], A = b[11], D = b[12], G = b[13], B = b[14], C = b[15], E = d[0], I = d[1], L = d[2], J = d[3], Q = d[4], M = d[5], K = d[6], H = d[7], P = d[8], U = d[9], O = d[10], Y = d[11], V = d[12],
            F = d[13], N = d[14], d = d[15];
        b[0] = E * a + I * s + L * x + J * D;
        b[1] = E * e + I * t + L * w + J * G;
        b[2] = E * p + I * v + L * y + J * B;
        b[3] = E * r + I * u + L * A + J * C;
        b[4] = Q * a + M * s + K * x + H * D;
        b[5] = Q * e + M * t + K * w + H * G;
        b[6] = Q * p + M * v + K * y + H * B;
        b[7] = Q * r + M * u + K * A + H * C;
        b[8] = P * a + U * s + O * x + Y * D;
        b[9] = P * e + U * t + O * w + Y * G;
        b[10] = P * p + U * v + O * y + Y * B;
        b[11] = P * r + U * u + O * A + Y * C;
        b[12] = V * a + F * s + N * x + d * D;
        b[13] = V * e + F * t + N * w + d * G;
        b[14] = V * p + F * v + N * y + d * B;
        b[15] = V * r + F * u + N * A + d * C;
        return this
    };
    a.getMat4MultiplyValue = function (a, b) {
        var d = a.mat, e = b.mat, p = new Float32Array(16);
        p[0] = d[0] * e[0] + d[4] * e[1] + d[8] * e[2] + d[12] * e[3];
        p[1] = d[1] * e[0] + d[5] * e[1] + d[9] * e[2] + d[13] * e[3];
        p[2] = d[2] * e[0] + d[6] * e[1] + d[10] * e[2] + d[14] * e[3];
        p[3] = d[3] * e[0] + d[7] * e[1] + d[11] * e[2] + d[15] * e[3];
        p[4] = d[0] * e[4] + d[4] * e[5] + d[8] * e[6] + d[12] * e[7];
        p[5] = d[1] * e[4] + d[5] * e[5] + d[9] * e[6] + d[13] * e[7];
        p[6] = d[2] * e[4] + d[6] * e[5] + d[10] * e[6] + d[14] * e[7];
        p[7] = d[3] * e[4] + d[7] * e[5] + d[11] * e[6] + d[15] * e[7];
        p[8] = d[0] * e[8] + d[4] * e[9] + d[8] * e[10] + d[12] * e[11];
        p[9] = d[1] * e[8] + d[5] * e[9] + d[9] * e[10] + d[13] * e[11];
        p[10] = d[2] * e[8] + d[6] * e[9] + d[10] * e[10] + d[14] * e[11];
        p[11] = d[3] * e[8] + d[7] * e[9] + d[11] *
            e[10] + d[15] * e[11];
        p[12] = d[0] * e[12] + d[4] * e[13] + d[8] * e[14] + d[12] * e[15];
        p[13] = d[1] * e[12] + d[5] * e[13] + d[9] * e[14] + d[13] * e[15];
        p[14] = d[2] * e[12] + d[6] * e[13] + d[10] * e[14] + d[14] * e[15];
        p[15] = d[3] * e[12] + d[7] * e[13] + d[11] * e[14] + d[15] * e[15];
        return p
    };
    a.kmMat4Assign = function (b, d) {
        if (b === d)return a.log("cc.kmMat4Assign(): pOut equals pIn"), b;
        var e = b.mat, n = d.mat;
        e[0] = n[0];
        e[1] = n[1];
        e[2] = n[2];
        e[3] = n[3];
        e[4] = n[4];
        e[5] = n[5];
        e[6] = n[6];
        e[7] = n[7];
        e[8] = n[8];
        e[9] = n[9];
        e[10] = n[10];
        e[11] = n[11];
        e[12] = n[12];
        e[13] = n[13];
        e[14] = n[14];
        e[15] = n[15];
        return b
    };
    b.assignFrom = function (b) {
        if (this === b)return a.log("cc.mat.Matrix4.assignFrom(): mat4 equals current matrix"), this;
        var d = this.mat;
        b = b.mat;
        d[0] = b[0];
        d[1] = b[1];
        d[2] = b[2];
        d[3] = b[3];
        d[4] = b[4];
        d[5] = b[5];
        d[6] = b[6];
        d[7] = b[7];
        d[8] = b[8];
        d[9] = b[9];
        d[10] = b[10];
        d[11] = b[11];
        d[12] = b[12];
        d[13] = b[13];
        d[14] = b[14];
        d[15] = b[15];
        return this
    };
    b.equals = function (b) {
        if (this === b)return a.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
        var d = this.mat;
        b = b.mat;
        for (var e = a.math.EPSILON, n = 0; 16 >
        n; n++)if (!(d[n] + e > b[n] && d[n] - e < b[n]))return !1;
        return !0
    };
    a.math.Matrix4.createByRotationX = function (b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = 1;
        e[3] = e[2] = e[1] = 0;
        e[4] = 0;
        e[5] = Math.cos(b);
        e[6] = Math.sin(b);
        e[7] = 0;
        e[8] = 0;
        e[9] = -Math.sin(b);
        e[10] = Math.cos(b);
        e[11] = 0;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByRotationY = function (b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = Math.cos(b);
        e[1] = 0;
        e[2] = -Math.sin(b);
        e[3] = 0;
        e[7] = e[6] = e[4] = 0;
        e[5] = 1;
        e[8] = Math.sin(b);
        e[9] = 0;
        e[10] = Math.cos(b);
        e[11] =
            0;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByRotationZ = function (b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = Math.cos(b);
        e[1] = Math.sin(b);
        e[3] = e[2] = 0;
        e[4] = -Math.sin(b);
        e[5] = Math.cos(b);
        e[7] = e[6] = 0;
        e[11] = e[9] = e[8] = 0;
        e[10] = 1;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByPitchYawRoll = function (b, d, e, n) {
        n = n || new a.math.Matrix4;
        var p = Math.cos(b);
        b = Math.sin(b);
        var r = Math.cos(d);
        d = Math.sin(d);
        var s = Math.cos(e);
        e = Math.sin(e);
        var t = b * d, v = p * d, u = n.mat;
        u[0] = r * s;
        u[4] = r * e;
        u[8] = -d;
        u[1] = t * s - p * e;
        u[5] = t * e + p * s;
        u[9] = b * r;
        u[2] = v * s + b * e;
        u[6] = v * e - b * s;
        u[10] = p * r;
        u[3] = u[7] = u[11] = 0;
        u[15] = 1;
        return n
    };
    a.math.Matrix4.createByQuaternion = function (b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
        e[1] = 2 * (b.x * b.y + b.z * b.w);
        e[2] = 2 * (b.x * b.z - b.y * b.w);
        e[3] = 0;
        e[4] = 2 * (b.x * b.y - b.z * b.w);
        e[5] = 1 - 2 * (b.x * b.x + b.z * b.z);
        e[6] = 2 * (b.z * b.y + b.x * b.w);
        e[7] = 0;
        e[8] = 2 * (b.x * b.z + b.y * b.w);
        e[9] = 2 * (b.y * b.z - b.x * b.w);
        e[10] = 1 - 2 * (b.x * b.x + b.y * b.y);
        e[11] = 0;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByRotationTranslation =
        function (b, d, e) {
            e = e || new a.math.Matrix4;
            var n = e.mat;
            b = b.mat;
            n[0] = b[0];
            n[1] = b[1];
            n[2] = b[2];
            n[3] = 0;
            n[4] = b[3];
            n[5] = b[4];
            n[6] = b[5];
            n[7] = 0;
            n[8] = b[6];
            n[9] = b[7];
            n[10] = b[8];
            n[11] = 0;
            n[12] = d.x;
            n[13] = d.y;
            n[14] = d.z;
            n[15] = 1;
            return e
        };
    a.math.Matrix4.createByScale = function (b, d, e, n) {
        n = n || new a.math.Matrix4;
        var p = n.mat;
        p[0] = b;
        p[5] = d;
        p[10] = e;
        p[15] = 1;
        p[1] = p[2] = p[3] = p[4] = p[6] = p[7] = p[8] = p[9] = p[11] = p[12] = p[13] = p[14] = 0;
        return n
    };
    a.kmMat4Translation = function (a, b, d, e) {
        a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
        a.mat[1] = a.mat[2] =
            a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0;
        a.mat[12] = b;
        a.mat[13] = d;
        a.mat[14] = e;
        return a
    };
    a.math.Matrix4.createByTranslation = function (b, d, e, n) {
        n = n || new a.math.Matrix4;
        n.identity();
        n.mat[12] = b;
        n.mat[13] = d;
        n.mat[14] = e;
        return n
    };
    b.getUpVec3 = function () {
        var b = this.mat;
        return (new a.math.Vec3(b[4], b[5], b[6])).normalize()
    };
    b.getRightVec3 = function () {
        var b = this.mat;
        return (new a.math.Vec3(b[0], b[1], b[2])).normalize()
    };
    b.getForwardVec3 = function () {
        var b = this.mat;
        return (new a.math.Vec3(b[8],
            b[9], b[10])).normalize()
    };
    a.kmMat4PerspectiveProjection = function (b, d, e, n, p) {
        var r = a.degreesToRadians(d / 2);
        d = p - n;
        var s = Math.sin(r);
        if (0 === d || 0 === s || 0 === e)return null;
        r = Math.cos(r) / s;
        b.identity();
        b.mat[0] = r / e;
        b.mat[5] = r;
        b.mat[10] = -(p + n) / d;
        b.mat[11] = -1;
        b.mat[14] = -2 * n * p / d;
        b.mat[15] = 0;
        return b
    };
    a.math.Matrix4.createPerspectiveProjection = function (b, d, e, n) {
        var p = a.degreesToRadians(b / 2);
        b = n - e;
        var r = Math.sin(p);
        if (0 === b || 0 === r || 0 === d)return null;
        var p = Math.cos(p) / r, r = new a.math.Matrix4, s = r.mat;
        r.identity();
        s[0] = p / d;
        s[5] = p;
        s[10] = -(n + e) / b;
        s[11] = -1;
        s[14] = -2 * e * n / b;
        s[15] = 0;
        return r
    };
    a.kmMat4OrthographicProjection = function (a, b, d, e, p, r, s) {
        a.identity();
        a.mat[0] = 2 / (d - b);
        a.mat[5] = 2 / (p - e);
        a.mat[10] = -2 / (s - r);
        a.mat[12] = -((d + b) / (d - b));
        a.mat[13] = -((p + e) / (p - e));
        a.mat[14] = -((s + r) / (s - r));
        return a
    };
    a.math.Matrix4.createOrthographicProjection = function (b, d, e, n, p, r) {
        var s = new a.math.Matrix4, t = s.mat;
        s.identity();
        t[0] = 2 / (d - b);
        t[5] = 2 / (n - e);
        t[10] = -2 / (r - p);
        t[12] = -((d + b) / (d - b));
        t[13] = -((n + e) / (n - e));
        t[14] = -((r + p) / (r - p));
        return s
    };
    a.kmMat4LookAt = function (b, d, e, n) {
        e = new a.math.Vec3(e);
        var p = new a.math.Vec3(n);
        e.subtract(d);
        e.normalize();
        p.normalize();
        n = new a.math.Vec3(e);
        n.cross(p);
        n.normalize();
        p = new a.math.Vec3(n);
        p.cross(e);
        n.normalize();
        b.identity();
        b.mat[0] = n.x;
        b.mat[4] = n.y;
        b.mat[8] = n.z;
        b.mat[1] = p.x;
        b.mat[5] = p.y;
        b.mat[9] = p.z;
        b.mat[2] = -e.x;
        b.mat[6] = -e.y;
        b.mat[10] = -e.z;
        d = a.math.Matrix4.createByTranslation(-d.x, -d.y, -d.z);
        b.multiply(d);
        return b
    };
    var e = new a.math.Matrix4;
    b.lookAt = function (b, d, h) {
        d = new a.math.Vec3(d);
        var n =
            new a.math.Vec3(h);
        h = this.mat;
        d.subtract(b);
        d.normalize();
        n.normalize();
        var p = new a.math.Vec3(d);
        p.cross(n);
        p.normalize();
        n = new a.math.Vec3(p);
        n.cross(d);
        p.normalize();
        this.identity();
        h[0] = p.x;
        h[4] = p.y;
        h[8] = p.z;
        h[1] = n.x;
        h[5] = n.y;
        h[9] = n.z;
        h[2] = -d.x;
        h[6] = -d.y;
        h[10] = -d.z;
        e = a.math.Matrix4.createByTranslation(-b.x, -b.y, -b.z, e);
        this.multiply(e);
        return this
    };
    a.kmMat4RotationAxisAngle = function (b, d, e) {
        var n = Math.cos(e);
        e = Math.sin(e);
        d = new a.math.Vec3(d);
        d.normalize();
        b.mat[0] = n + d.x * d.x * (1 - n);
        b.mat[1] = d.z *
            e + d.y * d.x * (1 - n);
        b.mat[2] = -d.y * e + d.z * d.x * (1 - n);
        b.mat[3] = 0;
        b.mat[4] = -d.z * e + d.x * d.y * (1 - n);
        b.mat[5] = n + d.y * d.y * (1 - n);
        b.mat[6] = d.x * e + d.z * d.y * (1 - n);
        b.mat[7] = 0;
        b.mat[8] = d.y * e + d.x * d.z * (1 - n);
        b.mat[9] = -d.x * e + d.y * d.z * (1 - n);
        b.mat[10] = n + d.z * d.z * (1 - n);
        b.mat[11] = 0;
        b.mat[12] = 0;
        b.mat[13] = 0;
        b.mat[14] = 0;
        b.mat[15] = 1;
        return b
    };
    a.math.Matrix4.createByAxisAndAngle = function (b, d, e) {
        e = e || new a.math.Matrix4;
        var n = this.mat, p = Math.cos(d);
        d = Math.sin(d);
        b = new a.math.Vec3(b);
        b.normalize();
        n[0] = p + b.x * b.x * (1 - p);
        n[1] = b.z * d + b.y * b.x *
            (1 - p);
        n[2] = -b.y * d + b.z * b.x * (1 - p);
        n[3] = 0;
        n[4] = -b.z * d + b.x * b.y * (1 - p);
        n[5] = p + b.y * b.y * (1 - p);
        n[6] = b.x * d + b.z * b.y * (1 - p);
        n[7] = 0;
        n[8] = b.y * d + b.x * b.z * (1 - p);
        n[9] = -b.x * d + b.y * b.z * (1 - p);
        n[10] = p + b.z * b.z * (1 - p);
        n[11] = 0;
        n[12] = n[13] = n[14] = 0;
        n[15] = 1;
        return e
    };
    b.extractRotation = function () {
        var b = new a.math.Matrix3, d = this.mat, e = b.mat;
        e[0] = d[0];
        e[1] = d[1];
        e[2] = d[2];
        e[3] = d[4];
        e[4] = d[5];
        e[5] = d[6];
        e[6] = d[8];
        e[7] = d[9];
        e[8] = d[10];
        return b
    };
    b.extractPlane = function (b) {
        var d = new a.math.Plane, e = this.mat;
        switch (b) {
            case a.math.Plane.RIGHT:
                d.a =
                    e[3] - e[0];
                d.b = e[7] - e[4];
                d.c = e[11] - e[8];
                d.d = e[15] - e[12];
                break;
            case a.math.Plane.LEFT:
                d.a = e[3] + e[0];
                d.b = e[7] + e[4];
                d.c = e[11] + e[8];
                d.d = e[15] + e[12];
                break;
            case a.math.Plane.BOTTOM:
                d.a = e[3] + e[1];
                d.b = e[7] + e[5];
                d.c = e[11] + e[9];
                d.d = e[15] + e[13];
                break;
            case a.math.Plane.TOP:
                d.a = e[3] - e[1];
                d.b = e[7] - e[5];
                d.c = e[11] - e[9];
                d.d = e[15] - e[13];
                break;
            case a.math.Plane.FAR:
                d.a = e[3] - e[2];
                d.b = e[7] - e[6];
                d.c = e[11] - e[10];
                d.d = e[15] - e[14];
                break;
            case a.math.Plane.NEAR:
                d.a = e[3] + e[2];
                d.b = e[7] + e[6];
                d.c = e[11] + e[10];
                d.d = e[15] + e[14];
                break;
            default:
                a.log("cc.math.Matrix4.extractPlane: Invalid plane index")
        }
        b = Math.sqrt(d.a * d.a + d.b * d.b + d.c * d.c);
        d.a /= b;
        d.b /= b;
        d.c /= b;
        d.d /= b;
        return d
    };
    b.toAxisAndAngle = function () {
        var b = this.extractRotation();
        return a.math.Quaternion.rotationMatrix(b).toAxisAndAngle()
    }
})(cc);
(function (a) {
    a.math.Plane = function (a, b, f, g) {
        a && void 0 === b ? (this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d) : (this.a = a || 0, this.b = b || 0, this.c = f || 0, this.d = g || 0)
    };
    a.kmPlane = a.math.Plane;
    var b = a.math.Plane.prototype;
    a.math.Plane.LEFT = 0;
    a.math.Plane.RIGHT = 1;
    a.math.Plane.BOTTOM = 2;
    a.math.Plane.TOP = 3;
    a.math.Plane.NEAR = 4;
    a.math.Plane.FAR = 5;
    a.math.Plane.POINT_INFRONT_OF_PLANE = 0;
    a.math.Plane.POINT_BEHIND_PLANE = 1;
    a.math.Plane.POINT_ON_PLANE = 2;
    b.dot = function (a) {
        return this.a * a.x + this.b * a.y + this.c * a.z + this.d * a.w
    };
    b.dotCoord =
        function (a) {
            return this.a * a.x + this.b * a.y + this.c * a.z + this.d
        };
    b.dotNormal = function (a) {
        return this.a * a.x + this.b * a.y + this.c * a.z
    };
    a.math.Plane.fromPointNormal = function (b, e) {
        return new a.math.Plane(e.x, e.y, e.z, -e.dot(b))
    };
    a.math.Plane.fromPoints = function (b, e, f) {
        e = new a.math.Vec3(e);
        f = new a.math.Vec3(f);
        var g = new a.math.Plane;
        e.subtract(b);
        f.subtract(b);
        e.cross(f);
        e.normalize();
        g.a = e.x;
        g.b = e.y;
        g.c = e.z;
        g.d = e.scale(-1).dot(b);
        return g
    };
    b.normalize = function () {
        var b = new a.math.Vec3(this.a, this.b, this.c), e = 1 /
            b.length();
        b.normalize();
        this.a = b.x;
        this.b = b.y;
        this.c = b.z;
        this.d *= e;
        return this
    };
    b.classifyPoint = function (b) {
        b = this.a * b.x + this.b * b.y + this.c * b.z + this.d;
        return 0.001 < b ? a.math.Plane.POINT_INFRONT_OF_PLANE : -0.001 > b ? a.math.Plane.POINT_BEHIND_PLANE : a.math.Plane.POINT_ON_PLANE
    }
})(cc);
(function (a) {
    a.math.Quaternion = function (a, b, f, g) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = f || 0, this.w = g || 0)
    };
    a.kmQuaternion = a.math.Quaternion;
    var b = a.math.Quaternion.prototype;
    b.conjugate = function (a) {
        this.x = -a.x;
        this.y = -a.y;
        this.z = -a.z;
        this.w = a.w;
        return this
    };
    b.dot = function (a) {
        return this.w * a.w + this.x * a.x + this.y * a.y + this.z * a.z
    };
    b.exponential = function () {
        return this
    };
    b.identity = function () {
        this.z = this.y = this.x = 0;
        this.w = 1;
        return this
    };
    b.inverse = function () {
        var b =
            this.length();
        if (Math.abs(b) > a.math.EPSILON)return this.w = this.z = this.y = this.x = 0, this;
        this.conjugate(this).scale(1 / b);
        return this
    };
    b.isIdentity = function () {
        return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w
    };
    b.length = function () {
        return Math.sqrt(this.lengthSq())
    };
    b.lengthSq = function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    };
    b.multiply = function (a) {
        var b = this.x, f = this.y, g = this.z, h = this.w;
        this.w = h * a.w - b * a.x - f * a.y - g * a.z;
        this.x = h * a.x + b * a.w + f * a.z - g * a.y;
        this.y = h * a.y + f * a.w + g * a.x -
            b * a.z;
        this.z = h * a.z + g * a.w + b * a.y - f * a.x;
        return this
    };
    b.normalize = function () {
        var b = this.length();
        if (Math.abs(b) <= a.math.EPSILON)throw Error("current quaternion is an invalid value");
        this.scale(1 / b);
        return this
    };
    b.rotationAxis = function (a, b) {
        var f = 0.5 * b, g = Math.sin(f);
        this.w = Math.cos(f);
        this.x = a.x * g;
        this.y = a.y * g;
        this.z = a.z * g;
        return this
    };
    a.math.Quaternion.rotationMatrix = function (b) {
        if (!b)return null;
        var e, f, g;
        e = [];
        f = b.mat;
        b = 0;
        e[0] = f[0];
        e[1] = f[3];
        e[2] = f[6];
        e[4] = f[1];
        e[5] = f[4];
        e[6] = f[7];
        e[8] = f[2];
        e[9] = f[5];
        e[10] = f[8];
        e[15] = 1;
        var h = e[0];
        b = h[0] + h[5] + h[10] + 1;
        b > a.math.EPSILON ? (b = 2 * Math.sqrt(b), e = (h[9] - h[6]) / b, f = (h[2] - h[8]) / b, g = (h[4] - h[1]) / b, b *= 0.25) : h[0] > h[5] && h[0] > h[10] ? (b = 2 * Math.sqrt(1 + h[0] - h[5] - h[10]), e = 0.25 * b, f = (h[4] + h[1]) / b, g = (h[2] + h[8]) / b, b = (h[9] - h[6]) / b) : h[5] > h[10] ? (b = 2 * Math.sqrt(1 + h[5] - h[0] - h[10]), e = (h[4] + h[1]) / b, f = 0.25 * b, g = (h[9] + h[6]) / b, b = (h[2] - h[8]) / b) : (b = 2 * Math.sqrt(1 + h[10] - h[0] - h[5]), e = (h[2] + h[8]) / b, f = (h[9] + h[6]) / b, g = 0.25 * b, b = (h[4] - h[1]) / b);
        return new a.math.Quaternion(e, f, g, b)
    };
    a.math.Quaternion.rotationYawPitchRoll =
        function (b, e, f) {
            var g, h, n, p, r;
            g = a.degreesToRadians(e) / 2;
            h = a.degreesToRadians(b) / 2;
            n = a.degreesToRadians(f) / 2;
            f = Math.cos(g);
            b = Math.cos(h);
            e = Math.cos(n);
            g = Math.sin(g);
            h = Math.sin(h);
            n = Math.sin(n);
            p = b * e;
            r = h * n;
            var s = new a.math.Quaternion;
            s.w = f * p + g * r;
            s.x = g * p - f * r;
            s.y = f * h * e + g * b * n;
            s.z = f * b * n - g * h * e;
            s.normalize();
            return s
        };
    b.slerp = function (b, e) {
        if (this.x === b.x && this.y === b.y && this.z === b.z && this.w === b.w)return this;
        var f = this.dot(b), g = Math.acos(f), h = Math.sqrt(1 - a.math.square(f)), f = Math.sin(e * g) / h, g = Math.sin((1 -
                e) * g) / h, h = new a.math.Quaternion(b);
        this.scale(g);
        h.scale(f);
        this.add(h);
        return this
    };
    b.toAxisAndAngle = function () {
        var b, e, f = new a.math.Vec3;
        b = Math.acos(this.w);
        e = Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z));
        e > -a.math.EPSILON && e < a.math.EPSILON || e < 2 * Math.PI + a.math.EPSILON && e > 2 * Math.PI - a.math.EPSILON ? (b = 0, f.x = 0, f.y = 0, f.z = 1) : (b *= 2, f.x = this.x / e, f.y = this.y / e, f.z = this.z / e, f.normalize());
        return {axis: f, angle: b}
    };
    b.scale = function (a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.assignFrom = function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = a.w;
        return this
    };
    b.add = function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    };
    a.math.Quaternion.rotationBetweenVec3 = function (b, e, f) {
        var g = new a.math.Vec3(b), h = new a.math.Vec3(e);
        g.normalize();
        h.normalize();
        var n = g.dot(h);
        e = new a.math.Quaternion;
        if (1 <= n)return e.identity(), e;
        -0.999999 > n ? Math.abs(f.lengthSq()) < a.math.EPSILON ? e.rotationAxis(f, Math.PI) : (g = new a.math.Vec3(1, 0, 0), g.cross(b), Math.abs(g.lengthSq()) < a.math.EPSILON &&
        (g.fill(0, 1, 0), g.cross(b)), g.normalize(), e.rotationAxis(g, Math.PI)) : (b = Math.sqrt(2 * (1 + n)), f = 1 / b, g.cross(h), e.x = g.x * f, e.y = g.y * f, e.z = g.z * f, e.w = 0.5 * b, e.normalize());
        return e
    };
    b.multiplyVec3 = function (b) {
        var e = this.x, f = this.y, g = this.z, h = new a.math.Vec3(b), n = new a.math.Vec3(e, f, g), e = new a.math.Vec3(e, f, g);
        n.cross(b);
        e.cross(n);
        n.scale(2 * q.w);
        e.scale(2);
        h.add(n);
        h.add(e);
        return h
    }
})(cc);
cc.math.AABB = function (a, b) {
    this.min = a || new cc.math.Vec3;
    this.max = b || new cc.math.Vec3
};
cc.math.AABB.prototype.containsPoint = function (a) {
    return a.x >= this.min.x && a.x <= this.max.x && a.y >= this.min.y && a.y <= this.max.y && a.z >= this.min.z && a.z <= this.max.z
};
cc.math.AABB.containsPoint = function (a, b) {
    return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z
};
cc.math.AABB.prototype.assignFrom = function (a) {
    this.min.assignFrom(a.min);
    this.max.assignFrom(a.max)
};
cc.math.AABB.assign = function (a, b) {
    a.min.assignFrom(b.min);
    a.max.assignFrom(b.max);
    return a
};
(function (a) {
    a.math.Matrix4Stack = function (a, b) {
        this.top = a;
        this.stack = b || []
    };
    a.km_mat4_stack = a.math.Matrix4Stack;
    var b = a.math.Matrix4Stack.prototype;
    b.initialize = function () {
        this.stack.length = 0;
        this.top = null
    };
    a.km_mat4_stack_push = function (b, e) {
        b.stack.push(b.top);
        b.top = new a.math.Matrix4(e)
    };
    a.km_mat4_stack_pop = function (a, b) {
        a.top = a.stack.pop()
    };
    a.km_mat4_stack_release = function (a) {
        a.stack = null;
        a.top = null
    };
    b.push = function (b) {
        b = b || this.top;
        this.stack.push(this.top);
        this.top = new a.math.Matrix4(b)
    };
    b.pop =
        function () {
            this.top = this.stack.pop()
        };
    b.release = function () {
        this._matrixPool = this.top = this.stack = null
    };
    b._getFromPool = function (b) {
        var e = this._matrixPool;
        if (0 === e.length)return new a.math.Matrix4(b);
        e = e.pop();
        e.assignFrom(b);
        return e
    };
    b._putInPool = function (a) {
        this._matrixPool.push(a)
    }
})(cc);
(function (a) {
    a.KM_GL_MODELVIEW = 5888;
    a.KM_GL_PROJECTION = 5889;
    a.KM_GL_TEXTURE = 5890;
    a.modelview_matrix_stack = new a.math.Matrix4Stack;
    a.projection_matrix_stack = new a.math.Matrix4Stack;
    a.texture_matrix_stack = new a.math.Matrix4Stack;
    a.current_stack = null;
    a.lazyInitialize = function () {
        var b = new a.math.Matrix4;
        a.modelview_matrix_stack.initialize();
        a.projection_matrix_stack.initialize();
        a.texture_matrix_stack.initialize();
        a.current_stack = a.modelview_matrix_stack;
        a.initialized = !0;
        b.identity();
        a.modelview_matrix_stack.push(b);
        a.projection_matrix_stack.push(b);
        a.texture_matrix_stack.push(b)
    };
    a.lazyInitialize();
    a.kmGLFreeAll = function () {
        a.modelview_matrix_stack.release();
        a.modelview_matrix_stack = null;
        a.projection_matrix_stack.release();
        a.projection_matrix_stack = null;
        a.texture_matrix_stack.release();
        a.texture_matrix_stack = null;
        a.initialized = !1;
        a.current_stack = null
    };
    a.kmGLPushMatrix = function () {
        a.current_stack.push(a.current_stack.top)
    };
    a.kmGLPushMatrixWitMat4 = function (b) {
        a.current_stack.stack.push(a.current_stack.top);
        b.assignFrom(a.current_stack.top);
        a.current_stack.top = b
    };
    a.kmGLPopMatrix = function () {
        a.current_stack.top = a.current_stack.stack.pop()
    };
    a.kmGLMatrixMode = function (b) {
        switch (b) {
            case a.KM_GL_MODELVIEW:
                a.current_stack = a.modelview_matrix_stack;
                break;
            case a.KM_GL_PROJECTION:
                a.current_stack = a.projection_matrix_stack;
                break;
            case a.KM_GL_TEXTURE:
                a.current_stack = a.texture_matrix_stack;
                break;
            default:
                throw Error("Invalid matrix mode specified");
        }
    };
    a.kmGLLoadIdentity = function () {
        a.current_stack.top.identity()
    };
    a.kmGLLoadMatrix = function (b) {
        a.current_stack.top.assignFrom(b)
    };
    a.kmGLMultMatrix = function (b) {
        a.current_stack.top.multiply(b)
    };
    var b = new a.math.Matrix4;
    a.kmGLTranslatef = function (d, f, g) {
        d = a.math.Matrix4.createByTranslation(d, f, g, b);
        a.current_stack.top.multiply(d)
    };
    var d = new a.math.Vec3;
    a.kmGLRotatef = function (e, f, g, h) {
        d.fill(f, g, h);
        e = a.math.Matrix4.createByAxisAndAngle(d, a.degreesToRadians(e), b);
        a.current_stack.top.multiply(e)
    };
    a.kmGLScalef = function (d, f, g) {
        d = a.math.Matrix4.createByScale(d, f, g, b);
        a.current_stack.top.multiply(d)
    };
    a.kmGLGetMatrix = function (b, d) {
        switch (b) {
            case a.KM_GL_MODELVIEW:
                d.assignFrom(a.modelview_matrix_stack.top);
                break;
            case a.KM_GL_PROJECTION:
                d.assignFrom(a.projection_matrix_stack.top);
                break;
            case a.KM_GL_TEXTURE:
                d.assignFrom(a.texture_matrix_stack.top);
                break;
            default:
                throw Error("Invalid matrix mode specified");
        }
    }
})(cc);
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor \x3d v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize \x3d u_pointSize;          \n    v_fragmentColor \x3d u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor \x3d v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color;             \n}";
cc.SHADER_SPRITE_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d CC_PMatrix * a_position;  \n    v_fragmentColor \x3d a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord \x3d a_texcoord; \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d CC_PMatrix * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a \x3c\x3d CC_alpha_value )          \n        discard; \n    gl_FragColor \x3d texColor * v_fragmentColor;  \n}";
cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d CC_PMatrix * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    \x3d v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_SPRITE_POSITION_TEXTURECOLOR: 8,
    TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST: 9,
    TYPE_SPRITE_POSITION_COLOR: 10,
    TYPE_MAX: 10,
    _programs: {},
    _init: function () {
        this.loadDefaultShaders();
        return !0
    },
    _loadDefaultShader: function (a, b) {
        switch (b) {
            case this.TYPE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT,
                    cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_SPRITE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR,
                    cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT,
                    cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_SPRITE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_SPRITE_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_POSITION_TEXTURE:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD,
                    cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_A8COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION,
                    cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
                a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                break;
            case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            default:
                cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
                return
        }
        a.link();
        a.updateUniforms()
    },
    loadDefaultShaders: function () {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = a;
        this._programs.ShaderPositionTextureColor =
            a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_SPRITE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_SPRITE_POSITION_TEXTURECOLOR] = a;
        this._programs.ShaderSpritePositionTextureColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a;
        this._programs.ShaderPositionTextureColorAlphaTest = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST] =
            a;
        this._programs.ShaderSpritePositionTextureColorAlphaTest = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        this._programs[cc.SHADER_POSITION_COLOR] = a;
        this._programs.ShaderPositionColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_SPRITE_POSITION_COLOR);
        this._programs[cc.SHADER_SPRITE_POSITION_COLOR] = a;
        this._programs.ShaderSpritePositionColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        this._programs[cc.SHADER_POSITION_TEXTURE] = a;
        this._programs.ShaderPositionTexture = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a;
        this._programs.ShaderPositionTextureUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a;
        this._programs.ShaderPositionTextureA8Color = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR);
        this._programs[cc.SHADER_POSITION_UCOLOR] =
            a;
        this._programs.ShaderPositionUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a;
        this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function () {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        a = this.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_SPRITE_POSITION_TEXTURECOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        a = this.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST);
        a = this.programForKey(cc.SHADER_POSITION_COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        a = this.programForKey(cc.SHADER_POSITION_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function (a) {
        return this._programs[a]
    },
    getProgram: function (a) {
        return this._programs[a]
    },
    addProgram: function (a, b) {
        this._programs[b] =
            a
    }
};
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function (a) {
        if (!a)return !1;
        var b, d = this._hashForUniforms[a];
        if (d) {
            b = !1;
            for (var e = arguments.length - 1, f = 0; f < e; ++f)arguments[f + 1] !== d[f] && (d[f] = arguments[f + 1], b = !0)
        } else d = [arguments[1], arguments[2], arguments[3], arguments[4]], this._hashForUniforms[a] = d, b = !0;
        return b
    },
    _description: function () {
        return "\x3cCCGLProgram \x3d " + this.toString() +
            " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e"
    },
    _compileShader: function (a, b, d) {
        if (!d || !a)return !1;
        d = (cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n") + "uniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" +
            d;
        this._glContext.shaderSource(a, d);
        this._glContext.compileShader(a);
        d = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
        d || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), b === this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
        return !0 === d
    },
    ctor: function (a, b, d) {
        this._uniforms = {};
        this._hashForUniforms = {};
        this._glContext = d || cc._renderContext;
        a && b && this.init(a, b)
    },
    destroyProgram: function () {
        this._hashForUniforms =
            this._uniforms = this._fragShader = this._vertShader = null;
        this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function (a, b) {
        var d = this._glContext;
        this._programObj = d.createProgram();
        this._fragShader = this._vertShader = null;
        a && (this._vertShader = d.createShader(d.VERTEX_SHADER), this._compileShader(this._vertShader, d.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
        b && (this._fragShader = d.createShader(d.FRAGMENT_SHADER), this._compileShader(this._fragShader,
            d.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
        this._vertShader && d.attachShader(this._programObj, this._vertShader);
        cc.checkGLErrorDebug();
        this._fragShader && d.attachShader(this._programObj, this._fragShader);
        for (var e in this._hashForUniforms)delete this._hashForUniforms[e];
        cc.checkGLErrorDebug();
        return !0
    },
    initWithString: function (a, b) {
        return this.initWithVertexShaderByteArray(a, b)
    },
    initWithVertexShaderFilename: function (a, b) {
        var d = cc.loader.getRes(a);
        if (!d)throw Error("Please load the resource firset : " +
            a);
        var e = cc.loader.getRes(b);
        if (!e)throw Error("Please load the resource firset : " + b);
        return this.initWithVertexShaderByteArray(d, e)
    },
    init: function (a, b) {
        return this.initWithVertexShaderFilename(a, b)
    },
    addAttribute: function (a, b) {
        this._glContext.bindAttribLocation(this._programObj, b, a)
    },
    link: function () {
        if (!this._programObj)return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader && this._glContext.deleteShader(this._fragShader);
        this._fragShader = this._vertShader = null;
        return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
    },
    use: function () {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function () {
        this._uniforms[cc.UNIFORM_PMATRIX_S] =
            this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
        this._uniforms[cc.UNIFORM_MVMATRIX_S] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
        this._uniforms[cc.UNIFORM_MVPMATRIX_S] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
        this._uniforms[cc.UNIFORM_TIME_S] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
        this._uniforms[cc.UNIFORM_SINTIME_S] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
        this._uniforms[cc.UNIFORM_COSTIME_S] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
        this._usesTime = null != this._uniforms[cc.UNIFORM_TIME_S] || null != this._uniforms[cc.UNIFORM_SINTIME_S] || null != this._uniforms[cc.UNIFORM_COSTIME_S];
        this._uniforms[cc.UNIFORM_RANDOM01_S] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
        this._uniforms[cc.UNIFORM_SAMPLER_S] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER_S],
            0)
    },
    _addUniformLocation: function (a) {
        var b = this._glContext.getUniformLocation(this._programObj, a);
        this._uniforms[a] = b
    },
    getUniformLocationForName: function (a) {
        if (!a)throw Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
        if (!this._programObj)throw Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
        return this._uniforms[a] || this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function () {
        return this._uniforms[cc.UNIFORM_MVPMATRIX_S]
    },
    getUniformSampler: function () {
        return this._uniforms[cc.UNIFORM_SAMPLER_S]
    },
    setUniformLocationWith1i: function (a, b) {
        var d = this._glContext;
        if ("string" === typeof a) {
            if (this._updateUniformLocation(a, b)) {
                var e = this.getUniformLocationForName(a);
                d.uniform1i(e, b)
            }
        } else d.uniform1i(a, b)
    },
    setUniformLocationWith2i: function (a, b, d) {
        var e = this._glContext;
        "string" === typeof a ? this._updateUniformLocation(a, b, d) && (a = this.getUniformLocationForName(a), e.uniform2i(a, b, d)) : e.uniform2i(a, b, d)
    },
    setUniformLocationWith3i: function (a,
                                        b, d, e) {
        var f = this._glContext;
        "string" === typeof a ? this._updateUniformLocation(a, b, d, e) && (a = this.getUniformLocationForName(a), f.uniform3i(a, b, d, e)) : f.uniform3i(a, b, d, e)
    },
    setUniformLocationWith4i: function (a, b, d, e, f) {
        var g = this._glContext;
        "string" === typeof a ? this._updateUniformLocation(a, b, d, e, f) && (a = this.getUniformLocationForName(a), g.uniform4i(a, b, d, e, f)) : g.uniform4i(a, b, d, e, f)
    },
    setUniformLocationWith2iv: function (a, b) {
        var d = "string" === typeof a ? this.getUniformLocationForName(a) : a;
        this._glContext.uniform2iv(d,
            b)
    },
    setUniformLocationWith3iv: function (a, b) {
        var d = "string" === typeof a ? this.getUniformLocationForName(a) : a;
        this._glContext.uniform3iv(d, b)
    },
    setUniformLocationWith4iv: function (a, b) {
        var d = "string" === typeof a ? this.getUniformLocationForName(a) : a;
        this._glContext.uniform4iv(d, b)
    },
    setUniformLocationI32: function (a, b) {
        this.setUniformLocationWith1i(a, b)
    },
    setUniformLocationWith1f: function (a, b) {
        var d = this._glContext;
        if ("string" === typeof a) {
            if (this._updateUniformLocation(a, b)) {
                var e = this.getUniformLocationForName(a);
                d.uniform1f(e, b)
            }
        } else d.uniform1f(a, b)
    },
    setUniformLocationWith2f: function (a, b, d) {
        var e = this._glContext;
        "string" === typeof a ? this._updateUniformLocation(a, b, d) && (a = this.getUniformLocationForName(a), e.uniform2f(a, b, d)) : e.uniform2f(a, b, d)
    },
    setUniformLocationWith3f: function (a, b, d, e) {
        var f = this._glContext;
        "string" === typeof a ? this._updateUniformLocation(a, b, d, e) && (a = this.getUniformLocationForName(a), f.uniform3f(a, b, d, e)) : f.uniform3f(a, b, d, e)
    },
    setUniformLocationWith4f: function (a, b, d, e, f) {
        var g = this._glContext;
        "string" === typeof a ? this._updateUniformLocation(a, b, d, e, f) && (a = this.getUniformLocationForName(a), g.uniform4f(a, b, d, e, f)) : g.uniform4f(a, b, d, e, f)
    },
    setUniformLocationWith2fv: function (a, b) {
        var d = "string" === typeof a ? this.getUniformLocationForName(a) : a;
        this._glContext.uniform2fv(d, b)
    },
    setUniformLocationWith3fv: function (a, b) {
        var d = "string" === typeof a ? this.getUniformLocationForName(a) : a;
        this._glContext.uniform3fv(d, b)
    },
    setUniformLocationWith4fv: function (a, b) {
        var d = "string" === typeof a ? this.getUniformLocationForName(a) :
            a;
        this._glContext.uniform4fv(d, b)
    },
    setUniformLocationWithMatrix4fv: function (a, b) {
        var d = "string" === typeof a ? this.getUniformLocationForName(a) : a;
        this._glContext.uniformMatrix4fv(d, !1, b)
    },
    setUniformLocationF32: function () {
        if (!(2 > arguments.length))switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function () {
        var a = new cc.math.Matrix4, b = new cc.math.Matrix4, d = new cc.math.Matrix4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
        cc.kmMat4Multiply(d, a, b);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], a.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], b.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX_S],
            d.mat, 1);
        this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME_S], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME_S], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME_S], a / 8, a / 4, a / 2, Math.cos(a)));
        -1 !== this._uniforms[cc.UNIFORM_RANDOM01_S] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01_S], Math.random(), Math.random(), Math.random(),
            Math.random())
    },
    _setUniformsForBuiltinsForRenderer: function (a) {
        if (a && a._renderCmd) {
            var b = new cc.math.Matrix4, d = new cc.math.Matrix4;
            cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
            cc.kmMat4Multiply(d, b, a._renderCmd._stackMatrix);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], b.mat, 1);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], a._renderCmd._stackMatrix.mat, 1);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX_S], d.mat, 1);
            this._usesTime &&
            (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME_S], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME_S], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME_S], a / 8, a / 4, a / 2, Math.cos(a)));
            -1 !== this._uniforms[cc.UNIFORM_RANDOM01_S] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01_S], Math.random(), Math.random(), Math.random(), Math.random())
        }
    },
    setUniformForModelViewProjectionMatrix: function () {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX_S],
            !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function (a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX_S], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function () {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], !1, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S],
            !1, cc.projection_matrix_stack.top.mat)
    },
    _setUniformForMVPMatrixWithMat4: function (a) {
        if (!a)throw Error("modelView matrix is undefined.");
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], !1, a.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], !1, cc.projection_matrix_stack.top.mat)
    },
    _updateProjectionUniform: function () {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function () {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function () {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function () {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function () {
        this._fragShader = this._vertShader = null;
        this._uniforms.length =
            0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var a in this._hashForUniforms)delete this._hashForUniforms[a]
    },
    getProgram: function () {
        return this._programObj
    },
    retain: function () {
    },
    release: function () {
    }
});
cc.GLProgram.create = function (a, b) {
    return new cc.GLProgram(a, b)
};
cc.GLProgram._highpSupported = null;
cc.GLProgram._isHighpSupported = function () {
    if (null == cc.GLProgram._highpSupported) {
        var a = cc._renderContext, a = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
        cc.GLProgram._highpSupported = 0 !== a.precision
    }
    return cc.GLProgram._highpSupported
};
cc.setProgram = function (a, b) {
    a.shaderProgram = b;
    var d = a.children;
    if (d)for (var e = 0; e < d.length; e++)cc.setProgram(d[e], b)
};
cc._currentProjectionMatrix = -1;
if (cc.ENABLE_GL_STATE_CACHE) {
    cc.MAX_ACTIVETEXTURE = 16;
    cc._currentShaderProgram = -1;
    cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    cc._blendingSource = -1;
    cc._blendingDest = -1;
    cc._GLServerState = 0;
    cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0);
    var _currBuffers = {}, _currBuffer;
    WebGLRenderingContext.prototype.glBindBuffer = WebGLRenderingContext.prototype.bindBuffer;
    WebGLRenderingContext.prototype.bindBuffer = function (a, b) {
        _currBuffers[a] !== b && (_currBuffers[a] = b, this.glBindBuffer(a, b));
        if (_currBuffer &&
            _currBuffer === b)return !0;
        _currBuffer = b;
        return !1
    };
    WebGLRenderingContext.prototype.glEnableVertexAttribArray = WebGLRenderingContext.prototype.enableVertexAttribArray;
    WebGLRenderingContext.prototype.enableVertexAttribArray = function (a) {
        a === cc.VERTEX_ATTRIB_FLAG_POSITION ? this._vertexAttribPosition || (this.glEnableVertexAttribArray(a), this._vertexAttribPosition = !0) : a === cc.VERTEX_ATTRIB_FLAG_COLOR ? this._vertexAttribColor || (this.glEnableVertexAttribArray(a), this._vertexAttribColor = !0) : a === cc.VERTEX_ATTRIB_FLAG_TEX_COORDS ?
        this._vertexAttribTexCoords || (this.glEnableVertexAttribArray(a), this._vertexAttribTexCoords = !0) : this.glEnableVertexAttribArray(a)
    };
    WebGLRenderingContext.prototype.glDisableVertexAttribArray = WebGLRenderingContext.prototype.disableVertexAttribArray;
    WebGLRenderingContext.prototype.disableVertexAttribArray = function (a) {
        a === cc.VERTEX_ATTRIB_FLAG_COLOR ? this._vertexAttribColor && (this.glDisableVertexAttribArray(a), this._vertexAttribColor = !1) : a === cc.VERTEX_ATTRIB_FLAG_TEX_COORDS ? this._vertexAttribTexCoords &&
        (this.glDisableVertexAttribArray(a), this._vertexAttribTexCoords = !1) : 0 !== a && this.glDisableVertexAttribArray(a)
    }
}
cc.glInvalidateStateCache = function () {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -1;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++)cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1;
        cc._blendingDest = -1;
        cc._GLServerState = 0
    }
};
cc.glUseProgram = function (a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function (a) {
    cc._renderContext.useProgram(a)
});
cc.glDeleteProgram = function (a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
    gl.deleteProgram(a)
};
cc.glBlendFunc = function (a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest)cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b)
};
cc.setBlending = function (a, b) {
    var d = cc._renderContext;
    a === d.ONE && b === d.ZERO ? d.disable(d.BLEND) : (d.enable(d.BLEND), cc._renderContext.blendFunc(a, b))
};
cc.glBlendFuncForParticle = function (a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) {
        cc._blendingSource = a;
        cc._blendingDest = b;
        var d = cc._renderContext;
        a === d.ONE && b === d.ZERO ? d.disable(d.BLEND) : (d.enable(d.BLEND), d.blendFuncSeparate(d.SRC_ALPHA, b, a, b))
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function () {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD);
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
};
cc.setProjectionMatrixDirty = function () {
    cc._currentProjectionMatrix = -1
};
cc.glBindTexture2D = function (a) {
    cc.glBindTexture2DN(0, a)
};
cc.glBindTexture2DN = function (a, b) {
    if (cc._currentBoundTexture[a] !== b) {
        cc._currentBoundTexture[a] = b;
        var d = cc._renderContext;
        d.activeTexture(d.TEXTURE0 + a);
        b ? d.bindTexture(d.TEXTURE_2D, b._webTextureObj) : d.bindTexture(d.TEXTURE_2D, null)
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function (a, b) {
    var d = cc._renderContext;
    d.activeTexture(d.TEXTURE0 + a);
    b ? d.bindTexture(d.TEXTURE_2D, b._webTextureObj) : d.bindTexture(d.TEXTURE_2D, null)
});
cc.glDeleteTexture = function (a) {
    cc.glDeleteTextureN(0, a)
};
cc.glDeleteTextureN = function (a, b) {
    cc.ENABLE_GL_STATE_CACHE && b === cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1);
    cc._renderContext.deleteTexture(b)
};
cc.glBindVAO = function (a) {
    cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && cc._uVAO !== a && (cc._uVAO = a)
};
cc.glEnable = function (a) {
};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 9;
cc.NextPOT = function (a) {
    a -= 1;
    a |= a >> 1;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    return (a | a >> 16) + 1
};
cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _texture: null,
    _pixelFormat: 0,
    clearStencilVal: 0,
    _clearColor: null,
    _className: "RenderTexture",
    ctor: function (a, b, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
        this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888;
        this._clearColor = new cc.Color(0, 0, 0, 255);
        void 0 !== a && void 0 !== b && (d = d || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, b, d, e || 0));
        this.setAnchorPoint(0,
            0)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this)
    },
    cleanup: function () {
        cc.Node.prototype.onExit.call(this);
        this._renderCmd.cleanup()
    },
    getSprite: function () {
        return this.sprite
    },
    setSprite: function (a) {
        this.sprite = a
    },
    setVirtualViewport: function (a, b, d) {
        this._renderCmd.setVirtualViewport(a, b, d)
    },
    initWithWidthAndHeight: function (a, b, d, e) {
        return this._renderCmd.initWithWidthAndHeight(a, b, d, e)
    },
    begin: function () {
        cc.renderer._turnToCacheMode(this.__instanceId);
        this._renderCmd.begin()
    },
    beginWithClear: function (a, b, d, e, f, g) {
        var h = cc._renderContext;
        f = f || h.COLOR_BUFFER_BIT;
        g = g || h.COLOR_BUFFER_BIT | h.DEPTH_BUFFER_BIT;
        this._beginWithClear(a, b, d, e, f, g, h.COLOR_BUFFER_BIT | h.DEPTH_BUFFER_BIT | h.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: function (a, b, d, e, f, g, h) {
        this.begin();
        this._renderCmd._beginWithClear(a, b, d, e, f, g, h)
    },
    end: function () {
        this._renderCmd.end()
    },
    clear: function (a, b, d, e) {
        this.beginWithClear(a, b, d,
            e);
        this.end()
    },
    clearRect: function (a, b, d, e) {
        this._renderCmd.clearRect(a, b, d, e)
    },
    clearDepth: function (a) {
        this._renderCmd.clearDepth(a)
    },
    clearStencil: function (a) {
        this._renderCmd.clearStencil(a)
    },
    getClearFlags: function () {
        return this.clearFlags
    },
    setClearFlags: function (a) {
        this.clearFlags = a
    },
    getClearColor: function () {
        return this._clearColor
    },
    setClearColor: function (a) {
        var b = this._clearColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = a.a;
        this._renderCmd.updateClearColor(a)
    },
    getClearDepth: function () {
        return this.clearDepthVal
    },
    setClearDepth: function (a) {
        this.clearDepthVal = a
    },
    getClearStencil: function () {
        return this.clearStencilVal
    },
    setClearStencil: function (a) {
        this.clearStencilVal = a
    },
    isAutoDraw: function () {
        return this.autoDraw
    },
    setAutoDraw: function (a) {
        this.autoDraw = a
    },
    saveToFile: function (a, b) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    newCCImage: function (a) {
        cc.log("saveToFile isn't supported on cocos2d-html5");
        return null
    },
    listenToBackground: function (a) {
    },
    listenToForeground: function (a) {
    }
});
_p = cc.RenderTexture.prototype;
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function (a, b, d, e) {
    return new cc.RenderTexture(a, b, d, e)
};
(function () {
    cc.RenderTexture.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._clearColorStr = "rgba(255,255,255,1)";
        this._cacheCanvas = document.createElement("canvas");
        this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"))
    };
    var a = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.RenderTexture.CanvasRenderCmd;
    a.cleanup = function () {
        this._cacheCanvas = this._cacheContext = null
    };
    a.clearStencil =
        function (a) {
        };
    a.setVirtualViewport = function (a, d, e) {
    };
    a.updateClearColor = function (a) {
        this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
    };
    a.initWithWidthAndHeight = function (a, d, e, f) {
        e = this._node;
        f = this._cacheCanvas;
        var g = cc.contentScaleFactor();
        f.width = 0 | a * g;
        f.height = 0 | d * g;
        a = new cc.Texture2D;
        a.initWithElement(f);
        a.handleLoadedTexture();
        a = e.sprite = new cc.Sprite(a);
        a.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
        e.autoDraw = !1;
        e.addChild(a);
        return !0
    };
    a.begin = function () {
    };
    a._beginWithClear =
        function (a, d, e, f, g, h, n) {
            a = a || 0;
            d = d || 0;
            e = e || 0;
            f = isNaN(f) ? 255 : f;
            g = this._cacheContext.getContext();
            h = this._cacheCanvas;
            g.setTransform(1, 0, 0, 1, 0, 0);
            this._cacheContext.setFillStyle("rgba(" + (0 | a) + "," + (0 | d) + "," + (0 | e) + "," + f / 255 + ")");
            g.clearRect(0, 0, h.width, h.height);
            g.fillRect(0, 0, h.width, h.height)
        };
    a.end = function () {
        var a = this._node, d = cc.contentScaleFactor();
        cc.renderer._renderingToCacheCanvas(this._cacheContext, a.__instanceId, d, d)
    };
    a.clearRect = function (a, d, e, f) {
        this._cacheContext.clearRect(a, d, e, -f)
    };
    a.clearDepth =
        function (a) {
            cc.log("clearDepth isn't supported on Cocos2d-Html5")
        };
    a.visit = function (a) {
        var d = this._node;
        this._syncStatus(a);
        d.sprite.visit(this);
        this._dirtyFlag = 0
    }
})();
(function () {
    cc.RenderTexture.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._depthRenderBuffer = this._textureCopy = this._oldFBO = this._fBO = null;
        this._rtTextureRect = new cc.Rect;
        this._fullRect = new cc.Rect;
        this._fullViewport = new cc.Rect
    };
    var a = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.RenderTexture.WebGLRenderCmd;
    a.setVirtualViewport = function (a, d, e) {
        this._rtTextureRect.x = a.x;
        this._rtTextureRect.y = a.y;
        this._fullRect = d;
        this._fullViewport = e
    };
    a.needDraw = function () {
        return this._needDraw && this._node.autoDraw
    };
    a.rendering = function (a) {
        var d = a || cc._renderContext;
        a = this._node;
        if (a.autoDraw) {
            a.begin();
            var e = a.clearFlags;
            if (e) {
                var f = [0, 0, 0, 0], g = 0, h = 0;
                e & d.COLOR_BUFFER_BIT && (f = d.getParameter(d.COLOR_CLEAR_VALUE), d.clearColor(a._clearColor.r / 255, a._clearColor.g / 255, a._clearColor.b / 255, a._clearColor.a / 255));
                e & d.DEPTH_BUFFER_BIT && (g = d.getParameter(d.DEPTH_CLEAR_VALUE), d.clearDepth(a.clearDepthVal));
                e & d.STENCIL_BUFFER_BIT &&
                (h = d.getParameter(d.STENCIL_CLEAR_VALUE), d.clearStencil(a.clearStencilVal));
                d.clear(e);
                e & d.COLOR_BUFFER_BIT && d.clearColor(f[0], f[1], f[2], f[3]);
                e & d.DEPTH_BUFFER_BIT && d.clearDepth(g);
                e & d.STENCIL_BUFFER_BIT && d.clearStencil(h)
            }
            a.sortAllChildren();
            d = a._children;
            for (e = 0; e < d.length; e++)f = d[e], f !== a.sprite && f._renderCmd.visit(a.sprite._renderCmd);
            a.end()
        }
    };
    a.clearStencil = function (a) {
        var d = cc._renderContext, e = d.getParameter(d.STENCIL_CLEAR_VALUE);
        d.clearStencil(a);
        d.clear(d.STENCIL_BUFFER_BIT);
        d.clearStencil(e)
    };
    a.cleanup = function () {
        this._textureCopy = null;
        var a = cc._renderContext;
        a.deleteFramebuffer(this._fBO);
        this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer)
    };
    a.updateClearColor = function (a) {
    };
    a.initWithWidthAndHeight = function (a, d, e, f) {
        var g = this._node;
        e === cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var h = cc._renderContext, n = cc.contentScaleFactor();
        this._fullRect = new cc.Rect(0, 0, a,
            d);
        this._fullViewport = new cc.Rect(0, 0, a, d);
        a = 0 | a * n;
        d = 0 | d * n;
        this._oldFBO = h.getParameter(h.FRAMEBUFFER_BINDING);
        var p;
        cc.configuration.supportsNPOT() ? (n = a, p = d) : (n = cc.NextPOT(a), p = cc.NextPOT(d));
        for (var r = new Uint8Array(n * p * 4), s = 0; s < n * p * 4; s++)r[s] = 0;
        this._pixelFormat = e;
        s = g._texture = new cc.Texture2D;
        if (!g._texture)return !1;
        s.initWithData(r, g._pixelFormat, n, p, cc.size(a, d));
        e = h.getParameter(h.RENDERBUFFER_BINDING);
        if (cc.configuration.checkForGLExtension("GL_QCOM")) {
            this._textureCopy = new cc.Texture2D;
            if (!this._textureCopy)return !1;
            this._textureCopy.initWithData(r, g._pixelFormat, n, p, cc.size(a, d))
        }
        this._fBO = h.createFramebuffer();
        h.bindFramebuffer(h.FRAMEBUFFER, this._fBO);
        h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, s._webTextureObj, 0);
        0 !== f && (this._depthRenderBuffer = h.createRenderbuffer(), h.bindRenderbuffer(h.RENDERBUFFER, this._depthRenderBuffer), h.renderbufferStorage(h.RENDERBUFFER, f, n, p), f === h.DEPTH_STENCIL ? h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_STENCIL_ATTACHMENT, h.RENDERBUFFER, this._depthRenderBuffer) :
            f === h.STENCIL_INDEX || f === h.STENCIL_INDEX8 ? h.framebufferRenderbuffer(h.FRAMEBUFFER, h.STENCIL_ATTACHMENT, h.RENDERBUFFER, this._depthRenderBuffer) : f === h.DEPTH_COMPONENT16 && h.framebufferRenderbuffer(h.FRAMEBUFFER, h.DEPTH_ATTACHMENT, h.RENDERBUFFER, this._depthRenderBuffer));
        h.checkFramebufferStatus(h.FRAMEBUFFER) !== h.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
        s.setAliasTexParameters();
        a = g.sprite = new cc.Sprite(s);
        a.scaleY = -1;
        a.setBlendFunc(h.ONE, h.ONE_MINUS_SRC_ALPHA);
        h.bindRenderbuffer(h.RENDERBUFFER,
            e);
        h.bindFramebuffer(h.FRAMEBUFFER, this._oldFBO);
        g.autoDraw = !1;
        g.addChild(a);
        return !0
    };
    a.begin = function () {
        var a = this._node;
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        var d = cc._renderContext, e = cc.director;
        e.setProjection(e.getProjection());
        var f = a._texture.getContentSizeInPixels(), g = cc.director.getWinSizeInPixels(), e = g.width / f.width, f = g.height / f.height, e = cc.math.Matrix4.createOrthographicProjection(-1 / e, 1 / e, -1 / f, 1 / f, -1, 1);
        cc.kmGLMultMatrix(e);
        e = new cc.Rect(0, 0, 0, 0);
        e.width = this._fullViewport.width;
        e.height = this._fullViewport.height;
        f = e.height / this._fullRect.height;
        e.x = e.width / this._fullRect.width * (this._fullRect.x - this._rtTextureRect.x);
        e.y = (this._fullRect.y - this._rtTextureRect.y) * f;
        d.viewport(e.x, e.y, e.width, e.height);
        this._oldFBO = d.getParameter(d.FRAMEBUFFER_BINDING);
        d.bindFramebuffer(d.FRAMEBUFFER, this._fBO);
        cc.configuration.checkForGLExtension("GL_QCOM") && (d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, this._textureCopy._webTextureObj,
            0), d.clear(d.COLOR_BUFFER_BIT | d.DEPTH_BUFFER_BIT), d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, a._texture._webTextureObj, 0))
    };
    a._beginWithClear = function (a, d, e, f, g, h, n) {
        a /= 255;
        d /= 255;
        e /= 255;
        f /= 255;
        var p = cc._renderContext, r = [0, 0, 0, 0], s = 0, t = 0;
        n & p.COLOR_BUFFER_BIT && (r = p.getParameter(p.COLOR_CLEAR_VALUE), p.clearColor(a, d, e, f));
        n & p.DEPTH_BUFFER_BIT && (s = p.getParameter(p.DEPTH_CLEAR_VALUE), p.clearDepth(g));
        n & p.STENCIL_BUFFER_BIT && (t = p.getParameter(p.STENCIL_CLEAR_VALUE), p.clearStencil(h));
        p.clear(n);
        n & p.COLOR_BUFFER_BIT && p.clearColor(r[0], r[1], r[2], r[3]);
        n & p.DEPTH_BUFFER_BIT && p.clearDepth(s);
        n & p.STENCIL_BUFFER_BIT && p.clearStencil(t)
    };
    a.end = function () {
        cc.renderer._renderingToBuffer(this._node.__instanceId);
        var a = cc._renderContext, d = cc.director;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        d.setViewport();
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    };
    a.clearRect = function (a, d, e, f) {
    };
    a.clearDepth = function (a) {
        var d = this._node;
        d.begin();
        var e = cc._renderContext, f = e.getParameter(e.DEPTH_CLEAR_VALUE);
        e.clearDepth(a);
        e.clear(e.DEPTH_BUFFER_BIT);
        e.clearDepth(f);
        d.end()
    };
    a.visit = function (a) {
        var d = this._node;
        d._visible && (cc.kmGLPushMatrix(), this._syncStatus(a), cc.renderer.pushRenderCommand(this), d.sprite.visit(this), this._dirtyFlag = 0, cc.kmGLPopMatrix())
    }
})();
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null, _mapStartChar: null, _textureLoaded: !1, _className: "LabelAtlas", ctor: function (a, b, d, e, f) {
        cc.AtlasNode.prototype.ctor.call(this);
        this._renderCmd.setCascade();
        b && cc.LabelAtlas.prototype.initWithString.call(this, a, b, d, e, f)
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this)
    }, textureLoaded: function () {
        return this._textureLoaded
    }, addLoadedEventListener: function (a,
                                         b) {
        this.addEventListener("load", a, b)
    }, initWithString: function (a, b, d, e, f) {
        var g = a + "", h, n;
        if (void 0 === d) {
            d = cc.loader.getRes(b);
            if (1 !== parseInt(d.version, 10))return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            b = cc.path.changeBasename(b, d.textureFilename);
            e = cc.contentScaleFactor();
            h = parseInt(d.itemWidth, 10) / e;
            n = parseInt(d.itemHeight, 10) / e;
            d = String.fromCharCode(parseInt(d.firstChar, 10))
        } else h = d || 0, n = e || 0, d = f || " ";
        var p = null, p = b instanceof cc.Texture2D ? b : cc.textureCache.addImage(b);
        this._textureLoaded = b = p.isLoaded();
        b || (this._string = g, p.addEventListener("load", function (a) {
            this.initWithTexture(p, h, n, g.length);
            this.string = this._string;
            this.setColor(this._renderCmd._displayedColor);
            this.dispatchEvent("load")
        }, this));
        return this.initWithTexture(p, h, n, g.length) ? (this._mapStartChar = d, this.string = g, !0) : !1
    }, setColor: function (a) {
        cc.AtlasNode.prototype.setColor.call(this, a);
        this._renderCmd.updateAtlasValues()
    }, getString: function () {
        return this._string
    }, addChild: function (a, b, d) {
        this._renderCmd._addChild(a);
        cc.Node.prototype.addChild.call(this, a, b, d)
    }, updateAtlasValues: function () {
        this._renderCmd.updateAtlasValues()
    }, setString: function (a) {
        a = String(a);
        var b = a.length;
        this._string = a;
        this.setContentSize(b * this._itemWidth, this._itemHeight);
        this._renderCmd.setString(a);
        this._renderCmd.updateAtlasValues();
        this.quadsToDraw = b
    }
});
(function () {
    var a = cc.LabelAtlas.prototype;
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "string", a.getString, a.setString)
})();
cc.LabelAtlas.create = function (a, b, d, e, f) {
    return new cc.LabelAtlas(a, b, d, e, f)
};
(function () {
    cc.LabelAtlas.CanvasRenderCmd = function (a) {
        cc.AtlasNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
    a.constructor = cc.LabelAtlas.CanvasRenderCmd;
    a.setCascade = function () {
        var a = this._node;
        a._cascadeOpacityEnabled = !0;
        a._cascadeColorEnabled = !1
    };
    a.updateAtlasValues = function () {
        for (var a = this._node, d = a._string || "", e = d.length, f = this._textureToRender, g = a._itemWidth, h = a._itemHeight, n = 0, p = -1; n < e; n++) {
            var r =
                d.charCodeAt(n) - a._mapStartChar.charCodeAt(0), s = parseInt(r % a._itemsPerRow, 10), r = parseInt(r / a._itemsPerRow, 10);
            if (!(0 > s || 0 > r || (s = cc.rect(s * g, r * h, g, h), r = f._contentSize, 0 > s.x || 0 > s.y || s.x + s.width > r.width || s.y + s.height > r.height))) {
                p++;
                var r = d.charCodeAt(n), t = a.getChildByTag(n);
                t ? 32 === r ? (t.init(), t.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (t.initWithTexture(f, s), t.visible = !0) : (t = new cc.Sprite, 32 === r ? (t.init(), t.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : t.initWithTexture(f, s), cc.Node.prototype.addChild.call(a,
                    t, 0, n));
                t.setPosition(p * g + g / 2, h / 2)
            }
        }
        this.updateContentSize(n, p + 1)
    };
    a.updateContentSize = function (a, d) {
        var e = this._node, f = e._contentSize;
        a !== d && a * e._itemWidth === f.width && e._itemHeight === f.height && e.setContentSize(d * e._itemWidth, e._itemHeight)
    };
    a.setString = function (a) {
        a = this._node;
        if (a._children) {
            a = a._children;
            for (var d = a.length, e = 0; e < d; e++) {
                var f = a[e];
                f && !f._lateChild && (f.visible = !1)
            }
        }
    };
    a._addChild = function () {
        child._lateChild = !0
    }
})();
(function () {
    cc.LabelAtlas.WebGLRenderCmd = function (a) {
        cc.AtlasNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelAtlas.WebGLRenderCmd;
    a.setCascade = function () {
        var a = this._node;
        a._cascadeOpacityEnabled = !0;
        a._cascadeColorEnabled = !0
    };
    a.rendering = function (a) {
        cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, a);
        if (cc.LABELATLAS_DEBUG_DRAW) {
            var d = this._node;
            a = d.getContentSize();
            var d = d.getBoundingBoxToWorld(), e = d.x, f = d.y;
            a.width = d.width;
            a.height = d.height;
            a = [cc.p(e, f), cc.p(e + a.width, f), cc.p(a.width + e, a.height + f), cc.p(e, f + a.height)];
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    };
    a.updateAtlasValues = function () {
        var a = this._node, d = a._string, e = d.length, f = this._textureAtlas, g = f.texture, h = g.pixelsWidth, g = g.pixelsHeight, n = a._itemWidth, p = a._itemHeight;
        a._ignoreContentScaleFactor || (n = a._itemWidth * cc.contentScaleFactor(), p = a._itemHeight * cc.contentScaleFactor());
        e > f.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var r = f.quads, s = this._displayedColor, s = {
            r: s.r,
            g: s.g,
            b: s.b,
            a: a._displayedOpacity
        }, t = a._itemWidth, v = a._itemHeight, u = 0, x = -1; u < e; u++) {
            var w = d.charCodeAt(u) - a._mapStartChar.charCodeAt(0), y = w % a._itemsPerRow, A = 0 | w / a._itemsPerRow;
            if (!(0 > y || 0 > A || y * t + t > h || A * v + v > g)) {
                x++;
                var D;
                cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (y = (2 * y * n + 1) / (2 * h), w = y + (2 * n - 2) / (2 * h), A = (2 * A * p + 1) / (2 * g), D = A + (2 * p - 2) / (2 * g)) : (y = y * n / h, w = y + n / h, A = A * p / g, D = A + p / g);
                var G = r[u], B = G.tl, C = G.tr, E = G.bl, G = G.br;
                B.texCoords.u = y;
                B.texCoords.v = A;
                C.texCoords.u = w;
                C.texCoords.v = A;
                E.texCoords.u = y;
                E.texCoords.v = D;
                G.texCoords.u = w;
                G.texCoords.v = D;
                E.vertices.x = x * t;
                E.vertices.y = 0;
                E.vertices.z = 0;
                G.vertices.x = x * t + t;
                G.vertices.y = 0;
                G.vertices.z = 0;
                B.vertices.x = x * t;
                B.vertices.y = a._itemHeight;
                B.vertices.z = 0;
                C.vertices.x = x * t + t;
                C.vertices.y = a._itemHeight;
                C.vertices.z = 0;
                B.colors = s;
                C.colors = s;
                E.colors = s;
                G.colors = s
            }
        }
        this.updateContentSize(u, x + 1);
        0 < e && (f.dirty = !0, a = f.totalQuads, e > a && f.increaseTotalQuadsWith(e - a))
    };
    a.updateContentSize = function (a, d) {
        var e = this._node, f = e._contentSize;
        a !== d && a * e._itemWidth === f.width && e._itemHeight === f.height && e.setContentSize(d * e._itemWidth, e._itemHeight)
    };
    a.setString = function (a) {
        a = a.length;
        a > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(a)
    };
    a._addChild = function () {
    }
})();
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _textureLoaded: !1,
    _className: "LabelBMFont",
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
    },
    _setString: function (a, b) {
        b ? this._initialString = a : this._string = a;
        var d = this._children;
        if (d)for (var e = 0; e < d.length; e++) {
            var f = d[e];
            f && f.setVisible(!1)
        }
        this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
    },
    ctor: function (a, b, d, e, f) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._imageOffset = cc.p(0, 0);
        this._reusedChar = [];
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
        this.initWithString(a, b, d, e, f)
    },
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a, b) {
        this.addEventListener("load", a, b)
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function (a) {
        this._opacityModifyRGB = a;
        if (a = this._children)for (var b = 0; b < a.length; b++) {
            var d = a[b];
            d && (d.opacityModifyRGB = this._opacityModifyRGB)
        }
    },
    _changeTextureColor: function () {
        this._renderCmd._changeTextureColor()
    },
    init: function () {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function (a, b, d, e, f) {
        a = a || "";
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        if (b) {
            var g = cc.loader.getRes(b);
            if (!g)return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"),
                !1;
            this._config = g;
            this._fntFile = b;
            b = cc.textureCache.addImage(g.atlasName);
            (this._textureLoaded = g = b.isLoaded()) || b.addEventListener("load", function (a) {
                this._textureLoaded = !0;
                this.initWithTexture(a, this._initialString.length);
                this.setString(this._initialString, !0);
                this.dispatchEvent("load")
            }, this)
        } else b = new cc.Texture2D, g = new Image, b.initWithElement(g), this._textureLoaded = !1;
        return this.initWithTexture(b, a.length) ? (this._alignment = e || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = f || cc.p(0, 0), this._width =
            null == d ? -1 : d, this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), this._renderCmd._initBatchTexture(), this.setString(a, !0), !0) : !1
    },
    createFontChars: function () {
        var a = this._renderCmd._texture || this.textureAtlas.texture, b = 0, d = cc.size(0, 0), e = 0, f = 1, g = this._string, h = g ? g.length : 0;
        if (0 !== h) {
            var n, p = this._config, r = p.kerningDict, s = p.commonHeight, t = p.fontDefDictionary;
            for (n = 0; n < h - 1; n++)10 === g.charCodeAt(n) && f++;
            var v =
                s * f, f = -(s - s * f), u = -1;
            for (n = 0; n < h; n++)if (s = g.charCodeAt(n), 0 !== s)if (10 === s)b = 0, f -= p.commonHeight; else {
                var u = r[u << 16 | s & 65535] || 0, x = t[s];
                x || (cc.log("cocos2d: LabelBMFont: character not found " + g[n]), x = {
                    rect: {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }, xOffset: 0, yOffset: 0, xAdvance: 0
                });
                var w = cc.rect(x.rect.x, x.rect.y, x.rect.width, x.rect.height), w = cc.rectPixelsToPoints(w);
                w.x += this._imageOffset.x;
                w.y += this._imageOffset.y;
                var y = this.getChildByTag(n);
                y ? this._renderCmd._updateCharTexture(y, w, s) : (y = new cc.Sprite, y.initWithTexture(a,
                    w, !1), y._newTextureWhenChangeColor = !0, this.addChild(y, 0, n));
                y.opacityModifyRGB = this._opacityModifyRGB;
                this._renderCmd._updateCharColorAndOpacity(y);
                w = cc.p(b + x.xOffset + 0.5 * x.rect.width + u, f + (p.commonHeight - x.yOffset) - 0.5 * w.height * cc.contentScaleFactor());
                y.setPosition(cc.pointPixelsToPoints(w));
                b += x.xAdvance + u;
                u = s;
                e < b && (e = b)
            }
            d.width = x && x.xAdvance < x.rect.width ? e - x.xAdvance + x.rect.width : e;
            d.height = v;
            this.setContentSize(cc.sizePixelsToPoints(d))
        }
    },
    updateString: function (a) {
        var b = this._children;
        if (b)for (var d =
            0, e = b.length; d < e; d++) {
            var f = b[d];
            f && (f.visible = !1)
        }
        this._config && this.createFontChars();
        a || this.updateLabel()
    },
    getString: function () {
        return this._initialString
    },
    setString: function (a, b) {
        a = String(a);
        null == b && (b = !0);
        null != a && cc.isString(a) || (a += "");
        this._initialString = a;
        this._setString(a, b)
    },
    _setStringForSetter: function (a) {
        this.setString(a, !1)
    },
    setCString: function (a) {
        this.setString(a, !0)
    },
    _getCharsWidth: function (a, b) {
        if (0 >= b)return 0;
        var d = this.getChildByTag(a), e = this.getChildByTag(a + b);
        return this._getLetterPosXLeft(e) -
            this._getLetterPosXLeft(d)
    },
    _checkWarp: function (a, b, d, e) {
        for (var f = a[b], g = 0, h = 0; h < b; h++)g += a[h].length;
        var g = g + b - e, n = this._getCharsWidth(g, a[b].length - 1);
        if (n > d && 1 < f.length) {
            e = d / n * f.length | 0;
            for (var h = f.substr(e), p = n - this._getCharsWidth(g + e, h.length - 1), r, s = 0, t = 0; p > d && 100 > t++;)e *= d / p, e |= 0, h = f.substr(e), p = n - this._getCharsWidth(g + e, h.length - 1);
            for (t = 0; p < d && 100 > t++;)h && (s = (r = cc.LabelTTF._wordRex.exec(h)) ? r[0].length : 1, r = h), this._lineBreakWithoutSpaces && (s = 0), e += s, h = f.substr(e), p = n - this._getCharsWidth(g +
                    e, h.length - 1);
            e -= s;
            0 === e && (e = 1, r = r.substr(1));
            d = f.substr(0, e);
            cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(r || h) && (s = (g = cc.LabelTTF._lastWordRex.exec(d)) ? g[0].length : 0, this._lineBreakWithoutSpaces && (s = 0), e -= s, r = f.substr(e), d = f.substr(0, e));
            cc.LabelTTF._firsrEnglish.test(r) && (g = cc.LabelTTF._lastEnglish.exec(d)) && d !== g[0] && (s = g[0].length, this._lineBreakWithoutSpaces && (s = 0), e -= s, r = f.substr(e), d = f.substr(0, e));
            a[b] = r || h;
            a.splice(b, 0, d)
        }
    },
    updateLabel: function () {
        this.string = this._initialString;
        var a, b, d;
        if (0 < this._width) {
            var e = this.string.split("\n"), f = "", g = 0, h = 0;
            for (a = 0; a < e.length; a++)h = e.length, this._checkWarp(e, a, this._width * this._scaleX, g), h < e.length && g++, 0 < a && (f += "\n"), f += e[a];
            f += String.fromCharCode(0);
            this._setString(f, !1)
        }
        if (this._alignment !== cc.TEXT_ALIGNMENT_LEFT)for (e = a = 0, f = this._string.length, g = [], h = 0; h < f; h++)if (10 === this._string[h].charCodeAt(0) || 0 === this._string[h].charCodeAt(0)) {
            b = 0;
            var n = g.length;
            if (0 === n)e++; else if (d = a + n - 1 + e, !(0 > d)) {
                var p = this.getChildByTag(d);
                if (null !=
                    p) {
                    b = p.getPositionX() + p._getWidth() / 2;
                    p = 0;
                    switch (this._alignment) {
                        case cc.TEXT_ALIGNMENT_CENTER:
                            p = this.width / 2 - b / 2;
                            break;
                        case cc.TEXT_ALIGNMENT_RIGHT:
                            p = this.width - b
                    }
                    if (0 !== p)for (b = 0; b < n; b++)d = a + b + e, 0 > d || (d = this.getChildByTag(d)) && (d.x += p);
                    a += n;
                    e++;
                    g.length = 0
                }
            }
        } else g.push(this._string[a])
    },
    setAlignment: function (a) {
        this._alignment = a;
        this.updateLabel()
    },
    _getAlignment: function () {
        return this._alignment
    },
    setBoundingWidth: function (a) {
        this._width = a;
        this.updateLabel()
    },
    _getBoundingWidth: function () {
        return this._width
    },
    setLineBreakWithoutSpace: function (a) {
        this._lineBreakWithoutSpaces = a;
        this.updateLabel()
    },
    setScale: function (a, b) {
        cc.Node.prototype.setScale.call(this, a, b);
        this.updateLabel()
    },
    setScaleX: function (a) {
        cc.Node.prototype.setScaleX.call(this, a);
        this.updateLabel()
    },
    setScaleY: function (a) {
        cc.Node.prototype.setScaleY.call(this, a);
        this.updateLabel()
    },
    setFntFile: function (a) {
        if (null != a && a !== this._fntFile) {
            var b = cc.loader.getRes(a);
            b ? (this._fntFile = a, this._config = b, a = cc.textureCache.addImage(b.atlasName), this._textureLoaded =
                b = a.isLoaded(), this.texture = a, b ? this.createFontChars() : a.addEventListener("load", function (a) {
                this._textureLoaded = !0;
                this.texture = a;
                this.createFontChars();
                this._changeTextureColor();
                this.updateLabel();
                this.dispatchEvent("load")
            }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function () {
        return this._fntFile
    },
    setTexture: function (a) {
        this._renderCmd.setTexture(a)
    },
    setAnchorPoint: function (a, b) {
        cc.Node.prototype.setAnchorPoint.call(this, a, b);
        this.updateLabel()
    },
    _setAnchorX: function (a) {
        cc.Node.prototype._setAnchorX.call(this, a);
        this.updateLabel()
    },
    _setAnchorY: function (a) {
        cc.Node.prototype._setAnchorY.call(this, a);
        this.updateLabel()
    },
    _atlasNameFromFntFile: function (a) {
    },
    _kerningAmountForFirst: function (a, b) {
        var d = 0;
        if (this._configuration.kerningDictionary) {
            var e = this._configuration.kerningDictionary[(a << 16 | b & 65535).toString()];
            e && (d = e.amount)
        }
        return d
    },
    _getLetterPosXLeft: function (a) {
        return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _getLetterPosXRight: function (a) {
        return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _isspace_unicode: function (a) {
        a = a.charCodeAt(0);
        return 9 <= a && 13 >= a || 32 === a || 133 === a || 160 === a || 5760 === a || 8192 <= a && 8202 >= a || 8232 === a || 8233 === a || 8239 === a || 8287 === a || 12288 === a
    },
    _utf8_trim_ws: function (a) {
        var b = a.length;
        if (!(0 >= b) && (b -= 1, this._isspace_unicode(a[b]))) {
            for (var d = b - 1; 0 <= d; --d)if (this._isspace_unicode(a[d]))b = d; else break;
            this._utf8_trim_from(a, b)
        }
    },
    _utf8_trim_from: function (a, b) {
        var d =
            a.length;
        b >= d || 0 > b || a.splice(b, d)
    }
});
(function () {
    var a = cc.LabelBMFont.prototype;
    cc.EventHelper.prototype.apply(a);
    cc.defineGetterSetter(a, "string", a.getString, a._setStringForSetter);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a.setBoundingWidth);
    cc.defineGetterSetter(a, "textAlign", a._getAlignment, a.setAlignment)
})();
cc.LabelBMFont.create = function (a, b, d, e, f) {
    return new cc.LabelBMFont(a, b, d, e, f)
};
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function (a) {
        a = a.match(this.ITEM_EXP);
        var b = {};
        if (a)for (var d = 0, e = a.length; d < e; d++) {
            var f = a[d], g = f.indexOf("\x3d"), h = f.substring(0, g), f = f.substring(g + 1);
            f.match(this.INT_EXP) ? f = parseInt(f) : '"' === f[0] && (f = f.substring(1, f.length - 1));
            b[h] = f
        }
        return b
    },
    parseFnt: function (a,
                        b) {
        var d = {}, e = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
        parseInt(e[0]);
        parseInt(e[1]);
        parseInt(e[2]);
        parseInt(e[3]);
        e = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
        d.commonHeight = e.lineHeight;
        if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
            var f = cc.configuration.getMaxTextureSize();
            (e.scaleW > f.width || e.scaleH > f.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== e.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
        e = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
        0 !== e.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
        d.atlasName = cc.path.changeBasename(b, e.file);
        for (var g = a.match(this.CHAR_EXP), h = d.fontDefDictionary = {}, e = 0, f = g.length; e < f; e++) {
            var n = this._parseStrToObj(g[e]);
            h[n.id] = {
                rect: {x: n.x, y: n.y, width: n.width, height: n.height},
                xOffset: n.xoffset,
                yOffset: n.yoffset,
                xAdvance: n.xadvance
            }
        }
        g = d.kerningDict = {};
        if (h = a.match(this.KERNING_EXP))for (e = 0, f = h.length; e < f; e++)n = this._parseStrToObj(h[e]),
            g[n.first << 16 | n.second & 65535] = n.amount;
        return d
    },
    load: function (a, b, d, e) {
        var f = this;
        cc.loader.loadTxt(a, function (a, d) {
            if (a)return e(a);
            e(null, f.parseFnt(d, b))
        })
    }
};
cc.loader.register(["fnt"], cc._fntLoader);
(function () {
    cc.LabelBMFont.CanvasRenderCmd = function (a) {
        cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
    a.constructor = cc.LabelBMFont.CanvasRenderCmd;
    a.rendering = function () {
        void 0
    };
    a._updateCharTexture = function (a, d, e) {
        32 === e ? a.setTextureRect(d, !1, cc.size(0, 0)) : (a.setTextureRect(d, !1), a.visible = !0)
    };
    a._updateCharColorAndOpacity = function (a) {
        a._displayedColor = this._displayedColor;
        a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        a._displayedOpacity = this._displayedOpacity;
        a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    };
    a.setTexture = function (a) {
        for (var d = this._node._children, e = this._displayedColor, f = 0; f < d.length; f++) {
            var g = d[f], h = g._renderCmd, n = h._displayedColor;
            if (this._texture === h._texture || n.r === e.r && n.g === e.g && n.b === e.b)g.texture = a
        }
        this._texture = a
    };
    a._changeTextureColor = function () {
        var a = this._node, d = this._textureToRender, e = d.getContentSize(), a = a._texture,
            f = a.getHtmlElementObj(), g = this._displayedColor, h = cc.rect(0, 0, f.width, f.height);
        d && 0 < e.width && f && (this._textureToRender = a._generateColorTexture(g.r, g.g, g.b, h))
    };
    a._updateChildrenDisplayedOpacity = function (a) {
        cc.Node.prototype.updateDisplayedOpacity.call(a, this._displayedOpacity)
    };
    a._updateChildrenDisplayedColor = function (a) {
        cc.Node.prototype.updateDisplayedColor.call(a, this._displayedColor)
    };
    a._initBatchTexture = function () {
    }
})();
(function () {
    cc.LabelBMFont.WebGLRenderCmd = function (a) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelBMFont.WebGLRenderCmd;
    a._updateCharTexture = function (a, d, e) {
        a.setTextureRect(d, !1);
        a.visible = !0
    };
    a._changeTextureColor = function () {
    };
    a._updateChildrenDisplayedOpacity = function (a) {
        a.updateDisplayedOpacity(this._displayedOpacity)
    };
    a._updateChildrenDisplayedColor =
        function (a) {
            a.updateDisplayedColor(this._displayedColor)
        };
    a._initBatchTexture = function () {
        var a = this._node, d = a.textureAtlas.texture;
        a._opacityModifyRGB = d.hasPremultipliedAlpha();
        var e = a._reusedChar = new cc.Sprite;
        e.initWithTexture(d, cc.rect(0, 0, 0, 0), !1);
        e.batchNode = a
    };
    a.rendering = function (a) {
        cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, a);
        a = this._node;
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            a = a.getContentSize();
            var d = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            a = [cc.p(d.x,
                d.y), cc.p(d.x + a.width, d.y), cc.p(d.x + a.width, d.y + a.height), cc.p(d.x, d.y + a.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255);
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    };
    a._updateCharColorAndOpacity = function () {
    }
})();
cc.MotionStreak = cc.Node.extend({
    texture: null,
    fastMode: !1,
    startingPositionInitialized: !1,
    _blendFunc: null,
    _stroke: 0,
    _fadeDelta: 0,
    _minSeg: 0,
    _maxPoints: 0,
    _nuPoints: 0,
    _previousNuPoints: 0,
    _pointVertexes: null,
    _pointState: null,
    _vertices: null,
    _colorPointer: null,
    _texCoords: null,
    _verticesBuffer: null,
    _colorPointerBuffer: null,
    _texCoordsBuffer: null,
    _className: "MotionStreak",
    ctor: function (a, b, d, e, f) {
        cc.Node.prototype.ctor.call(this);
        this._positionR = cc.p(0, 0);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        this.startingPositionInitialized = this.fastMode = !1;
        this.texture = null;
        this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0;
        this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null;
        void 0 !== f && this.initWithFade(a, b, d, e, f)
    },
    getTexture: function () {
        return this.texture
    },
    setTexture: function (a) {
        this.texture !== a && (this.texture = a)
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a, b) {
        void 0 === b ? this._blendFunc = a : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getOpacity: function () {
        cc.log("cc.MotionStreak.getOpacity has not been supported.");
        return 0
    },
    setOpacity: function (a) {
        cc.log("cc.MotionStreak.setOpacity has not been supported.")
    },
    setOpacityModifyRGB: function (a) {
    },
    isOpacityModifyRGB: function () {
        return !1
    },
    isFastMode: function () {
        return this.fastMode
    },
    setFastMode: function (a) {
        this.fastMode = a
    },
    isStartingPositionInitialized: function () {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function (a) {
        this.startingPositionInitialized = a
    },
    getStroke: function () {
        return this._stroke
    },
    setStroke: function (a) {
        this._stroke = a
    },
    initWithFade: function (a, b, d, e, f) {
        if (!f)throw Error("cc.MotionStreak.initWithFade(): Invalid filename or texture");
        cc.isString(f) && (f = cc.textureCache.addImage(f));
        cc.Node.prototype.setPosition.call(this, cc.p(0, 0));
        this.anchorY = this.anchorX = 0;
        this.ignoreAnchor = !0;
        this.startingPositionInitialized = !1;
        this.fastMode = !0;
        this._minSeg = -1 === b ? d / 5 : b;
        this._minSeg *=
            this._minSeg;
        this._stroke = d;
        this._fadeDelta = 1 / a;
        this._maxPoints = a = (0 | 60 * a) + 2;
        this._nuPoints = 0;
        this._pointState = new Float32Array(a);
        this._pointVertexes = new Float32Array(2 * a);
        this._vertices = new Float32Array(4 * a);
        this._texCoords = new Float32Array(4 * a);
        this._colorPointer = new Uint8Array(8 * a);
        this._verticesBuffer = gl.createBuffer();
        this._texCoordsBuffer = gl.createBuffer();
        this._colorPointerBuffer = gl.createBuffer();
        this._blendFunc.src = gl.SRC_ALPHA;
        this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
        this.texture = f;
        this.color =
            e;
        this.scheduleUpdate();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW);
        return !0
    },
    tintWithColor: function (a) {
        this.color = a;
        for (var b = this._colorPointer, d = 0, e = 2 * this._nuPoints; d < e; d++)b[4 * d] = a.r, b[4 * d +
        1] = a.g, b[4 * d + 2] = a.b
    },
    reset: function () {
        this._nuPoints = 0
    },
    setPosition: function (a, b) {
        this.startingPositionInitialized = !0;
        void 0 === b ? (this._positionR.x = a.x, this._positionR.y = a.y) : (this._positionR.x = a, this._positionR.y = b)
    },
    getPositionX: function () {
        return this._positionR.x
    },
    setPositionX: function (a) {
        this._positionR.x = a;
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    getPositionY: function () {
        return this._positionR.y
    },
    setPositionY: function (a) {
        this._positionR.y = a;
        this.startingPositionInitialized ||
        (this.startingPositionInitialized = !0)
    },
    update: function (a) {
        if (this.startingPositionInitialized) {
            this._renderCmd._updateDisplayColor();
            a *= this._fadeDelta;
            var b, d, e, f, g = 0, h = this._nuPoints, n = this._pointState, p = this._pointVertexes, r = this._vertices, s = this._colorPointer;
            for (e = 0; e < h; e++)n[e] -= a, 0 >= n[e] ? g++ : (b = e - g, 0 < g ? (n[b] = n[e], p[2 * b] = p[2 * e], p[2 * b + 1] = p[2 * e + 1], f = 2 * e, d = 2 * b, r[2 * d] = r[2 * f], r[2 * d + 1] = r[2 * f + 1], r[2 * (d + 1)] = r[2 * (f + 1)], r[2 * (d + 1) + 1] = r[2 * (f + 1) + 1], f *= 4, d *= 4, s[d + 0] = s[f + 0], s[d + 1] = s[f + 1], s[d + 2] = s[f + 2], s[d +
            4] = s[f + 4], s[d + 5] = s[f + 5], s[d + 6] = s[f + 6]) : d = 8 * b, b = 255 * n[b], s[d + 3] = b, s[d + 7] = b);
            h -= g;
            e = !0;
            h >= this._maxPoints ? e = !1 : 0 < h && (a = cc.pDistanceSQ(cc.p(p[2 * (h - 1)], p[2 * (h - 1) + 1]), this._positionR) < this._minSeg, d = 1 === h ? !1 : cc.pDistanceSQ(cc.p(p[2 * (h - 2)], p[2 * (h - 2) + 1]), this._positionR) < 2 * this._minSeg, a || d) && (e = !1);
            e && (p[2 * h] = this._positionR.x, p[2 * h + 1] = this._positionR.y, n[h] = 1, n = 8 * h, e = this.getDisplayedColor(), s[n] = e.r, s[n + 1] = e.g, s[n + 2] = e.b, s[n + 4] = e.r, s[n + 5] = e.g, s[n + 6] = e.b, s[n + 3] = 255, s[n + 7] = 255, 0 < h && this.fastMode && (1 < h ?
                cc.vertexLineToPolygon(p, this._stroke, this._vertices, h, 1) : cc.vertexLineToPolygon(p, this._stroke, this._vertices, 0, 2)), h++);
            this.fastMode || cc.vertexLineToPolygon(p, this._stroke, this._vertices, 0, h);
            if (h && this._previousNuPoints !== h) {
                p = 1 / h;
                s = this._texCoords;
                for (e = 0; e < h; e++)s[4 * e] = 0, s[4 * e + 1] = p * e, s[2 * (2 * e + 1)] = 1, s[2 * (2 * e + 1) + 1] = p * e;
                this._previousNuPoints = h
            }
            this._nuPoints = h
        }
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.MotionStreak.WebGLRenderCmd(this) : null
    }
});
cc.MotionStreak.create = function (a, b, d, e, f) {
    return new cc.MotionStreak(a, b, d, e, f)
};
cc.MotionStreak.WebGLRenderCmd = function (a) {
    cc.Node.WebGLRenderCmd.call(this, a);
    this._needDraw = !0;
    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
};
cc.MotionStreak.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
cc.MotionStreak.WebGLRenderCmd.prototype.constructor = cc.Sprite.WebGLRenderCmd;
cc.MotionStreak.WebGLRenderCmd.prototype.rendering = function (a) {
    var b = this._node;
    1 >= b._nuPoints || !b.texture || !b.texture.isLoaded() || (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(b.texture), a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), a.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), a.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), a.bindBuffer(a.ARRAY_BUFFER,
        b._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, b._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, b._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, b._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP,
        0, 2 * b._nuPoints), cc.g_NumberOfDraws++)
};
cc.NodeGrid = cc.Node.extend({
    grid: null, _target: null, _gridRect: null, ctor: function (a) {
        cc.Node.prototype.ctor.call(this);
        void 0 === a && (a = cc.rect());
        this._gridRect = a
    }, getGrid: function () {
        return this.grid
    }, setGrid: function (a) {
        this.grid = a
    }, setGridRect: function (a) {
        this._gridRect = a
    }, getGridRect: function () {
        return this._gridRect
    }, setTarget: function (a) {
        this._target = a
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.NodeGrid.WebGLRenderCmd(this) : new cc.Node.CanvasRenderCmd(this)
    }
});
_p = cc.NodeGrid.prototype;
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
cc.NodeGrid.create = function () {
    return new cc.NodeGrid
};
(function () {
    cc.NodeGrid.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !1;
        this._gridBeginCommand = new cc.CustomRenderCmd(this, this.onGridBeginDraw);
        this._gridEndCommand = new cc.CustomRenderCmd(this, this.onGridEndDraw)
    };
    var a = cc.NodeGrid.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.NodeGrid.WebGLRenderCmd;
    a.visit = function (a) {
        var d = this._node;
        if (d._visible) {
            a = a || this.getParentRenderCmd();
            d._parent && d._parent._renderCmd && (this._curLevel =
                d._parent._renderCmd._curLevel + 1);
            var e = cc.current_stack;
            e.stack.push(e.top);
            this._syncStatus(a);
            e.top = this._stackMatrix;
            cc.renderer.pushRenderCommand(this._gridBeginCommand);
            d._target && d._target.visit();
            if ((a = d._children) && 0 < a.length) {
                var f = a.length;
                d.sortAllChildren();
                for (d = 0; d < f; d++) {
                    var g = a[d];
                    g && g.visit()
                }
            }
            cc.renderer.pushRenderCommand(this._gridEndCommand);
            this._dirtyFlag = 0;
            e.top = e.stack.pop()
        }
    };
    a.onGridBeginDraw = function () {
        var a = this._node.grid;
        a && a._active && a.beforeDraw()
    };
    a.onGridEndDraw =
        function () {
            var a = this._node.grid;
            a && a._active && a.afterDraw(this._node)
        }
})();
cc.v2fzero = function () {
    return {x: 0, y: 0}
};
cc.v2f = function (a, b) {
    return {x: a, y: b}
};
cc.v2fadd = function (a, b) {
    return cc.v2f(a.x + b.x, a.y + b.y)
};
cc.v2fsub = function (a, b) {
    return cc.v2f(a.x - b.x, a.y - b.y)
};
cc.v2fmult = function (a, b) {
    return cc.v2f(a.x * b, a.y * b)
};
cc.v2fperp = function (a) {
    return cc.v2f(-a.y, a.x)
};
cc.v2fneg = function (a) {
    return cc.v2f(-a.x, -a.y)
};
cc.v2fdot = function (a, b) {
    return a.x * b.x + a.y * b.y
};
cc.v2fforangle = function (a) {
    return cc.v2f(Math.cos(a), Math.sin(a))
};
cc.v2fnormalize = function (a) {
    a = cc.pNormalize(cc.p(a.x, a.y));
    return cc.v2f(a.x, a.y)
};
cc.__v2f = function (a) {
    return cc.v2f(a.x, a.y)
};
cc.__t = function (a) {
    return {u: a.x, v: a.y}
};
cc.DrawNode = cc.Node.extend({
    _buffer: null, _blendFunc: null, _lineWidth: 1, _drawColor: null, getBlendFunc: function () {
        return this._blendFunc
    }, setBlendFunc: function (a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    }, setLineWidth: function (a) {
        this._lineWidth = a
    }, getLineWidth: function () {
        return this._lineWidth
    }, setDrawColor: function (a) {
        var b = this._drawColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = null == a.a ? 255 : a.a
    }, getDrawColor: function () {
        return cc.color(this._drawColor.r,
            this._drawColor.g, this._drawColor.b, this._drawColor.a)
    }
});
cc.DrawNode.create = function () {
    return new cc.DrawNode
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    cc._renderType === cc.game.RENDER_TYPE_CANVAS ? (cc._DrawNodeElement = function (a, b, d, e, f, g, h, n, p) {
        this.type = a;
        this.verts = b || null;
        this.fillColor = d || null;
        this.lineWidth = e || 0;
        this.lineColor = f || null;
        this.lineCap = g || "butt";
        this.isClosePolygon = h || !1;
        this.isFill = n || !1;
        this.isStroke = p || !1
    }, cc.extend(cc.DrawNode.prototype, {
        _className: "DrawNodeCanvas", ctor: function () {
            cc.Node.prototype.ctor.call(this);
            var a = this._renderCmd;
            a._buffer = this._buffer = [];
            a._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
            a._blendFunc = this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            this.init()
        }, drawRect: function (a, b, d, e, f) {
            e = null == e ? this._lineWidth : e;
            f = f || this.getDrawColor();
            null == f.a && (f.a = 255);
            a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
            b = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            b.verts = a;
            b.lineWidth = e;
            b.lineColor = f;
            b.isClosePolygon = !0;
            b.isStroke = !0;
            b.lineCap = "butt";
            if (b.fillColor = d)null == d.a && (d.a = 255), b.isFill = !0;
            this._buffer.push(b)
        }, drawCircle: function (a,
                                 b, d, e, f, g, h) {
            g = g || this._lineWidth;
            h = h || this.getDrawColor();
            null == h.a && (h.a = 255);
            for (var n = 2 * Math.PI / e, p = [], r = 0; r <= e; r++) {
                var s = r * n, t = b * Math.cos(s + d) + a.x, s = b * Math.sin(s + d) + a.y;
                p.push(cc.p(t, s))
            }
            f && p.push(cc.p(a.x, a.y));
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = p;
            a.lineWidth = g;
            a.lineColor = h;
            a.isClosePolygon = !0;
            a.isStroke = !0;
            this._buffer.push(a)
        }, drawQuadBezier: function (a, b, d, e, f, g) {
            f = f || this._lineWidth;
            g = g || this.getDrawColor();
            null == g.a && (g.a = 255);
            for (var h = [], n = 0, p = 0; p < e; p++) {
                var r =
                    Math.pow(1 - n, 2) * a.x + 2 * (1 - n) * n * b.x + n * n * d.x, s = Math.pow(1 - n, 2) * a.y + 2 * (1 - n) * n * b.y + n * n * d.y;
                h.push(cc.p(r, s));
                n += 1 / e
            }
            h.push(cc.p(d.x, d.y));
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = h;
            a.lineWidth = f;
            a.lineColor = g;
            a.isStroke = !0;
            a.lineCap = "round";
            this._buffer.push(a)
        }, drawCubicBezier: function (a, b, d, e, f, g, h) {
            g = g || this._lineWidth;
            h = h || this.getDrawColor();
            null == h.a && (h.a = 255);
            for (var n = [], p = 0, r = 0; r < f; r++) {
                var s = Math.pow(1 - p, 3) * a.x + 3 * Math.pow(1 - p, 2) * p * b.x + 3 * (1 - p) * p * p * d.x + p * p * p * e.x, t = Math.pow(1 - p,
                        3) * a.y + 3 * Math.pow(1 - p, 2) * p * b.y + 3 * (1 - p) * p * p * d.y + p * p * p * e.y;
                n.push(cc.p(s, t));
                p += 1 / f
            }
            n.push(cc.p(e.x, e.y));
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = n;
            a.lineWidth = g;
            a.lineColor = h;
            a.isStroke = !0;
            a.lineCap = "round";
            this._buffer.push(a)
        }, drawCatmullRom: function (a, b, d, e) {
            this.drawCardinalSpline(a, 0.5, b, d, e)
        }, drawCardinalSpline: function (a, b, d, e, f) {
            e = e || this._lineWidth;
            f = f || this.getDrawColor();
            null == f.a && (f.a = 255);
            for (var g = [], h, n, p = 1 / a.length, r = 0; r < d + 1; r++)n = r / d, 1 === n ? (h = a.length - 1, n = 1) : (h = 0 |
                n / p, n = (n - p * h) / p), h = cc.cardinalSplineAt(cc.getControlPointAt(a, h - 1), cc.getControlPointAt(a, h - 0), cc.getControlPointAt(a, h + 1), cc.getControlPointAt(a, h + 2), b, n), g.push(h);
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = g;
            a.lineWidth = e;
            a.lineColor = f;
            a.isStroke = !0;
            a.lineCap = "round";
            this._buffer.push(a)
        }, drawDot: function (a, b, d) {
            d = d || this.getDrawColor();
            null == d.a && (d.a = 255);
            var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
            e.verts = [a];
            e.lineWidth = b;
            e.fillColor = d;
            this._buffer.push(e)
        }, drawDots: function (a,
                               b, d) {
            if (a && 0 != a.length) {
                d = d || this.getDrawColor();
                null == d.a && (d.a = 255);
                for (var e = 0, f = a.length; e < f; e++)this.drawDot(a[e], b, d)
            }
        }, drawSegment: function (a, b, d, e) {
            d = d || this._lineWidth;
            e = e || this.getDrawColor();
            null == e.a && (e.a = 255);
            var f = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            f.verts = [a, b];
            f.lineWidth = 2 * d;
            f.lineColor = e;
            f.isStroke = !0;
            f.lineCap = "round";
            this._buffer.push(f)
        }, drawPoly_: function (a, b, d, e) {
            d = null == d ? this._lineWidth : d;
            e = e || this.getDrawColor();
            null == e.a && (e.a = 255);
            var f = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            f.verts = a;
            f.fillColor = b;
            f.lineWidth = d;
            f.lineColor = e;
            f.isClosePolygon = !0;
            f.isStroke = !0;
            f.lineCap = "round";
            b && (f.isFill = !0);
            this._buffer.push(f)
        }, drawPoly: function (a, b, d, e) {
            for (var f = [], g = 0; g < a.length; g++)f.push(cc.p(a[g].x, a[g].y));
            return this.drawPoly_(f, b, d, e)
        }, clear: function () {
            this._buffer.length = 0
        }, _createRenderCmd: function () {
            return new cc.DrawNode.CanvasRenderCmd(this)
        }
    })) : cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.extend(cc.DrawNode.prototype, {
        _bufferCapacity: 0, _trianglesArrayBuffer: null,
        _trianglesWebBuffer: null, _trianglesReader: null, _dirty: !1, _className: "DrawNodeWebGL", ctor: function () {
            cc.Node.prototype.ctor.call(this);
            this._buffer = [];
            this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            this._drawColor = cc.color(255, 255, 255, 255);
            this.init()
        }, init: function () {
            return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(),
                this._dirty = !0) : !1
        }, drawRect: function (a, b, d, e, f) {
            e = null == e ? this._lineWidth : e;
            f = f || this.getDrawColor();
            null == f.a && (f.a = 255);
            a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
            null == d ? this._drawSegments(a, e, f, !0) : this.drawPoly(a, d, e, f)
        }, drawCircle: function (a, b, d, e, f, g, h) {
            g = g || this._lineWidth;
            h = h || this.getDrawColor();
            null == h.a && (h.a = 255);
            var n = 2 * Math.PI / e, p = [], r;
            for (r = 0; r <= e; r++) {
                var s = r * n, t = b * Math.cos(s + d) + a.x, s = b * Math.sin(s + d) + a.y;
                p.push(cc.p(t, s))
            }
            f && p.push(cc.p(a.x, a.y));
            g *= 0.5;
            r = 0;
            for (a = p.length; r < a - 1; r++)this.drawSegment(p[r],
                p[r + 1], g, h)
        }, drawQuadBezier: function (a, b, d, e, f, g) {
            f = f || this._lineWidth;
            g = g || this.getDrawColor();
            null == g.a && (g.a = 255);
            for (var h = [], n = 0, p = 0; p < e; p++) {
                var r = Math.pow(1 - n, 2) * a.x + 2 * (1 - n) * n * b.x + n * n * d.x, s = Math.pow(1 - n, 2) * a.y + 2 * (1 - n) * n * b.y + n * n * d.y;
                h.push(cc.p(r, s));
                n += 1 / e
            }
            h.push(cc.p(d.x, d.y));
            this._drawSegments(h, f, g, !1)
        }, drawCubicBezier: function (a, b, d, e, f, g, h) {
            g = g || this._lineWidth;
            h = h || this.getDrawColor();
            null == h.a && (h.a = 255);
            for (var n = [], p = 0, r = 0; r < f; r++) {
                var s = Math.pow(1 - p, 3) * a.x + 3 * Math.pow(1 - p, 2) * p * b.x +
                    3 * (1 - p) * p * p * d.x + p * p * p * e.x, t = Math.pow(1 - p, 3) * a.y + 3 * Math.pow(1 - p, 2) * p * b.y + 3 * (1 - p) * p * p * d.y + p * p * p * e.y;
                n.push(cc.p(s, t));
                p += 1 / f
            }
            n.push(cc.p(e.x, e.y));
            this._drawSegments(n, g, h, !1)
        }, drawCatmullRom: function (a, b, d, e) {
            this.drawCardinalSpline(a, 0.5, b, d, e)
        }, drawCardinalSpline: function (a, b, d, e, f) {
            e = e || this._lineWidth;
            f = f || this.getDrawColor();
            null == f.a && (f.a = 255);
            for (var g = [], h, n, p = 1 / a.length, r = 0; r < d + 1; r++)n = r / d, 1 === n ? (h = a.length - 1, n = 1) : (h = 0 | n / p, n = (n - p * h) / p), h = cc.cardinalSplineAt(cc.getControlPointAt(a, h - 1), cc.getControlPointAt(a,
                h - 0), cc.getControlPointAt(a, h + 1), cc.getControlPointAt(a, h + 2), b, n), g.push(h);
            e *= 0.5;
            a = 0;
            for (b = g.length; a < b - 1; a++)this.drawSegment(g[a], g[a + 1], e, f)
        }, _render: function () {
            var a = cc._renderContext;
            a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer);
            this._dirty && (a.bufferData(a.ARRAY_BUFFER, this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
            var b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
            a.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
            a.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12);
            a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length);
            cc.incrementGLDraws(1)
        }, _ensureCapacity: function (a) {
            var b = this._buffer;
            if (b.length + a > this._bufferCapacity) {
                var d = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                this._bufferCapacity += Math.max(this._bufferCapacity, a);
                if (null == b || 0 === b.length)this._buffer =
                    [], this._trianglesArrayBuffer = new ArrayBuffer(d * this._bufferCapacity), this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer); else {
                    a = [];
                    for (var e = new ArrayBuffer(d * this._bufferCapacity), f = 0; f < b.length; f++)a[f] = new cc.V2F_C4B_T2F_Triangle(b[f].a, b[f].b, b[f].c, e, f * d);
                    this._trianglesReader = new Uint8Array(e);
                    this._trianglesArrayBuffer = e;
                    this._buffer = a
                }
            }
        }, drawDot: function (a, b, d) {
            d = d || this.getDrawColor();
            null == d.a && (d.a = 255);
            var e = {r: 0 | d.r, g: 0 | d.g, b: 0 | d.b, a: 0 | d.a};
            d = {
                vertices: {x: a.x - b, y: a.y - b},
                colors: e, texCoords: {u: -1, v: -1}
            };
            var f = {
                vertices: {x: a.x - b, y: a.y + b},
                colors: e,
                texCoords: {u: -1, v: 1}
            }, g = {vertices: {x: a.x + b, y: a.y + b}, colors: e, texCoords: {u: 1, v: 1}};
            a = {vertices: {x: a.x + b, y: a.y - b}, colors: e, texCoords: {u: 1, v: -1}};
            this._ensureCapacity(6);
            this._buffer.push(new cc.V2F_C4B_T2F_Triangle(d, f, g, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
            this._buffer.push(new cc.V2F_C4B_T2F_Triangle(d, g, a, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
            this._dirty = !0
        }, drawDots: function (a, b, d) {
            if (a && 0 !== a.length) {
                d = d || this.getDrawColor();
                null == d.a && (d.a = 255);
                for (var e = 0, f = a.length; e < f; e++)this.drawDot(a[e], b, d)
            }
        }, drawSegment: function (a, b, d, e) {
            e = e || this.getDrawColor();
            null == e.a && (e.a = 255);
            d = d || 0.5 * this._lineWidth;
            this._ensureCapacity(18);
            e = {r: 0 | e.r, g: 0 | e.g, b: 0 | e.b, a: 0 | e.a};
            var f = cc.__v2f(a), g = cc.__v2f(b);
            b = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(g, f)));
            a = cc.v2fperp(b);
            var h = cc.v2fmult(b, d), n = cc.v2fmult(a, d);
            d = cc.v2fsub(g, cc.v2fadd(h, n));
            var p = cc.v2fadd(g,
                cc.v2fsub(h, n)), r = cc.v2fsub(g, h), g = cc.v2fadd(g, h), s = cc.v2fsub(f, h), t = cc.v2fadd(f, h), v = cc.v2fsub(f, cc.v2fsub(h, n)), f = cc.v2fadd(f, cc.v2fadd(h, n)), h = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, n = this._trianglesArrayBuffer, u = this._buffer;
            u.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: d,
                colors: e,
                texCoords: cc.__t(cc.v2fneg(cc.v2fadd(b, a)))
            }, {vertices: p, colors: e, texCoords: cc.__t(cc.v2fsub(b, a))}, {
                vertices: r,
                colors: e,
                texCoords: cc.__t(cc.v2fneg(b))
            }, n, u.length * h));
            u.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: g,
                colors: e, texCoords: cc.__t(b)
            }, {vertices: p, colors: e, texCoords: cc.__t(cc.v2fsub(b, a))}, {
                vertices: r,
                colors: e,
                texCoords: cc.__t(cc.v2fneg(b))
            }, n, u.length * h));
            u.push(new cc.V2F_C4B_T2F_Triangle({vertices: g, colors: e, texCoords: cc.__t(b)}, {
                vertices: s,
                colors: e,
                texCoords: cc.__t(cc.v2fneg(b))
            }, {vertices: r, colors: e, texCoords: cc.__t(cc.v2fneg(b))}, n, u.length * h));
            u.push(new cc.V2F_C4B_T2F_Triangle({vertices: g, colors: e, texCoords: cc.__t(b)}, {
                vertices: s,
                colors: e,
                texCoords: cc.__t(cc.v2fneg(b))
            }, {
                vertices: t, colors: e,
                texCoords: cc.__t(b)
            }, n, u.length * h));
            u.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: v,
                colors: e,
                texCoords: cc.__t(cc.v2fsub(a, b))
            }, {vertices: s, colors: e, texCoords: cc.__t(cc.v2fneg(b))}, {
                vertices: t,
                colors: e,
                texCoords: cc.__t(b)
            }, n, u.length * h));
            u.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: v,
                colors: e,
                texCoords: cc.__t(cc.v2fsub(a, b))
            }, {vertices: f, colors: e, texCoords: cc.__t(cc.v2fadd(b, a))}, {
                vertices: t,
                colors: e,
                texCoords: cc.__t(b)
            }, n, u.length * h));
            this._dirty = !0
        }, drawPoly: function (a, b, d, e) {
            if (null == b)this._drawSegments(a,
                d, e, !0); else {
                null == b.a && (b.a = 255);
                null == e.a && (e.a = 255);
                d = null == d ? this._lineWidth : d;
                d *= 0.5;
                b = {r: 0 | b.r, g: 0 | b.g, b: 0 | b.b, a: 0 | b.a};
                e = {r: 0 | e.r, g: 0 | e.g, b: 0 | e.b, a: 0 | e.a};
                var f = [], g, h, n, p, r = a.length;
                for (g = 0; g < r; g++) {
                    h = cc.__v2f(a[(g - 1 + r) % r]);
                    n = cc.__v2f(a[g]);
                    p = cc.__v2f(a[(g + 1) % r]);
                    var s = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(n, h)));
                    n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(p, n)));
                    s = cc.v2fmult(cc.v2fadd(s, n), 1 / (cc.v2fdot(s, n) + 1));
                    f[g] = {offset: s, n: n}
                }
                s = 0 < d;
                this._ensureCapacity(3 * (3 * r - 2));
                var t = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                    v = this._trianglesArrayBuffer, u = this._buffer, x = !1 == s ? 0.5 : 0;
                for (g = 0; g < r - 2; g++)h = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(f[0].offset, x)), n = cc.v2fsub(cc.__v2f(a[g + 1]), cc.v2fmult(f[g + 1].offset, x)), p = cc.v2fsub(cc.__v2f(a[g + 2]), cc.v2fmult(f[g + 2].offset, x)), u.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: h,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {vertices: n, colors: b, texCoords: cc.__t(cc.v2fzero())}, {
                    vertices: p,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, v, u.length * t));
                for (g = 0; g < r; g++) {
                    x = (g + 1) % r;
                    h = cc.__v2f(a[g]);
                    n =
                        cc.__v2f(a[x]);
                    p = f[g].n;
                    var w = f[g].offset, y = f[x].offset, x = s ? cc.v2fsub(h, cc.v2fmult(w, d)) : cc.v2fsub(h, cc.v2fmult(w, 0.5)), A = s ? cc.v2fsub(n, cc.v2fmult(y, d)) : cc.v2fsub(n, cc.v2fmult(y, 0.5));
                    h = s ? cc.v2fadd(h, cc.v2fmult(w, d)) : cc.v2fadd(h, cc.v2fmult(w, 0.5));
                    n = s ? cc.v2fadd(n, cc.v2fmult(y, d)) : cc.v2fadd(n, cc.v2fmult(y, 0.5));
                    s ? (u.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: x,
                        colors: e,
                        texCoords: cc.__t(cc.v2fneg(p))
                    }, {vertices: A, colors: e, texCoords: cc.__t(cc.v2fneg(p))}, {
                        vertices: n,
                        colors: e,
                        texCoords: cc.__t(p)
                    }, v, u.length *
                        t)), u.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: x,
                        colors: e,
                        texCoords: cc.__t(cc.v2fneg(p))
                    }, {vertices: h, colors: e, texCoords: cc.__t(p)}, {
                        vertices: n,
                        colors: e,
                        texCoords: cc.__t(p)
                    }, v, u.length * t))) : (u.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: x,
                        colors: b,
                        texCoords: cc.__t(cc.v2fzero())
                    }, {vertices: A, colors: b, texCoords: cc.__t(cc.v2fzero())}, {
                        vertices: n,
                        colors: b,
                        texCoords: cc.__t(p)
                    }, v, u.length * t)), u.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: x,
                            colors: b,
                            texCoords: cc.__t(cc.v2fzero())
                        }, {vertices: h, colors: b, texCoords: cc.__t(p)},
                        {vertices: n, colors: b, texCoords: cc.__t(p)}, v, u.length * t)))
                }
                this._dirty = !0
            }
        }, _drawSegments: function (a, b, d, e) {
            b = null == b ? this._lineWidth : b;
            d = d || this._drawColor;
            null == d.a && (d.a = 255);
            b *= 0.5;
            if (!(0 >= b)) {
                d = {r: 0 | d.r, g: 0 | d.g, b: 0 | d.b, a: 0 | d.a};
                var f = [], g, h, n, p, r = a.length;
                for (g = 0; g < r; g++) {
                    h = cc.__v2f(a[(g - 1 + r) % r]);
                    n = cc.__v2f(a[g]);
                    p = cc.__v2f(a[(g + 1) % r]);
                    var s = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(n, h)));
                    n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(p, n)));
                    p = cc.v2fmult(cc.v2fadd(s, n), 1 / (cc.v2fdot(s, n) + 1));
                    f[g] = {
                        offset: p,
                        n: n
                    }
                }
                this._ensureCapacity(3 * (3 * r - 2));
                p = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                var s = this._trianglesArrayBuffer, t = this._buffer;
                e = e ? r : r - 1;
                for (g = 0; g < e; g++) {
                    var v = (g + 1) % r;
                    h = cc.__v2f(a[g]);
                    n = cc.__v2f(a[v]);
                    var u = f[g].n, x = f[g].offset, w = f[v].offset, v = cc.v2fsub(h, cc.v2fmult(x, b)), y = cc.v2fsub(n, cc.v2fmult(w, b));
                    h = cc.v2fadd(h, cc.v2fmult(x, b));
                    n = cc.v2fadd(n, cc.v2fmult(w, b));
                    t.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: v,
                            colors: d,
                            texCoords: cc.__t(cc.v2fneg(u))
                        }, {vertices: y, colors: d, texCoords: cc.__t(cc.v2fneg(u))},
                        {vertices: n, colors: d, texCoords: cc.__t(u)}, s, t.length * p));
                    t.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: v,
                        colors: d,
                        texCoords: cc.__t(cc.v2fneg(u))
                    }, {vertices: h, colors: d, texCoords: cc.__t(u)}, {
                        vertices: n,
                        colors: d,
                        texCoords: cc.__t(u)
                    }, s, t.length * p))
                }
                this._dirty = !0
            }
        }, clear: function () {
            this._buffer.length = 0;
            this._dirty = !0
        }, _createRenderCmd: function () {
            return new cc.DrawNode.WebGLRenderCmd(this)
        }
    })
});
(function () {
    cc.DrawNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._blendFunc = this._drawColor = this._buffer = null
    };
    cc.DrawNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd;
    cc.extend(cc.DrawNode.CanvasRenderCmd.prototype, {
        rendering: function (a, b, d) {
            a = a || cc._renderContext;
            a.getContext();
            var e = this._node._displayedOpacity / 255;
            if (0 !== e) {
                a.setTransform(this._worldTransform,
                    b, d);
                a.setGlobalAlpha(e);
                this._blendFunc && this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE && a.setCompositeOperation("lighter");
                for (var e = this._buffer, f = 0, g = e.length; f < g; f++) {
                    var h = e[f];
                    switch (h.type) {
                        case cc.DrawNode.TYPE_DOT:
                            this._drawDot(a, h, b, d);
                            break;
                        case cc.DrawNode.TYPE_SEGMENT:
                            this._drawSegment(a, h, b, d);
                            break;
                        case cc.DrawNode.TYPE_POLY:
                            this._drawPoly(a, h, b, d)
                    }
                }
            }
        }, _drawDot: function (a, b, d, e) {
            var f = b.fillColor, g = b.verts[0];
            b = b.lineWidth;
            var h = a.getContext();
            a.setFillStyle("rgba(" +
                (0 | f.r) + "," + (0 | f.g) + "," + (0 | f.b) + "," + f.a / 255 + ")");
            h.beginPath();
            h.arc(g.x * d, -g.y * e, b * d, 0, 2 * Math.PI, !1);
            h.closePath();
            h.fill()
        }, _drawSegment: function (a, b, d, e) {
            var f = b.lineColor, g = b.verts[0], h = b.verts[1], n = b.lineWidth;
            b = b.lineCap;
            var p = a.getContext();
            a.setStrokeStyle("rgba(" + (0 | f.r) + "," + (0 | f.g) + "," + (0 | f.b) + "," + f.a / 255 + ")");
            p.lineWidth = n * d;
            p.beginPath();
            p.lineCap = b;
            p.moveTo(g.x * d, -g.y * e);
            p.lineTo(h.x * d, -h.y * e);
            p.stroke()
        }, _drawPoly: function (a, b, d, e) {
            var f = b.verts, g = b.lineCap;
            if (null != f) {
                var h = b.fillColor,
                    n = b.lineWidth, p = b.lineColor, r = b.isClosePolygon, s = b.isFill;
                b = b.isStroke;
                var t = a.getContext(), v = f[0];
                t.lineCap = g;
                h && a.setFillStyle("rgba(" + (0 | h.r) + "," + (0 | h.g) + "," + (0 | h.b) + "," + h.a / 255 + ")");
                n && (t.lineWidth = n * d);
                p && a.setStrokeStyle("rgba(" + (0 | p.r) + "," + (0 | p.g) + "," + (0 | p.b) + "," + p.a / 255 + ")");
                t.beginPath();
                t.moveTo(v.x * d, -v.y * e);
                a = 1;
                for (g = f.length; a < g; a++)t.lineTo(f[a].x * d, -f[a].y * e);
                r && t.closePath();
                s && t.fill();
                b && t.stroke()
            }
        }
    })
})();
(function () {
    cc.DrawNode.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    cc.DrawNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd;
    cc.DrawNode.WebGLRenderCmd.prototype.rendering = function (a) {
        a = this._node;
        0 < a._buffer.length && (cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
            a._render())
    }
})();
cc.stencilBits = -1;
cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0, inverted: !1, _stencil: null, _className: "ClippingNode", ctor: function (a) {
        a = a || null;
        cc.Node.prototype.ctor.call(this);
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1;
        this._renderCmd.initStencilBits()
    }, init: function (a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1;
        this._renderCmd.initStencilBits();
        return !0
    }, onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this._stencil.onEnter()
    }, onEnterTransitionDidFinish: function () {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function () {
        this._stencil.onExitTransitionDidStart();
        cc.Node.prototype.onExitTransitionDidStart.call(this)
    }, onExit: function () {
        this._stencil.onExit();
        cc.Node.prototype.onExit.call(this)
    }, getAlphaThreshold: function () {
        return this.alphaThreshold
    }, setAlphaThreshold: function (a) {
        this.alphaThreshold = a
    }, isInverted: function () {
        return this.inverted
    }, setInverted: function (a) {
        this.inverted = a
    }, getStencil: function () {
        return this._stencil
    }, setStencil: function (a) {
        this._stencil !== a && this._renderCmd.setStencil(a)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this)
    }
});
_p = cc.ClippingNode.prototype;
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
cc.ClippingNode.create = function (a) {
    return new cc.ClippingNode(a)
};
(function () {
    cc.ClippingNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._clipElemType = this._godhelpme = this._needDraw = !1;
        this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._saveCmdCallback);
        this._rendererClipCmd = new cc.CustomRenderCmd(this, this._clipCmdCallback);
        this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback)
    };
    var a = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ClippingNode.CanvasRenderCmd;
    a.initStencilBits = function () {
    };
    a.setStencil = function (a) {
        if (null != a)if (this._node._stencil = a, a instanceof cc.DrawNode) {
            if (a._buffer)for (var d = 0; d < a._buffer.length; d++)a._buffer[d].isFill = !1, a._buffer[d].isStroke = !1;
            a._renderCmd.rendering = function (d, f, g) {
                f = f || cc.view.getScaleX();
                g = g || cc.view.getScaleY();
                d = (d || cc._renderContext).getContext();
                var h = this._transform;
                d.transform(h.a, h.b, h.c, h.d, h.tx * f, -h.ty * g);
                for (h = 0; h < a._buffer.length; h++) {
                    var n = a._buffer[h].verts, p = n[0];
                    d.moveTo(p.x * f, -p.y * g);
                    for (p = n.length -
                        1; 0 < p; p--)d.lineTo(n[p].x * f, -n[p].y * g)
                }
            }
        } else a._parent = this._node
    };
    a._saveCmdCallback = function (a, d, e) {
        var f = a || cc._renderContext;
        a = f.getContext();
        this._clipElemType ? (d = cc.ClippingNode.CanvasRenderCmd._getSharedCache(), e = a.canvas, d.width = e.width, d.height = e.height, d.getContext("2d").drawImage(e, 0, 0)) : (f.save(), a.beginPath(), f.setTransform(this._worldTransform, d, e), this._node.inverted && (a.rect(0, 0, a.canvas.width, -a.canvas.height), a.clip()))
    };
    a._setStencilCompositionOperation = function (a) {
        if (a) {
            var d =
                this._node;
            a._renderCmd && a._renderCmd._blendFuncStr && (a._renderCmd._blendFuncStr = d.inverted ? "destination-out" : "destination-in");
            if (a._children) {
                a = a._children;
                for (var d = 0, e = a.length; d < e; d++)this._setStencilCompositionOperation(a[d])
            }
        }
    };
    a._clipCmdCallback = function (a) {
        var d = this._node;
        a = (a || cc._renderContext).getContext();
        this._clipElemType ? this._setStencilCompositionOperation(d._stencil) : a.clip()
    };
    a._restoreCmdCallback = function (a) {
        var d = cc.ClippingNode.CanvasRenderCmd._getSharedCache();
        a = a || cc._renderContext;
        var e = a.getContext();
        this._clipElemType ? (e.save(), e.setTransform(1, 0, 0, 1, 0, 0), e.globalCompositeOperation = "destination-over", e.drawImage(d, 0, 0), e.restore(), this._dirtyFlag = 0) : a.restore()
    };
    a.transform = function (a, d) {
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, d);
        var e = this._node;
        e._stencil && e._stencil._renderCmd && e._stencil._renderCmd.transform(this, d)
    };
    a._cangodhelpme = function (a) {
        if (!0 === a || !1 === a)cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = a;
        return cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme
    };
    a.visit = function (a) {
        var d = this._node;
        if (d._visible) {
            if (a = a || this.getParentRenderCmd())this._curLevel = a._curLevel + 1;
            this._clipElemType = !(!this._cangodhelpme() && d._stencil instanceof cc.DrawNode);
            if (d._stencil && d._stencil.visible) {
                this._syncStatus(a);
                cc.renderer.pushRenderCommand(this._rendererSaveCmd);
                this._clipElemType ? cc.Node.CanvasRenderCmd.prototype.visit.call(this, a) : d._stencil.visit(this);
                cc.renderer.pushRenderCommand(this._rendererClipCmd);
                if (this._clipElemType)d._stencil.visit(this); else {
                    a =
                        d._children;
                    this._cangodhelpme(!0);
                    var e = a.length;
                    if (0 < e)for (d.sortAllChildren(), d = 0; d < e; d++)a[d]._renderCmd.visit(this);
                    this._cangodhelpme(!1)
                }
                cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
                this._dirtyFlag = 0
            } else this.inverted && cc.Node.CanvasRenderCmd.prototype.visit.call(this, a)
        }
    };
    cc.ClippingNode.CanvasRenderCmd._sharedCache = null;
    cc.ClippingNode.CanvasRenderCmd._getSharedCache = function () {
        return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache =
                document.createElement("canvas"))
    }
})();
(function () {
    cc.ClippingNode.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !1;
        this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
        this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
        this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
        this._mask_layer_le = this._currentStencilEnabled = null
    };
    var a = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ClippingNode.WebGLRenderCmd;
    cc.ClippingNode.WebGLRenderCmd._init_once = null;
    cc.ClippingNode.WebGLRenderCmd._visit_once = null;
    cc.ClippingNode.WebGLRenderCmd._layer = -1;
    a.initStencilBits = function () {
        cc.ClippingNode.WebGLRenderCmd._init_once = !0;
        cc.ClippingNode.WebGLRenderCmd._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."), cc.ClippingNode.WebGLRenderCmd._init_once = !1)
    };
    a.transform = function (a, d) {
        var e = this._node;
        cc.Node.WebGLRenderCmd.prototype.transform.call(this,
            a, d);
        e._stencil && e._stencil._renderCmd.transform(this, d)
    };
    a.visit = function (a) {
        var d = this._node;
        if (d._visible)if (d._parent && d._parent._renderCmd && (this._curLevel = d._parent._renderCmd._curLevel + 1), 1 > cc.stencilBits)cc.Node.WebGLRenderCmd.prototype.visit.call(this, a); else if (d._stencil && d._stencil.visible)if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.stencilBits)cc.ClippingNode.WebGLRenderCmd._visit_once = !0, cc.ClippingNode.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children."),
            cc.ClippingNode.WebGLRenderCmd._visit_once = !1), cc.Node.WebGLRenderCmd.prototype.visit.call(this, a); else {
            cc.renderer.pushRenderCommand(this._beforeVisitCmd);
            var e = cc.current_stack;
            e.stack.push(e.top);
            this._syncStatus(a);
            e.top = this._stackMatrix;
            d._stencil._renderCmd.visit(this);
            cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
            if ((a = d._children) && 0 < a.length) {
                var f = a.length;
                d.sortAllChildren();
                for (d = 0; d < f; d++)a[d]._renderCmd.visit(this)
            }
            cc.renderer.pushRenderCommand(this._afterVisitCmd);
            this._dirtyFlag =
                0;
            e.top = e.stack.pop()
        } else d.inverted && cc.Node.WebGLRenderCmd.prototype.visit.call(this, a)
    };
    a.setStencil = function (a) {
        var d = this._node;
        d._stencil && (d._stencil._parent = null);
        d._stencil = a;
        d._stencil && (d._stencil._parent = d)
    };
    a._onBeforeVisit = function (a) {
        var d = a || cc._renderContext;
        a = this._node;
        cc.ClippingNode.WebGLRenderCmd._layer++;
        var e = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
        this._mask_layer_le = e | e - 1;
        this._currentStencilEnabled = d.isEnabled(d.STENCIL_TEST);
        d.clear(d.DEPTH_BUFFER_BIT);
        d.enable(d.STENCIL_TEST);
        d.depthMask(!1);
        d.clear(d.STENCIL_BUFFER_BIT);
        d.stencilFunc(d.NEVER, e, e);
        d.stencilOp(d.REPLACE, d.KEEP, d.KEEP);
        d.stencilMask(e);
        d.clear(d.STENCIL_BUFFER_BIT);
        1 > a.alphaThreshold && (d = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), cc.glUseProgram(d.getProgram()), d.setUniformLocationWith1f(cc.UNIFORM_ALPHA_TEST_VALUE_S, a.alphaThreshold), d.setUniformLocationWithMatrix4fv(cc.UNIFORM_MVMATRIX_S, cc.renderer.mat4Identity.mat), cc.setProgram(a._stencil, d))
    };
    a._onAfterDrawStencil = function (a) {
        a =
            a || cc._renderContext;
        a.depthMask(!0);
        a.stencilFunc(this._node.inverted ? a.NOTEQUAL : a.EQUAL, this._mask_layer_le, this._mask_layer_le);
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
    };
    a._onAfterVisit = function (a) {
        a = a || cc._renderContext;
        cc.ClippingNode.WebGLRenderCmd._layer--;
        if (this._currentStencilEnabled) {
            var d = 1 << ccui.Layout.WebGLRenderCmd._layer, e = d | d - 1;
            a.stencilMask(d);
            a.stencilFunc(a.EQUAL, e, e)
        } else a.disable(a.STENCIL_TEST)
    }
})();
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _gridRect: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function (a, b, d, e) {
        cc.sys._checkWebGLRenderMode();
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize = null;
        this._gridRect = new cc.rect;
        this._texture = null;
        this._step = cc.p(0, 0);
        this._grabber = null;
        this._isTextureFlipped = !1;
        this._shaderProgram = null;
        this._directorProjection = 0;
        this._dirty = !1;
        void 0 !== a && this.initWithSize(a,
            b, d, e)
    },
    isActive: function () {
        return this._active
    },
    setActive: function (a) {
        this._active = a;
        if (!a) {
            a = cc.director;
            var b = a.getProjection();
            a.setProjection(b)
        }
    },
    getReuseGrid: function () {
        return this._reuseGrid
    },
    setReuseGrid: function (a) {
        this._reuseGrid = a
    },
    getGridSize: function () {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function (a) {
        this._gridSize.width = parseInt(a.width);
        this._gridSize.height = parseInt(a.height)
    },
    setGridRect: function (a) {
        this._gridRect = a
    },
    getGridRect: function () {
        return this._gridRect
    },
    getStep: function () {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function (a) {
        this._step.x = a.x;
        this._step.y = a.y
    },
    isTextureFlipped: function () {
        return this._isTextureFlipped
    },
    setTextureFlipped: function (a) {
        this._isTextureFlipped !== a && (this._isTextureFlipped = a, this.calculateVertexPoints())
    },
    initWithSize: function (a, b, d, e) {
        if (!b) {
            var f = cc.director.getWinSizeInPixels(), g = cc.NextPOT(f.width), h = cc.NextPOT(f.height), n = new Uint8Array(g * h * 4);
            if (!n)return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            b = new cc.Texture2D;
            b.initWithData(n, cc.Texture2D.PIXEL_FORMAT_RGBA8888, g, h, f);
            if (!b)return cc.log("cocos2d: CCGrid: error creating texture"), !1
        }
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize = a;
        this._texture = b;
        this._isTextureFlipped = d || !1;
        if (void 0 === e || cc._rectEqualToZero(e))b = this._texture.getContentSize(), e = new cc.rect(0, 0, b.width, b.height);
        this._gridRect = e;
        this._step.x = this._gridRect.width / a.width;
        this._step.y = this._gridRect.height / a.height;
        this._grabber = new cc.Grabber;
        if (!this._grabber)return !1;
        this._grabber.grab(this._texture);
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        this.calculateVertexPoints();
        return !0
    },
    beforeDraw: function () {
        this._directorProjection = cc.director.getProjection();
        var a = cc.director.getWinSizeInPixels();
        gl.viewport(0, 0, a.width, a.height);
        this._grabber.beforeRender(this._texture)
    },
    afterDraw: function (a) {
        this._grabber.afterRender(this._texture);
        cc.director.setViewport();
        if (a && a.getCamera().isDirty()) {
            var b = a.getAnchorPointInPoints(), d = a._renderCmd._stackMatrix, e = cc.math.Matrix4.createByTranslation(b.x,
                b.y, 0);
            d.multiply(e);
            a._camera._locateForRenderer(d);
            e = cc.math.Matrix4.createByTranslation(-b.x, -b.y, 0, e);
            d.multiply(e)
        }
        cc.glBindTexture2D(this._texture);
        this.beforeBlit();
        this.blit(a);
        this.afterBlit()
    },
    beforeBlit: function () {
    },
    afterBlit: function () {
    },
    blit: function () {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function () {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function () {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function () {
        var a = cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0, 0, a.width, a.height);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        a = cc.math.Matrix4.createOrthographicProjection(0, a.width, 0, a.height, -1, 1);
        cc.kmGLMultMatrix(a);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        cc.setProjectionMatrixDirty()
    }
});
cc.GridBase.create = function (a, b, d, e) {
    return new cc.GridBase(a, b, d, e)
};
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    _needDepthTestForBlit: !1,
    _oldDepthTestValue: !1,
    _oldDepthWriteValue: !1,
    ctor: function (a, b, d, e) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, b, d, e)
    },
    vertex: function (a) {
        return this.getVertex(a)
    },
    getVertex: function (a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.vertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._vertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    originalVertex: function (a) {
        return this.getOriginalVertex(a)
    },
    getOriginalVertex: function (a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._originalVertices;
        return new cc.Vertex3F(b[a], b[a +
        1], b[a + 2])
    },
    setVertex: function (a, b) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var d = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y), e = this._vertices;
        e[d] = b.x;
        e[d + 1] = b.y;
        e[d + 2] = b.z;
        this._dirty = !0
    },
    beforeBlit: function () {
        if (this._needDepthTestForBlit) {
            var a = cc._renderContext;
            this._oldDepthTestValue = a.isEnabled(a.DEPTH_TEST);
            this._oldDepthWriteValue = a.getParameter(a.DEPTH_WRITEMASK);
            a.enable(a.DEPTH_TEST);
            a.depthMask(!0)
        }
    },
    afterBlit: function () {
        if (this._needDepthTestForBlit) {
            var a =
                cc._renderContext;
            this._oldDepthTestValue ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST);
            a.depthMask(this._oldDepthWriteValue)
        }
    },
    blit: function (a) {
        var b = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
        a = cc._renderContext;
        var d = this._dirty;
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        d && a.bufferData(a.ARRAY_BUFFER,
            this._vertices, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        d && a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        d && a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        a.drawElements(a.TRIANGLES, 6 * b, a.UNSIGNED_SHORT, 0);
        d && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function () {
        if (0 < this._reuseGrid) {
            for (var a = this._originalVertices, b = this._vertices, d = 0, e = this._vertices.length; d < e; d++)a[d] = b[d];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function () {
        var a = cc._renderContext, b = this._texture.pixelsWidth, d = this._texture.pixelsHeight, e = this._texture.getContentSizeInPixels().height, f = this._gridSize, g = (f.width + 1) * (f.height + 1);
        this._vertices = new Float32Array(3 * g);
        this._texCoordinates = new Float32Array(2 * g);
        this._indices = new Uint16Array(f.width * f.height * 6);
        this._verticesBuffer &&
        a.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = a.createBuffer();
        this._texCoordinateBuffer && a.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = a.createBuffer();
        this._indicesBuffer && a.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = a.createBuffer();
        for (var h, n, p = this._indices, r = this._texCoordinates, s = this._isTextureFlipped, t = this._vertices, g = 0; g < f.width; ++g)for (h = 0; h < f.height; ++h) {
            var v = h * f.width + g;
            n = g * this._step.x + this._gridRect.x;
            var u = n + this._step.x, x = h * this._step.y +
                this._gridRect.y, w = x + this._step.y, y = g * (f.height + 1) + h, A = (g + 1) * (f.height + 1) + h, D = (g + 1) * (f.height + 1) + (h + 1), G = g * (f.height + 1) + (h + 1);
            p[6 * v] = y;
            p[6 * v + 1] = A;
            p[6 * v + 2] = G;
            p[6 * v + 3] = A;
            p[6 * v + 4] = D;
            p[6 * v + 5] = G;
            var v = [3 * y, 3 * A, 3 * D, 3 * G], B = [{x: n, y: x, z: 0}, {x: u, y: x, z: 0}, {
                x: u,
                y: w,
                z: 0
            }, {
                x: n,
                y: w,
                z: 0
            }], y = [2 * y, 2 * A, 2 * D, 2 * G], u = [cc.p(n, x), cc.p(u, x), cc.p(u, w), cc.p(n, w)];
            for (n = 0; 4 > n; ++n)t[v[n]] = B[n].x, t[v[n] + 1] = B[n].y, t[v[n] + 2] = B[n].z, r[y[n]] = u[n].x / b, r[y[n] + 1] = s ? (e - u[n].y) / d : u[n].y / d
        }
        this._originalVertices = new Float32Array(this._vertices);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        this._dirty = !0
    },
    setNeedDepthTestForBlit: function (a) {
        this._needDepthTestForBlit = a
    },
    getNeedDepthTestForBlit: function () {
        return this._needDepthTestForBlit
    }
});
cc.Grid3D.create = function (a, b, d) {
    return new cc.Grid3D(a, b, d)
};
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function (a, b, d, e) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, b, d, e)
    },
    tile: function (a) {
        return this.getTile(a)
    },
    getTile: function (a) {
        a.x === (0 | a.x) && a.y ===
        (0 | a.y) || cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    getOriginalTile: function (a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(b[a],
            b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    originalTile: function (a) {
        return this.getOriginalTile(a)
    },
    setTile: function (a, b) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var d = 12 * (this._gridSize.height * a.x + a.y), e = this._vertices;
        e[d] = b.bl.x;
        e[d + 1] = b.bl.y;
        e[d + 2] = b.bl.z;
        e[d + 3] = b.br.x;
        e[d + 4] = b.br.y;
        e[d + 5] = b.br.z;
        e[d + 6] = b.tl.x;
        e[d + 7] = b.tl.y;
        e[d + 8] = b.tl.z;
        e[d + 9] = b.tr.x;
        e[d +
        10] = b.tr.y;
        e[d + 11] = b.tr.z;
        this._dirty = !0
    },
    blit: function (a) {
        var b = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
        a = cc._renderContext;
        var d = this._dirty;
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
        a.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        d && a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            3, a.FLOAT, !1, 0, this._vertices);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        d && a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, this._texCoordinates);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        d && a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        a.drawElements(a.TRIANGLES, 6 * b, a.UNSIGNED_SHORT, 0);
        d && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function () {
        if (0 < this._reuseGrid) {
            for (var a =
                this._vertices, b = this._originalVertices, d = 0; d < a.length; d++)b[d] = a[d];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function () {
        var a = this._texture.pixelsWidth, b = this._texture.pixelsHeight, d = this._texture.getContentSizeInPixels().height, e = this._gridSize, f = e.width * e.height;
        this._vertices = new Float32Array(12 * f);
        this._texCoordinates = new Float32Array(8 * f);
        this._indices = new Uint16Array(6 * f);
        var g = cc._renderContext;
        this._verticesBuffer && g.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = g.createBuffer();
        this._texCoordinateBuffer && g.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = g.createBuffer();
        this._indicesBuffer && g.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = g.createBuffer();
        var h, n, p = 0, r = this._step, s = this._vertices, t = this._texCoordinates, v = this._isTextureFlipped;
        for (h = 0; h < e.width; h++)for (n = 0; n < e.height; n++) {
            var u = h * r.x, x = u + r.x, w = n * r.y, y = w + r.y;
            s[12 * p] = u;
            s[12 * p + 1] = w;
            s[12 * p + 2] = 0;
            s[12 * p + 3] = x;
            s[12 * p + 4] = w;
            s[12 * p + 5] = 0;
            s[12 * p + 6] = u;
            s[12 * p + 7] = y;
            s[12 * p + 8] = 0;
            s[12 * p + 9] = x;
            s[12 *
            p + 10] = y;
            s[12 * p + 11] = 0;
            var A = w, D = y;
            v && (A = d - w, D = d - y);
            t[8 * p] = u / a;
            t[8 * p + 1] = A / b;
            t[8 * p + 2] = x / a;
            t[8 * p + 3] = A / b;
            t[8 * p + 4] = u / a;
            t[8 * p + 5] = D / b;
            t[8 * p + 6] = x / a;
            t[8 * p + 7] = D / b;
            p++
        }
        a = this._indices;
        for (h = 0; h < f; h++)a[6 * h + 0] = 4 * h + 0, a[6 * h + 1] = 4 * h + 1, a[6 * h + 2] = 4 * h + 2, a[6 * h + 3] = 4 * h + 1, a[6 * h + 4] = 4 * h + 2, a[6 * h + 5] = 4 * h + 3;
        this._originalVertices = new Float32Array(this._vertices);
        g.bindBuffer(g.ARRAY_BUFFER, this._verticesBuffer);
        g.bufferData(g.ARRAY_BUFFER, this._vertices, g.DYNAMIC_DRAW);
        g.bindBuffer(g.ARRAY_BUFFER, this._texCoordinateBuffer);
        g.bufferData(g.ARRAY_BUFFER,
            this._texCoordinates, g.DYNAMIC_DRAW);
        g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        g.bufferData(g.ELEMENT_ARRAY_BUFFER, this._indices, g.DYNAMIC_DRAW);
        this._dirty = !0
    }
});
cc.TiledGrid3D.create = function (a, b, d) {
    return new cc.TiledGrid3D(a, b, d)
};
cc.Grabber = cc.Class.extend({
    _FBO: null, _oldFBO: null, _oldClearColor: null, _gl: null, ctor: function () {
        cc.sys._checkWebGLRenderMode();
        this._gl = cc._renderContext;
        this._oldClearColor = [0, 0, 0, 0];
        this._oldFBO = null;
        this._FBO = this._gl.createFramebuffer()
    }, grab: function (a) {
        var b = this._gl;
        this._oldFBO = b.getParameter(b.FRAMEBUFFER_BINDING);
        b.bindFramebuffer(b.FRAMEBUFFER, this._FBO);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, a._webTextureObj, 0);
        b.checkFramebufferStatus(b.FRAMEBUFFER) !== b.FRAMEBUFFER_COMPLETE &&
        cc.log("Frame Grabber: could not attach texture to frmaebuffer");
        b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO)
    }, beforeRender: function (a) {
        a = this._gl;
        this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING);
        a.bindFramebuffer(a.FRAMEBUFFER, this._FBO);
        this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    }, afterRender: function (a) {
        a = this._gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        a.colorMask(!0, !0, !0, !0)
    }, destroy: function () {
        this._gl.deleteFramebuffer(this._FBO)
    }
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget: null, target: null, tag: cc.ACTION_TAG_INVALID, ctor: function () {
        this.target = this.originalTarget = null;
        this.tag = cc.ACTION_TAG_INVALID
    }, copy: function () {
        cc.log("copy is deprecated. Please use clone instead.");
        return this.clone()
    }, clone: function () {
        var a = new cc.Action;
        a.originalTarget = null;
        a.target = null;
        a.tag = this.tag;
        return a
    }, isDone: function () {
        return !0
    }, startWithTarget: function (a) {
        this.target = this.originalTarget = a
    }, stop: function () {
        this.target = null
    }, step: function (a) {
        cc.log("[Action step]. override me")
    },
    update: function (a) {
        cc.log("[Action update]. override me")
    }, getTarget: function () {
        return this.target
    }, setTarget: function (a) {
        this.target = a
    }, getOriginalTarget: function () {
        return this.originalTarget
    }, setOriginalTarget: function (a) {
        this.originalTarget = a
    }, getTag: function () {
        return this.tag
    }, setTag: function (a) {
        this.tag = a
    }, retain: function () {
    }, release: function () {
    }
});
cc.action = function () {
    return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0, ctor: function () {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0
    }, getDuration: function () {
        return this._duration * (this._timesForRepeat || 1)
    }, setDuration: function (a) {
        this._duration = a
    }, reverse: function () {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null
    }, clone: function () {
        return new cc.FiniteTimeAction
    }
});
cc.Speed = cc.Action.extend({
    _speed: 0, _innerAction: null, ctor: function (a, b) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
        a && this.initWithAction(a, b)
    }, getSpeed: function () {
        return this._speed
    }, setSpeed: function (a) {
        this._speed = a
    }, initWithAction: function (a, b) {
        if (!a)throw Error("cc.Speed.initWithAction(): action must be non nil");
        this._innerAction = a;
        this._speed = b;
        return !0
    }, clone: function () {
        var a = new cc.Speed;
        a.initWithAction(this._innerAction.clone(), this._speed);
        return a
    }, startWithTarget: function (a) {
        cc.Action.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    }, stop: function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    }, step: function (a) {
        this._innerAction.step(a * this._speed)
    }, isDone: function () {
        return this._innerAction.isDone()
    }, reverse: function () {
        return new cc.Speed(this._innerAction.reverse(), this._speed)
    }, setInnerAction: function (a) {
        this._innerAction !== a && (this._innerAction = a)
    }, getInnerAction: function () {
        return this._innerAction
    }
});
cc.speed = function (a, b) {
    return new cc.Speed(a, b)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function (a, b) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundaryFullyCovered = this._boundarySet = !1;
        this._fullScreenSize = this._halfScreenSize = null;
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        a && (b ? this.initWithTarget(a,
            b) : this.initWithTarget(a))
    },
    clone: function () {
        var a = new cc.Follow, b = this._worldRect, b = new cc.Rect(b.x, b.y, b.width, b.height);
        a.initWithTarget(this._followedNode, b);
        return a
    },
    isBoundarySet: function () {
        return this._boundarySet
    },
    setBoudarySet: function (a) {
        this._boundarySet = a
    },
    initWithTarget: function (a, b) {
        if (!a)throw Error("cc.Follow.initWithAction(): followedNode must be non nil");
        b = b || cc.rect(0, 0, 0, 0);
        this._followedNode = a;
        this._worldRect = b;
        this._boundarySet = !cc._rectEqualToZero(b);
        this._boundaryFullyCovered = !1;
        var d = cc.director.getWinSize();
        this._fullScreenSize = cc.p(d.width, d.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
        this._boundarySet && (this.leftBoundary = -(b.x + b.width - this._fullScreenSize.x), this.rightBoundary = -b.x, this.topBoundary = -b.y, this.bottomBoundary = -(b.y + b.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary =
            (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary === this.bottomBoundary && this.leftBoundary === this.rightBoundary && (this._boundaryFullyCovered = !0));
        return !0
    },
    step: function (a) {
        a = this._followedNode.x;
        var b = this._followedNode.y;
        a = this._halfScreenSize.x - a;
        b = this._halfScreenSize.y - b;
        this.target._renderCmd._dirtyFlag = 0;
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a,
            b)
    },
    isDone: function () {
        return !this._followedNode.running
    },
    stop: function () {
        this.target = null;
        cc.Action.prototype.stop.call(this)
    }
});
cc.follow = function (a, b) {
    return new cc.Follow(a, b)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _timesForRepeat: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function (a) {
        this._timesForRepeat = this._speed = 1;
        this._repeatForever = !1;
        this.MAX_VALUE = 2;
        this._speedMethod = this._repeatMethod = !1;
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.initWithDuration(a)
    },
    getElapsed: function () {
        return this._elapsed
    },
    initWithDuration: function (a) {
        this._duration = 0 === a ? cc.FLT_EPSILON : a;
        this._elapsed =
            0;
        return this._firstTick = !0
    },
    isDone: function () {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function (a) {
        a._repeatForever = this._repeatForever;
        a._speed = this._speed;
        a._timesForRepeat = this._timesForRepeat;
        a._easeList = this._easeList;
        a._speedMethod = this._speedMethod;
        a._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function (a) {
        if (this._easeList) {
            a._easeList = [];
            for (var b = 0; b < this._easeList.length; b++)a._easeList.push(this._easeList[b].reverse())
        }
    },
    clone: function () {
        var a = new cc.ActionInterval(this._duration);
        this._cloneDecoration(a);
        return a
    },
    easing: function (a) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var b = 0; b < arguments.length; b++)this._easeList.push(arguments[b]);
        return this
    },
    _computeEaseTime: function (a) {
        var b = this._easeList;
        if (!b || 0 === b.length)return a;
        for (var d = 0, e = b.length; d < e; d++)a = b[d].easing(a);
        return a
    },
    step: function (a) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
        a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
        a = 1 > a ?
            a : 1;
        this.update(0 < a ? a : 0);
        this._repeatMethod && 1 < this._timesForRepeat && this.isDone() && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function (a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        this._elapsed = 0;
        this._firstTick = !0
    },
    reverse: function () {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null
    },
    setAmplitudeRate: function (a) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function () {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0
    },
    speed: function (a) {
        if (0 >= a)return cc.log("The speed parameter error"), this;
        this._speedMethod = !0;
        this._speed *= a;
        return this
    },
    getSpeed: function () {
        return this._speed
    },
    setSpeed: function (a) {
        this._speed = a;
        return this
    },
    repeat: function (a) {
        a = Math.round(a);
        if (isNaN(a) || 1 > a)return cc.log("The repeat parameter error"), this;
        this._repeatMethod = !0;
        this._timesForRepeat *= a;
        return this
    },
    repeatForever: function () {
        this._repeatMethod = !0;
        this._timesForRepeat = this.MAX_VALUE;
        this._repeatForever = !0;
        return this
    }
});
cc.actionInterval = function (a) {
    return new cc.ActionInterval(a)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
    _actions: null, _split: null, _last: 0, ctor: function (a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        var b = a instanceof Array ? a : arguments, d = b.length - 1;
        0 <= d && null == b[d] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= d) {
            for (var e = b[0], f = 1; f < d; f++)b[f] && (e = cc.Sequence._actionOneTwo(e, b[f]));
            this.initWithTwoActions(e, b[d])
        }
    }, initWithTwoActions: function (a, b) {
        if (!a || !b)throw Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
        this.initWithDuration(a._duration + b._duration);
        this._actions[0] = a;
        this._actions[1] = b;
        return !0
    }, clone: function () {
        var a = new cc.Sequence;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1
    }, stop: function () {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this)
    }, update: function (a) {
        var b =
            0, d = this._split, e = this._actions, f = this._last;
        a = this._computeEaseTime(a);
        a < d ? (a = 0 !== d ? a / d : 1, 0 === b && 1 === f && (e[1].update(0), e[1].stop())) : (b = 1, a = 1 === d ? 1 : (a - d) / (1 - d), -1 === f && (e[0].startWithTarget(this.target), e[0].update(1), e[0].stop()), f || (e[0].update(1), e[0].stop()));
        e = e[b];
        f === b && e.isDone() || (f !== b && e.startWithTarget(this.target), a *= e._timesForRepeat, e.update(1 < a ? a % 1 : a), this._last = b)
    }, reverse: function () {
        var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.sequence = function (a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var d, e, f, g; b && 0 < b.length;)for (e = Array.prototype.shift.call(b), g = e._timesForRepeat || 1, e._repeatMethod = !1, e._timesForRepeat = 1, f = 0, d || (d = e, f = 1), f; f < g; f++)d = cc.Sequence._actionOneTwo(d, e);
    return d
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function (a, b) {
    var d = new cc.Sequence;
    d.initWithTwoActions(a, b);
    return d
};
cc.Repeat = cc.ActionInterval.extend({
    _times: 0, _total: 0, _nextDt: 0, _actionInstant: !1, _innerAction: null, ctor: function (a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    }, initWithAction: function (a, b) {
        return this.initWithDuration(a._duration * b) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    }, clone: function () {
        var a = new cc.Repeat;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone(),
            this._times);
        return a
    }, startWithTarget: function (a) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    }, stop: function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    }, update: function (a) {
        a = this._computeEaseTime(a);
        var b = this._innerAction, d = this._duration, e = this._times, f = this._nextDt;
        if (a >= f) {
            for (; a > f && this._total < e;)b.update(1), this._total++, b.stop(), b.startWithTarget(this.target),
                this._nextDt = f += b._duration / d;
            1 <= a && this._total < e && this._total++;
            this._actionInstant || (this._total === e ? (b.update(1), b.stop()) : b.update(a - (f - b._duration / d)))
        } else b.update(a * e % 1)
    }, isDone: function () {
        return this._total === this._times
    }, reverse: function () {
        var a = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }, setInnerAction: function (a) {
        this._innerAction !== a && (this._innerAction = a)
    }, getInnerAction: function () {
        return this._innerAction
    }
});
cc.repeat = function (a, b) {
    return new cc.Repeat(a, b)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null, ctor: function (a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
        a && this.initWithAction(a)
    }, initWithAction: function (a) {
        if (!a)throw Error("cc.RepeatForever.initWithAction(): action must be non null");
        this._innerAction = a;
        return !0
    }, clone: function () {
        var a = new cc.RepeatForever;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone());
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    }, step: function (a) {
        var b = this._innerAction;
        b.step(a);
        b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b._duration))
    }, isDone: function () {
        return !1
    }, reverse: function () {
        var a = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }, setInnerAction: function (a) {
        this._innerAction !== a && (this._innerAction = a)
    }, getInnerAction: function () {
        return this._innerAction
    }
});
cc.repeatForever = function (a) {
    return new cc.RepeatForever(a)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
    _one: null, _two: null, ctor: function (a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._two = this._one = null;
        var b = a instanceof Array ? a : arguments, d = b.length - 1;
        0 <= d && null == b[d] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= d) {
            for (var e = b[0], f = 1; f < d; f++)b[f] && (e = cc.Spawn._actionOneTwo(e, b[f]));
            this.initWithTwoActions(e, b[d])
        }
    }, initWithTwoActions: function (a, b) {
        if (!a || !b)throw Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
        var d =
            !1, e = a._duration, f = b._duration;
        this.initWithDuration(Math.max(e, f)) && (this._one = a, this._two = b, e > f ? this._two = cc.Sequence._actionOneTwo(b, cc.delayTime(e - f)) : e < f && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(f - e))), d = !0);
        return d
    }, clone: function () {
        var a = new cc.Spawn;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._one.clone(), this._two.clone());
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._one.startWithTarget(a);
        this._two.startWithTarget(a)
    },
    stop: function () {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this)
    }, update: function (a) {
        a = this._computeEaseTime(a);
        this._one && this._one.update(a);
        this._two && this._two.update(a)
    }, reverse: function () {
        var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.spawn = function (a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var d = b[0], e = 1; e < b.length; e++)null != b[e] && (d = cc.Spawn._actionOneTwo(d, b[e]));
    return d
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function (a, b) {
    var d = new cc.Spawn;
    d.initWithTwoActions(a, b);
    return d
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function (a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, d)
    },
    initWithDuration: function (a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = d || this._dstAngleX, !0) : !1
    },
    clone: function () {
        var a = new cc.RotateTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._dstAngleX,
            this._dstAngleY);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.rotationX % 360, d = this._dstAngleX - b;
        180 < d && (d -= 360);
        -180 > d && (d += 360);
        this._startAngleX = b;
        this._diffAngleX = d;
        this._startAngleY = a.rotationY % 360;
        a = this._dstAngleY - this._startAngleY;
        180 < a && (a -= 360);
        -180 > a && (a += 360);
        this._diffAngleY = a
    },
    reverse: function () {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function (a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX =
            this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
});
cc.rotateTo = function (a, b, d) {
    return new cc.RotateTo(a, b, d)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0, _startAngleX: 0, _angleY: 0, _startAngleY: 0, ctor: function (a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = d || this._angleX, !0) : !1
    }, clone: function () {
        var a = new cc.RotateBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._angleX, this._angleY);
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._startAngleX = a.rotationX;
        this._startAngleY = a.rotationY
    }, update: function (a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    }, reverse: function () {
        var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.rotateBy = function (a, b, d) {
    return new cc.RotateBy(a, b, d)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null, _startPosition: null, _previousPosition: null, ctor: function (a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== b.x && (d = b.y, b = b.x), this._positionDelta.x = b, this._positionDelta.y = d, !0) : !1
    }, clone: function () {
        var a =
            new cc.MoveBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._positionDelta);
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    }, update: function (a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._positionDelta.x * a;
            a *= this._positionDelta.y;
            var d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e =
                    this.target.getPositionX(), f = this.target.getPositionY(), g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                b += d.x;
                a += d.y;
                g.x = b;
                g.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(d.x + b, d.y + a)
        }
    }, reverse: function () {
        var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.moveBy = function (a, b, d) {
    return new cc.MoveBy(a, b, d)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null, ctor: function (a, b, d) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, b, d) ? (void 0 !== b.x && (d = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = d, !0) : !1
    }, clone: function () {
        var a = new cc.MoveTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition);
        return a
    }, startWithTarget: function (a) {
        cc.MoveBy.prototype.startWithTarget.call(this,
            a);
        this._positionDelta.x = this._endPosition.x - a.getPositionX();
        this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
});
cc.moveTo = function (a, b, d) {
    return new cc.MoveTo(a, b, d)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function (a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, d)
    },
    initWithDuration: function (a, b, d) {
        var e = !1;
        cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = d, e = !0);
        return e
    },
    clone: function () {
        var a = new cc.SkewTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startSkewX = a.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        180 < this._deltaX && (this._deltaX -= 360);
        -180 > this._deltaX && (this._deltaX += 360);
        this._startSkewY = a.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        180 < this._deltaY && (this._deltaY -= 360);
        -180 > this._deltaY && (this._deltaY += 360)
    },
    update: function (a) {
        a = this._computeEaseTime(a);
        this.target.skewX = this._startSkewX + this._deltaX * a;
        this.target.skewY =
            this._startSkewY + this._deltaY * a
    }
});
cc.skewTo = function (a, b, d) {
    return new cc.SkewTo(a, b, d)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
    ctor: function (a, b, d) {
        cc.SkewTo.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        var e = !1;
        cc.SkewTo.prototype.initWithDuration.call(this, a, b, d) && (this._skewX = b, this._skewY = d, e = !0);
        return e
    }, clone: function () {
        var a = new cc.SkewBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._skewX, this._skewY);
        return a
    }, startWithTarget: function (a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY
    }, reverse: function () {
        var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.skewBy = function (a, b, d) {
    return new cc.SkewBy(a, b, d)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null, _delta: null, _height: 0, _jumps: 0, _previousPosition: null, ctor: function (a, b, d, e, f) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, b, d, e, f)
    }, initWithDuration: function (a, b, d, e, f) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === f && (f = e, e = d, d = b.y, b = b.x), this._delta.x = b, this._delta.y = d, this._height = e, this._jumps =
            f, !0) : !1
    }, clone: function () {
        var a = new cc.JumpBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    }, update: function (a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = a * this._jumps % 1, b = 4 * this._height * b * (1 - b), b = b + this._delta.y *
                a;
            a *= this._delta.x;
            var d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(), f = this.target.getPositionY(), g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                a += d.x;
                b += d.y;
                g.x = a;
                g.y = b;
                this.target.setPosition(a, b)
            } else this.target.setPosition(d.x + a, d.y + b)
        }
    }, reverse: function () {
        var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.jumpBy = function (a, b, d, e, f) {
    return new cc.JumpBy(a, b, d, e, f)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null, ctor: function (a, b, d, e, f) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, b, d, e, f)
    }, initWithDuration: function (a, b, d, e, f) {
        return cc.JumpBy.prototype.initWithDuration.call(this, a, b, d, e, f) ? (void 0 === f && (d = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = d, !0) : !1
    }, startWithTarget: function (a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y =
            this._endPosition.y - this._startPosition.y
    }, clone: function () {
        var a = new cc.JumpTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return a
    }
});
cc.jumpTo = function (a, b, d, e, f) {
    return new cc.JumpTo(a, b, d, e, f)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function (a, b, d, e, f) {
    return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * b + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
};
cc.BezierBy = cc.ActionInterval.extend({
    _config: null, _startPosition: null, _previousPosition: null, ctor: function (a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
    }, clone: function () {
        var a = new cc.BezierBy;
        this._cloneDecoration(a);
        for (var b = [], d = 0; d < this._config.length; d++) {
            var e =
                this._config[d];
            b.push(cc.p(e.x, e.y))
        }
        a.initWithDuration(this._duration, b);
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    }, update: function (a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._config, d = b[0].y, e = b[1].y, f = b[2].y, b = cc.bezierAt(0, b[0].x, b[1].x, b[2].x, a);
            a = cc.bezierAt(0, d, e, f, a);
            d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(), f = this.target.getPositionY(), g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                b += d.x;
                a += d.y;
                g.x = b;
                g.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(d.x + b, d.y + a)
        }
    }, reverse: function () {
        var a = this._config, a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])], a = new cc.BezierBy(this._duration, a);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.bezierBy = function (a, b) {
    return new cc.BezierBy(a, b)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null, ctor: function (a, b) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
        b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
    }, clone: function () {
        var a = new cc.BezierTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toConfig);
        return a
    }, startWithTarget: function (a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a);
        a = this._startPosition;
        var b =
            this._toConfig, d = this._config;
        d[0] = cc.pSub(b[0], a);
        d[1] = cc.pSub(b[1], a);
        d[2] = cc.pSub(b[2], a)
    }
});
cc.bezierTo = function (a, b) {
    return new cc.BezierTo(a, b)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function (a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, d)
    },
    initWithDuration: function (a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != d ? d : b, !0) : !1
    },
    clone: function () {
        var a = new cc.ScaleTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startScaleX = a.scaleX;
        this._startScaleY = a.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function (a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
});
cc.scaleTo = function (a, b, d) {
    return new cc.ScaleTo(a, b, d)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function (a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    }, reverse: function () {
        var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }, clone: function () {
        var a = new cc.ScaleBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    }
});
cc.scaleBy = function (a, b, d) {
    return new cc.ScaleBy(a, b, d)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
    _times: 0, _originalState: !1, ctor: function (a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
    }, clone: function () {
        var a = new cc.Blink;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._times);
        return a
    }, update: function (a) {
        a = this._computeEaseTime(a);
        if (this.target && !this.isDone()) {
            var b = 1 / this._times;
            this.target.visible =
                a % b > b / 2
        }
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._originalState = a.visible
    }, stop: function () {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this)
    }, reverse: function () {
        var a = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.blink = function (a, b) {
    return new cc.Blink(a, b)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0, _fromOpacity: 0, ctor: function (a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
    }, clone: function () {
        var a = new cc.FadeTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }, update: function (a) {
        a = this._computeEaseTime(a);
        var b = void 0 !== this._fromOpacity ? this._fromOpacity :
            255;
        this.target.opacity = b + (this._toOpacity - b) * a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._fromOpacity = a.opacity
    }
});
cc.fadeTo = function (a, b) {
    return new cc.FadeTo(a, b)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null, ctor: function (a) {
        cc.FadeTo.prototype.ctor.call(this);
        null == a && (a = 0);
        this.initWithDuration(a, 255)
    }, reverse: function () {
        var a = new cc.FadeOut;
        a.initWithDuration(this._duration, 0);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }, clone: function () {
        var a = new cc.FadeIn;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }, startWithTarget: function (a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, a)
    }
});
cc.fadeIn = function (a) {
    return new cc.FadeIn(a)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
    ctor: function (a) {
        cc.FadeTo.prototype.ctor.call(this);
        null == a && (a = 0);
        this.initWithDuration(a, 0)
    }, reverse: function () {
        var a = new cc.FadeIn;
        a._reverseAction = this;
        a.initWithDuration(this._duration, 255);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }, clone: function () {
        var a = new cc.FadeOut;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }
});
cc.fadeOut = function (a) {
    return new cc.FadeOut(a)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
    _to: null, _from: null, ctor: function (a, b, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, initWithDuration: function (a, b, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, d, e), !0) : !1
    }, clone: function () {
        var a = new cc.TintTo;
        this._cloneDecoration(a);
        var b = this._to;
        a.initWithDuration(this._duration, b.r, b.g, b.b);
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = this.target.color
    }, update: function (a) {
        a = this._computeEaseTime(a);
        var b = this._from, d = this._to;
        b && this.target.setColor(cc.color(b.r + (d.r - b.r) * a, b.g + (d.g - b.g) * a, b.b + (d.b - b.b) * a))
    }
});
cc.tintTo = function (a, b, d, e) {
    return new cc.TintTo(a, b, d, e)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0, _deltaG: 0, _deltaB: 0, _fromR: 0, _fromG: 0, _fromB: 0, ctor: function (a, b, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, initWithDuration: function (a, b, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = d, this._deltaB = e, !0) : !1
    }, clone: function () {
        var a = new cc.TintBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.color;
        this._fromR = a.r;
        this._fromG = a.g;
        this._fromB = a.b
    }, update: function (a) {
        a = this._computeEaseTime(a);
        this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
    }, reverse: function () {
        var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.tintBy = function (a, b, d, e) {
    return new cc.TintBy(a, b, d, e)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
    update: function (a) {
    }, reverse: function () {
        var a = new cc.DelayTime(this._duration);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }, clone: function () {
        var a = new cc.DelayTime;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration);
        return a
    }
});
cc.delayTime = function (a) {
    return new cc.DelayTime(a)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
    _other: null, ctor: function (a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
        a && this.initWithAction(a)
    }, initWithAction: function (a) {
        if (!a)throw Error("cc.ReverseTime.initWithAction(): action must be non null");
        if (a === this._other)throw Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
        return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
    }, clone: function () {
        var a = new cc.ReverseTime;
        this._cloneDecoration(a);
        a.initWithAction(this._other.clone());
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._other.startWithTarget(a)
    }, update: function (a) {
        a = this._computeEaseTime(a);
        this._other && this._other.update(1 - a)
    }, reverse: function () {
        return this._other.clone()
    }, stop: function () {
        this._other.stop();
        cc.Action.prototype.stop.call(this)
    }
});
cc.reverseTime = function (a) {
    return new cc.ReverseTime(a)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    _currFrameIndex: 0,
    ctor: function (a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
        a && this.initWithAnimation(a)
    },
    getAnimation: function () {
        return this._animation
    },
    setAnimation: function (a) {
        this._animation = a
    },
    getCurrentFrameIndex: function () {
        return this._currFrameIndex
    },
    initWithAnimation: function (a) {
        if (!a)throw Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
        var b = a.getDuration();
        if (this.initWithDuration(b * a.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(a);
            this._origFrame = null;
            this._executedLoops = 0;
            var d = this._splitTimes, e = d.length = 0, f = b / a.getTotalDelayUnits();
            a = a.getFrames();
            cc.arrayVerifyType(a, cc.AnimationFrame);
            for (var g = 0; g < a.length; g++) {
                var h = e * f / b, e = e + a[g].getDelayUnits();
                d.push(h)
            }
            return !0
        }
        return !1
    },
    clone: function () {
        var a = new cc.Animate;
        this._cloneDecoration(a);
        a.initWithAnimation(this._animation.clone());
        return a
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._animation.getRestoreOriginalFrame() && (this._origFrame = a.displayFrame());
        this._executedLoops = this._nextFrame = 0
    },
    update: function (a) {
        a = this._computeEaseTime(a);
        1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
        for (var b = this._animation.getFrames(), d = b.length, e = this._splitTimes, f = this._nextFrame; f < d; f++)if (e[f] <= a)_currFrameIndex = f, this.target.setSpriteFrame(b[_currFrameIndex].getSpriteFrame()), this._nextFrame = f + 1; else break
    },
    reverse: function () {
        var a =
            this._animation, b = a.getFrames(), d = [];
        cc.arrayVerifyType(b, cc.AnimationFrame);
        if (0 < b.length)for (var e = b.length - 1; 0 <= e; e--) {
            var f = b[e];
            if (!f)break;
            d.push(f.clone())
        }
        b = new cc.Animation(d, a.getDelayPerUnit(), a.getLoops());
        b.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
        a = new cc.Animate(b);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    stop: function () {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this)
    }
});
cc.animate = function (a) {
    return new cc.Animate(a)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
    _action: null, _forcedTarget: null, ctor: function (a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        b && this.initWithTarget(a, b)
    }, initWithTarget: function (a, b) {
        return this.initWithDuration(b._duration) ? (this._forcedTarget = a, this._action = b, !0) : !1
    }, clone: function () {
        var a = new cc.TargetedAction;
        this._cloneDecoration(a);
        a.initWithTarget(this._forcedTarget, this._action.clone());
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._action.startWithTarget(this._forcedTarget)
    }, stop: function () {
        this._action.stop()
    }, update: function (a) {
        a = this._computeEaseTime(a);
        this._action.update(a)
    }, getForcedTarget: function () {
        return this._forcedTarget
    }, setForcedTarget: function (a) {
        this._forcedTarget !== a && (this._forcedTarget = a)
    }
});
cc.targetedAction = function (a, b) {
    return new cc.TargetedAction(a, b)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function () {
        return !0
    }, step: function (a) {
        this.update(1)
    }, update: function (a) {
    }, reverse: function () {
        return this.clone()
    }, clone: function () {
        return new cc.ActionInstant
    }
});
cc.Show = cc.ActionInstant.extend({
    update: function (a) {
        this.target.visible = !0
    }, reverse: function () {
        return new cc.Hide
    }, clone: function () {
        return new cc.Show
    }
});
cc.show = function () {
    return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
    update: function (a) {
        this.target.visible = !1
    }, reverse: function () {
        return new cc.Show
    }, clone: function () {
        return new cc.Hide
    }
});
cc.hide = function () {
    return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function (a) {
        this.target.visible = !this.target.visible
    }, reverse: function () {
        return new cc.ToggleVisibility
    }, clone: function () {
        return new cc.ToggleVisibility
    }
});
cc.toggleVisibility = function () {
    return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0, ctor: function (a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.init(a)
    }, update: function (a) {
        this.target.removeFromParent(this._isNeedCleanUp)
    }, init: function (a) {
        this._isNeedCleanUp = a;
        return !0
    }, reverse: function () {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }, clone: function () {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
});
cc.removeSelf = function (a) {
    return new cc.RemoveSelf(a)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1, ctor: function (a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = !1;
        void 0 !== a && this.initWithFlipX(a)
    }, initWithFlipX: function (a) {
        this._flippedX = a;
        return !0
    }, update: function (a) {
        this.target.flippedX = this._flippedX
    }, reverse: function () {
        return new cc.FlipX(!this._flippedX)
    }, clone: function () {
        var a = new cc.FlipX;
        a.initWithFlipX(this._flippedX);
        return a
    }
});
cc.flipX = function (a) {
    return new cc.FlipX(a)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1, ctor: function (a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = !1;
        void 0 !== a && this.initWithFlipY(a)
    }, initWithFlipY: function (a) {
        this._flippedY = a;
        return !0
    }, update: function (a) {
        this.target.flippedY = this._flippedY
    }, reverse: function () {
        return new cc.FlipY(!this._flippedY)
    }, clone: function () {
        var a = new cc.FlipY;
        a.initWithFlipY(this._flippedY);
        return a
    }
});
cc.flipY = function (a) {
    return new cc.FlipY(a)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
    _x: 0, _y: 0, ctor: function (a, b) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._y = this._x = 0;
        void 0 !== a && (void 0 !== a.x && (b = a.y, a = a.x), this.initWithPosition(a, b))
    }, initWithPosition: function (a, b) {
        this._x = a;
        this._y = b;
        return !0
    }, update: function (a) {
        this.target.setPosition(this._x, this._y)
    }, clone: function () {
        var a = new cc.Place;
        a.initWithPosition(this._x, this._y);
        return a
    }
});
cc.place = function (a, b) {
    return new cc.Place(a, b)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null, _function: null, _data: null, ctor: function (a, b, d) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this.initWithFunction(a, b, d)
    }, initWithFunction: function (a, b, d) {
        a && (this._function = a);
        b && (this._selectorTarget = b);
        void 0 !== d && (this._data = d);
        return !0
    }, execute: function () {
        this._function && this._function.call(this._selectorTarget, this.target, this._data)
    }, update: function (a) {
        this.execute()
    }, getTargetCallback: function () {
        return this._selectorTarget
    }, setTargetCallback: function (a) {
        a !==
        this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    }, clone: function () {
        var a = new cc.CallFunc;
        a.initWithFunction(this._function, this._selectorTarget, this._data);
        return a
    }
});
cc.callFunc = function (a, b, d) {
    return new cc.CallFunc(a, b, d)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function () {
        cc.ActionInterval.prototype.ctor.call(this);
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.getCamera();
        var b = a.getCenter();
        this._centerXOrig = b.x;
        this._centerYOrig = b.y;
        this._centerZOrig = b.z;
        b = a.getEye();
        this._eyeXOrig = b.x;
        this._eyeYOrig = b.y;
        this._eyeZOrig = b.z;
        a = a.getUp();
        this._upXOrig = a.x;
        this._upYOrig = a.y;
        this._upZOrig = a.z
    },
    clone: function () {
        return new cc.ActionCamera
    },
    reverse: function () {
        return new cc.ReverseTime(this)
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function (a, b, d, e, f, g, h) {
        cc.ActionCamera.prototype.ctor.call(this);
        void 0 !== h && this.initWithDuration(a, b, d, e, f, g, h)
    },
    initWithDuration: function (a, b, d, e, f, g, h) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = b, this._deltaRadius = d, this._angleZ = e, this._deltaAngleZ = f, this._angleX = g, this._deltaAngleX = h, this._radDeltaZ =
            cc.degreesToRadians(f), this._radDeltaX = cc.degreesToRadians(h), !0) : !1
    },
    sphericalRadius: function () {
        var a, b;
        b = this.target.getCamera();
        var d = b.getEye();
        a = b.getCenter();
        b = d.x - a.x;
        var e = d.y - a.y;
        a = d.z - a.z;
        var d = Math.sqrt(Math.pow(b, 2) + Math.pow(e, 2) + Math.pow(a, 2)), f = Math.sqrt(Math.pow(b, 2) + Math.pow(e, 2));
        0 === f && (f = cc.FLT_EPSILON);
        0 === d && (d = cc.FLT_EPSILON);
        a = Math.acos(a / d);
        b = 0 > b ? Math.PI - Math.asin(e / f) : Math.asin(e / f);
        return {newRadius: d / cc.Camera.getZEye(), zenith: a, azimuth: b}
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        a = this.sphericalRadius();
        isNaN(this._radius) && (this._radius = a.newRadius);
        isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith));
        isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth));
        this._radZ = cc.degreesToRadians(this._angleZ);
        this._radX = cc.degreesToRadians(this._angleX)
    },
    clone: function () {
        var a = new cc.OrbitCamera;
        a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
        return a
    },
    update: function (a) {
        a =
            this._computeEaseTime(a);
        var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(), d = this._radZ + this._radDeltaZ * a, e = this._radX + this._radDeltaX * a;
        a = Math.sin(d) * Math.cos(e) * b + this._centerXOrig;
        e = Math.sin(d) * Math.sin(e) * b + this._centerYOrig;
        b = Math.cos(d) * b + this._centerZOrig;
        this.target.getCamera().setEye(a, e, b);
        this.target.setNodeDirty()
    }
});
cc.orbitCamera = function (a, b, d, e, f, g, h) {
    return new cc.OrbitCamera(a, b, d, e, f, g, h)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
    _inner: null, ctor: function (a) {
        cc.ActionInterval.prototype.ctor.call(this);
        a && this.initWithAction(a)
    }, initWithAction: function (a) {
        if (!a)throw Error("cc.ActionEase.initWithAction(): action must be non nil");
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    }, clone: function () {
        var a = new cc.ActionEase;
        a.initWithAction(this._inner.clone());
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._inner.startWithTarget(this.target)
    },
    stop: function () {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this)
    }, update: function (a) {
        this._inner.update(a)
    }, reverse: function () {
        return new cc.ActionEase(this._inner.reverse())
    }, getInnerAction: function () {
        return this._inner
    }
});
cc.actionEase = function (a) {
    return new cc.ActionEase(a)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0, ctor: function (a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    }, setRate: function (a) {
        this._rate = a
    }, getRate: function () {
        return this._rate
    }, initWithAction: function (a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
    }, clone: function () {
        var a = new cc.EaseRateAction;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }, reverse: function () {
        return new cc.EaseRateAction(this._inner.reverse(),
            1 / this._rate)
    }
});
cc.easeRateAction = function (a, b) {
    return new cc.EaseRateAction(a, b)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
    update: function (a) {
        this._inner.update(Math.pow(a, this._rate))
    }, reverse: function () {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
    }, clone: function () {
        var a = new cc.EaseIn;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseIn.create = function (a, b) {
    return new cc.EaseIn(a, b)
};
cc.easeIn = function (a) {
    return {
        _rate: a, easing: function (a) {
            return Math.pow(a, this._rate)
        }, reverse: function () {
            return cc.easeIn(1 / this._rate)
        }
    }
};
cc.EaseOut = cc.EaseRateAction.extend({
    update: function (a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    }, reverse: function () {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
    }, clone: function () {
        var a = new cc.EaseOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseOut.create = function (a, b) {
    return new cc.EaseOut(a, b)
};
cc.easeOut = function (a) {
    return {
        _rate: a, easing: function (a) {
            return Math.pow(a, 1 / this._rate)
        }, reverse: function () {
            return cc.easeOut(1 / this._rate)
        }
    }
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function (a) {
        a *= 2;
        1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
    }, clone: function () {
        var a = new cc.EaseInOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }, reverse: function () {
        return new cc.EaseInOut(this._inner.reverse(), this._rate)
    }
});
cc.EaseInOut.create = function (a, b) {
    return new cc.EaseInOut(a, b)
};
cc.easeInOut = function (a) {
    return {
        _rate: a, easing: function (a) {
            a *= 2;
            return 1 > a ? 0.5 * Math.pow(a, this._rate) : 1 - 0.5 * Math.pow(2 - a, this._rate)
        }, reverse: function () {
            return cc.easeInOut(this._rate)
        }
    }
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function (a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    }, reverse: function () {
        return new cc.EaseExponentialOut(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseExponentialIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialIn.create = function (a) {
    return new cc.EaseExponentialIn(a)
};
cc._easeExponentialInObj = {
    easing: function (a) {
        return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
    }, reverse: function () {
        return cc._easeExponentialOutObj
    }
};
cc.easeExponentialIn = function () {
    return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function (a) {
        this._inner.update(1 === a ? 1 : -Math.pow(2, -10 * a) + 1)
    }, reverse: function () {
        return new cc.EaseExponentialIn(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseExponentialOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialOut.create = function (a) {
    return new cc.EaseExponentialOut(a)
};
cc._easeExponentialOutObj = {
    easing: function (a) {
        return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1
    }, reverse: function () {
        return cc._easeExponentialInObj
    }
};
cc.easeExponentialOut = function () {
    return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function (a) {
        1 !== a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
        this._inner.update(a)
    }, reverse: function () {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseExponentialInOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialInOut.create = function (a) {
    return new cc.EaseExponentialInOut(a)
};
cc._easeExponentialInOutObj = {
    easing: function (a) {
        return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
    }, reverse: function () {
        return cc._easeExponentialInOutObj
    }
};
cc.easeExponentialInOut = function () {
    return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
    update: function (a) {
        a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
        this._inner.update(a)
    }, reverse: function () {
        return new cc.EaseSineOut(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseSineIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineIn.create = function (a) {
    return new cc.EaseSineIn(a)
};
cc._easeSineInObj = {
    easing: function (a) {
        return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
    }, reverse: function () {
        return cc._easeSineOutObj
    }
};
cc.easeSineIn = function () {
    return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
    update: function (a) {
        a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2);
        this._inner.update(a)
    }, reverse: function () {
        return new cc.EaseSineIn(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseSineOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineOut.create = function (a) {
    return new cc.EaseSineOut(a)
};
cc._easeSineOutObj = {
    easing: function (a) {
        return 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2)
    }, reverse: function () {
        return cc._easeSineInObj
    }
};
cc.easeSineOut = function () {
    return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function (a) {
        a = 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
        this._inner.update(a)
    }, clone: function () {
        var a = new cc.EaseSineInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
});
cc.EaseSineInOut.create = function (a) {
    return new cc.EaseSineInOut(a)
};
cc._easeSineInOutObj = {
    easing: function (a) {
        return 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1)
    }, reverse: function () {
        return cc._easeSineInOutObj
    }
};
cc.easeSineInOut = function () {
    return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: 0.3, ctor: function (a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        a && this.initWithAction(a, b)
    }, getPeriod: function () {
        return this._period
    }, setPeriod: function (a) {
        this._period = a
    }, initWithAction: function (a, b) {
        cc.ActionEase.prototype.initWithAction.call(this, a);
        this._period = null == b ? 0.3 : b;
        return !0
    }, reverse: function () {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
        return null
    }, clone: function () {
        var a = new cc.EaseElastic;
        a.initWithAction(this._inner.clone(),
            this._period);
        return a
    }
});
cc.EaseElastic.create = function (a, b) {
    return new cc.EaseElastic(a, b)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function (a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, a -= 1, b = -Math.pow(2, 10 * a) * Math.sin((a - b) * Math.PI * 2 / this._period));
        this._inner.update(b)
    }, reverse: function () {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period)
    }, clone: function () {
        var a = new cc.EaseElasticIn;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticIn.create = function (a, b) {
    return new cc.EaseElasticIn(a, b)
};
cc._easeElasticInObj = {
    easing: function (a) {
        if (0 === a || 1 === a)return a;
        a -= 1;
        return -Math.pow(2, 10 * a) * Math.sin((a - 0.075) * Math.PI * 2 / 0.3)
    }, reverse: function () {
        return cc._easeElasticOutObj
    }
};
cc.easeElasticIn = function (a) {
    return a && 0.3 !== a ? {
        _period: a, easing: function (a) {
            if (0 === a || 1 === a)return a;
            a -= 1;
            return -Math.pow(2, 10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period)
        }, reverse: function () {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function (a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, b = Math.pow(2, -10 * a) * Math.sin((a - b) * Math.PI * 2 / this._period) + 1);
        this._inner.update(b)
    }, reverse: function () {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period)
    }, clone: function () {
        var a = new cc.EaseElasticOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticOut.create = function (a, b) {
    return new cc.EaseElasticOut(a, b)
};
cc._easeElasticOutObj = {
    easing: function (a) {
        return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - 0.075) * Math.PI * 2 / 0.3) + 1
    }, reverse: function () {
        return cc._easeElasticInObj
    }
};
cc.easeElasticOut = function (a) {
    return a && 0.3 !== a ? {
        _period: a, easing: function (a) {
            return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period) + 1
        }, reverse: function () {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function (a) {
        var b = 0, b = this._period;
        if (0 === a || 1 === a)b = a; else {
            b || (b = this._period = 0.3 * 1.5);
            var d = b / 4;
            a = 2 * a - 1;
            b = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * Math.PI * 2 / b) : Math.pow(2, -10 * a) * Math.sin((a - d) * Math.PI * 2 / b) * 0.5 + 1
        }
        this._inner.update(b)
    }, reverse: function () {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
    }, clone: function () {
        var a = new cc.EaseElasticInOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticInOut.create = function (a, b) {
    return new cc.EaseElasticInOut(a, b)
};
cc.easeElasticInOut = function (a) {
    return {
        _period: a || 0.3, easing: function (a) {
            var d = 0, d = this._period;
            if (0 === a || 1 === a)d = a; else {
                d || (d = this._period = 0.3 * 1.5);
                var e = d / 4;
                a = 2 * a - 1;
                d = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - e) * Math.PI * 2 / d) : Math.pow(2, -10 * a) * Math.sin((a - e) * Math.PI * 2 / d) * 0.5 + 1
            }
            return d
        }, reverse: function () {
            return cc.easeElasticInOut(this._period)
        }
    }
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function (a) {
        if (a < 1 / 2.75)return 7.5625 * a * a;
        if (a < 2 / 2.75)return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
        if (a < 2.5 / 2.75)return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
        a -= 2.625 / 2.75;
        return 7.5625 * a * a + 0.984375
    }, clone: function () {
        var a = new cc.EaseBounce;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseBounce(this._inner.reverse())
    }
});
cc.EaseBounce.create = function (a) {
    return new cc.EaseBounce(a)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function (a) {
        a = 1 - this.bounceTime(1 - a);
        this._inner.update(a)
    }, reverse: function () {
        return new cc.EaseBounceOut(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseBounceIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceIn.create = function (a) {
    return new cc.EaseBounceIn(a)
};
cc._bounceTime = function (a) {
    if (a < 1 / 2.75)return 7.5625 * a * a;
    if (a < 2 / 2.75)return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75)return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
cc._easeBounceInObj = {
    easing: function (a) {
        return 1 - cc._bounceTime(1 - a)
    }, reverse: function () {
        return cc._easeBounceOutObj
    }
};
cc.easeBounceIn = function () {
    return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function (a) {
        a = this.bounceTime(a);
        this._inner.update(a)
    }, reverse: function () {
        return new cc.EaseBounceIn(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseBounceOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceOut.create = function (a) {
    return new cc.EaseBounceOut(a)
};
cc._easeBounceOutObj = {
    easing: function (a) {
        return cc._bounceTime(a)
    }, reverse: function () {
        return cc._easeBounceInObj
    }
};
cc.easeBounceOut = function () {
    return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function (a) {
        var b = 0, b = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
        this._inner.update(b)
    }, clone: function () {
        var a = new cc.EaseBounceInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
});
cc.EaseBounceInOut.create = function (a) {
    return new cc.EaseBounceInOut(a)
};
cc._easeBounceInOutObj = {
    easing: function (a) {
        return a = 0.5 > a ? 0.5 * (1 - cc._bounceTime(1 - 2 * a)) : 0.5 * cc._bounceTime(2 * a - 1) + 0.5
    }, reverse: function () {
        return cc._easeBounceInOutObj
    }
};
cc.easeBounceInOut = function () {
    return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
    update: function (a) {
        this._inner.update(0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158))
    }, reverse: function () {
        return new cc.EaseBackOut(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseBackIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackIn.create = function (a) {
    return new cc.EaseBackIn(a)
};
cc._easeBackInObj = {
    easing: function (a) {
        return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
    }, reverse: function () {
        return cc._easeBackOutObj
    }
};
cc.easeBackIn = function () {
    return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
    update: function (a) {
        a -= 1;
        this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
    }, reverse: function () {
        return new cc.EaseBackIn(this._inner.reverse())
    }, clone: function () {
        var a = new cc.EaseBackOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackOut.create = function (a) {
    return new cc.EaseBackOut(a)
};
cc._easeBackOutObj = {
    easing: function (a) {
        a -= 1;
        return a * a * (2.70158 * a + 1.70158) + 1
    }, reverse: function () {
        return cc._easeBackInObj
    }
};
cc.easeBackOut = function () {
    return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function (a) {
        a *= 2;
        1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
    }, clone: function () {
        var a = new cc.EaseBackInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
});
cc.EaseBackInOut.create = function (a) {
    return new cc.EaseBackInOut(a)
};
cc._easeBackInOutObj = {
    easing: function (a) {
        a *= 2;
        if (1 > a)return a * a * (3.5949095 * a - 2.5949095) / 2;
        a -= 2;
        return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
    }, reverse: function () {
        return cc._easeBackInOutObj
    }
};
cc.easeBackInOut = function () {
    return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null, _p1: null, _p2: null, _p3: null, ctor: function (a) {
        cc.ActionEase.prototype.ctor.call(this, a)
    }, _updateTime: function (a, b, d, e, f) {
        return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * b + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
    }, update: function (a) {
        a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
        this._inner.update(a)
    }, clone: function () {
        var a = new cc.EaseBezierAction;
        a.initWithAction(this._inner.clone());
        a.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return a
    },
    reverse: function () {
        var a = new cc.EaseBezierAction(this._inner.reverse());
        a.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return a
    }, setBezierParamer: function (a, b, d, e) {
        this._p0 = a || 0;
        this._p1 = b || 0;
        this._p2 = d || 0;
        this._p3 = e || 0
    }
});
cc.EaseBezierAction.create = function (a) {
    return new cc.EaseBezierAction(a)
};
cc.easeBezierAction = function (a, b, d, e) {
    return {
        easing: function (f) {
            return cc.EaseBezierAction.prototype._updateTime(a, b, d, e, f)
        }, reverse: function () {
            return cc.easeBezierAction(e, d, b, a)
        }
    }
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function (a) {
        return Math.pow(a, 2)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuadraticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
});
cc.EaseQuadraticActionIn.create = function (a) {
    return new cc.EaseQuadraticActionIn(a)
};
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime, reverse: function () {
        return cc._easeQuadraticActionIn
    }
};
cc.easeQuadraticActionIn = function () {
    return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        return -a * (a - 2)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuadraticActionOut;
        a.initWithAction();
        return a
    }, reverse: function () {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionOut.create = function (a) {
    return new cc.EaseQuadraticActionOut(a)
};
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime, reverse: function () {
        return cc._easeQuadraticActionOut
    }
};
cc.easeQuadraticActionOut = function () {
    return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        var b = a;
        a *= 2;
        1 > a ? b = a * a * 0.5 : (--a, b = -0.5 * (a * (a - 2) - 1));
        return b
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuadraticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionInOut.create = function (a) {
    return new cc.EaseQuadraticActionInOut(a)
};
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime, reverse: function () {
        return cc._easeQuadraticActionInOut
    }
};
cc.easeQuadraticActionInOut = function () {
    return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function (a) {
        return a * a * a * a
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuarticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
});
cc.EaseQuarticActionIn.create = function (a) {
    return new cc.EaseQuarticActionIn(a)
};
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime, reverse: function () {
        return cc._easeQuarticActionIn
    }
};
cc.easeQuarticActionIn = function () {
    return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a -= 1;
        return -(a * a * a * a - 1)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuarticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionOut.create = function (a) {
    return new cc.EaseQuarticActionOut(a)
};
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime, reverse: function () {
        return cc._easeQuarticActionOut
    }
};
cc.easeQuarticActionOut = function () {
    return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a *= 2;
        if (1 > a)return 0.5 * a * a * a * a;
        a -= 2;
        return -0.5 * (a * a * a * a - 2)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuarticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionInOut.create = function (a) {
    return new cc.EaseQuarticActionInOut(a)
};
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime, reverse: function () {
        return cc._easeQuarticActionInOut
    }
};
cc.easeQuarticActionInOut = function () {
    return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function (a) {
        return a * a * a * a * a
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuinticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
});
cc.EaseQuinticActionIn.create = function (a) {
    return new cc.EaseQuinticActionIn(a)
};
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime, reverse: function () {
        return cc._easeQuinticActionIn
    }
};
cc.easeQuinticActionIn = function () {
    return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a -= 1;
        return a * a * a * a * a + 1
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuinticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionOut.create = function (a) {
    return new cc.EaseQuinticActionOut(a)
};
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime, reverse: function () {
        return cc._easeQuinticActionOut
    }
};
cc.easeQuinticActionOut = function () {
    return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a *= 2;
        if (1 > a)return 0.5 * a * a * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a * a * a + 2)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseQuinticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionInOut.create = function (a) {
    return new cc.EaseQuinticActionInOut(a)
};
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime, reverse: function () {
        return cc._easeQuinticActionInOut
    }
};
cc.easeQuinticActionInOut = function () {
    return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function (a) {
        return -1 * (Math.sqrt(1 - a * a) - 1)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseCircleActionIn;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
});
cc.EaseCircleActionIn.create = function (a) {
    return new cc.EaseCircleActionIn(a)
};
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime, reverse: function () {
        return cc._easeCircleActionIn
    }
};
cc.easeCircleActionIn = function () {
    return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a -= 1;
        return Math.sqrt(1 - a * a)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseCircleActionOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
});
cc.EaseCircleActionOut.create = function (a) {
    return new cc.EaseCircleActionOut(a)
};
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime, reverse: function () {
        return cc._easeCircleActionOut
    }
};
cc.easeCircleActionOut = function () {
    return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a *= 2;
        if (1 > a)return -0.5 * (Math.sqrt(1 - a * a) - 1);
        a -= 2;
        return 0.5 * (Math.sqrt(1 - a * a) + 1)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseCircleActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
});
cc.EaseCircleActionInOut.create = function (a) {
    return new cc.EaseCircleActionInOut(a)
};
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime, reverse: function () {
        return cc._easeCircleActionInOut
    }
};
cc.easeCircleActionInOut = function () {
    return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function (a) {
        return a * a * a
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseCubicActionIn;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
});
cc.EaseCubicActionIn.create = function (a) {
    return new cc.EaseCubicActionIn(a)
};
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime, reverse: function () {
        return cc._easeCubicActionIn
    }
};
cc.easeCubicActionIn = function () {
    return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a -= 1;
        return a * a * a + 1
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseCubicActionOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
});
cc.EaseCubicActionOut.create = function (a) {
    return new cc.EaseCubicActionOut(a)
};
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime, reverse: function () {
        return cc._easeCubicActionOut
    }
};
cc.easeCubicActionOut = function () {
    return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function (a) {
        a *= 2;
        if (1 > a)return 0.5 * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a + 2)
    }, update: function (a) {
        this._inner.update(this._updateTime(a))
    }, clone: function () {
        var a = new cc.EaseCubicActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    }, reverse: function () {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
});
cc.EaseCubicActionInOut.create = function (a) {
    return new cc.EaseCubicActionInOut(a)
};
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime, reverse: function () {
        return cc._easeCubicActionInOut
    }
};
cc.easeCubicActionInOut = function () {
    return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function (a, b, d, e, f, g) {
    var h = g * g, n = h * g, p = (1 - f) / 2;
    f = p * (-n + 2 * h - g);
    var r = p * (-n + h) + (2 * n - 3 * h + 1);
    g = p * (n - 2 * h + g) + (-2 * n + 3 * h);
    h = p * (n - h);
    return cc.p(a.x * f + b.x * r + d.x * g + e.x * h, a.y * f + b.y * r + d.y * g + e.y * h)
};
cc.reverseControlPoints = function (a) {
    for (var b = [], d = a.length - 1; 0 <= d; d--)b.push(cc.p(a[d].x, a[d].y));
    return b
};
cc.cloneControlPoints = function (a) {
    for (var b = [], d = 0; d < a.length; d++)b.push(cc.p(a[d].x, a[d].y));
    return b
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function (a, b) {
    var d = Math.min(a.length - 1, Math.max(b, 0));
    return a[d]
};
cc.reverseControlPointsInline = function (a) {
    for (var b = a.length, d = 0 | b / 2, e = 0; e < d; ++e) {
        var f = a[e];
        a[e] = a[b - e - 1];
        a[b - e - 1] = f
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null, _deltaT: 0, _tension: 0, _previousPosition: null, _accumulatedDiff: null, ctor: function (a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        void 0 !== d && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        if (!b || 0 === b.length)throw Error("Invalid configuration. It must at least have one control point");
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension = d, !0) : !1
    }, clone: function () {
        var a =
            new cc.CardinalSplineTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0)
    }, update: function (a) {
        a = this._computeEaseTime(a);
        var b, d = this._points;
        if (1 === a)b = d.length - 1, a = 1; else {
            var e = this._deltaT;
            b = 0 | a / e;
            a = (a - e * b) / e
        }
        b = cc.cardinalSplineAt(cc.getControlPointAt(d,
            b - 1), cc.getControlPointAt(d, b - 0), cc.getControlPointAt(d, b + 1), cc.getControlPointAt(d, b + 2), this._tension, a);
        cc.ENABLE_STACKABLE_ACTIONS && (d = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 !== d || 0 !== a) && (e = this._accumulatedDiff, d = e.x + d, a = e.y + a, e.x = d, e.y = a, b.x += d, b.y += a);
        this.updatePosition(b)
    }, reverse: function () {
        var a = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, a, this._tension)
    }, updatePosition: function (a) {
        this.target.setPosition(a);
        this._previousPosition = a
    }, getPoints: function () {
        return this._points
    }, setPoints: function (a) {
        this._points = a
    }
});
cc.cardinalSplineTo = function (a, b, d) {
    return new cc.CardinalSplineTo(a, b, d)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null, ctor: function (a, b, d) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, b, d)
    }, startWithTarget: function (a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
        this._startPosition.x = a.getPositionX();
        this._startPosition.y = a.getPositionY()
    }, reverse: function () {
        for (var a = this._points.slice(), b, d = a[0], e = 1; e < a.length; ++e)b = a[e], a[e] = cc.pSub(b, d), d = b;
        a = cc.reverseControlPoints(a);
        d = a[a.length - 1];
        a.pop();
        d.x = -d.x;
        d.y = -d.y;
        a.unshift(d);
        for (e = 1; e < a.length; ++e)b = a[e], b.x = -b.x, b.y = -b.y, b.x += d.x, b.y += d.y, d = a[e] = b;
        return cc.cardinalSplineBy(this._duration, a, this._tension)
    }, updatePosition: function (a) {
        var b = this._startPosition, d = a.x + b.x;
        a = a.y + b.y;
        this._previousPosition.x = d;
        this._previousPosition.y = a;
        this.target.setPosition(d, a)
    }, clone: function () {
        var a = new cc.CardinalSplineBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    }
});
cc.cardinalSplineBy = function (a, b, d) {
    return new cc.CardinalSplineBy(a, b, d)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function (a, b) {
        b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    }, clone: function () {
        var a = new cc.CatmullRomTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomTo = function (a, b) {
    return new cc.CatmullRomTo(a, b)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function (a, b) {
        cc.CardinalSplineBy.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    }, clone: function () {
        var a = new cc.CatmullRomBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomBy = function (a, b) {
    return new cc.CatmullRomBy(a, b)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function (a, b) {
    }
});
cc.ActionTween = cc.ActionInterval.extend({
    key: "", from: 0, to: 0, delta: 0, ctor: function (a, b, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, initWithDuration: function (a, b, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = e, this.from = d, !0) : !1
    }, startWithTarget: function (a) {
        if (!a || !a.updateTweenAction)throw Error("cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function");
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this.delta = this.to - this.from
    }, update: function (a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    }, reverse: function () {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from)
    }, clone: function () {
        var a = new cc.ActionTween;
        a.initWithDuration(this._duration, this.key, this.from, this.to);
        return a
    }
});
cc.actionTween = function (a, b, d, e) {
    return new cc.ActionTween(a, b, d, e)
};
cc.ActionTween.create = cc.actionTween;
cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null, _gridNodeTarget: null, ctor: function (a, b) {
        cc.sys._checkWebGLRenderMode();
        cc.ActionInterval.prototype.ctor.call(this);
        this._gridSize = cc.size(0, 0);
        b && this.initWithDuration(a, b)
    }, _cacheTargetAsGridNode: function (a) {
        this._gridNodeTarget = a
    }, clone: function () {
        var a = new cc.GridAction, b = this._gridSize;
        a.initWithDuration(this._duration, cc.size(b.width, b.height));
        return a
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        cc.renderer.childrenOrderDirty = !0;
        this._cacheTargetAsGridNode(a);
        var b = this.getGrid();
        (a = this._gridNodeTarget.getGrid()) && 0 < a.getReuseGrid() ? (b = a.getGridSize(), a.isActive() && b.width === this._gridSize.width && b.height === this._gridSize.height && a.reuse()) : (a && a.isActive() && a.setActive(!1), this._gridNodeTarget.setGrid(b), this._gridNodeTarget.getGrid().setActive(!0))
    }, reverse: function () {
        return new cc.ReverseTime(this)
    }, initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this,
            a) ? (this._gridSize.width = b.width, this._gridSize.height = b.height, !0) : !1
    }, getGrid: function () {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
    }
});
cc.gridAction = function (a, b) {
    return new cc.GridAction(a, b)
};
cc.GridAction.create = cc.gridAction;
cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function () {
        return new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect())
    }, getGridRect: function () {
        return this._gridNodeTarget.getGridRect()
    }, vertex: function (a) {
        return this.getVertex(a)
    }, getVertex: function (a) {
        return this.target.grid.getVertex(a)
    }, originalVertex: function (a) {
        return this.getOriginalVertex(a)
    }, getOriginalVertex: function (a) {
        return this.target.grid.originalVertex(a)
    }, setVertex: function (a, b) {
        this.target.grid.setVertex(a,
            b)
    }
});
cc.grid3DAction = function (a, b) {
    return new cc.Grid3DAction(a, b)
};
cc.Grid3DAction.create = cc.grid3DAction;
cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function (a) {
        return this.getTile(a)
    }, getTile: function (a) {
        return this.target.grid.tile(a)
    }, originalTile: function (a) {
        return this.getOriginalTile(a)
    }, getOriginalTile: function (a) {
        return this.target.grid.originalTile(a)
    }, setTile: function (a, b) {
        this.target.grid.setTile(a, b)
    }, getGrid: function () {
        return new cc.TiledGrid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect())
    }
});
cc.tiledGrid3DAction = function (a, b) {
    return new cc.TiledGrid3DAction(a, b)
};
cc.TiledGrid3DAction.create = cc.tiledGrid3DAction;
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function (a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        cc.renderer.childrenOrderDirty = !0;
        (a = this.target.grid) && a.isActive() && a.setActive(!1)
    }
});
cc.stopGrid = function () {
    return new cc.StopGrid
};
cc.StopGrid.create = cc.stopGrid;
cc.ReuseGrid = cc.ActionInstant.extend({
    _times: null, ctor: function (a) {
        cc.ActionInstant.prototype.ctor.call(this);
        void 0 !== a && this.initWithTimes(a)
    }, initWithTimes: function (a) {
        this._times = a;
        return !0
    }, startWithTarget: function (a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        cc.renderer.childrenOrderDirty = !0;
        this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
    }
});
cc.reuseGrid = function (a) {
    return new cc.ReuseGrid(a)
};
cc.ReuseGrid.create = cc.reuseGrid;
cc.Waves3D = cc.Grid3DAction.extend({
    _waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, getAmplitude: function () {
        return this._amplitude
    }, setAmplitude: function (a) {
        this._amplitude = a
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    }, setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    }, initWithDuration: function (a, b, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = d, this._amplitude =
            e, this._amplitudeRate = 1, !0) : !1
    }, update: function (a) {
        for (var b = this._gridSize, d = this._amplitude, e = cc.p(0, 0), f = this._amplitudeRate, g = this._waves, h = 0; h < b.width + 1; ++h)for (var n = 0; n < b.height + 1; ++n) {
            e.x = h;
            e.y = n;
            var p = this.originalVertex(e);
            p.z += Math.sin(Math.PI * a * g * 2 + 0.01 * (p.y + p.x)) * d * f;
            this.setVertex(e, p)
        }
    }
});
cc.waves3D = function (a, b, d, e) {
    return new cc.Waves3D(a, b, d, e)
};
cc.Waves3D.create = cc.waves3D;
cc.FlipX3D = cc.Grid3DAction.extend({
    ctor: function (a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    }, initWithDuration: function (a) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, 1))
    }, initWithSize: function (a, b) {
        return 1 !== a.width || 1 !== a.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, b, a)
    }, update: function (a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var d = Math.cos(b / 2), b = new cc.Vertex3F,
            e = cc.p(0, 0);
        e.x = e.y = 1;
        var f = this.originalVertex(e);
        e.x = e.y = 0;
        var e = this.originalVertex(e), g = f.x, h = e.x, n, p;
        g > h ? (f = cc.p(0, 0), e = cc.p(0, 1), n = cc.p(1, 0), p = cc.p(1, 1)) : (n = cc.p(0, 0), p = cc.p(0, 1), f = cc.p(1, 0), e = cc.p(1, 1), g = h);
        b.x = g - g * d;
        b.z = Math.abs(parseFloat(g * a / 4));
        a = this.originalVertex(f);
        a.x = b.x;
        a.z += b.z;
        this.setVertex(f, a);
        a = this.originalVertex(e);
        a.x = b.x;
        a.z += b.z;
        this.setVertex(e, a);
        a = this.originalVertex(n);
        a.x -= b.x;
        a.z -= b.z;
        this.setVertex(n, a);
        a = this.originalVertex(p);
        a.x -= b.x;
        a.z -= b.z;
        this.setVertex(p,
            a)
    }
});
cc.flipX3D = function (a) {
    return new cc.FlipX3D(a)
};
cc.FlipX3D.create = cc.flipX3D;
cc.FlipY3D = cc.FlipX3D.extend({
    ctor: function (a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    }, update: function (a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var d = Math.cos(b / 2), b = new cc.Vertex3F, e = cc.p(0, 0);
        e.x = e.y = 1;
        var f = this.originalVertex(e);
        e.x = e.y = 0;
        var e = this.originalVertex(e), g = f.y, h = e.y, n, p;
        g > h ? (f = cc.p(0, 0), e = cc.p(0, 1), n = cc.p(1, 0), p = cc.p(1, 1)) : (e = cc.p(0, 0), f = cc.p(0, 1), p = cc.p(1, 0), n = cc.p(1, 1), g = h);
        b.y = g - g * d;
        b.z = Math.abs(parseFloat(g * a) / 4);
        a = this.originalVertex(f);
        a.y = b.y;
        a.z += b.z;
        this.setVertex(f, a);
        a = this.originalVertex(e);
        a.y -= b.y;
        a.z -= b.z;
        this.setVertex(e, a);
        a = this.originalVertex(n);
        a.y = b.y;
        a.z += b.z;
        this.setVertex(n, a);
        a = this.originalVertex(p);
        a.y -= b.y;
        a.z -= b.z;
        this.setVertex(p, a)
    }
});
cc.flipY3D = function (a) {
    return new cc.FlipY3D(a)
};
cc.FlipY3D.create = cc.flipY3D;
cc.Lens3D = cc.Grid3DAction.extend({
    _position: null, _radius: 0, _lensEffect: 0, _concave: !1, _dirty: !1, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, getLensEffect: function () {
        return this._lensEffect
    }, setLensEffect: function (a) {
        this._lensEffect = a
    }, setConcave: function (a) {
        this._concave = a
    }, getPosition: function () {
        return this._position
    }, setPosition: function (a) {
        cc.pointEqualToPoint(a, this._position) || (this._position.x = a.x, this._position.y =
            a.y, this._dirty = !0)
    }, initWithDuration: function (a, b, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(d), this._radius = e, this._lensEffect = 0.7, this._dirty = !0) : !1
    }, update: function (a) {
        if (this._dirty) {
            a = this._gridSize.width;
            for (var b = this._gridSize.height, d = this._radius, e = this._lensEffect, f = cc.p(0, 0), g = cc.p(0, 0), h, n, p, r = 0; r < a + 1; ++r)for (var s = 0; s < b + 1; ++s)f.x = r, f.y = s, h = this.originalVertex(f), g.x = this._position.x - h.x, g.y = this._position.y - h.y, n = cc.pLength(g), n < d && (n = d -
                n, n /= d, 0 === n && (n = 0.001), n = Math.log(n) * e, p = Math.exp(n) * d, n = cc.pLength(g), 0 < n && (g.x /= n, g.y /= n, g.x *= p, g.y *= p, h.z += cc.pLength(g) * e)), this.setVertex(f, h);
            this._dirty = !1
        }
    }
});
cc.lens3D = function (a, b, d, e) {
    return new cc.Lens3D(a, b, d, e)
};
cc.Lens3D.create = cc.lens3D;
cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null, _radius: 0, _waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (a, b, d, e, f, g) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== g && this.initWithDuration(a, b, d, e, f, g)
    }, getPosition: function () {
        return this._position
    }, setPosition: function (a) {
        this._position.x = a.x;
        this._position.y = a.y
    }, getAmplitude: function () {
        return this._amplitude
    }, setAmplitude: function (a) {
        this._amplitude = a
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    },
    setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    }, initWithDuration: function (a, b, d, e, f, g) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(d), this._radius = e, this._waves = f, this._amplitude = g, this._amplitudeRate = 1, !0) : !1
    }, update: function (a) {
        for (var b = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._radius, g = this._waves, h = this._amplitude, n = this._amplitudeRate, p, r, s = cc.p(0, 0), t = 0; t < b + 1; ++t)for (var v = 0; v < d + 1; ++v) {
            e.x = t;
            e.y = v;
            p = this.originalVertex(e);
            s.x =
                this._position.x - p.x;
            s.y = this._position.y - p.y;
            r = cc.pLength(s);
            if (r < f) {
                r = f - r;
                var u = Math.pow(r / f, 2);
                p.z += Math.sin(a * Math.PI * g * 2 + 0.1 * r) * h * n * u
            }
            this.setVertex(e, p)
        }
    }
});
cc.ripple3D = function (a, b, d, e, f, g) {
    return new cc.Ripple3D(a, b, d, e, f, g)
};
cc.Ripple3D.create = cc.ripple3D;
cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: 0, _shakeZ: !1, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, initWithDuration: function (a, b, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = d, this._shakeZ = e, !0) : !1
    }, update: function (a) {
        a = this._gridSize.width;
        for (var b = this._gridSize.height, d = this._randRange, e = this._shakeZ, f = cc.p(0, 0), g, h = 0; h < a + 1; ++h)for (var n = 0; n < b + 1; ++n)f.x = h, f.y = n, g = this.originalVertex(f),
            g.x += cc.rand() % (2 * d) - d, g.y += cc.rand() % (2 * d) - d, e && (g.z += cc.rand() % (2 * d) - d), this.setVertex(f, g)
    }
});
cc.shaky3D = function (a, b, d, e) {
    return new cc.Shaky3D(a, b, d, e)
};
cc.Shaky3D.create = cc.shaky3D;
cc.Liquid = cc.Grid3DAction.extend({
    _waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, getAmplitude: function () {
        return this._amplitude
    }, setAmplitude: function (a) {
        this._amplitude = a
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    }, setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    }, initWithDuration: function (a, b, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = d, this._amplitude =
            e, this._amplitudeRate = 1, !0) : !1
    }, update: function (a) {
        for (var b = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._waves, g = this._amplitude, h = this._amplitudeRate, n, p = 1; p < b; ++p)for (var r = 1; r < d; ++r)e.x = p, e.y = r, n = this.originalVertex(e), n.x += Math.sin(a * Math.PI * f * 2 + 0.01 * n.x) * g * h, n.y += Math.sin(a * Math.PI * f * 2 + 0.01 * n.y) * g * h, this.setVertex(e, n)
    }
});
cc.liquid = function (a, b, d, e) {
    return new cc.Liquid(a, b, d, e)
};
cc.Liquid.create = cc.liquid;
cc.Waves = cc.Grid3DAction.extend({
    _waves: 0, _amplitude: 0, _amplitudeRate: 0, _vertical: !1, _horizontal: !1, ctor: function (a, b, d, e, f, g) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== g && this.initWithDuration(a, b, d, e, f, g)
    }, getAmplitude: function () {
        return this._amplitude
    }, setAmplitude: function (a) {
        this._amplitude = a
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    }, setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    }, initWithDuration: function (a, b, d, e, f, g) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this,
            a, b) ? (this._waves = d, this._amplitude = e, this._amplitudeRate = 1, this._horizontal = f, this._vertical = g, !0) : !1
    }, update: function (a) {
        for (var b = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = this._vertical, g = this._horizontal, h = this._waves, n = this._amplitude, p = this._amplitudeRate, r, s = 0; s < b + 1; ++s)for (var t = 0; t < d + 1; ++t)e.x = s, e.y = t, r = this.originalVertex(e), f && (r.x += Math.sin(a * Math.PI * h * 2 + 0.01 * r.y) * n * p), g && (r.y += Math.sin(a * Math.PI * h * 2 + 0.01 * r.x) * n * p), this.setVertex(e, r)
    }
});
cc.waves = function (a, b, d, e, f, g) {
    return new cc.Waves(a, b, d, e, f, g)
};
cc.Waves.create = cc.waves;
cc.Twirl = cc.Grid3DAction.extend({
    _position: null, _twirls: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (a, b, d, e, f) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== f && this.initWithDuration(a, b, d, e, f)
    }, getPosition: function () {
        return this._position
    }, setPosition: function (a) {
        this._position.x = a.x;
        this._position.y = a.y
    }, getAmplitude: function () {
        return this._amplitude
    }, setAmplitude: function (a) {
        this._amplitude = a
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    }, setAmplitudeRate: function (a) {
        this._amplitudeRate =
            a
    }, initWithDuration: function (a, b, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(d), this._twirls = e, this._amplitude = f, this._amplitudeRate = 1, !0) : !1
    }, update: function (a) {
        for (var b = this._position, d = this._gridSize.width, e = this._gridSize.height, f = cc.p(0, 0), g = 0.1 * this._amplitude * this._amplitudeRate, h = this._twirls, n, p, r, s = cc.p(0, 0), t = 0; t < d + 1; ++t)for (var v = 0; v < e + 1; ++v)f.x = t, f.y = v, n = this.originalVertex(f), s.x = t - d / 2, s.y = v - e / 2, p = cc.pLength(s) * Math.cos(Math.PI / 2 + a * Math.PI *
                h * 2) * g, r = Math.sin(p) * (n.y - b.y) + Math.cos(p) * (n.x - b.x), p = Math.cos(p) * (n.y - b.y) - Math.sin(p) * (n.x - b.x), n.x = b.x + r, n.y = b.y + p, this.setVertex(f, n)
    }
});
cc.twirl = function (a, b, d, e, f) {
    return new cc.Twirl(a, b, d, e, f)
};
cc.Twirl.create = cc.twirl;
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0, _shakeZ: !1, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, initWithDuration: function (a, b, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = d, this._shakeZ = e, !0) : !1
    }, update: function (a) {
        a = this._gridSize;
        for (var b = this._randRange, d = cc.p(0, 0), e = 0; e < a.width; ++e)for (var f = 0; f < a.height; ++f) {
            d.x = e;
            d.y = f;
            var g = this.originalTile(d);
            g.bl.x += cc.rand() % (2 *
                b) - b;
            g.br.x += cc.rand() % (2 * b) - b;
            g.tl.x += cc.rand() % (2 * b) - b;
            g.tr.x += cc.rand() % (2 * b) - b;
            g.bl.y += cc.rand() % (2 * b) - b;
            g.br.y += cc.rand() % (2 * b) - b;
            g.tl.y += cc.rand() % (2 * b) - b;
            g.tr.y += cc.rand() % (2 * b) - b;
            this._shakeZ && (g.bl.z += cc.rand() % (2 * b) - b, g.br.z += cc.rand() % (2 * b) - b, g.tl.z += cc.rand() % (2 * b) - b, g.tr.z += cc.rand() % (2 * b) - b);
            this.setTile(d, g)
        }
    }
});
cc.shakyTiles3D = function (a, b, d, e) {
    return new cc.ShakyTiles3D(a, b, d, e)
};
cc.ShakyTiles3D.create = cc.shakyTiles3D;
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0, _once: !1, _shatterZ: !1, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, initWithDuration: function (a, b, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._once = !1, this._randRange = d, this._shatterZ = e, !0) : !1
    }, update: function (a) {
        if (!1 === this._once) {
            a = this._gridSize;
            for (var b = this._randRange, d, e = cc.p(0, 0), f = 0; f < a.width; ++f)for (var g = 0; g < a.height; ++g)e.x = f,
                e.y = g, d = this.originalTile(e), d.bl.x += cc.rand() % (2 * b) - b, d.br.x += cc.rand() % (2 * b) - b, d.tl.x += cc.rand() % (2 * b) - b, d.tr.x += cc.rand() % (2 * b) - b, d.bl.y += cc.rand() % (2 * b) - b, d.br.y += cc.rand() % (2 * b) - b, d.tl.y += cc.rand() % (2 * b) - b, d.tr.y += cc.rand() % (2 * b) - b, this._shatterZ && (d.bl.z += cc.rand() % (2 * b) - b, d.br.z += cc.rand() % (2 * b) - b, d.tl.z += cc.rand() % (2 * b) - b, d.tr.z += cc.rand() % (2 * b) - b), this.setTile(e, d);
            this._once = !0
        }
    }
});
cc.shatteredTiles3D = function (a, b, d, e) {
    return new cc.ShatteredTiles3D(a, b, d, e)
};
cc.ShatteredTiles3D.create = cc.shatteredTiles3D;
cc.Tile = function (a, b, d) {
    this.position = a || cc.p(0, 0);
    this.startPosition = b || cc.p(0, 0);
    this.delta = d || cc.p(0, 0)
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0, _tilesCount: 0, _tilesOrder: null, _tiles: null, ctor: function (a, b, d) {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        this._tiles = [];
        void 0 !== d && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = d, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
    }, shuffle: function (a, b) {
        for (var d = b - 1; 0 <= d; d--) {
            var e = 0 | cc.rand() % (d + 1), f = a[d];
            a[d] = a[e];
            a[e] = f
        }
    },
    getDelta: function (a) {
        var b = this._gridSize, d = a.width * b.height + a.height;
        return cc.size(this._tilesOrder[d] / b.height - a.width, this._tilesOrder[d] % b.height - a.height)
    }, placeTile: function (a, b) {
        var d = this.originalTile(a), e = this.target.grid.getStep(), f = b.position;
        d.bl.x += f.x * e.x;
        d.bl.y += f.y * e.y;
        d.br.x += f.x * e.x;
        d.br.y += f.y * e.y;
        d.tl.x += f.x * e.x;
        d.tl.y += f.y * e.y;
        d.tr.x += f.x * e.x;
        d.tr.y += f.y * e.y;
        this.setTile(a, d)
    }, startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        a = this._gridSize;
        this._tilesCount = a.width * a.height;
        for (var b = this._tilesOrder, d = b.length = 0; d < this._tilesCount; ++d)b[d] = d;
        this.shuffle(b, this._tilesCount);
        for (var b = this._tiles, d = b.length = 0, e = cc.size(0, 0), f = 0; f < a.width; ++f)for (var g = 0; g < a.height; ++g)b[d] = new cc.Tile, b[d].position = cc.p(f, g), b[d].startPosition = cc.p(f, g), e.width = f, e.height = g, b[d].delta = this.getDelta(e), ++d
    }, update: function (a) {
        for (var b = 0, d = this._gridSize, e = this._tiles, f, g = cc.p(0, 0), h = 0; h < d.width; ++h)for (var n = 0; n < d.height; ++n)g.x = h, g.y = n, f = e[b], f.position.x =
            f.delta.width * a, f.position.y = f.delta.height * a, this.placeTile(g, f), ++b
    }
});
cc.shuffleTiles = function (a, b, d) {
    return new cc.ShuffleTiles(a, b, d)
};
cc.ShuffleTiles.create = cc.shuffleTiles;
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function (a, b) {
        var d = this._gridSize.width * b, e = this._gridSize.height * b;
        return d === this._gridSize.width && e === this._gridSize.height ? 0 : 0 === d + e ? 1 : Math.pow((a.x + a.y) / (d + e), 6)
    }, turnOnTile: function (a) {
        this.setTile(a, this.originalTile(a))
    }, turnOffTile: function (a) {
        this.setTile(a, new cc.Quad3)
    }, transformTile: function (a, b) {
        var d = this.originalTile(a), e = this.target.grid.getStep();
        d.bl.x += e.x / 2 * (1 - b);
        d.bl.y += e.y / 2 * (1 - b);
        d.br.x -= e.x / 2 * (1 - b);
        d.br.y += e.y / 2 * (1 -
            b);
        d.tl.x += e.x / 2 * (1 - b);
        d.tl.y -= e.y / 2 * (1 - b);
        d.tr.x -= e.x / 2 * (1 - b);
        d.tr.y -= e.y / 2 * (1 - b);
        this.setTile(a, d)
    }, update: function (a) {
        for (var b = this._gridSize, d = cc.p(0, 0), e, f = 0; f < b.width; ++f)for (var g = 0; g < b.height; ++g)d.x = f, d.y = g, e = this.testFunc(d, a), 0 === e ? this.turnOffTile(d) : 1 > e ? this.transformTile(d, e) : this.turnOnTile(d)
    }
});
cc.fadeOutTRTiles = function (a, b) {
    return new cc.FadeOutTRTiles(a, b)
};
cc.FadeOutTRTiles.create = cc.fadeOutTRTiles;
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function (a, b) {
        var d = this._gridSize.width * (1 - b), e = this._gridSize.height * (1 - b);
        return 0 === d + e ? 0 : 0 === a.x + a.y ? 1 : Math.pow((d + e) / (a.x + a.y), 6)
    }
});
cc.fadeOutBLTiles = function (a, b) {
    return new cc.FadeOutBLTiles(a, b)
};
cc.FadeOutBLTiles.create = cc.fadeOutBLTiles;
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function (a, b) {
        var d = this._gridSize.height * b;
        return d === this._gridSize.height ? 0 : 0 === d ? 1 : Math.pow(a.y / d, 6)
    }, transformTile: function (a, b) {
        var d = this.originalTile(a), e = this.target.grid.getStep();
        d.bl.y += e.y / 2 * (1 - b);
        d.br.y += e.y / 2 * (1 - b);
        d.tl.y -= e.y / 2 * (1 - b);
        d.tr.y -= e.y / 2 * (1 - b);
        this.setTile(a, d)
    }
});
cc.fadeOutUpTiles = function (a, b) {
    return new cc.FadeOutUpTiles(a, b)
};
cc.FadeOutUpTiles.create = cc.fadeOutUpTiles;
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function (a, b) {
        var d = this._gridSize.height * (1 - b);
        return 0 === d ? 0 : 0 === a.y ? 1 : Math.pow(d / a.y, 6)
    }
});
cc.fadeOutDownTiles = function (a, b) {
    return new cc.FadeOutDownTiles(a, b)
};
cc.FadeOutDownTiles.create = cc.fadeOutDownTiles;
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null, _tilesCount: 0, _tilesOrder: null, ctor: function (a, b, d) {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        void 0 !== b && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = d || 0, this._tilesOrder.length = 0, !0) : !1
    }, shuffle: function (a, b) {
        for (var d = b - 1; 0 <= d; d--) {
            var e = 0 | cc.rand() % (d + 1), f = a[d];
            a[d] = a[e];
            a[e] = f
        }
    }, turnOnTile: function (a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function (a) {
        this.setTile(a, new cc.Quad3)
    }, startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._tilesCount = this._gridSize.width * this._gridSize.height;
        a = this._tilesOrder;
        for (var b = a.length = 0; b < this._tilesCount; ++b)a[b] = b;
        this.shuffle(a, this._tilesCount)
    }, update: function (a) {
        a = 0 | a * this._tilesCount;
        for (var b = this._gridSize, d, e = cc.p(0, 0), f = this._tilesOrder, g = 0; g < this._tilesCount; g++)d = f[g], e.x = 0 | d / b.height, e.y = d % (0 | b.height), g < a ? this.turnOffTile(e) : this.turnOnTile(e)
    }
});
cc.turnOffTiles = function (a, b, d) {
    return new cc.TurnOffTiles(a, b, d)
};
cc.TurnOffTiles.create = cc.turnOffTiles;
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, getAmplitude: function () {
        return this._amplitude
    }, setAmplitude: function (a) {
        this._amplitude = a
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    }, setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    }, initWithDuration: function (a, b, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves =
            d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    }, update: function (a) {
        for (var b = this._gridSize, d = this._waves, e = this._amplitude, f = this._amplitudeRate, g = cc.p(0, 0), h, n = 0; n < b.width; n++)for (var p = 0; p < b.height; p++)g.x = n, g.y = p, h = this.originalTile(g), h.bl.z = Math.sin(a * Math.PI * d * 2 + 0.01 * (h.bl.y + h.bl.x)) * e * f, h.br.z = h.bl.z, h.tl.z = h.bl.z, h.tr.z = h.bl.z, this.setTile(g, h)
    }
});
cc.wavesTiles3D = function (a, b, d, e) {
    return new cc.WavesTiles3D(a, b, d, e)
};
cc.WavesTiles3D.create = cc.wavesTiles3D;
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0, _amplitude: 0, _amplitudeRate: 0, ctor: function (a, b, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    }, getAmplitude: function () {
        return this._amplitude
    }, setAmplitude: function (a) {
        this._amplitude = a
    }, getAmplitudeRate: function () {
        return this._amplitudeRate
    }, setAmplitudeRate: function (a) {
        this._amplitudeRate = a
    }, initWithDuration: function (a, b, d, e) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._jumps =
            d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    }, update: function (a) {
        var b = Math.sin(Math.PI * a * this._jumps * 2) * this._amplitude * this._amplitudeRate;
        a = Math.sin(Math.PI * (a * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate;
        for (var d = this._gridSize, e = this.target.grid, f, g = cc.p(0, 0), h = 0; h < d.width; h++)for (var n = 0; n < d.height; n++)g.x = h, g.y = n, f = e.originalTile(g), 0 === (h + n) % 2 ? (f.bl.z += b, f.br.z += b, f.tl.z += b, f.tr.z += b) : (f.bl.z += a, f.br.z += a, f.tl.z += a, f.tr.z += a), e.setTile(g, f)
    }
});
cc.jumpTiles3D = function (a, b, d, e) {
    return new cc.JumpTiles3D(a, b, d, e)
};
cc.JumpTiles3D.create = cc.jumpTiles3D;
cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0, _winSize: null, ctor: function (a, b) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        this._rows = b;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, b))
    }, update: function (a) {
        for (var b = this._gridSize, d = this._winSize.width, e, f, g = cc.p(0, 0), h = 0; h < b.height; ++h)g.y = h, e = this.originalTile(g), f = 1, 0 === h % 2 && (f = -1), e.bl.x += f * d * a, e.br.x += f * d * a, e.tl.x += f * d * a, e.tr.x += f * d * a, this.setTile(g,
            e)
    }, startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.splitRows = function (a, b) {
    return new cc.SplitRows(a, b)
};
cc.SplitRows.create = cc.splitRows;
cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0, _winSize: null, ctor: function (a, b) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        this._cols = b;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(b, 1))
    }, update: function (a) {
        for (var b = this._gridSize.width, d = this._winSize.height, e, f, g = cc.p(0, 0), h = 0; h < b; ++h)g.x = h, e = this.originalTile(g), f = 1, 0 === h % 2 && (f = -1), e.bl.y += f * d * a, e.br.y += f * d * a, e.tl.y += f * d * a, e.tr.y += f * d * a, this.setTile(g,
            e);
        cc.renderer.childrenOrderDirty = !0
    }, startWithTarget: function (a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.splitCols = function (a, b) {
    return new cc.SplitCols(a, b)
};
cc.SplitCols.create = cc.splitCols;
cc.PageTurn3D = cc.Grid3DAction.extend({
    getGrid: function () {
        var a = new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect());
        a.setNeedDepthTestForBlit(!0);
        return a
    }, clone: function () {
        var a = new cc.PageTurn3D;
        a.initWithDuration(this._duration, this._gridSize);
        return a
    }, update: function (a) {
        var b = Math.max(0, a - 0.25), b = -100 - b * b * 500, d = Math.sqrt(a), e = 0.5 < d ? Math.PI / 2 * d : Math.PI / 2 * (1 - d);
        a = (2 - a) * Math.PI;
        for (var d = Math.sin(e), e = Math.cos(e), f = this._gridSize, g = cc.p(0, 0), h = 0; h <= f.width; ++h)for (var n =
            0; n <= f.height; ++n) {
            g.x = h;
            g.y = n;
            var p = this.getOriginalVertex(g);
            p.x -= this.getGridRect().x;
            var r = Math.sqrt(p.x * p.x + (p.y - b) * (p.y - b)), s = r * d, t = Math.asin(p.x / r) / d, v = Math.cos(t);
            p.x = t <= Math.PI ? s * Math.sin(t) : 0;
            p.y = r + b - s * (1 - v) * d;
            p.z = s * (1 - v) * e;
            p.x = p.z * Math.sin(a) + p.x * Math.cos(a);
            p.z = p.z * Math.cos(a) - p.x * Math.cos(a);
            p.z /= 7;
            0.5 > p.z && (p.z = 0.5);
            p.x += this.getGridRect().x;
            this.setVertex(g, p)
        }
    }
});
cc.pageTurn3D = function (a, b) {
    return new cc.PageTurn3D(a, b)
};
cc.PageTurn3D.create = cc.pageTurn3D;
cc.ProgressTimer = cc.Node.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    ctor: function (a) {
        cc.Node.prototype.ctor.call(this);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        a && this.initWithSprite(a)
    },
    onEnter: function () {
        this._super();
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this._renderCmd.initCmd(), this._renderCmd._updateProgress())
    },
    cleanup: function () {
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._renderCmd.releaseData();
        this._super()
    },
    getMidpoint: function () {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function (a) {
        this._midPoint = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function () {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function (a) {
        this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function () {
        return this._type
    },
    getPercentage: function () {
        return this._percentage
    },
    getSprite: function () {
        return this._sprite
    },
    setPercentage: function (a) {
        this._percentage !== a && (this._percentage = cc.clampf(a, 0, 100), this._renderCmd._updateProgress())
    },
    setOpacityModifyRGB: function (a) {
    },
    isOpacityModifyRGB: function () {
        return !1
    },
    isReverseDirection: function () {
        return this._reverseDirection
    },
    setColor: function (a) {
        this._sprite.color = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setOpacity: function (a) {
        this._sprite.opacity = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getColor: function () {
        return this._sprite.color
    },
    getOpacity: function () {
        return this._sprite.opacity
    },
    setReverseProgress: function (a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.resetVertexData())
    },
    setSprite: function (a) {
        this._sprite !== a && ((this._sprite = a) ? (this.setContentSize(a.width, a.height), a.ignoreAnchorPointForPosition(!0)) : this.setContentSize(0, 0), this._renderCmd.resetVertexData())
    },
    setType: function (a) {
        a !== this._type && (this._type = a, this._renderCmd.resetVertexData())
    },
    setReverseDirection: function (a) {
        this._reverseDirection !==
        a && (this._reverseDirection = a, this._renderCmd.resetVertexData())
    },
    initWithSprite: function (a) {
        this.percentage = 0;
        this.setAnchorPoint(0.5, 0.5);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate = cc.p(1, 1);
        this.setSprite(a);
        this._renderCmd.resetVertexData();
        return !0
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this)
    }
});
_p = cc.ProgressTimer.prototype;
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function (a) {
    return new cc.ProgressTimer(a)
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({
    _to: 0, _from: 0, ctor: function (a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== b && this.initWithDuration(a, b)
    }, initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, !0) : !1
    }, clone: function () {
        var a = new cc.ProgressTo;
        a.initWithDuration(this._duration, this._to);
        return a
    }, reverse: function () {
        cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
        return null
    }, startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = a.percentage
    }, update: function (a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressTo = function (a, b) {
    return new cc.ProgressTo(a, b)
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: 0, _from: 0, ctor: function (a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== d && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = d, this._from = b, !0) : !1
    }, clone: function () {
        var a = new cc.ProgressFromTo;
        a.initWithDuration(this._duration, this._from, this._to);
        return a
    }, reverse: function () {
        return cc.progressFromTo(this._duration, this._to, this._from)
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a)
    }, update: function (a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressFromTo = function (a, b, d) {
    return new cc.ProgressFromTo(a, b, d)
};
cc.ProgressFromTo.create = cc.progressFromTo;
(function () {
    cc.ProgressTimer.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._PI180 = Math.PI / 180;
        this._barRect = cc.rect(0, 0, 0, 0);
        this._origin = cc.p(0, 0);
        this._radius = 0;
        this._endAngle = this._startAngle = 270;
        this._counterClockWise = !1
    };
    var a = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ProgressTimer.CanvasRenderCmd;
    a.rendering = function (a, d, e) {
        a = a || cc._renderContext;
        var f = a.getContext(), g = this._node, h = g._sprite,
            n = h._renderCmd._textureCoord, p = h._renderCmd._displayedOpacity / 255;
        if (0 !== n.width && 0 !== n.height && h._texture && n.validRect && 0 !== p) {
            a.setTransform(this._worldTransform, d, e);
            a.setCompositeOperation(h._blendFuncStr);
            a.setGlobalAlpha(p);
            var r = h._rect, s = h._offsetPosition, p = s.x, t = -s.y - r.height, v = r.width, r = r.height;
            a.save();
            h._flippedX && (p = -p - v, f.scale(-1, 1));
            h._flippedY && (t = s.y, f.scale(1, -1));
            g._type === cc.ProgressTimer.TYPE_BAR ? (g = this._barRect, f.beginPath(), f.rect(g.x * d, g.y * e, g.width * d, g.height * e), f.clip(),
                f.closePath()) : g._type === cc.ProgressTimer.TYPE_RADIAL && (g = this._origin.x * d, s = this._origin.y * e, f.beginPath(), f.arc(g, s, this._radius * e, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), f.lineTo(g, s), f.clip(), f.closePath());
            g = h._texture.getHtmlElementObj();
            h._renderCmd._colorized ? f.drawImage(g, 0, 0, n.width, n.height, p * d, t * e, v * d, r * e) : f.drawImage(g, n.renderX, n.renderY, n.width, n.height, p * d, t * e, v * d, r * e);
            a.restore();
            cc.g_NumberOfDraws++
        }
    };
    a.releaseData = function () {
    };
    a.resetVertexData =
        function () {
        };
    a._updateProgress = function () {
        var a = this._node, d = a._sprite, e = d.width, f = d.height, g = a._midPoint;
        if (a._type === cc.ProgressTimer.TYPE_RADIAL) {
            this._radius = Math.round(Math.sqrt(e * e + f * f));
            var h, n = !1, p = this._origin;
            p.x = e * g.x;
            p.y = -f * g.y;
            a._reverseDirection ? (h = 270, g = 270 - 3.6 * a._percentage) : (g = -90, h = -90 + 3.6 * a._percentage);
            d._flippedX && (p.x -= 2 * e * a._midPoint.x, g = -g - 180, h = -h - 180, n = !n);
            d._flippedY && (p.y += 2 * f * a._midPoint.y, n = !n, g = -g, h = -h);
            this._startAngle = g;
            this._endAngle = h;
            this._counterClockWise = n
        } else n =
            a._barChangeRate, p = a._percentage / 100, a = this._barRect, n = cc.size(e * (1 - n.x), f * (1 - n.y)), p = cc.size((e - n.width) * p, (f - n.height) * p), n = cc.size(n.width + p.width, n.height + p.height), h = cc.p(e * g.x, f * g.y), p = h.x - n.width / 2, 0.5 < g.x && n.width / 2 >= e - h.x && (p = e - n.width), e = h.y - n.height / 2, 0.5 < g.y && n.height / 2 >= f - h.y && (e = f - n.height), a.x = 0, f = 1, d._flippedX && (a.x -= n.width, f = -1), 0 < p && (a.x += p * f), a.y = 0, f = 1, d._flippedY && (a.y += n.height, f = -1), 0 < e && (a.y -= e * f), a.width = n.width, a.height = -n.height
    };
    a._updateColor = function () {
    };
    a._syncStatus =
        function (a) {
            var d = this._node;
            if (d._sprite) {
                var e = cc.Node._dirtyFlags, f = this._dirtyFlag, g = a ? a._node : null;
                g && g._cascadeColorEnabled && a._dirtyFlag & e.colorDirty && (f |= e.colorDirty);
                g && g._cascadeOpacityEnabled && a._dirtyFlag & e.opacityDirty && (f |= e.opacityDirty);
                a && a._dirtyFlag & e.transformDirty && (f |= e.transformDirty);
                this._dirtyFlag = f;
                var d = d._sprite._renderCmd, h = d._dirtyFlag, g = h & e.colorDirty, h = h & e.opacityDirty;
                g && d._syncDisplayColor();
                h && d._syncDisplayOpacity();
                (g || h) && d._updateColor();
                f & e.transformDirty &&
                this.transform(a);
                f & e.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & e.orderDirty)
            }
        };
    a.updateStatus = function () {
        var a = this._node;
        if (a._sprite) {
            var d = cc.Node._dirtyFlags, e = this._dirtyFlag, a = a._sprite._renderCmd, f = a._dirtyFlag, g = f & d.colorDirty, f = f & d.opacityDirty;
            g && a._updateDisplayColor();
            f && a._updateDisplayOpacity();
            (g || f) && a._updateColor();
            e & d.transformDirty && this.transform(this.getParentRenderCmd(), !0);
            this._dirtyFlag = 0
        }
    }
})();
(function () {
    cc.ProgressTimer.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._progressDirty = this._needDraw = !0;
        this.initCmd()
    };
    var a = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ProgressTimer.WebGLRenderCmd;
    a.transform = function (a, d) {
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, d);
        this._node._sprite._renderCmd.transform(this, d)
    };
    a.rendering = function (a) {
        var d = this._node;
        a = a || cc._renderContext;
        if (0 !== this._vertexDataCount &&
            d._sprite) {
            this._shaderProgram.use();
            this._shaderProgram._updateProjectionUniform();
            var e = d._sprite._blendFunc;
            cc.glBlendFunc(e.src, e.dst);
            cc.glBindTexture2D(d._sprite.texture);
            a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer);
            a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION);
            a.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR);
            a.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS);
            this._vertexDataDirty && (a.bufferSubData(a.ARRAY_BUFFER, 0, this._float32View), this._vertexDataDirty = !1);
            e = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, e, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, e, 12);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, e, 16);
            d._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : d._type === cc.ProgressTimer.TYPE_BAR && (d._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP,
                0, this._vertexDataCount));
            cc.g_NumberOfDraws++
        }
    };
    a._syncStatus = function (a) {
        var d = this._node;
        if (d._sprite) {
            var e = cc.Node._dirtyFlags, f = this._dirtyFlag, g = a ? a._node : null;
            g && g._cascadeColorEnabled && a._dirtyFlag & e.colorDirty && (f |= e.colorDirty);
            g && g._cascadeOpacityEnabled && a._dirtyFlag & e.opacityDirty && (f |= e.opacityDirty);
            a && a._dirtyFlag & e.transformDirty && (f |= e.transformDirty);
            this._dirtyFlag = f;
            var d = d._sprite._renderCmd, h = d._dirtyFlag, g = h & e.colorDirty, h = h & e.opacityDirty;
            g && d._syncDisplayColor();
            h && d._syncDisplayOpacity();
            if (g || h)d._updateColor(), this._updateColor();
            f & e.transformDirty && this.transform(a);
            f & e.textureDirty && (this._updateProgressData(), this._dirtyFlag ^= this._dirtyFlag & e.textureDirty);
            d._dirtyFlag = 0
        }
    };
    a.updateStatus = function () {
        var a = this._node;
        if (a._sprite) {
            var d = cc.Node._dirtyFlags, e = this._dirtyFlag, a = a._sprite._renderCmd, f = a._dirtyFlag, g = f & d.colorDirty, f = f & d.opacityDirty;
            g && (a._updateDisplayColor(), this._dirtyFlag ^= this._dirtyFlag & d.colorDirty);
            f && (a._updateDisplayOpacity(), this._dirtyFlag ^= this._dirtyFlag &
                d.opacityDirty);
            if (g || f)a._updateColor(), this._updateColor();
            e & d.transformDirty && this.transform(this.getParentRenderCmd(), !0);
            e & d.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & d.orderDirty);
            e & d.textureDirty && (this._updateProgressData(), this._dirtyFlag ^= this._dirtyFlag & d.textureDirty)
        }
    };
    a.releaseData = function () {
        if (this._vertexData) {
            var a = this._vertexWebGLBuffer;
            setTimeout(function () {
                cc._renderContext.deleteBuffer(a)
            }, 0.1);
            this._vertexArrayBuffer = this._float32View = this._vertexData = this._vertexWebGLBuffer =
                null;
            this._vertexDataCount = 0
        }
    };
    a.initCmd = function () {
        if (!this._vertexData) {
            this._vertexWebGLBuffer = cc._renderContext.createBuffer();
            var a = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
            this._vertexArrayBuffer = new ArrayBuffer(8 * a);
            this._float32View = new Float32Array(this._vertexArrayBuffer);
            this._vertexData = [];
            for (i = 0; 8 > i; i++)this._vertexData[i] = new cc.V3F_C4B_T2F(null, null, null, this._vertexArrayBuffer, i * a);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexWebGLBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, this._float32View, gl.DYNAMIC_DRAW);
            this._vertexDataCount = 0;
            this._vertexDataDirty = !0;
            this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR)
        }
    };
    a.resetVertexData = function () {
        this._vertexDataCount = 0
    };
    a._updateProgressData = function () {
        var a = this._node._type;
        a === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : a === cc.ProgressTimer.TYPE_BAR && this._updateBar();
        this._vertexDataDirty = !0
    };
    a._updateProgress = function () {
        this.setDirtyFlag(cc.Node._dirtyFlags.textureDirty)
    };
    a._updateBar = function () {
        var a = this._node;
        if (a._sprite) {
            var d = a._percentage / 100, e = a._barChangeRate, e = cc.pMult(cc.p(1 - e.x + d * e.x, 1 - e.y + d * e.y), 0.5), d = cc.pSub(a._midPoint, e), a = cc.pAdd(a._midPoint, e);
            0 > d.x && (a.x += -d.x, d.x = 0);
            1 < a.x && (d.x -= a.x - 1, a.x = 1);
            0 > d.y && (a.y += -d.y, d.y = 0);
            1 < a.y && (d.y -= a.y - 1, a.y = 1);
            this._reverseDirection ? (e = this._vertexData, this._vertexDataCount || (this._vertexDataCount = 8, this._textureCoordFromAlphaPoint(e[0].texCoords, 0, 1), this._vertexFromAlphaPoint(e[0].vertices, 0, 1), this._textureCoordFromAlphaPoint(e[1].texCoords, 0, 0), this._vertexFromAlphaPoint(e[1].vertices,
                0, 0), this._textureCoordFromAlphaPoint(e[6].texCoords, 1, 1), this._vertexFromAlphaPoint(e[6].vertices, 1, 1), this._textureCoordFromAlphaPoint(e[7].texCoords, 1, 0), this._vertexFromAlphaPoint(e[7].vertices, 1, 0)), this._textureCoordFromAlphaPoint(e[2].texCoords, d.x, a.y), this._vertexFromAlphaPoint(e[2].vertices, d.x, a.y), this._textureCoordFromAlphaPoint(e[3].texCoords, d.x, d.y), this._vertexFromAlphaPoint(e[3].vertices, d.x, d.y), this._textureCoordFromAlphaPoint(e[4].texCoords, a.x, a.y), this._vertexFromAlphaPoint(e[4].vertices,
                a.x, a.y), this._textureCoordFromAlphaPoint(e[5].texCoords, a.x, d.y), this._vertexFromAlphaPoint(e[5].vertices, a.x, d.y)) : (this._vertexDataCount || (this._vertexDataCount = 4), e = this._vertexData, this._textureCoordFromAlphaPoint(e[0].texCoords, d.x, a.y), this._vertexFromAlphaPoint(e[0].vertices, d.x, a.y), this._textureCoordFromAlphaPoint(e[1].texCoords, d.x, d.y), this._vertexFromAlphaPoint(e[1].vertices, d.x, d.y), this._textureCoordFromAlphaPoint(e[2].texCoords, a.x, a.y), this._vertexFromAlphaPoint(e[2].vertices, a.x,
                a.y), this._textureCoordFromAlphaPoint(e[3].texCoords, a.x, d.y), this._vertexFromAlphaPoint(e[3].vertices, a.x, d.y));
            this._updateColor()
        }
    };
    a._updateRadial = function () {
        var a = this._node;
        if (a._sprite) {
            var d, e = a._midPoint;
            d = a._percentage / 100;
            var f = 2 * cc.PI * (a._reverseDirection ? d : 1 - d), a = cc.p(e.x, 1), g = cc.pRotateByAngle(a, e, f), f = 0;
            if (0 === d)g = a, f = 0; else if (1 === d)g = a, f = 4; else {
                var h = cc.FLT_MAX, n = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                for (d = 0; d <= n; ++d) {
                    var p = (d + (n - 1)) % n, r = this._boundaryTexCoord(d % n), p = this._boundaryTexCoord(p);
                    0 === d ? p = cc.pLerp(r, p, 1 - e.x) : 4 === d && (r = cc.pLerp(r, p, 1 - e.x));
                    var s = cc.p(0, 0);
                    cc.pLineIntersect(r, p, e, g, s) && (0 !== d && 4 !== d || 0 <= s.x && 1 >= s.x) && 0 <= s.y && s.y < h && (h = s.y, f = d)
                }
                g = cc.pAdd(e, cc.pMult(cc.pSub(g, e), h))
            }
            d = !0;
            this._vertexDataCount !== f + 3 && (d = !1, this._vertexDataCount = f + 3);
            this._updateColor();
            h = this._vertexData;
            if (!d)for (this._textureCoordFromAlphaPoint(h[0].texCoords, e.x, e.y), this._vertexFromAlphaPoint(h[0].vertices, e.x, e.y), this._textureCoordFromAlphaPoint(h[1].texCoords, a.x, a.y), this._vertexFromAlphaPoint(h[1].vertices,
                a.x, a.y), d = 0; d < f; d++)e = this._boundaryTexCoord(d), this._textureCoordFromAlphaPoint(h[d + 2].texCoords, e.x, e.y), this._vertexFromAlphaPoint(h[d + 2].vertices, e.x, e.y);
            this._textureCoordFromAlphaPoint(h[this._vertexDataCount - 1].texCoords, g.x, g.y);
            this._vertexFromAlphaPoint(h[this._vertexDataCount - 1].vertices, g.x, g.y)
        }
    };
    a._boundaryTexCoord = function (a) {
        if (a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
            var d = cc.ProgressTimer.TEXTURE_COORDS;
            return this._node._reverseDirection ? cc.p(d >> 7 - (a << 1) & 1, d >> 7 - ((a << 1) + 1) & 1) :
                cc.p(d >> (a << 1) + 1 & 1, d >> (a << 1) & 1)
        }
        return cc.p(0, 0)
    };
    a._textureCoordFromAlphaPoint = function (a, d, e) {
        var f = this._node._sprite;
        if (f) {
            var g = f.quad, h = cc.p(g.bl.texCoords.u, g.bl.texCoords.v), g = cc.p(g.tr.texCoords.u, g.tr.texCoords.v);
            f.textureRectRotated && (f = alpha.x, alpha.x = alpha.y, alpha.y = f);
            a.u = h.x * (1 - d) + g.x * d;
            a.v = h.y * (1 - e) + g.y * e
        } else a.u = 0, a.v = 0
    };
    a._vertexFromAlphaPoint = function (a, d, e) {
        var f = this._node._sprite._renderCmd;
        if (f) {
            var f = f._quad, g = cc.p(f.bl.vertices.x, f.bl.vertices.y), h = cc.p(f.tr.vertices.x,
                f.tr.vertices.y);
            a.x = g.x * (1 - d) + h.x * d;
            a.y = g.y * (1 - e) + h.y * e;
            a.z = f.bl.vertices.z
        } else a.x = 0, a.y = 0
    };
    a._updateColor = function () {
        var a = this._node;
        if (a._sprite && this._vertexDataCount) {
            for (var a = a._sprite.quad.tl.colors, d = this._vertexData, e = 0, f = this._vertexDataCount; e < f; ++e)d[e].colors = a;
            this._vertexDataDirty = !0
        }
    }
})();
cc.SCENE_FADE = 4208917214;
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    ctor: function (a, b) {
        cc.Scene.prototype.ctor.call(this);
        void 0 !== a && void 0 !== b && this.initWithDuration(a, b)
    },
    _setNewScene: function (a) {
        this.unschedule(this._setNewScene);
        a = cc.director;
        this._isSendCleanupToScene = a.isSendCleanupToScene();
        a.runScene(this._inScene);
        cc.eventManager.setEnabled(!0);
        this._outScene.visible = !0
    },
    _sceneOrder: function () {
        this._isInSceneOnTop = !0
    },
    visit: function () {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit());
        cc.Node.prototype.visit.call(this)
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        cc.eventManager.setEnabled(!1);
        this._outScene.onExitTransitionDidStart();
        this._inScene.onEnter()
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        cc.eventManager.setEnabled(!0);
        this._outScene.onExit();
        this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function () {
        cc.Node.prototype.cleanup.call(this);
        this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function (a, b) {
        if (!b)throw Error("cc.TransitionScene.initWithDuration(): Argument scene must be non-nil");
        if (this.init()) {
            this._duration = a;
            this.attr({x: 0, y: 0, anchorX: 0, anchorY: 0});
            this._inScene = b;
            this._outScene = cc.director.getRunningScene();
            this._outScene || (this._outScene = new cc.Scene, this._outScene.init());
            if (this._inScene === this._outScene)throw Error("cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene");
            this._sceneOrder();
            return !0
        }
        return !1
    },
    finish: function () {
        this._inScene.attr({visible: !0, x: 0, y: 0, scale: 1, rotation: 0});
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._inScene.getCamera().restore();
        this._outScene.attr({visible: !1, x: 0, y: 0, scale: 1, rotation: 0});
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._outScene.getCamera().restore();
        this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function () {
        this._inScene.visible = !0;
        this._outScene.visible = !1
    }
});
cc.TransitionScene.create = function (a, b) {
    return new cc.TransitionScene(a, b)
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0, ctor: function (a, b, d) {
        cc.TransitionScene.prototype.ctor.call(this);
        void 0 != d && this.initWithDuration(a, b, d)
    }, initWithDuration: function (a, b, d) {
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._orientation = d);
        return !0
    }
});
cc.TransitionSceneOriented.create = function (a, b, d) {
    return new cc.TransitionSceneOriented(a, b, d)
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
    ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({scale: 0.001, anchorX: 0.5, anchorY: 0.5});
        this._outScene.attr({scale: 1, anchorX: 0.5, anchorY: 0.5});
        var a = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, 0.001), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
        this._outScene.runAction(a);
        this._inScene.runAction(cc.sequence(a.reverse(),
            cc.callFunc(this.finish, this)))
    }
});
cc.TransitionRotoZoom.create = function (a, b) {
    return new cc.TransitionRotoZoom(a, b)
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
    ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize();
        this._inScene.attr({scale: 0.5, x: a.width, y: 0, anchorX: 0.5, anchorY: 0.5});
        this._outScene.anchorX = 0.5;
        this._outScene.anchorY = 0.5;
        var b = cc.jumpBy(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2), d = cc.scaleTo(this._duration / 4, 1), a = cc.scaleTo(this._duration / 4, 0.5), a = cc.sequence(a,
            b), b = cc.sequence(b, d), d = cc.delayTime(this._duration / 2);
        this._outScene.runAction(a);
        this._inScene.runAction(cc.sequence(d, b, cc.callFunc(this.finish, this)))
    }
});
cc.TransitionJumpZoom.create = function (a, b) {
    return new cc.TransitionJumpZoom(a, b)
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
    ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action();
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
    }, initScenes: function () {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    }, action: function () {
        return cc.moveTo(this._duration, cc.p(0, 0))
    }, easeActionWithAction: function (a) {
        return new cc.EaseOut(a,
            2)
    }
});
cc.TransitionMoveInL.create = function (a, b) {
    return new cc.TransitionMoveInL(a, b)
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    ctor: function (a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, initScenes: function () {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
});
cc.TransitionMoveInR.create = function (a, b) {
    return new cc.TransitionMoveInR(a, b)
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    ctor: function (a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, initScenes: function () {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInT.create = function (a, b) {
    return new cc.TransitionMoveInT(a, b)
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    ctor: function (a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, initScenes: function () {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInB.create = function (a, b) {
    return new cc.TransitionMoveInB(a, b)
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
    ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !1
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action(), b = this.action(), a = cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)), b = this.easeActionWithAction(b);
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }, initScenes: function () {
        this._inScene.setPosition(-cc.director.getWinSize().width +
            cc.ADJUST_FACTOR, 0)
    }, action: function () {
        return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    }, easeActionWithAction: function (a) {
        return new cc.EaseInOut(a, 2)
    }
});
cc.TransitionSlideInL.create = function (a, b) {
    return new cc.TransitionSlideInL(a, b)
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    ctor: function (a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !0
    }, initScenes: function () {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    }, action: function () {
        return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
});
cc.TransitionSlideInR.create = function (a, b) {
    return new cc.TransitionSlideInR(a, b)
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    ctor: function (a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !1
    }, initScenes: function () {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }, action: function () {
        return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
});
cc.TransitionSlideInB.create = function (a, b) {
    return new cc.TransitionSlideInB(a, b)
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    ctor: function (a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !0
    }, initScenes: function () {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    }, action: function () {
        return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
});
cc.TransitionSlideInT.create = function (a, b) {
    return new cc.TransitionSlideInT(a, b)
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({scale: 0.001, anchorX: 2 / 3, anchorY: 0.5});
        this._outScene.attr({scale: 1, anchorX: 1 / 3, anchorY: 0.5});
        var a = cc.scaleTo(this._duration, 0.01), b = cc.scaleTo(this._duration, 1);
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(b), cc.callFunc(this.finish, this)));
        this._outScene.runAction(this.easeActionWithAction(a))
    },
    easeActionWithAction: function (a) {
        return new cc.EaseOut(a, 2)
    }
});
cc.TransitionShrinkGrow.create = function (a, b) {
    return new cc.TransitionShrinkGrow(a, b)
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    ctor: function (a, b, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == d && (d = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, d)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, b = 90) : (a = -90, d = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0,
            d, a, 0, 0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipX.create = function (a, b, d) {
    return new cc.TransitionFlipX(a, b, d)
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    ctor: function (a, b, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == d && (d = cc.TRANSITION_ORIENTATION_UP_OVER);
        b && this.initWithDuration(a, b, d)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, d = 270, b = 90) : (a = -90, d = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, d, a, 90,
            0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipY.create = function (a, b, d) {
    return new cc.TransitionFlipY(a, b, d)
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function (a, b, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == d && (d = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, d)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, b = 90) : (a = -90, d = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration /
            2, 1, 0, d, a, -45, 0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipAngular.create = function (a, b, d) {
    return new cc.TransitionFlipAngular(a, b, d)
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    ctor: function (a, b, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == d && (d = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, d)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, b = 90) : (a = -90, d = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2,
            1, 0, d, a, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipX.create = function (a, b, d) {
    return new cc.TransitionZoomFlipX(a, b, d)
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    ctor: function (a, b, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == d && (d = cc.TRANSITION_ORIENTATION_UP_OVER);
        b && this.initWithDuration(a, b, d)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, d = 270, b = 90) : (a = -90, d = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, d,
            a, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipY.create = function (a, b, d) {
    return new cc.TransitionZoomFlipY(a, b, d)
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function (a, b, d) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == d && (d = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, d)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var d;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, d = 270, b = 90) : (a = -90, d = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration /
            2, 1, 0, d, a, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipAngular.create = function (a, b, d) {
    return new cc.TransitionZoomFlipAngular(a, b, d)
};
cc.TransitionFade = cc.TransitionScene.extend({
    _color: null, ctor: function (a, b, d) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._color = cc.color();
        b && this.initWithDuration(a, b, d)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = new cc.LayerColor(this._color);
        this._inScene.visible = !1;
        this.addChild(a, 2, cc.SCENE_FADE);
        var a = this.getChildByTag(cc.SCENE_FADE), b = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish,
            this));
        a.runAction(b)
    }, onExit: function () {
        cc.TransitionScene.prototype.onExit.call(this);
        this.removeChildByTag(cc.SCENE_FADE, !1)
    }, initWithDuration: function (a, b, d) {
        d = d || cc.color.BLACK;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._color.r = d.r, this._color.g = d.g, this._color.b = d.b, this._color.a = 0);
        return !0
    }
});
cc.TransitionFade.create = function (a, b, d) {
    return new cc.TransitionFade(a, b, d)
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
    ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.color(0, 0, 0, 0), b = cc.director.getWinSize(), a = new cc.LayerColor(a), d = new cc.RenderTexture(b.width, b.height);
        d.sprite.anchorX = 0.5;
        d.sprite.anchorY = 0.5;
        d.attr({x: b.width / 2, y: b.height / 2, anchorX: 0.5, anchorY: 0.5});
        d.begin();
        this._inScene.visit();
        d.end();
        var e = new cc.RenderTexture(b.width,
            b.height);
        e.setPosition(b.width / 2, b.height / 2);
        e.sprite.anchorX = e.anchorX = 0.5;
        e.sprite.anchorY = e.anchorY = 0.5;
        e.begin();
        this._outScene.visit();
        e.end();
        d.sprite.setBlendFunc(cc.ONE, cc.ONE);
        e.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        a.addChild(d);
        a.addChild(e);
        d.sprite.opacity = 255;
        e.sprite.opacity = 255;
        b = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this));
        e.sprite.runAction(b);
        this.addChild(a, 2, cc.SCENE_FADE)
    }, onExit: function () {
        this.removeChildByTag(cc.SCENE_FADE,
            !1);
        cc.TransitionScene.prototype.onExit.call(this)
    }, visit: function () {
        cc.Node.prototype.visit.call(this)
    }, draw: function () {
    }
});
cc.TransitionCrossFade.create = function (a, b) {
    return new cc.TransitionCrossFade(a, b)
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    _gridProxy: null, ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !1
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = cc.director.getWinSize(), a = cc.turnOffTiles(this._duration, cc.size(0 | a.width / a.height * 12, 12)), a = this.easeActionWithAction(a);
        this._gridProxy.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid()))
    }, visit: function () {
        this._inScene.visit();
        this._gridProxy.visit()
    }, easeActionWithAction: function (a) {
        return a
    }
});
cc.TransitionTurnOffTiles.create = function (a, b) {
    return new cc.TransitionTurnOffTiles(a, b)
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
    _gridProxy: null, _switchTargetToInscene: function () {
        this._gridProxy.setTarget(this._inScene)
    }, ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = this.action(), a = cc.sequence(a, cc.callFunc(this._switchTargetToInscene, this), a.reverse());
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a),
            cc.callFunc(this.finish, this), cc.stopGrid()))
    }, onExit: function () {
        this._gridProxy.setTarget(null);
        this._gridProxy.onExit();
        cc.TransitionScene.prototype.onExit.call(this)
    }, visit: function () {
        this._gridProxy.visit()
    }, easeActionWithAction: function (a) {
        return new cc.EaseInOut(a, 3)
    }, action: function () {
        return cc.splitCols(this._duration / 2, 3)
    }
});
cc.TransitionSplitCols.create = function (a, b) {
    return new cc.TransitionSplitCols(a, b)
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    ctor: function (a, b) {
        cc.TransitionSplitCols.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, action: function () {
        return cc.splitRows(this._duration / 2, 3)
    }
});
cc.TransitionSplitRows.create = function (a, b) {
    return new cc.TransitionSplitRows(a, b)
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
    _gridProxy: null, ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !1
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = cc.director.getWinSize(), a = this.actionWithSize(cc.size(0 | a.width / a.height * 12, 12));
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a),
            cc.callFunc(this.finish, this), cc.stopGrid()))
    }, visit: function () {
        this._inScene.visit();
        this._gridProxy.visit()
    }, easeActionWithAction: function (a) {
        return a
    }, actionWithSize: function (a) {
        return cc.fadeOutTRTiles(this._duration, a)
    }
});
cc.TransitionFadeTR.create = function (a, b) {
    return new cc.TransitionFadeTR(a, b)
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    ctor: function (a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, actionWithSize: function (a) {
        return cc.fadeOutBLTiles(this._duration, a)
    }
});
cc.TransitionFadeBL.create = function (a, b) {
    return new cc.TransitionFadeBL(a, b)
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    ctor: function (a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, actionWithSize: function (a) {
        return new cc.FadeOutUpTiles(this._duration, a)
    }
});
cc.TransitionFadeUp.create = function (a, b) {
    return new cc.TransitionFadeUp(a, b)
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    ctor: function (a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, actionWithSize: function (a) {
        return cc.fadeOutDownTiles(this._duration, a)
    }
});
cc.TransitionFadeDown.create = function (a, b) {
    return new cc.TransitionFadeDown(a, b)
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0, _from: 0, _sceneToBeModified: null, _className: "TransitionProgress", ctor: function (a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _setAttrs: function (a, b, d) {
        a.attr({x: b, y: d, anchorX: 0.5, anchorY: 0.5})
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._setupTransition();
        var a = cc.director.getWinSize(), b = new cc.RenderTexture(a.width, a.height);
        b.sprite.anchorX = 0.5;
        b.sprite.anchorY = 0.5;
        this._setAttrs(b,
            a.width / 2, a.height / 2);
        b.clear(0, 0, 0, 1);
        b.begin();
        this._sceneToBeModified.visit();
        b.end();
        this._sceneToBeModified === this._outScene && this.hideOutShowIn();
        a = this._progressTimerNodeWithRenderTexture(b);
        b = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this));
        a.runAction(b);
        this.addChild(a, 2, cc.SCENE_RADIAL)
    }, onExit: function () {
        this.removeChildByTag(cc.SCENE_RADIAL, !0);
        cc.TransitionScene.prototype.onExit.call(this)
    }, _setupTransition: function () {
        this._sceneToBeModified =
            this._outScene;
        this._from = 100;
        this._to = 0
    }, _progressTimerNodeWithRenderTexture: function (a) {
        cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
        return null
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !1
    }
});
cc.TransitionProgress.create = function (a, b) {
    return new cc.TransitionProgress(a, b)
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    ctor: function (a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !1;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCCW.create = function (a, b) {
    return new cc.TransitionProgressRadialCCW(a, b)
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    ctor: function (a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !0;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCW.create = function (a, b) {
    var d = new cc.TransitionProgressRadialCW;
    return null !== d && d.initWithDuration(a, b) ? d : new cc.TransitionProgressRadialCW(a, b)
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    ctor: function (a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(1, 0);
        a.barChangeRate = cc.p(1, 0);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressHorizontal.create = function (a, b) {
    return new cc.TransitionProgressHorizontal(a, b)
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    ctor: function (a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0, 0);
        a.barChangeRate = cc.p(0, 1);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressVertical.create = function (a, b) {
    return new cc.TransitionProgressVertical(a, b)
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    ctor: function (a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 0;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }, _sceneOrder: function () {
        this._isInSceneOnTop = !1
    }, _setupTransition: function () {
        this._sceneToBeModified =
            this._inScene;
        this._from = 0;
        this._to = 100
    }
});
cc.TransitionProgressInOut.create = function (a, b) {
    return new cc.TransitionProgressInOut(a, b)
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    ctor: function (a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    }, _progressTimerNodeWithRenderTexture: function (a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressOutIn.create = function (a, b) {
    return new cc.TransitionProgressOutIn(a, b)
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
    ctor: function (a, b, d) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        this.initWithDuration(a, b, d)
    }, _back: !0, _gridProxy: null, _className: "TransitionPageTurn", initWithDuration: function (a, b, d) {
        this._back = d;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b);
        return !0
    }, actionWithSize: function (a) {
        return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, a)) : cc.pageTurn3D(this._duration, a)
    }, onEnter: function () {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(), b;
        a.width > a.height ? (a = 16, b = 12) : (a = 12, b = 16);
        a = this.actionWithSize(cc.size(a, b));
        b = this._gridProxy;
        this._back ? (b.setTarget(this._inScene), b.onEnter(), this._inScene.visible = !1, b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())), this._inScene.runAction(cc.show())) : (b.setTarget(this._outScene), b.onEnter(), b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())))
    }, visit: function () {
        this._back ? this._outScene.visit() : this._inScene.visit();
        this._gridProxy.visit()
    },
    _sceneOrder: function () {
        this._isInSceneOnTop = this._back
    }
});
cc.TransitionPageTurn.create = function (a, b, d) {
    return new cc.TransitionPageTurn(a, b, d)
};
cc.Codec = {name: "Jacob__Codec"};
cc.unzip = function () {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function () {
    var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
};
cc.unzipBase64AsArray = function (a, b) {
    b = b || 1;
    var d = this.unzipBase64(a), e = [], f, g, h;
    f = 0;
    for (h = d.length / b; f < h; f++)for (e[f] = 0, g = b - 1; 0 <= g; --g)e[f] += d.charCodeAt(f * b + g) << 8 * g;
    return e
};
cc.unzipAsArray = function (a, b) {
    b = b || 1;
    var d = this.unzip(a), e = [], f, g, h;
    f = 0;
    for (h = d.length / b; f < h; f++)for (e[f] = 0, g = b - 1; 0 <= g; --g)e[f] += d.charCodeAt(f * b + g) << 8 * g;
    return e
};
cc.StringToArray = function (a) {
    a = a.split(",");
    var b = [], d;
    for (d = 0; d < a.length; d++)b.push(parseInt(a[d]));
    return b
};
cc.Codec.Base64 = {name: "Jacob__Codec__Base64"};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d";
cc.Codec.Base64.decode = function (a) {
    var b = [], d, e, f, g, h, n = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); n < a.length;)d = this._keyStr.indexOf(a.charAt(n++)), e = this._keyStr.indexOf(a.charAt(n++)), g = this._keyStr.indexOf(a.charAt(n++)), h = this._keyStr.indexOf(a.charAt(n++)), d = d << 2 | e >> 4, e = (e & 15) << 4 | g >> 2, f = (g & 3) << 6 | h, b.push(String.fromCharCode(d)), 64 !== g && b.push(String.fromCharCode(e)), 64 !== h && b.push(String.fromCharCode(f));
    return b = b.join("")
};
cc.Codec.Base64.decodeAsArray = function (a, b) {
    var d = this.decode(a), e = [], f, g, h;
    f = 0;
    for (h = d.length / b; f < h; f++)for (e[f] = 0, g = b - 1; 0 <= g; --g)e[f] += d.charCodeAt(f * b + g) << 8 * g;
    return e
};
cc.uint8ArrayToUint32Array = function (a) {
    if (0 !== a.length % 4)return null;
    for (var b = a.length / 4, d = window.Uint32Array ? new Uint32Array(b) : [], e = 0; e < b; e++) {
        var f = 4 * e;
        d[e] = a[f] + 256 * a[f + 1] + 65536 * a[f + 2] + 16777216 * a[f + 3]
    }
    return d
};
cc.Codec.GZip = function (a) {
    this.data = a;
    this.debug = !1;
    this.gpflags = void 0;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = Array(32768);
    this.bIdx = 0;
    this.modeZIP = !1;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = void 0;
    this.literalTree = Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = Array(17);
    this.fpos[0] = 0;
    this.fmax = this.flens = void 0
};
cc.Codec.GZip.gunzip = function (a) {
    return (new cc.Codec.GZip(a)).gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function () {
    this.b1 = this.b0 = 0;
    this.jump = null;
    this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161,
    97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function () {
    this.outputArr = [];
    this.nextFile();
    return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function () {
    this.bits += 8;
    return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
};
cc.Codec.GZip.prototype.byteAlign = function () {
    this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function () {
    var a;
    this.bits++;
    a = this.bb & 1;
    this.bb >>= 1;
    0 === this.bb && (this.bb = this.readByte(), a = this.bb & 1, this.bb = this.bb >> 1 | 128);
    return a
};
cc.Codec.GZip.prototype.readBits = function (a) {
    for (var b = 0, d = a; d--;)b = b << 1 | this.readBit();
    a && (b = cc.Codec.GZip.bitReverse[b] >> 8 - a);
    return b
};
cc.Codec.GZip.prototype.flushBuffer = function () {
    this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function (a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    32768 === this.bIdx && (this.bIdx = 0)
};
cc.Codec.GZip.prototype.IsPat = function () {
    for (; ;) {
        if (this.fpos[this.len] >= this.fmax)return -1;
        if (this.flens[this.fpos[this.len]] === this.len)return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
};
cc.Codec.GZip.prototype.Rec = function () {
    var a = this.Places[this.treepos], b;
    if (17 === this.len)return -1;
    this.treepos++;
    this.len++;
    b = this.IsPat();
    if (0 <= b)a.b0 = b; else if (a.b0 = 32768, this.Rec())return -1;
    b = this.IsPat();
    if (0 <= b)a.b1 = b, a.jump = null; else if (a.b1 = 32768, a.jump = this.Places[this.treepos], a.jumppos = this.treepos, this.Rec())return -1;
    this.len--;
    return 0
};
cc.Codec.GZip.prototype.CreateTree = function (a, b, d, e) {
    this.Places = a;
    this.treepos = 0;
    this.flens = d;
    this.fmax = b;
    for (a = 0; 17 > a; a++)this.fpos[a] = 0;
    this.len = 0;
    return this.Rec() ? -1 : 0
};
cc.Codec.GZip.prototype.DecodeValue = function (a) {
    for (var b, d, e = 0, f = a[e]; ;)if (b = this.readBit()) {
        if (!(f.b1 & 32768))return f.b1;
        f = f.jump;
        b = a.length;
        for (d = 0; d < b; d++)if (a[d] === f) {
            e = d;
            break
        }
    } else {
        if (!(f.b0 & 32768))return f.b0;
        e++;
        f = a[e]
    }
    return -1
};
cc.Codec.GZip.prototype.DeflateLoop = function () {
    var a, b, d, e, f;
    do if (a = this.readBit(), d = this.readBits(2), 0 === d)for (this.byteAlign(), d = this.readByte(), d |= this.readByte() << 8, b = this.readByte(), b |= this.readByte() << 8, (d ^ ~b) & 65535 && document.write("BlockLen checksum mismatch\n"); d--;)b = this.readByte(), this.addBuffer(b); else if (1 === d)for (; ;)if (d = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, 23 < d ? (d = d << 1 | this.readBit(), 199 < d ? (d -= 128, d = d << 1 | this.readBit()) : (d -= 48, 143 < d && (d += 136))) : d += 256, 256 > d)this.addBuffer(d);
    else if (256 === d)break; else {
        var g;
        d -= 257;
        f = this.readBits(cc.Codec.GZip.cplext[d]) + cc.Codec.GZip.cplens[d];
        d = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
        8 < cc.Codec.GZip.cpdext[d] ? (g = this.readBits(8), g |= this.readBits(cc.Codec.GZip.cpdext[d] - 8) << 8) : g = this.readBits(cc.Codec.GZip.cpdext[d]);
        g += cc.Codec.GZip.cpdist[d];
        for (d = 0; d < f; d++)b = this.buf32k[this.bIdx - g & 32767], this.addBuffer(b)
    } else if (2 === d) {
        var h = Array(320);
        b = 257 + this.readBits(5);
        g = 1 + this.readBits(5);
        e = 4 + this.readBits(4);
        for (d = 0; 19 > d; d++)h[d] =
            0;
        for (d = 0; d < e; d++)h[cc.Codec.GZip.border[d]] = this.readBits(3);
        f = this.distanceTree.length;
        for (e = 0; e < f; e++)this.distanceTree[e] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.distanceTree, 19, h, 0))return this.flushBuffer(), 1;
        f = b + g;
        e = 0;
        for (var n = -1; e < f;)if (n++, d = this.DecodeValue(this.distanceTree), 16 > d)h[e++] = d; else if (16 === d) {
            var p;
            d = 3 + this.readBits(2);
            if (e + d > f)return this.flushBuffer(), 1;
            for (p = e ? h[e - 1] : 0; d--;)h[e++] = p
        } else {
            d = 17 === d ? 3 + this.readBits(3) : 11 + this.readBits(7);
            if (e + d > f)return this.flushBuffer(),
                1;
            for (; d--;)h[e++] = 0
        }
        f = this.literalTree.length;
        for (e = 0; e < f; e++)this.literalTree[e] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.literalTree, b, h, 0))return this.flushBuffer(), 1;
        f = this.literalTree.length;
        for (e = 0; e < f; e++)this.distanceTree[e] = new cc.Codec.GZip.HufNode;
        d = [];
        for (e = b; e < h.length; e++)d[e - b] = h[e];
        if (this.CreateTree(this.distanceTree, g, d, 0))return this.flushBuffer(), 1;
        for (; ;)if (d = this.DecodeValue(this.literalTree), 256 <= d) {
            d -= 256;
            if (0 === d)break;
            d--;
            f = this.readBits(cc.Codec.GZip.cplext[d]) +
                cc.Codec.GZip.cplens[d];
            d = this.DecodeValue(this.distanceTree);
            8 < cc.Codec.GZip.cpdext[d] ? (g = this.readBits(8), g |= this.readBits(cc.Codec.GZip.cpdext[d] - 8) << 8) : g = this.readBits(cc.Codec.GZip.cpdext[d]);
            for (g += cc.Codec.GZip.cpdist[d]; f--;)b = this.buf32k[this.bIdx - g & 32767], this.addBuffer(b)
        } else this.addBuffer(d)
    } while (!a);
    this.flushBuffer();
    this.byteAlign();
    return 0
};
cc.Codec.GZip.prototype.unzipFile = function (a) {
    var b;
    this.gunzip();
    for (b = 0; b < this.unzipped.length; b++)if (this.unzipped[b][1] === a)return this.unzipped[b][0]
};
cc.Codec.GZip.prototype.nextFile = function () {
    this.outputArr = [];
    this.modeZIP = !1;
    var a = [];
    a[0] = this.readByte();
    a[1] = this.readByte();
    120 === a[0] && 218 === a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++);
    31 === a[0] && 139 === a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++);
    if (80 === a[0] && 75 === a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 === a[2] && 4 === a[3])) {
        a[0] = this.readByte();
        a[1] = this.readByte();
        this.gpflags = this.readByte();
        this.gpflags |= this.readByte() << 8;
        a = this.readByte();
        a |= this.readByte() << 8;
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        var b = this.readByte(), b = b | this.readByte() << 8, d = this.readByte(), d = d | this.readByte() << 8, e = 0;
        for (this.nameBuf = []; b--;) {
            var f = this.readByte();
            "/" === f | ":" === f ? e = 0 : e < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[e++] = String.fromCharCode(f))
        }
        this.fileout ||
        (this.fileout = this.nameBuf);
        for (var e = 0; e < d;)this.readByte(), e++;
        8 === a && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++);
        this.skipdir()
    }
};
cc.Codec.GZip.prototype.skipdir = function () {
    var a = [], b;
    this.gpflags & 8 && (a[0] = this.readByte(), a[1] = this.readByte(), a[2] = this.readByte(), a[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
    this.modeZIP && this.nextFile();
    a[0] = this.readByte();
    if (8 !== a[0])return 0;
    this.gpflags = this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    if (this.gpflags & 4)for (a[0] =
                                  this.readByte(), a[2] = this.readByte(), this.len = a[0] + 256 * a[1], a = 0; a < this.len; a++)this.readByte();
    if (this.gpflags & 8)for (a = 0, this.nameBuf = []; b = this.readByte();) {
        if ("7" === b || ":" === b)a = 0;
        a < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[a++] = b)
    }
    if (this.gpflags & 16)for (; this.readByte(););
    this.gpflags & 2 && (this.readByte(), this.readByte());
    this.DeflateLoop();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.modeZIP && this.nextFile()
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function () {
    function a(a) {
        throw a;
    }

    function b(a, b) {
        var d = a.split("."), e = B;
        d[0] in e || !e.execScript || e.execScript("var " + d[0]);
        for (var f; d.length && (f = d.shift());)d.length || b === D ? e = e[f] ? e[f] : e[f] = {} : e[f] = b
    }

    function d(a) {
        if ("string" === typeof a) {
            a = a.split("");
            var b, d;
            b = 0;
            for (d = a.length; b < d; b++)a[b] = (a[b].charCodeAt(0) & 255) >>> 0
        }
        b = 1;
        d = 0;
        for (var e = a.length, f, g = 0; 0 < e;) {
            f = 1024 < e ? 1024 : e;
            e -= f;
            do b += a[g++], d += b; while (--f);
            b %= 65521;
            d %= 65521
        }
        return (d << 16 | b) >>> 0
    }

    function e(b, d) {
        this.index = "number" === typeof d ? d : 0;
        this.i = 0;
        this.buffer = b instanceof (C ? Uint8Array : Array) ? b : new (C ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && a(Error("invalid index"));
        this.buffer.length <= this.index && this.f()
    }

    function f(a) {
        this.buffer = new (C ? Uint16Array : Array)(2 * a);
        this.length = 0
    }

    function g(a) {
        var b = a.length, d = 0, e = Number.POSITIVE_INFINITY, f, g, h, n, p, r, s, u, t;
        for (u = 0; u < b; ++u)a[u] > d && (d = a[u]), a[u] < e && (e = a[u]);
        f = 1 << d;
        g = new (C ? Uint32Array : Array)(f);
        h = 1;
        n = 0;
        for (p = 2; h <= d;) {
            for (u = 0; u < b; ++u)if (a[u] === h) {
                r = 0;
                s = n;
                for (t = 0; t < h; ++t)r =
                    r << 1 | s & 1, s >>= 1;
                for (t = r; t < f; t += p)g[t] = h << 16 | u;
                ++n
            }
            ++h;
            n <<= 1;
            p <<= 1
        }
        return [g, d, e]
    }

    function h(a, b) {
        this.h = K;
        this.w = 0;
        this.input = a;
        this.b = 0;
        b && (b.lazy && (this.w = b.lazy), "number" === typeof b.compressionType && (this.h = b.compressionType), b.outputBuffer && (this.a = C && b.outputBuffer instanceof Array ? new Uint8Array(b.outputBuffer) : b.outputBuffer), "number" === typeof b.outputIndex && (this.b = b.outputIndex));
        this.a || (this.a = new (C ? Uint8Array : Array)(32768))
    }

    function n(a, b) {
        this.length = a;
        this.G = b
    }

    function p() {
        var b = P;
        switch (G) {
            case 3 ===
            b:
                return [257, b - 3, 0];
            case 4 === b:
                return [258, b - 4, 0];
            case 5 === b:
                return [259, b - 5, 0];
            case 6 === b:
                return [260, b - 6, 0];
            case 7 === b:
                return [261, b - 7, 0];
            case 8 === b:
                return [262, b - 8, 0];
            case 9 === b:
                return [263, b - 9, 0];
            case 10 === b:
                return [264, b - 10, 0];
            case 12 >= b:
                return [265, b - 11, 1];
            case 14 >= b:
                return [266, b - 13, 1];
            case 16 >= b:
                return [267, b - 15, 1];
            case 18 >= b:
                return [268, b - 17, 1];
            case 22 >= b:
                return [269, b - 19, 2];
            case 26 >= b:
                return [270, b - 23, 2];
            case 30 >= b:
                return [271, b - 27, 2];
            case 34 >= b:
                return [272, b - 31, 2];
            case 42 >= b:
                return [273, b - 35, 3];
            case 50 >=
            b:
                return [274, b - 43, 3];
            case 58 >= b:
                return [275, b - 51, 3];
            case 66 >= b:
                return [276, b - 59, 3];
            case 82 >= b:
                return [277, b - 67, 4];
            case 98 >= b:
                return [278, b - 83, 4];
            case 114 >= b:
                return [279, b - 99, 4];
            case 130 >= b:
                return [280, b - 115, 4];
            case 162 >= b:
                return [281, b - 131, 5];
            case 194 >= b:
                return [282, b - 163, 5];
            case 226 >= b:
                return [283, b - 195, 5];
            case 257 >= b:
                return [284, b - 227, 5];
            case 258 === b:
                return [285, b - 258, 0];
            default:
                a("invalid length: " + b)
        }
    }

    function r(b, d) {
        function e(b, d) {
            var f = b.G, g = [], h = 0, n;
            n = U[b.length];
            g[h++] = n & 65535;
            g[h++] = n >> 16 & 255;
            g[h++] =
                n >> 24;
            var p;
            switch (G) {
                case 1 === f:
                    p = [0, f - 1, 0];
                    break;
                case 2 === f:
                    p = [1, f - 2, 0];
                    break;
                case 3 === f:
                    p = [2, f - 3, 0];
                    break;
                case 4 === f:
                    p = [3, f - 4, 0];
                    break;
                case 6 >= f:
                    p = [4, f - 5, 1];
                    break;
                case 8 >= f:
                    p = [5, f - 7, 1];
                    break;
                case 12 >= f:
                    p = [6, f - 9, 2];
                    break;
                case 16 >= f:
                    p = [7, f - 13, 2];
                    break;
                case 24 >= f:
                    p = [8, f - 17, 3];
                    break;
                case 32 >= f:
                    p = [9, f - 25, 3];
                    break;
                case 48 >= f:
                    p = [10, f - 33, 4];
                    break;
                case 64 >= f:
                    p = [11, f - 49, 4];
                    break;
                case 96 >= f:
                    p = [12, f - 65, 5];
                    break;
                case 128 >= f:
                    p = [13, f - 97, 5];
                    break;
                case 192 >= f:
                    p = [14, f - 129, 6];
                    break;
                case 256 >= f:
                    p = [15, f - 193, 6];
                    break;
                case 384 >= f:
                    p = [16, f - 257, 7];
                    break;
                case 512 >= f:
                    p = [17, f - 385, 7];
                    break;
                case 768 >= f:
                    p = [18, f - 513, 8];
                    break;
                case 1024 >= f:
                    p = [19, f - 769, 8];
                    break;
                case 1536 >= f:
                    p = [20, f - 1025, 9];
                    break;
                case 2048 >= f:
                    p = [21, f - 1537, 9];
                    break;
                case 3072 >= f:
                    p = [22, f - 2049, 10];
                    break;
                case 4096 >= f:
                    p = [23, f - 3073, 10];
                    break;
                case 6144 >= f:
                    p = [24, f - 4097, 11];
                    break;
                case 8192 >= f:
                    p = [25, f - 6145, 11];
                    break;
                case 12288 >= f:
                    p = [26, f - 8193, 12];
                    break;
                case 16384 >= f:
                    p = [27, f - 12289, 12];
                    break;
                case 24576 >= f:
                    p = [28, f - 16385, 13];
                    break;
                case 32768 >= f:
                    p = [29, f - 24577, 13];
                    break;
                default:
                    a("invalid distance")
            }
            n =
                p;
            g[h++] = n[0];
            g[h++] = n[1];
            g[h++] = n[2];
            f = 0;
            for (h = g.length; f < h; ++f)t[F++] = g[f];
            y[g[0]]++;
            w[g[3]]++;
            R = b.length + d - 1;
            u = null
        }

        var f, g, h, p, r, s = {}, u, t = C ? new Uint16Array(2 * d.length) : [], F = 0, R = 0, y = new (C ? Uint32Array : Array)(286), w = new (C ? Uint32Array : Array)(30), N = b.w, K;
        if (!C) {
            for (h = 0; 285 >= h;)y[h++] = 0;
            for (h = 0; 29 >= h;)w[h++] = 0
        }
        y[256] = 1;
        f = 0;
        for (g = d.length; f < g; ++f) {
            h = r = 0;
            for (p = 3; h < p && f + h !== g; ++h)r = r << 8 | d[f + h];
            s[r] === D && (s[r] = []);
            h = s[r];
            if (!(0 < R--)) {
                for (; 0 < h.length && 32768 < f - h[0];)h.shift();
                if (f + 3 >= g) {
                    u && e(u, -1);
                    h = 0;
                    for (p = g - f; h < p; ++h)K = d[f + h], t[F++] = K, ++y[K];
                    break
                }
                if (0 < h.length) {
                    r = p = D;
                    var x = 0, v = D, X = D, A = v = D, H = d.length, X = 0, A = h.length;
                    a:for (; X < A; X++) {
                        p = h[A - X - 1];
                        v = 3;
                        if (3 < x) {
                            for (v = x; 3 < v; v--)if (d[p + v - 1] !== d[f + v - 1])continue a;
                            v = x
                        }
                        for (; 258 > v && f + v < H && d[p + v] === d[f + v];)++v;
                        v > x && (r = p, x = v);
                        if (258 === v)break
                    }
                    p = new n(x, f - r);
                    u ? u.length < p.length ? (K = d[f - 1], t[F++] = K, ++y[K], e(p, 0)) : e(u, -1) : p.length < N ? u = p : e(p, 0)
                } else u ? e(u, -1) : (K = d[f], t[F++] = K, ++y[K])
            }
            h.push(f)
        }
        t[F++] = 256;
        y[256]++;
        b.L = y;
        b.K = w;
        return C ? t.subarray(0, F) : t
    }

    function s(a,
               b) {
        function d(a) {
            var b = t[a][F[a]];
            b === s ? (d(a + 1), d(a + 1)) : --u[b];
            ++F[a]
        }

        var e = a.length, g = new f(572), h = new (C ? Uint8Array : Array)(e), n, p, r;
        if (!C)for (p = 0; p < e; p++)h[p] = 0;
        for (p = 0; p < e; ++p)0 < a[p] && g.push(p, a[p]);
        e = Array(g.length / 2);
        n = new (C ? Uint32Array : Array)(g.length / 2);
        if (1 === e.length)return h[g.pop().index] = 1, h;
        p = 0;
        for (r = g.length / 2; p < r; ++p)e[p] = g.pop(), n[p] = e[p].value;
        var s = n.length;
        p = new (C ? Uint16Array : Array)(b);
        var g = new (C ? Uint8Array : Array)(b), u = new (C ? Uint8Array : Array)(s);
        r = Array(b);
        var t = Array(b), F =
            Array(b), R = (1 << b) - s, y = 1 << b - 1, w, N, K;
        p[b - 1] = s;
        for (w = 0; w < b; ++w)R < y ? g[w] = 0 : (g[w] = 1, R -= y), R <<= 1, p[b - 2 - w] = (p[b - 1 - w] / 2 | 0) + s;
        p[0] = g[0];
        r[0] = Array(p[0]);
        t[0] = Array(p[0]);
        for (w = 1; w < b; ++w)p[w] > 2 * p[w - 1] + g[w] && (p[w] = 2 * p[w - 1] + g[w]), r[w] = Array(p[w]), t[w] = Array(p[w]);
        for (R = 0; R < s; ++R)u[R] = b;
        for (y = 0; y < p[b - 1]; ++y)r[b - 1][y] = n[y], t[b - 1][y] = y;
        for (R = 0; R < b; ++R)F[R] = 0;
        1 === g[b - 1] && (--u[0], ++F[b - 1]);
        for (w = b - 2; 0 <= w; --w) {
            N = R = 0;
            K = F[w + 1];
            for (y = 0; y < p[w]; y++)N = r[w + 1][K] + r[w + 1][K + 1], N > n[R] ? (r[w][y] = N, t[w][y] = s, K += 2) : (r[w][y] = n[R],
                t[w][y] = R, ++R);
            F[w] = 0;
            1 === g[w] && d(w)
        }
        n = u;
        p = 0;
        for (r = e.length; p < r; ++p)h[e[p].index] = n[p];
        return h
    }

    function t(b) {
        var d = new (C ? Uint16Array : Array)(b.length), e = [], f = [], g = 0, h, n, p;
        h = 0;
        for (n = b.length; h < n; h++)e[b[h]] = (e[b[h]] | 0) + 1;
        h = 1;
        for (n = 16; h <= n; h++)f[h] = g, g += e[h] | 0, g > 1 << h && a("overcommitted"), g <<= 1;
        65536 > g && a("undercommitted");
        h = 0;
        for (n = b.length; h < n; h++)for (g = f[b[h]], f[b[h]] += 1, e = d[h] = 0, p = b[h]; e < p; e++)d[h] = d[h] << 1 | g & 1, g >>>= 1;
        return d
    }

    function v(a, b) {
        this.input = a;
        this.a = new (C ? Uint8Array : Array)(32768);
        this.h =
            O.j;
        var d = {}, e;
        !b && (b = {}) || "number" !== typeof b.compressionType || (this.h = b.compressionType);
        for (e in b)d[e] = b[e];
        d.outputBuffer = this.a;
        this.z = new h(this.input, d)
    }

    function u(b, d) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = C ? new Uint8Array(b) : b;
        this.s = !1;
        this.m = V;
        this.B = !1;
        if (d || !(d = {}))d.index && (this.c = d.index), d.bufferSize && (this.l = d.bufferSize), d.bufferType && (this.m = d.bufferType), d.resize && (this.B = d.resize);
        switch (this.m) {
            case Y:
                this.b = 32768;
                this.a = new (C ? Uint8Array : Array)(32768 +
                    this.l + 258);
                break;
            case V:
                this.b = 0;
                this.a = new (C ? Uint8Array : Array)(this.l);
                this.f = this.J;
                this.t = this.H;
                this.o = this.I;
                break;
            default:
                a(Error("invalid inflate mode"))
        }
    }

    function x(b, d) {
        for (var e = b.g, f = b.e, g = b.input, h = b.c, n; f < d;)n = g[h++], n === D && a(Error("input buffer is broken")), e |= n << f, f += 8;
        b.g = e >>> d;
        b.e = f - d;
        b.c = h;
        return e & (1 << d) - 1
    }

    function w(b, d) {
        for (var e = b.g, f = b.e, g = b.input, h = b.c, n = d[0], p = d[1], r; f < p;)r = g[h++], r === D && a(Error("input buffer is broken")), e |= r << f, f += 8;
        g = n[e & (1 << p) - 1];
        n = g >>> 16;
        b.g = e >> n;
        b.e =
            f - n;
        b.c = h;
        return g & 65535
    }

    function y(a) {
        function b(a, d, e) {
            var f, g, h, n;
            for (n = 0; n < a;)switch (f = w(this, d), f) {
                case 16:
                    for (h = 3 + x(this, 2); h--;)e[n++] = g;
                    break;
                case 17:
                    for (h = 3 + x(this, 3); h--;)e[n++] = 0;
                    g = 0;
                    break;
                case 18:
                    for (h = 11 + x(this, 7); h--;)e[n++] = 0;
                    g = 0;
                    break;
                default:
                    g = e[n++] = f
            }
            return e
        }

        var d = x(a, 5) + 257, e = x(a, 5) + 1, f = x(a, 4) + 4, h = new (C ? Uint8Array : Array)(F.length), n;
        for (n = 0; n < f; ++n)h[F[n]] = x(a, 3);
        f = g(h);
        h = new (C ? Uint8Array : Array)(d);
        n = new (C ? Uint8Array : Array)(e);
        a.o(g(b.call(a, d, f, h)), g(b.call(a, e, f, n)))
    }

    function A(b,
               d) {
        var e, f;
        this.input = b;
        this.c = 0;
        if (d || !(d = {}))d.index && (this.c = d.index), d.verify && (this.M = d.verify);
        e = b[this.c++];
        f = b[this.c++];
        switch (e & 15) {
            case ma:
                this.method = ma;
                break;
            default:
                a(Error("unsupported compression method"))
        }
        0 !== ((e << 8) + f) % 31 && a(Error("invalid fcheck flag:" + ((e << 8) + f) % 31));
        f & 32 && a(Error("fdict flag is not supported"));
        this.A = new u(b, {index: this.c, bufferSize: d.bufferSize, bufferType: d.bufferType, resize: d.resize})
    }

    var D = void 0, G = !0, B = this, C = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
    e.prototype.f = function () {
        var a = this.buffer, b, d = a.length, e = new (C ? Uint8Array : Array)(d << 1);
        if (C)e.set(a); else for (b = 0; b < d; ++b)e[b] = a[b];
        return this.buffer = e
    };
    e.prototype.d = function (a, b, d) {
        var e = this.buffer, f = this.index, g = this.i, h = e[f];
        d && 1 < b && (a = 8 < b ? (M[a & 255] << 24 | M[a >>> 8 & 255] << 16 | M[a >>> 16 & 255] << 8 | M[a >>> 24 & 255]) >> 32 - b : M[a] >> 8 - b);
        if (8 > b + g)h = h << b | a, g += b; else for (d = 0; d < b; ++d)h = h << 1 | a >> b - d - 1 & 1, 8 === ++g && (g = 0, e[f++] = M[h], h = 0, f === e.length && (e = this.f()));
        e[f] = h;
        this.buffer = e;
        this.i = g;
        this.index = f
    };
    e.prototype.finish = function () {
        var a = this.buffer, b = this.index, d;
        0 < this.i && (a[b] <<= 8 - this.i, a[b] = M[a[b]], b++);
        C ? d = a.subarray(0, b) : (a.length = b, d = a);
        return d
    };
    var E = new (C ? Uint8Array : Array)(256), I;
    for (I = 0; 256 > I; ++I) {
        for (var L = I, J = L, Q = 7, L = L >>> 1; L; L >>>= 1)J <<= 1, J |= L & 1, --Q;
        E[I] = (J << Q & 255) >>> 0
    }
    var M = E, E = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049,
        498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275,
        3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277,
        2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
        2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
        2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746,
        711928724, 3020668471, 3272380065, 1510334235, 755167117];
    C && new Uint32Array(E);
    f.prototype.getParent = function (a) {
        return 2 * ((a - 2) / 4 | 0)
    };
    f.prototype.push = function (a, b) {
        var d, e, f = this.buffer, g;
        d = this.length;
        f[this.length++] = b;
        for (f[this.length++] = a; 0 < d;)if (e = this.getParent(d), f[d] > f[e])g = f[d], f[d] = f[e], f[e] = g, g = f[d + 1], f[d + 1] = f[e + 1], f[e + 1] = g, d = e; else break;
        return this.length
    };
    f.prototype.pop = function () {
        var a, b, d = this.buffer, e, f, g;
        b = d[0];
        a = d[1];
        this.length -= 2;
        d[0] = d[this.length];
        d[1] = d[this.length + 1];
        for (g =
                 0; ;) {
            f = 2 * g + 2;
            if (f >= this.length)break;
            f + 2 < this.length && d[f + 2] > d[f] && (f += 2);
            if (d[f] > d[g])e = d[g], d[g] = d[f], d[f] = e, e = d[g + 1], d[g + 1] = d[f + 1], d[f + 1] = e; else break;
            g = f
        }
        return {index: a, value: b, length: this.length}
    };
    var K = 2, E = {NONE: 0, r: 1, j: K, N: 3}, H = [];
    for (I = 0; 288 > I; I++)switch (G) {
        case 143 >= I:
            H.push([I + 48, 8]);
            break;
        case 255 >= I:
            H.push([I - 144 + 400, 9]);
            break;
        case 279 >= I:
            H.push([I - 256 + 0, 7]);
            break;
        case 287 >= I:
            H.push([I - 280 + 192, 8]);
            break;
        default:
            a("invalid literal: " + I)
    }
    h.prototype.n = function () {
        var b, d, f, g, h = this.input;
        switch (this.h) {
            case 0:
                f = 0;
                for (g = h.length; f < g;) {
                    d = C ? h.subarray(f, f + 65535) : h.slice(f, f + 65535);
                    f += d.length;
                    var n = f === g, p = D, u = p = D, u = p = D, F = this.a, R = this.b;
                    if (C) {
                        for (F = new Uint8Array(this.a.buffer); F.length <= R + d.length + 5;)F = new Uint8Array(F.length << 1);
                        F.set(this.a)
                    }
                    p = n ? 1 : 0;
                    F[R++] = p | 0;
                    p = d.length;
                    u = ~p + 65536 & 65535;
                    F[R++] = p & 255;
                    F[R++] = p >>> 8 & 255;
                    F[R++] = u & 255;
                    F[R++] = u >>> 8 & 255;
                    if (C)F.set(d, R), R += d.length, F = F.subarray(0, R); else {
                        p = 0;
                        for (u = d.length; p < u; ++p)F[R++] = d[p];
                        F.length = R
                    }
                    this.b = R;
                    this.a = F
                }
                break;
            case 1:
                f =
                    new e(new Uint8Array(this.a.buffer), this.b);
                f.d(1, 1, G);
                f.d(1, 2, G);
                h = r(this, h);
                d = 0;
                for (n = h.length; d < n; d++)if (g = h[d], e.prototype.d.apply(f, H[g]), 256 < g)f.d(h[++d], h[++d], G), f.d(h[++d], 5), f.d(h[++d], h[++d], G); else if (256 === g)break;
                this.a = f.finish();
                this.b = this.a.length;
                break;
            case K:
                g = new e(new Uint8Array(this.a), this.b);
                var y, w, N, x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], v, X, p = Array(19), A, F = K;
                g.d(1, 1, G);
                g.d(F, 2, G);
                h = r(this, h);
                u = s(this.L, 15);
                v = t(u);
                F = s(this.K, 7);
                R = t(F);
                for (y = 286; 257 < y && 0 === u[y -
                1]; y--);
                for (w = 30; 1 < w && 0 === F[w - 1]; w--);
                var W = y, fa = w;
                b = new (C ? Uint32Array : Array)(W + fa);
                var U = new (C ? Uint32Array : Array)(316), O, V;
                X = new (C ? Uint8Array : Array)(19);
                for (A = N = 0; A < W; A++)b[N++] = u[A];
                for (A = 0; A < fa; A++)b[N++] = F[A];
                if (!C)for (A = 0, fa = X.length; A < fa; ++A)X[A] = 0;
                A = O = 0;
                for (fa = b.length; A < fa; A += N) {
                    for (N = 1; A + N < fa && b[A + N] === b[A]; ++N);
                    W = N;
                    if (0 === b[A])if (3 > W)for (; 0 < W--;)U[O++] = 0, X[0]++; else for (; 0 < W;)V = 138 > W ? W : 138, V > W - 3 && V < W && (V = W - 3), 10 >= V ? (U[O++] = 17, U[O++] = V - 3, X[17]++) : (U[O++] = 18, U[O++] = V - 11, X[18]++), W -= V; else if (U[O++] =
                            b[A], X[b[A]]++, W--, 3 > W)for (; 0 < W--;)U[O++] = b[A], X[b[A]]++; else for (; 0 < W;)V = 6 > W ? W : 6, V > W - 3 && V < W && (V = W - 3), U[O++] = 16, U[O++] = V - 3, X[16]++, W -= V
                }
                b = C ? U.subarray(0, O) : U.slice(0, O);
                X = s(X, 7);
                for (A = 0; 19 > A; A++)p[A] = X[x[A]];
                for (N = 19; 4 < N && 0 === p[N - 1]; N--);
                x = t(X);
                g.d(y - 257, 5, G);
                g.d(w - 1, 5, G);
                g.d(N - 4, 4, G);
                for (A = 0; A < N; A++)g.d(p[A], 3, G);
                A = 0;
                for (p = b.length; A < p; A++)if (d = b[A], g.d(x[d], X[d], G), 16 <= d) {
                    A++;
                    switch (d) {
                        case 16:
                            n = 2;
                            break;
                        case 17:
                            n = 3;
                            break;
                        case 18:
                            n = 7;
                            break;
                        default:
                            a("invalid code: " + d)
                    }
                    g.d(b[A], n, G)
                }
                n = [v, u];
                R = [R,
                    F];
                d = n[0];
                n = n[1];
                F = R[0];
                v = R[1];
                R = 0;
                for (p = h.length; R < p; ++R)if (f = h[R], g.d(d[f], n[f], G), 256 < f)g.d(h[++R], h[++R], G), u = h[++R], g.d(F[u], v[u], G), g.d(h[++R], h[++R], G); else if (256 === f)break;
                this.a = g.finish();
                this.b = this.a.length;
                break;
            default:
                a("invalid compression type")
        }
        return this.a
    };
    I = [];
    var P;
    for (P = 3; 258 >= P; P++)L = p(), I[P] = L[2] << 24 | L[1] << 16 | L[0];
    var U = C ? new Uint32Array(I) : I, O = E;
    v.prototype.n = function () {
        var b, e, f, g, h = 0;
        g = this.a;
        b = ma;
        switch (b) {
            case ma:
                e = Math.LOG2E * Math.log(32768) - 8;
                break;
            default:
                a(Error("invalid compression method"))
        }
        e =
            e << 4 | b;
        g[h++] = e;
        switch (b) {
            case ma:
                switch (this.h) {
                    case O.NONE:
                        f = 0;
                        break;
                    case O.r:
                        f = 1;
                        break;
                    case O.j:
                        f = 2;
                        break;
                    default:
                        a(Error("unsupported compression type"))
                }
                break;
            default:
                a(Error("invalid compression method"))
        }
        b = f << 6 | 0;
        g[h++] = b | 31 - (256 * e + b) % 31;
        b = d(this.input);
        this.z.b = h;
        g = this.z.n();
        h = g.length;
        C && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
        g[h++] = b >> 24 & 255;
        g[h++] = b >> 16 & 255;
        g[h++] = b >> 8 & 255;
        g[h++] = b & 255;
        return g
    };
    b("Zlib.Deflate",
        v);
    b("Zlib.Deflate.compress", function (a, b) {
        return (new v(a, b)).n()
    });
    b("Zlib.Deflate.CompressionType", O);
    b("Zlib.Deflate.CompressionType.NONE", O.NONE);
    b("Zlib.Deflate.CompressionType.FIXED", O.r);
    b("Zlib.Deflate.CompressionType.DYNAMIC", O.j);
    var Y = 0, V = 1, E = {D: Y, C: V};
    u.prototype.p = function () {
        for (; !this.s;) {
            var b = x(this, 3);
            b & 1 && (this.s = G);
            b >>>= 1;
            switch (b) {
                case 0:
                    var b = this.input, d = this.c, e = this.a, f = this.b, g = D, h = D, n = D, p = e.length, g = D;
                    this.e = this.g = 0;
                    g = b[d++];
                    g === D && a(Error("invalid uncompressed block header: LEN (first byte)"));
                    h = g;
                    g = b[d++];
                    g === D && a(Error("invalid uncompressed block header: LEN (second byte)"));
                    h |= g << 8;
                    g = b[d++];
                    g === D && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                    n = g;
                    g = b[d++];
                    g === D && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                    n |= g << 8;
                    h === ~n && a(Error("invalid uncompressed block header: length verify"));
                    d + h > b.length && a(Error("input buffer is broken"));
                    switch (this.m) {
                        case Y:
                            for (; f + h > e.length;) {
                                g = p - f;
                                h -= g;
                                if (C)e.set(b.subarray(d, d + g), f), f += g, d += g; else for (; g--;)e[f++] =
                                    b[d++];
                                this.b = f;
                                e = this.f();
                                f = this.b
                            }
                            break;
                        case V:
                            for (; f + h > e.length;)e = this.f({v: 2});
                            break;
                        default:
                            a(Error("invalid inflate mode"))
                    }
                    if (C)e.set(b.subarray(d, d + h), f), f += h, d += h; else for (; h--;)e[f++] = b[d++];
                    this.c = d;
                    this.b = f;
                    this.a = e;
                    break;
                case 1:
                    this.o(fa, sa);
                    break;
                case 2:
                    y(this);
                    break;
                default:
                    a(Error("unknown BTYPE: " + b))
            }
        }
        return this.t()
    };
    I = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var F = C ? new Uint16Array(I) : I;
    I = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227,
        258, 258, 258];
    var N = C ? new Uint16Array(I) : I;
    I = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var W = C ? new Uint8Array(I) : I;
    I = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var R = C ? new Uint16Array(I) : I;
    I = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var X = C ? new Uint8Array(I) : I;
    I = new (C ? Uint8Array : Array)(288);
    L = 0;
    for (J = I.length; L < J; ++L)I[L] = 143 >= L ? 8 : 255 >= L ? 9 : 279 >= L ? 7 : 8;
    var fa = g(I);
    I = new (C ? Uint8Array :
        Array)(30);
    L = 0;
    for (J = I.length; L < J; ++L)I[L] = 5;
    var sa = g(I);
    u.prototype.o = function (a, b) {
        var d = this.a, e = this.b;
        this.u = a;
        for (var f = d.length - 258, g, h, n; 256 !== (g = w(this, a));)if (256 > g)e >= f && (this.b = e, d = this.f(), e = this.b), d[e++] = g; else for (g -= 257, n = N[g], 0 < W[g] && (n += x(this, W[g])), g = w(this, b), h = R[g], 0 < X[g] && (h += x(this, X[g])), e >= f && (this.b = e, d = this.f(), e = this.b); n--;)d[e] = d[e++ - h];
        for (; 8 <= this.e;)this.e -= 8, this.c--;
        this.b = e
    };
    u.prototype.I = function (a, b) {
        var d = this.a, e = this.b;
        this.u = a;
        for (var f = d.length, g, h, n; 256 !==
        (g = w(this, a));)if (256 > g)e >= f && (d = this.f(), f = d.length), d[e++] = g; else for (g -= 257, n = N[g], 0 < W[g] && (n += x(this, W[g])), g = w(this, b), h = R[g], 0 < X[g] && (h += x(this, X[g])), e + n > f && (d = this.f(), f = d.length); n--;)d[e] = d[e++ - h];
        for (; 8 <= this.e;)this.e -= 8, this.c--;
        this.b = e
    };
    u.prototype.f = function () {
        var a = new (C ? Uint8Array : Array)(this.b - 32768), b = this.b - 32768, d, e, f = this.a;
        if (C)a.set(f.subarray(32768, a.length)); else for (d = 0, e = a.length; d < e; ++d)a[d] = f[d + 32768];
        this.k.push(a);
        this.q += a.length;
        if (C)f.set(f.subarray(b, b + 32768));
        else for (d = 0; 32768 > d; ++d)f[d] = f[b + d];
        this.b = 32768;
        return f
    };
    u.prototype.J = function (a) {
        var b, d = this.input.length / this.c + 1 | 0, e, f, g, h = this.input, n = this.a;
        a && ("number" === typeof a.v && (d = a.v), "number" === typeof a.F && (d += a.F));
        2 > d ? (e = (h.length - this.c) / this.u[2], g = e / 2 * 258 | 0, f = g < n.length ? n.length + g : n.length << 1) : f = n.length * d;
        C ? (b = new Uint8Array(f), b.set(n)) : b = n;
        return this.a = b
    };
    u.prototype.t = function () {
        var a = 0, b = this.a, d = this.k, e, f = new (C ? Uint8Array : Array)(this.q + (this.b - 32768)), g, h, n, p;
        if (0 === d.length)return C ?
            this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        g = 0;
        for (h = d.length; g < h; ++g)for (e = d[g], n = 0, p = e.length; n < p; ++n)f[a++] = e[n];
        g = 32768;
        for (h = this.b; g < h; ++g)f[a++] = b[g];
        this.k = [];
        return this.buffer = f
    };
    u.prototype.H = function () {
        var a, b = this.b;
        C ? this.B ? (a = new Uint8Array(b), a.set(this.a.subarray(0, b))) : a = this.a.subarray(0, b) : (this.a.length > b && (this.a.length = b), a = this.a);
        return this.buffer = a
    };
    A.prototype.p = function () {
        var b = this.input, e, f;
        e = this.A.p();
        this.c = this.A.c;
        this.M && (f = (b[this.c++] << 24 | b[this.c++] <<
            16 | b[this.c++] << 8 | b[this.c++]) >>> 0, f !== d(e) && a(Error("invalid adler-32 checksum")));
        return e
    };
    b("Zlib.Inflate", A);
    b("Zlib.Inflate.BufferType", E);
    E.ADAPTIVE = E.C;
    E.BLOCK = E.D;
    b("Zlib.Inflate.prototype.decompress", A.prototype.p);
    E = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    C && new Uint16Array(E);
    E = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    C && new Uint16Array(E);
    E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    C && new Uint8Array(E);
    E = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    C && new Uint16Array(E);
    E = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    C && new Uint8Array(E);
    E = new (C ? Uint8Array : Array)(288);
    I = 0;
    for (L = E.length; I < L; ++I)E[I] = 143 >= I ? 8 : 255 >= I ? 9 : 279 >= I ? 7 : 8;
    g(E);
    E = new (C ? Uint8Array : Array)(30);
    I = 0;
    for (L = E.length; I < L; ++I)E[I] = 5;
    g(E);
    var ma = 8
}).call(this);
_p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.PNGReader = cc.Class.extend({
    ctor: function (a) {
        var b, d, e, f;
        this.data = a;
        this.pos = 8;
        this.palette = [];
        this.imgData = [];
        this.transparency = {};
        this.animation = null;
        this.text = {};
        for (e = null; ;) {
            b = this.readUInt32();
            f = a = void 0;
            f = [];
            for (a = 0; 4 > a; ++a)f.push(String.fromCharCode(this.data[this.pos++]));
            a = f.join("");
            switch (a) {
                case "IHDR":
                    this.width = this.readUInt32();
                    this.height = this.readUInt32();
                    this.bits = this.data[this.pos++];
                    this.colorType = this.data[this.pos++];
                    this.compressionMethod = this.data[this.pos++];
                    this.filterMethod =
                        this.data[this.pos++];
                    this.interlaceMethod = this.data[this.pos++];
                    break;
                case "acTL":
                    this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || Infinity,
                        frames: []
                    };
                    break;
                case "PLTE":
                    this.palette = this.read(b);
                    break;
                case "fcTL":
                    e && this.animation.frames.push(e);
                    this.pos += 4;
                    e = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                    };
                    a = this.readUInt16();
                    b = this.readUInt16() || 100;
                    e.delay = 1E3 * a / b;
                    e.disposeOp = this.data[this.pos++];
                    e.blendOp = this.data[this.pos++];
                    e.data = [];
                    break;
                case "IDAT":
                case "fdAT":
                    "fdAT" === a && (this.pos += 4, b -= 4);
                    a = (null != e ? e.data : void 0) || this.imgData;
                    for (f = 0; 0 <= b ? f < b : f > b; 0 <= b ? ++f : --f)a.push(this.data[this.pos++]);
                    break;
                case "tRNS":
                    this.transparency = {};
                    switch (this.colorType) {
                        case 3:
                            this.transparency.indexed = this.read(b);
                            b = 255 - this.transparency.indexed.length;
                            if (0 < b)for (a = 0; 0 <= b ? a < b : a > b; 0 <= b ? ++a : --a)this.transparency.indexed.push(255);
                            break;
                        case 0:
                            this.transparency.grayscale = this.read(b)[0];
                            break;
                        case 2:
                            this.transparency.rgb = this.read(b)
                    }
                    break;
                case "tEXt":
                    f = this.read(b);
                    b = f.indexOf(0);
                    a = String.fromCharCode.apply(String, f.slice(0, b));
                    this.text[a] = String.fromCharCode.apply(String, f.slice(b + 1));
                    break;
                case "IEND":
                    e && this.animation.frames.push(e);
                    a:{
                        switch (this.colorType) {
                            case 0:
                            case 3:
                            case 4:
                                e = 1;
                                break a;
                            case 2:
                            case 6:
                                e = 3;
                                break a
                        }
                        e = void 0
                    }
                    this.colors = e;
                    this.hasAlphaChannel = 4 === (d = this.colorType) || 6 === d;
                    d = this.colors + (this.hasAlphaChannel ? 1 : 0);
                    this.pixelBitlength = this.bits * d;
                    a:{
                        switch (this.colors) {
                            case 1:
                                d = "DeviceGray";
                                break a;
                            case 3:
                                d = "DeviceRGB";
                                break a
                        }
                        d = void 0
                    }
                    this.colorSpace = d;
                    Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
                    return;
                default:
                    this.pos += b
            }
            this.pos += 4;
            if (this.pos > this.data.length)throw Error("Incomplete or corrupt PNG file");
        }
    }, read: function (a) {
        var b, d;
        d = [];
        for (b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b)d.push(this.data[this.pos++]);
        return d
    }, readUInt32: function () {
        var a, b, d, e;
        a = this.data[this.pos++] << 24;
        b = this.data[this.pos++] << 16;
        d = this.data[this.pos++] << 8;
        e = this.data[this.pos++];
        return a | b | d | e
    }, readUInt16: function () {
        var a,
            b;
        a = this.data[this.pos++] << 8;
        b = this.data[this.pos++];
        return a | b
    }, decodePixels: function (a) {
        var b, d, e, f, g, h, n, p, r, s, t, v, u, x, w;
        null == a && (a = this.imgData);
        if (0 === a.length)return new Uint8Array(0);
        a = (new Zlib.Inflate(a, {index: 0, verify: !1})).decompress();
        p = this.pixelBitlength / 8;
        v = p * this.width;
        r = new Uint8Array(v * this.height);
        h = a.length;
        for (d = s = t = 0; s < h;) {
            switch (a[s++]) {
                case 0:
                    for (b = 0; b < v; b += 1)r[d++] = a[s++];
                    break;
                case 1:
                    for (f = u = 0; u < v; f = u += 1)b = a[s++], g = f < p ? 0 : r[d - p], r[d++] = (b + g) % 256;
                    break;
                case 2:
                    for (f = g = 0; g <
                    v; f = g += 1)b = a[s++], e = (f - f % p) / p, u = t && r[(t - 1) * v + e * p + f % p], r[d++] = (u + b) % 256;
                    break;
                case 3:
                    for (f = w = 0; w < v; f = w += 1)b = a[s++], e = (f - f % p) / p, g = f < p ? 0 : r[d - p], u = t && r[(t - 1) * v + e * p + f % p], r[d++] = (b + Math.floor((g + u) / 2)) % 256;
                    break;
                case 4:
                    for (f = w = 0; w < v; f = w += 1)b = a[s++], e = (f - f % p) / p, g = f < p ? 0 : r[d - p], 0 === t ? u = x = 0 : (u = r[(t - 1) * v + e * p + f % p], x = e && r[(t - 1) * v + (e - 1) * p + f % p]), n = g + u - x, f = Math.abs(n - g), e = Math.abs(n - u), n = Math.abs(n - x), g = f <= e && f <= n ? g : e <= n ? u : x, r[d++] = (b + g) % 256;
                    break;
                default:
                    throw Error("Invalid filter algorithm: " + a[s - 1]);
            }
            t++
        }
        return r
    },
    copyToImageData: function (a, b) {
        var d, e, f, g, h, n, p, r;
        e = this.colors;
        r = null;
        d = this.hasAlphaChannel;
        this.palette.length && (r = null != (f = this._decodedPalette) ? f : this._decodedPalette = this.decodePalette(), e = 4, d = !0);
        f = a.data || a;
        p = f.length;
        h = r || b;
        g = n = 0;
        if (1 === e)for (; g < p;)e = r ? 4 * b[g / 4] : n, n = h[e++], f[g++] = n, f[g++] = n, f[g++] = n, f[g++] = d ? h[e++] : 255, n = e; else for (; g < p;)e = r ? 4 * b[g / 4] : n, f[g++] = h[e++], f[g++] = h[e++], f[g++] = h[e++], f[g++] = d ? h[e++] : 255, n = e
    }, decodePalette: function () {
        var a, b, d, e, f, g, h, n, p;
        d = this.palette;
        g = this.transparency.indexed ||
            [];
        f = new Uint8Array((g.length || 0) + d.length);
        b = h = a = e = 0;
        for (n = d.length; h < n; b = h += 3)f[e++] = d[b], f[e++] = d[b + 1], f[e++] = d[b + 2], f[e++] = null != (p = g[a++]) ? p : 255;
        return f
    }, render: function (a) {
        var b;
        a.width = this.width;
        a.height = this.height;
        a = a.getContext("2d");
        b = a.createImageData(this.width, this.height);
        this.copyToImageData(b, this.decodePixels());
        return a.putImageData(b, 0, 0)
    }
});
cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function (a) {
        return this._tiffData[a]
    },
    getUint16: function (a) {
        return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
    },
    getUint32: function (a) {
        var b = this._tiffData;
        return this._littleEndian ? b[a + 3] << 24 | b[a + 2] << 16 | b[a + 1] << 8 | b[a] : b[a] << 24 | b[a + 1] << 16 | b[a + 2] << 8 | b[a + 3]
    },
    checkLittleEndian: function () {
        var a = this.getUint16(0);
        if (18761 === a)this.littleEndian = !0; else if (19789 === a)this.littleEndian = !1; else throw console.log(a), TypeError("Invalid byte order value.");
        return this.littleEndian
    },
    hasTowel: function () {
        if (42 !== this.getUint16(2))throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function (a) {
        var b = this.fieldTypeNames;
        return a in b ? b[a] : null
    },
    getFieldTagName: function (a) {
        var b = this.fieldTagNames;
        if (a in b)return b[a];
        console.log("Unknown Field Tag:", a);
        return "Tag" + a
    },
    getFieldTypeLength: function (a) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT",
            "SSHORT"].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
    },
    getFieldValues: function (a, b, d, e) {
        a = [];
        var f = this.getFieldTypeLength(b);
        if (4 >= f * d)!1 === this.littleEndian ? a.push(e >>> 8 * (4 - f)) : a.push(e); else for (var g = 0; g < d; g++) {
            var h = f * g;
            8 <= f ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(b) ? (a.push(this.getUint32(e + h)), a.push(this.getUint32(e + h + 4))) : cc.log("Can't handle this field type or size") : a.push(this.getBytes(f, e + h))
        }
        "ASCII" === b && a.forEach(function (a,
                                             b, d) {
            d[b] = String.fromCharCode(a)
        });
        return a
    },
    getBytes: function (a, b) {
        if (0 >= a)cc.log("No bytes requested"); else {
            if (1 >= a)return this.getUint8(b);
            if (2 >= a)return this.getUint16(b);
            if (3 >= a)return this.getUint32(b) >>> 8;
            if (4 >= a)return this.getUint32(b);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function (a, b, d) {
        d = d || 0;
        b += Math.floor(d / 8);
        var e = d + a;
        a = 32 - a;
        var f, g;
        0 >= e ? console.log("No bits requested") : 8 >= e ? (f = 24 + d, g = this.getUint8(b)) : 16 >= e ? (f = 16 + d, g = this.getUint16(b)) : 32 >= e ? (f = d, g = this.getUint32(b)) : console.log("Too many bits requested");
        return {bits: g << f >>> a, byteOffset: b + Math.floor(e / 8), bitOffset: e % 8}
    },
    parseFileDirectory: function (a) {
        var b = this.getUint16(a), d = [];
        a += 2;
        for (var e = 0; e < b; a += 12, e++) {
            var f = this.getUint16(a), g = this.getUint16(a + 2), h = this.getUint32(a + 4), n = this.getUint32(a + 8), f = this.getFieldTagName(f), g = this.getFieldTypeName(g), h = this.getFieldValues(f, g, h, n);
            d[f] = {type: g, values: h}
        }
        this._fileDirectories.push(d);
        b = this.getUint32(a);
        0 !== b && this.parseFileDirectory(b)
    },
    clampColorSample: function (a, b) {
        var d = Math.pow(2, 8 - b);
        return Math.floor(a *
            d + (d - 1))
    },
    parseTIFF: function (a, b) {
        b = b || document.createElement("canvas");
        this._tiffData = a;
        this.canvas = b;
        this.checkLittleEndian();
        if (this.hasTowel()) {
            var d = this.getUint32(4);
            this._fileDirectories.length = 0;
            this.parseFileDirectory(d);
            var e = this._fileDirectories[0], d = e.ImageWidth.values[0], f = e.ImageLength.values[0];
            this.canvas.width = d;
            this.canvas.height = f;
            var g = [], h = e.Compression ? e.Compression.values[0] : 1, n = e.SamplesPerPixel.values[0], p = [], r = 0, s = !1;
            e.BitsPerSample.values.forEach(function (a, b, d) {
                p[b] = {
                    bitsPerSample: a,
                    hasBytesPerSample: !1, bytesPerSample: void 0
                };
                0 === a % 8 && (p[b].hasBytesPerSample = !0, p[b].bytesPerSample = a / 8);
                r += a
            }, this);
            if (0 === r % 8)var s = !0, t = r / 8;
            var v = e.StripOffsets.values, u = v.length;
            if (e.StripByteCounts)var x = e.StripByteCounts.values; else if (cc.log("Missing StripByteCounts!"), 1 === u)x = [Math.ceil(d * f * r / 8)]; else throw Error("Cannot recover from missing StripByteCounts");
            for (var w = 0; w < u; w++) {
                var y = v[w];
                g[w] = [];
                for (var A = x[w], D = 0, G = 0, B = 1, C = !0, E = [], I = 0, L = 0, J = 0; D < A; D += B)switch (h) {
                    case 1:
                        B = 0;
                        for (E = []; B < n; B++)if (p[B].hasBytesPerSample)E.push(this.getBytes(p[B].bytesPerSample,
                            y + D + p[B].bytesPerSample * B)); else {
                            var Q = this.getBits(p[B].bitsPerSample, y + D, G);
                            E.push(Q.bits);
                            D = Q.byteOffset - y;
                            G = Q.bitOffset;
                            throw RangeError("Cannot handle sub-byte bits per sample");
                        }
                        g[w].push(E);
                        if (s)B = t; else throw B = 0, RangeError("Cannot handle sub-byte bits per pixel");
                        break;
                    case 32773:
                        if (C) {
                            var C = !1, M = 1, K = 1, B = this.getInt8(y + D);
                            0 <= B && 127 >= B ? M = B + 1 : -127 <= B && -1 >= B ? K = -B + 1 : C = !0
                        } else {
                            for (var H = this.getUint8(y + D), B = 0; B < K; B++) {
                                if (p[L].hasBytesPerSample)J = J << 8 * I | H, I++, I === p[L].bytesPerSample && (E.push(J),
                                    J = I = 0, L++); else throw RangeError("Cannot handle sub-byte bits per sample");
                                L === n && (g[w].push(E), E = [], L = 0)
                            }
                            M--;
                            0 === M && (C = !0)
                        }
                        B = 1
                }
            }
            if (b.getContext) {
                t = this.canvas.getContext("2d");
                t.fillStyle = "rgba(255, 255, 255, 0)";
                w = e.RowsPerStrip ? e.RowsPerStrip.values[0] : f;
                y = g.length;
                f %= w;
                f = 0 === f ? w : f;
                D = w;
                h = 0;
                E = e.PhotometricInterpretation.values[0];
                M = [];
                K = 0;
                e.ExtraSamples && (M = e.ExtraSamples.values, K = M.length);
                if (e.ColorMap)var Q = e.ColorMap.values, P = Math.pow(2, p[0].bitsPerSample);
                for (w = 0; w < y; w++) {
                    w + 1 === y && (D = f);
                    e =
                        g[w].length;
                    h *= w;
                    for (s = n = 0; n < D, s < e; n++)for (v = 0; v < d; v++, s++) {
                        x = g[w][s];
                        C = G = A = 0;
                        u = 1;
                        if (0 < K)for (A = 0; A < K; A++)if (1 === M[A] || 2 === M[A]) {
                            u = x[3 + A] / 256;
                            break
                        }
                        switch (E) {
                            case 0:
                                if (p[0].hasBytesPerSample)var U = Math.pow(16, 2 * p[0].bytesPerSample);
                                x.forEach(function (a, b, d) {
                                    d[b] = U - a
                                });
                            case 1:
                                A = G = C = this.clampColorSample(x[0], p[0].bitsPerSample);
                                break;
                            case 2:
                                A = this.clampColorSample(x[0], p[0].bitsPerSample);
                                G = this.clampColorSample(x[1], p[1].bitsPerSample);
                                C = this.clampColorSample(x[2], p[2].bitsPerSample);
                                break;
                            case 3:
                                if (void 0 ===
                                    Q)throw Error("Palette image missing color map");
                                x = x[0];
                                A = this.clampColorSample(Q[x], 16);
                                G = this.clampColorSample(Q[P + x], 16);
                                C = this.clampColorSample(Q[2 * P + x], 16);
                                break;
                            default:
                                throw RangeError("Unknown Photometric Interpretation:", E);
                        }
                        t.fillStyle = "rgba(" + A + ", " + G + ", " + C + ", " + u + ")";
                        t.fillRect(v, h + n, 1, 1)
                    }
                    h = D
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
};
cc.Particle = function (a, b, d, e, f, g, h, n, p, r, s, t) {
    this.pos = a ? a : cc.p(0, 0);
    this.startPos = b ? b : cc.p(0, 0);
    this.color = d ? d : {r: 0, g: 0, b: 0, a: 255};
    this.deltaColor = e ? e : {r: 0, g: 0, b: 0, a: 255};
    this.size = f || 0;
    this.deltaSize = g || 0;
    this.rotation = h || 0;
    this.deltaRotation = n || 0;
    this.timeToLive = p || 0;
    this.atlasIndex = r || 0;
    this.modeA = s ? s : new cc.Particle.ModeA;
    this.modeB = t ? t : new cc.Particle.ModeB;
    this.isChangeColor = !1;
    this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function (a, b, d) {
    this.dir = a ? a : cc.p(0, 0);
    this.radialAccel = b || 0;
    this.tangentialAccel = d || 0
};
cc.Particle.ModeB = function (a, b, d, e) {
    this.angle = a || 0;
    this.degreesPerSecond = b || 0;
    this.radius = d || 0;
    this.deltaRadius = e || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({
    _className: "ParticleSystem",
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: null,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _textureLoaded: null,
    ctor: function (a) {
        cc.Node.prototype.ctor.call(this);
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA;
        this.modeB = new cc.ParticleSystem.ModeB;
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        this._particles = [];
        this._sourcePosition = cc.p(0, 0);
        this._posVar = cc.p(0,
            0);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._endColorVar = cc.color(255, 255, 255, 255);
        this._plistFile = "";
        this._elapsed = 0;
        this._dontTint = !1;
        this._pointZeroForParticle = cc.p(0, 0);
        this._particleIdx = this._emitCounter = 0;
        this._batchNode = null;
        this.atlasIndex = 0;
        this._transformSystemDirty = !1;
        this._allocatedParticles = 0;
        this._isActive = !1;
        this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar =
            this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
        this._texture = null;
        this._opacityModifyRGB = !1;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.autoRemoveOnFinish = !1;
        this._textureLoaded = !0;
        !a || cc.isNumber(a) ? (a = a || 100, this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(a)) : cc.isString(a) ? this.initWithFile(a) : cc.isObject(a) && this.initWithDictionary(a, "")
    },
    _createRenderCmd: function () {
        return cc._renderType ===
        cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleSystem.CanvasRenderCmd(this) : new cc.ParticleSystem.WebGLRenderCmd(this)
    },
    ignoreColor: function (a) {
        this._dontTint = a
    },
    initTexCoordsWithRect: function (a) {
        this._renderCmd.initTexCoordsWithRect(a)
    },
    getBatchNode: function () {
        return this._batchNode
    },
    setBatchNode: function (a) {
        this._renderCmd.setBatchNode(a)
    },
    getAtlasIndex: function () {
        return this.atlasIndex
    },
    setAtlasIndex: function (a) {
        this.atlasIndex = a
    },
    getDrawMode: function () {
        return this._renderCmd.getDrawMode()
    },
    setDrawMode: function (a) {
        this._renderCmd.setDrawMode(a)
    },
    getShapeType: function () {
        return this._renderCmd.getShapeType()
    },
    setShapeType: function (a) {
        this._renderCmd.setShapeType(a)
    },
    isActive: function () {
        return this._isActive
    },
    getParticleCount: function () {
        return this.particleCount
    },
    setParticleCount: function (a) {
        this.particleCount = a
    },
    getDuration: function () {
        return this.duration
    },
    setDuration: function (a) {
        this.duration = a
    },
    getSourcePosition: function () {
        return {x: this._sourcePosition.x, y: this._sourcePosition.y}
    },
    setSourcePosition: function (a) {
        this._sourcePosition = a
    },
    getPosVar: function () {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function (a) {
        this._posVar = a
    },
    getLife: function () {
        return this.life
    },
    setLife: function (a) {
        this.life = a
    },
    getLifeVar: function () {
        return this.lifeVar
    },
    setLifeVar: function (a) {
        this.lifeVar = a
    },
    getAngle: function () {
        return this.angle
    },
    setAngle: function (a) {
        this.angle = a
    },
    getAngleVar: function () {
        return this.angleVar
    },
    setAngleVar: function (a) {
        this.angleVar = a
    },
    getGravity: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var a = this.modeA.gravity;
        return cc.p(a.x, a.y)
    },
    setGravity: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
        this.modeA.gravity = a
    },
    getSpeed: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
        return this.modeA.speed
    },
    setSpeed: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
        this.modeA.speed = a
    },
    getSpeedVar: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
        return this.modeA.speedVar
    },
    setSpeedVar: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
        this.modeA.speedVar = a
    },
    getTangentialAccel: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccel
    },
    setTangentialAccel: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
        this.modeA.tangentialAccel = a
    },
    getTangentialAccelVar: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY &&
        cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = a
    },
    getRadialAccel: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
        return this.modeA.radialAccel
    },
    setRadialAccel: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
        this.modeA.radialAccel = a
    },
    getRadialAccelVar: function () {
        this.emitterMode !==
        cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.radialAccelVar
    },
    setRadialAccelVar: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
        this.modeA.radialAccelVar = a
    },
    getRotationIsDir: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
        return this.modeA.rotationIsDir
    },
    setRotationIsDir: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
        this.modeA.rotationIsDir = a
    },
    getStartRadius: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
        return this.modeB.startRadius
    },
    setStartRadius: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
        this.modeB.startRadius = a
    },
    getStartRadiusVar: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
        return this.modeB.startRadiusVar
    },
    setStartRadiusVar: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
        this.modeB.startRadiusVar = a
    },
    getEndRadius: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
        return this.modeB.endRadius
    },
    setEndRadius: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
        this.modeB.endRadius = a
    },
    getEndRadiusVar: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
        return this.modeB.endRadiusVar
    },
    setEndRadiusVar: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
        this.modeB.endRadiusVar = a
    },
    getRotatePerSecond: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
        this.modeB.rotatePerSecond = a
    },
    getRotatePerSecondVar: function () {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS &&
        cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function (a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
        this.modeB.rotatePerSecondVar = a
    },
    setScale: function (a, b) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScale.call(this, a, b)
    },
    setRotation: function (a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setRotation.call(this,
            a)
    },
    setScaleX: function (a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function (a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleY.call(this, a)
    },
    getStartSize: function () {
        return this.startSize
    },
    setStartSize: function (a) {
        this.startSize = a
    },
    getStartSizeVar: function () {
        return this.startSizeVar
    },
    setStartSizeVar: function (a) {
        this.startSizeVar = a
    },
    getEndSize: function () {
        return this.endSize
    },
    setEndSize: function (a) {
        this.endSize = a
    },
    getEndSizeVar: function () {
        return this.endSizeVar
    },
    setEndSizeVar: function (a) {
        this.endSizeVar = a
    },
    getStartColor: function () {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    },
    setStartColor: function (a) {
        this._startColor = cc.color(a)
    },
    getStartColorVar: function () {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    },
    setStartColorVar: function (a) {
        this._startColorVar = cc.color(a)
    },
    getEndColor: function () {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b,
            this._endColor.a)
    },
    setEndColor: function (a) {
        this._endColor = cc.color(a)
    },
    getEndColorVar: function () {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
    },
    setEndColorVar: function (a) {
        this._endColorVar = cc.color(a)
    },
    getStartSpin: function () {
        return this.startSpin
    },
    setStartSpin: function (a) {
        this.startSpin = a
    },
    getStartSpinVar: function () {
        return this.startSpinVar
    },
    setStartSpinVar: function (a) {
        this.startSpinVar = a
    },
    getEndSpin: function () {
        return this.endSpin
    },
    setEndSpin: function (a) {
        this.endSpin =
            a
    },
    getEndSpinVar: function () {
        return this.endSpinVar
    },
    setEndSpinVar: function (a) {
        this.endSpinVar = a
    },
    getEmissionRate: function () {
        return this.emissionRate
    },
    setEmissionRate: function (a) {
        this.emissionRate = a
    },
    getTotalParticles: function () {
        return this._totalParticles
    },
    setTotalParticles: function (a) {
        this._renderCmd.setTotalParticles(a)
    },
    getTexture: function () {
        return this._texture
    },
    setTexture: function (a) {
        a && (a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addEventListener("load",
            function (a) {
                this._textureLoaded = !0;
                this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height))
            }, this)))
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a, b) {
        if (void 0 === b)this._blendFunc !== a && (this._blendFunc = a, this._updateBlendFunc()); else if (this._blendFunc.src !== a || this._blendFunc.dst !== b)this._blendFunc = {
            src: a,
            dst: b
        }, this._updateBlendFunc()
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function (a) {
        this._opacityModifyRGB = a
    },
    isBlendAdditive: function () {
        return this._blendFunc.src ===
            cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE || this._blendFunc.src === cc.ONE && this._blendFunc.dst === cc.ONE
    },
    setBlendAdditive: function (a) {
        var b = this._blendFunc;
        a ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE) : this._renderCmd._setBlendAdditive()
    },
    getPositionType: function () {
        return this.positionType
    },
    setPositionType: function (a) {
        this.positionType = a
    },
    isAutoRemoveOnFinish: function () {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function (a) {
        this.autoRemoveOnFinish = a
    },
    getEmitterMode: function () {
        return this.emitterMode
    },
    setEmitterMode: function (a) {
        this.emitterMode = a
    },
    init: function () {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function (a) {
        this._plistFile = a;
        a = cc.loader.getRes(a);
        return a ? this.initWithDictionary(a, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1)
    },
    getBoundingBoxToWorld: function () {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function (a, b) {
        var d = !1, e = null, e = this._valueForKey, f = parseInt(e("maxParticles", a));
        if (this.initWithTotalParticles(f)) {
            this.angle =
                parseFloat(e("angle", a));
            this.angleVar = parseFloat(e("angleVariance", a));
            this.duration = parseFloat(e("duration", a));
            this._blendFunc.src = parseInt(e("blendFuncSource", a));
            this._blendFunc.dst = parseInt(e("blendFuncDestination", a));
            d = this._startColor;
            d.r = 255 * parseFloat(e("startColorRed", a));
            d.g = 255 * parseFloat(e("startColorGreen", a));
            d.b = 255 * parseFloat(e("startColorBlue", a));
            d.a = 255 * parseFloat(e("startColorAlpha", a));
            d = this._startColorVar;
            d.r = 255 * parseFloat(e("startColorVarianceRed", a));
            d.g = 255 * parseFloat(e("startColorVarianceGreen",
                    a));
            d.b = 255 * parseFloat(e("startColorVarianceBlue", a));
            d.a = 255 * parseFloat(e("startColorVarianceAlpha", a));
            d = this._endColor;
            d.r = 255 * parseFloat(e("finishColorRed", a));
            d.g = 255 * parseFloat(e("finishColorGreen", a));
            d.b = 255 * parseFloat(e("finishColorBlue", a));
            d.a = 255 * parseFloat(e("finishColorAlpha", a));
            d = this._endColorVar;
            d.r = 255 * parseFloat(e("finishColorVarianceRed", a));
            d.g = 255 * parseFloat(e("finishColorVarianceGreen", a));
            d.b = 255 * parseFloat(e("finishColorVarianceBlue", a));
            d.a = 255 * parseFloat(e("finishColorVarianceAlpha",
                    a));
            this.startSize = parseFloat(e("startParticleSize", a));
            this.startSizeVar = parseFloat(e("startParticleSizeVariance", a));
            this.endSize = parseFloat(e("finishParticleSize", a));
            this.endSizeVar = parseFloat(e("finishParticleSizeVariance", a));
            this.setPosition(parseFloat(e("sourcePositionx", a)), parseFloat(e("sourcePositiony", a)));
            this._posVar.x = parseFloat(e("sourcePositionVariancex", a));
            this._posVar.y = parseFloat(e("sourcePositionVariancey", a));
            this.startSpin = parseFloat(e("rotationStart", a));
            this.startSpinVar =
                parseFloat(e("rotationStartVariance", a));
            this.endSpin = parseFloat(e("rotationEnd", a));
            this.endSpinVar = parseFloat(e("rotationEndVariance", a));
            this.emitterMode = parseInt(e("emitterType", a));
            if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY)d = this.modeA, d.gravity.x = parseFloat(e("gravityx", a)), d.gravity.y = parseFloat(e("gravityy", a)), d.speed = parseFloat(e("speed", a)), d.speedVar = parseFloat(e("speedVariance", a)), f = e("radialAcceleration", a), d.radialAccel = f ? parseFloat(f) : 0, f = e("radialAccelVariance", a), d.radialAccelVar =
                f ? parseFloat(f) : 0, f = e("tangentialAcceleration", a), d.tangentialAccel = f ? parseFloat(f) : 0, f = e("tangentialAccelVariance", a), d.tangentialAccelVar = f ? parseFloat(f) : 0, f = e("rotationIsDir", a).toLowerCase(), d.rotationIsDir = null != f && ("true" === f || "1" === f); else if (this.emitterMode === cc.ParticleSystem.MODE_RADIUS)d = this.modeB, d.startRadius = parseFloat(e("maxRadius", a)), d.startRadiusVar = parseFloat(e("maxRadiusVariance", a)), d.endRadius = parseFloat(e("minRadius", a)), d.endRadiusVar = 0, d.rotatePerSecond = parseFloat(e("rotatePerSecond",
                a)), d.rotatePerSecondVar = parseFloat(e("rotatePerSecondVariance", a)); else return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
            this.life = parseFloat(e("particleLifespan", a));
            this.lifeVar = parseFloat(e("particleLifespanVariance", a));
            this.emissionRate = this._totalParticles / this.life;
            if (!this._batchNode)if (this._opacityModifyRGB = !1, d = e("textureFileName", a), d = cc.path.changeBasename(this._plistFile, d), f = cc.textureCache.getTextureForKey(d))this.setTexture(f); else if ((e =
                    e("textureImageData", a)) && 0 !== e.length) {
                e = cc.unzipBase64AsArray(e, 1);
                if (!e)return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                f = cc.getImageFormatByData(e);
                if (f !== cc.FMT_TIFF && f !== cc.FMT_PNG)return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                var g = document.createElement("canvas");
                f === cc.FMT_PNG ? (new cc.PNGReader(e)).render(g) : cc.tiffReader.parseTIFF(e, g);
                cc.textureCache.cacheImage(d, g);
                (e = cc.textureCache.getTextureForKey(d)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
                this.setTexture(e)
            } else {
                f = cc.textureCache.addImage(d);
                if (!f)return !1;
                this.setTexture(f)
            }
            d = !0
        }
        return d
    },
    initWithTotalParticles: function (a) {
        this._totalParticles = a;
        var b, d = this._particles;
        for (b = d.length = 0; b < a; b++)d[b] = new cc.Particle;
        if (!d)return cc.log("Particle system: not enough memory"), !1;
        this._allocatedParticles = a;
        if (this._batchNode)for (b = 0; b < this._totalParticles; b++)d[b].atlasIndex = b;
        this._isActive = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this._transformSystemDirty = this.autoRemoveOnFinish = !1;
        this.scheduleUpdateWithPriority(1);
        this._renderCmd._initWithTotalParticles(a);
        return !0
    },
    destroyParticleSystem: function () {
        this.unscheduleUpdate()
    },
    addParticle: function () {
        if (this.isFull())return !1;
        var a = this._renderCmd.addParticle();
        this.initParticle(a);
        ++this.particleCount;
        return !0
    },
    initParticle: function (a) {
        var b = cc.randomMinus1To1;
        a.timeToLive = this.life + this.lifeVar * b();
        a.timeToLive = Math.max(0, a.timeToLive);
        a.pos.x = this._sourcePosition.x + this._posVar.x * b();
        a.pos.y = this._sourcePosition.y + this._posVar.y * b();
        var d, e;
        d = this._startColor;
        var f = this._startColorVar, g = this._endColor;
        e = this._endColorVar;
        d = {
            r: cc.clampf(d.r + f.r * b(), 0, 255),
            g: cc.clampf(d.g + f.g * b(), 0, 255),
            b: cc.clampf(d.b + f.b * b(), 0, 255),
            a: cc.clampf(d.a + f.a * b(), 0, 255)
        };
        e = {
            r: cc.clampf(g.r + e.r * b(), 0, 255),
            g: cc.clampf(g.g + e.g * b(), 0, 255),
            b: cc.clampf(g.b + e.b * b(), 0, 255),
            a: cc.clampf(g.a + e.a * b(), 0, 255)
        };
        a.color = d;
        f = a.deltaColor;
        g = a.timeToLive;
        f.r = (e.r - d.r) / g;
        f.g = (e.g - d.g) / g;
        f.b = (e.b - d.b) / g;
        f.a = (e.a - d.a) / g;
        d = this.startSize + this.startSizeVar * b();
        d = Math.max(0, d);
        a.size = d;
        this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? a.deltaSize = 0 : (e = this.endSize + this.endSizeVar * b(), e = Math.max(0, e), a.deltaSize = (e - d) / g);
        d = this.startSpin + this.startSpinVar * b();
        e = this.endSpin + this.endSpinVar * b();
        a.rotation = d;
        a.deltaRotation = (e - d) / g;
        this.positionType === cc.ParticleSystem.TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType ===
        cc.ParticleSystem.TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y);
        d = cc.degreesToRadians(this.angle + this.angleVar * b());
        if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY)g = this.modeA, e = a.modeA, f = g.speed + g.speedVar * b(), e.dir.x = Math.cos(d), e.dir.y = Math.sin(d), cc.pMultIn(e.dir, f), e.radialAccel = g.radialAccel + g.radialAccelVar * b(), e.tangentialAccel = g.tangentialAccel + g.tangentialAccelVar * b(), g.rotationIsDir && (a.rotation = -cc.radiansToDegrees(cc.pToAngle(e.dir))); else {
            e = this.modeB;
            a = a.modeB;
            var f = e.startRadius + e.startRadiusVar * b(), h = e.endRadius + e.endRadiusVar * b();
            a.radius = f;
            a.deltaRadius = e.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (h - f) / g;
            a.angle = d;
            a.degreesPerSecond = cc.degreesToRadians(e.rotatePerSecond + e.rotatePerSecondVar * b())
        }
    },
    stopSystem: function () {
        this._isActive = !1;
        this._elapsed = this.duration;
        this._emitCounter = 0
    },
    resetSystem: function () {
        this._isActive = !0;
        this._elapsed = 0;
        var a = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx)a[this._particleIdx].timeToLive =
            0
    },
    isFull: function () {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function (a, b) {
        this._renderCmd.updateQuadWithParticle(a, b)
    },
    postStep: function () {
        this._renderCmd.postStep()
    },
    update: function (a) {
        if (this._isActive && this.emissionRate) {
            var b = 1 / this.emissionRate;
            this.particleCount < this._totalParticles && (this._emitCounter += a);
            for (; this.particleCount < this._totalParticles && this._emitCounter > b;)this.addParticle(), this._emitCounter -= b;
            this._elapsed += a;
            -1 !== this.duration && this.duration <
            this._elapsed && this.stopSystem()
        }
        this._particleIdx = 0;
        b = cc.Particle.TemporaryPoints[0];
        this.positionType === cc.ParticleSystem.TYPE_FREE ? cc.pIn(b, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (b.x = this._position.x, b.y = this._position.y);
        if (this._visible) {
            for (var d = cc.Particle.TemporaryPoints[1], e = cc.Particle.TemporaryPoints[2], f = cc.Particle.TemporaryPoints[3], g = this._particles; this._particleIdx < this.particleCount;) {
                cc.pZeroIn(d);
                cc.pZeroIn(e);
                cc.pZeroIn(f);
                var h = g[this._particleIdx];
                h.timeToLive -= a;
                if (0 < h.timeToLive) {
                    if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
                        var n = f, p = d, r = e;
                        h.pos.x || h.pos.y ? (cc.pIn(p, h.pos), cc.pNormalizeIn(p)) : cc.pZeroIn(p);
                        cc.pIn(r, p);
                        cc.pMultIn(p, h.modeA.radialAccel);
                        var s = r.x;
                        r.x = -r.y;
                        r.y = s;
                        cc.pMultIn(r, h.modeA.tangentialAccel);
                        cc.pIn(n, p);
                        cc.pAddIn(n, r);
                        cc.pAddIn(n, this.modeA.gravity);
                        cc.pMultIn(n, a);
                        cc.pAddIn(h.modeA.dir, n);
                        cc.pIn(n, h.modeA.dir);
                        cc.pMultIn(n, a);
                        cc.pAddIn(h.pos, n)
                    } else n = h.modeB, n.angle +=
                        n.degreesPerSecond * a, n.radius += n.deltaRadius * a, h.pos.x = -Math.cos(n.angle) * n.radius, h.pos.y = -Math.sin(n.angle) * n.radius;
                    this._renderCmd._updateDeltaColor(h, a);
                    h.size += h.deltaSize * a;
                    h.size = Math.max(0, h.size);
                    h.rotation += h.deltaRotation * a;
                    n = d;
                    this.positionType === cc.ParticleSystem.TYPE_FREE || this.positionType === cc.ParticleSystem.TYPE_RELATIVE ? (p = e, cc.pIn(p, b), cc.pSubIn(p, h.startPos), cc.pIn(n, h.pos), cc.pSubIn(n, p)) : cc.pIn(n, h.pos);
                    this._batchNode && (n.x += this._position.x, n.y += this._position.y);
                    this._renderCmd.updateParticlePosition(h,
                        n);
                    ++this._particleIdx
                } else if (h = h.atlasIndex, this._particleIdx !== this.particleCount - 1 && (n = g[this._particleIdx], g[this._particleIdx] = g[this.particleCount - 1], g[this.particleCount - 1] = n), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + h), g[this.particleCount - 1].atlasIndex = h), --this.particleCount, 0 === this.particleCount && this.autoRemoveOnFinish) {
                    this.unscheduleUpdate();
                    this._parent.removeChild(this, !0);
                    return
                }
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function () {
        this.update(0)
    },
    _valueForKey: function (a, b) {
        if (b) {
            var d = b[a];
            return null != d ? d : ""
        }
        return ""
    },
    _updateBlendFunc: function () {
        if (this._batchNode)cc.log("Can't change blending functions when the particle is being batched"); else {
            var a = this._texture;
            if (a && a instanceof cc.Texture2D) {
                this._opacityModifyRGB = !1;
                var b = this._blendFunc;
                b.src === cc.BLEND_SRC && b.dst === cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA))
            }
        }
    },
    clone: function () {
        var a = new cc.ParticleSystem;
        if (a.initWithTotalParticles(this.getTotalParticles())) {
            a.setAngle(this.getAngle());
            a.setAngleVar(this.getAngleVar());
            a.setDuration(this.getDuration());
            var b = this.getBlendFunc();
            a.setBlendFunc(b.src, b.dst);
            a.setStartColor(this.getStartColor());
            a.setStartColorVar(this.getStartColorVar());
            a.setEndColor(this.getEndColor());
            a.setEndColorVar(this.getEndColorVar());
            a.setStartSize(this.getStartSize());
            a.setStartSizeVar(this.getStartSizeVar());
            a.setEndSize(this.getEndSize());
            a.setEndSizeVar(this.getEndSizeVar());
            a.setPosition(cc.p(this.x, this.y));
            a.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
            a.setPositionType(this.getPositionType());
            a.setStartSpin(this.getStartSpin() || 0);
            a.setStartSpinVar(this.getStartSpinVar() || 0);
            a.setEndSpin(this.getEndSpin() || 0);
            a.setEndSpinVar(this.getEndSpinVar() || 0);
            a.setEmitterMode(this.getEmitterMode());
            this.getEmitterMode() === cc.ParticleSystem.MODE_GRAVITY ? (b = this.getGravity(), a.setGravity(cc.p(b.x, b.y)), a.setSpeed(this.getSpeed()), a.setSpeedVar(this.getSpeedVar()), a.setRadialAccel(this.getRadialAccel()), a.setRadialAccelVar(this.getRadialAccelVar()), a.setTangentialAccel(this.getTangentialAccel()),
                a.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() === cc.ParticleSystem.MODE_RADIUS && (a.setStartRadius(this.getStartRadius()), a.setStartRadiusVar(this.getStartRadiusVar()), a.setEndRadius(this.getEndRadius()), a.setEndRadiusVar(this.getEndRadiusVar()), a.setRotatePerSecond(this.getRotatePerSecond()), a.setRotatePerSecondVar(this.getRotatePerSecondVar()));
            a.setLife(this.getLife());
            a.setLifeVar(this.getLifeVar());
            a.setEmissionRate(this.getEmissionRate());
            if (!this.getBatchNode() &&
                (a.setOpacityModifyRGB(this.isOpacityModifyRGB()), b = this.getTexture())) {
                var d = b.getContentSize();
                a.setTextureWithRect(b, cc.rect(0, 0, d.width, d.height))
            }
        }
        return a
    },
    setDisplayFrame: function (a) {
        if (a) {
            var b = a.getOffsetInPixels();
            0 === b.x && 0 === b.y || cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
            a = a.getTexture();
            this._texture !== a && this.setTexture(a)
        }
    },
    setTextureWithRect: function (a, b) {
        this._texture !== a && (this._texture = a, this._updateBlendFunc());
        this.initTexCoordsWithRect(b)
    },
    listenBackToForeground: function (a) {
    }
});
_p = cc.ParticleSystem.prototype;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode);
cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType);
cc.defineGetterSetter(_p, "active", _p.isActive);
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function (a) {
    return new cc.ParticleSystem(a)
};
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create;
cc.ParticleSystem.ModeA = function (a, b, d, e, f, g, h, n) {
    this.gravity = a ? a : cc.p(0, 0);
    this.speed = b || 0;
    this.speedVar = d || 0;
    this.tangentialAccel = e || 0;
    this.tangentialAccelVar = f || 0;
    this.radialAccel = g || 0;
    this.radialAccelVar = h || 0;
    this.rotationIsDir = n || !1
};
cc.ParticleSystem.ModeB = function (a, b, d, e, f, g) {
    this.startRadius = a || 0;
    this.startRadiusVar = b || 0;
    this.endRadius = d || 0;
    this.endRadiusVar = e || 0;
    this.rotatePerSecond = f || 0;
    this.rotatePerSecondVar = g || 0
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
(function () {
    cc.ParticleSystem.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._drawMode = cc.ParticleSystem.TEXTURE_MODE;
        this._shapeType = cc.ParticleSystem.BALL_SHAPE;
        this._pointRect = cc.rect(0, 0, 0, 0);
        this._tintCache = document.createElement("canvas")
    };
    var a = cc.ParticleSystem.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ParticleSystem.CanvasRenderCmd;
    a.getDrawMode = function () {
        return this._drawMode
    };
    a.setDrawMode = function (a) {
        this._drawMode =
            a
    };
    a.getShapeType = function () {
        return this._shapeType
    };
    a.setShapeType = function (a) {
        this._shapeType = a
    };
    a.setBatchNode = function (a) {
        this._batchNode !== a && (this._node._batchNode = a)
    };
    a.updateQuadWithParticle = function (a, d) {
    };
    a.updateParticlePosition = function (a, d) {
        cc.pIn(a.drawPos, d)
    };
    a.rendering = function (a, d, e) {
        a = a || cc._renderContext;
        var f = a.getContext(), g = this._node, h = this._pointRect;
        a.setTransform(this._worldTransform, d, e);
        a.save();
        g.isBlendAdditive() ? f.globalCompositeOperation = "lighter" : f.globalCompositeOperation =
            "source-over";
        var n, p;
        e = this._node.particleCount;
        var r = this._node._particles;
        if (g.drawMode !== cc.ParticleSystem.SHAPE_MODE && g._texture) {
            if (!g._texture._textureLoaded) {
                a.restore();
                return
            }
            var s = g._texture.getHtmlElementObj();
            if (!s.width || !s.height) {
                a.restore();
                return
            }
            n = s;
            for (d = 0; d < e; d++)if (n = r[d], p = n.color.a / 255, 0 !== p) {
                f.globalAlpha = p;
                f.save();
                f.translate(0 | n.drawPos.x, -(0 | n.drawPos.y));
                var t = 4 * Math.floor(n.size / 4);
                p = h.width;
                var v = h.height;
                f.scale(Math.max(1 / p * t, 1E-6), Math.max(1 / v * t, 1E-6));
                n.rotation &&
                f.rotate(cc.degreesToRadians(n.rotation));
                n = n.isChangeColor ? this._changeTextureColor(g._texture, n.color, this._pointRect) : s;
                f.drawImage(n, -(0 | p / 2), -(0 | v / 2));
                f.restore()
            }
        } else for (s = cc._drawingUtil, d = 0; d < e; d++)n = r[d], h = 0 | 0.5 * n.size, p = n.color.a / 255, 0 !== p && (f.globalAlpha = p, f.save(), f.translate(0 | n.drawPos.x, -(0 | n.drawPos.y)), g.shapeType === cc.ParticleSystem.STAR_SHAPE ? (n.rotation && f.rotate(cc.degreesToRadians(n.rotation)), s.drawStar(a, h, n.color)) : s.drawColorBall(a, h, n.color), f.restore());
        a.restore();
        cc.g_NumberOfDraws++
    };
    a._changeTextureColor = function (a, d, e) {
        var f = this._tintCache, g = a.getContentSize();
        f.width = g.width;
        f.height = g.height;
        return a._generateColorTexture(d.r, d.g, d.b, e, f)
    };
    a.initTexCoordsWithRect = function (a) {
        this._pointRect = a
    };
    a.setTotalParticles = function (a) {
        this._node._totalParticles = 200 > a ? a : 200
    };
    a.addParticle = function () {
        var a = this._node, d = a._particles;
        a.particleCount < d.length ? a = d[a.particleCount] : (a = new cc.Particle, d.push(a));
        return a
    };
    a._setupVBO = function () {
    };
    a._allocMemory = function () {
        return !0
    };
    a.postStep =
        function () {
        };
    a._setBlendAdditive = function () {
        var a = this._node._blendFunc;
        a.src = cc.BLEND_SRC;
        a.dst = cc.BLEND_DST
    };
    a._initWithTotalParticles = function (a) {
    };
    a._updateDeltaColor = function (a, d) {
        this._node._dontTint || (a.color.r += a.deltaColor.r * d, a.color.g += a.deltaColor.g * d, a.color.b += a.deltaColor.b * d, a.color.a += a.deltaColor.a * d, a.isChangeColor = !0)
    }
})();
(function () {
    cc.ParticleSystem.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._buffersVBO = [0, 0];
        this._quads = [];
        this._indices = [];
        this._quadsArrayBuffer = null
    };
    var a = cc.ParticleSystem.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ParticleSystem.WebGLRenderCmd;
    a.getDrawMode = function () {
    };
    a.setDrawMode = function (a) {
    };
    a.getShapeType = function () {
    };
    a.setShapeType = function (a) {
    };
    a.setBatchNode = function (a) {
        var d = this._node;
        if (d._batchNode !==
            a) {
            var e = d._batchNode;
            if (d._batchNode = a)for (var f = d._particles, g = 0; g < d._totalParticles; g++)f[g].atlasIndex = g;
            a ? e || (d._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, d.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(d._totalParticles), d.setTexture(e.getTexture()), this._setupVBO())
        }
    };
    a.initIndices = function (a) {
        for (var d = this._indices, e = 0; e < a; ++e) {
            var f = 6 * e, g = 4 * e;
            d[f + 0] = g + 0;
            d[f + 1] = g + 1;
            d[f + 2] = g + 2;
            d[f + 5] = g + 1;
            d[f + 4] = g + 2;
            d[f + 3] = g + 3
        }
    };
    a.isDifferentTexture =
        function (a, d) {
            return a === d
        };
    a.updateParticlePosition = function (a, d) {
        this.updateQuadWithParticle(a, d)
    };
    a.updateQuadWithParticle = function (a, d) {
        var e = null, f = this._node;
        f._batchNode ? (e = f._batchNode.textureAtlas.quads[f.atlasIndex + a.atlasIndex], f._batchNode.textureAtlas.dirty = !0) : e = this._quads[f._particleIdx];
        var g, h, n;
        f._opacityModifyRGB ? (f = 0 | a.color.r * a.color.a / 255, g = 0 | a.color.g * a.color.a / 255, h = 0 | a.color.b * a.color.a / 255) : (f = 0 | a.color.r, g = 0 | a.color.g, h = 0 | a.color.b);
        n = 0 | a.color.a;
        var p = e.bl.colors, r = e.br.colors,
            s = e.tl.colors, t = e.tr.colors;
        p.r = r.r = s.r = t.r = f;
        p.g = r.g = s.g = t.g = g;
        p.b = r.b = s.b = t.b = h;
        p.a = r.a = s.a = t.a = n;
        f = a.size / 2;
        a.rotation ? (g = -f, h = -f, n = d.x, p = d.y, s = -cc.degreesToRadians(a.rotation), r = Math.cos(s), s = Math.sin(s), e.bl.vertices.x = g * r - h * s + n, e.bl.vertices.y = g * s + h * r + p, e.br.vertices.x = f * r - h * s + n, e.br.vertices.y = f * s + h * r + p, e.tl.vertices.x = g * r - f * s + n, e.tl.vertices.y = g * s + f * r + p, e.tr.vertices.x = f * r - f * s + n, e.tr.vertices.y = f * s + f * r + p) : (e.bl.vertices.x = d.x - f, e.bl.vertices.y = d.y - f, e.br.vertices.x = d.x + f, e.br.vertices.y = d.y -
            f, e.tl.vertices.x = d.x - f, e.tl.vertices.y = d.y + f, e.tr.vertices.x = d.x + f, e.tr.vertices.y = d.y + f)
    };
    a.rendering = function (a) {
        var d = this._node;
        d._texture && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBindTexture2D(d._texture), cc.glBlendFuncForParticle(d._blendFunc.src, d._blendFunc.dst), a.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), a.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), a.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS),
            a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.drawElements(a.TRIANGLES, 6 * d._particleIdx, a.UNSIGNED_SHORT, 0))
    };
    a.initTexCoordsWithRect = function (a) {
        var d = this._node, e = d.texture, f = cc.contentScaleFactor(), g = cc.rect(a.x * f, a.y * f, a.width *
            f, a.height * f), f = a.width, h = a.height;
        e && (f = e.pixelsWidth, h = e.pixelsHeight);
        cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * g.x + 1) / (2 * f), a = (2 * g.y + 1) / (2 * h), f = e + (2 * g.width - 2) / (2 * f), g = a + (2 * g.height - 2) / (2 * h)) : (e = g.x / f, a = g.y / h, f = e + g.width / f, g = a + g.height / h);
        h = g;
        g = a;
        a = h;
        var n = 0, p = 0;
        d._batchNode ? (h = d._batchNode.textureAtlas.quads, n = d.atlasIndex, p = d.atlasIndex + d._totalParticles) : (h = this._quads, n = 0, p = d._totalParticles);
        for (d = n; d < p; d++)h[d] || (h[d] = cc.V3F_C4B_T2F_QuadZero()), n = h[d], n.bl.texCoords.u = e, n.bl.texCoords.v =
            a, n.br.texCoords.u = f, n.br.texCoords.v = a, n.tl.texCoords.u = e, n.tl.texCoords.v = g, n.tr.texCoords.u = f, n.tr.texCoords.v = g
    };
    a.setTotalParticles = function (a) {
        var d = this._node;
        if (a > d._allocatedParticles) {
            var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            this._indices = new Uint16Array(6 * a);
            var f = new ArrayBuffer(a * e), g = d._particles;
            g.length = 0;
            for (var h = this._quads, n = h.length = 0; n < a; n++)g[n] = new cc.Particle, h[n] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, f, n * e);
            d._allocatedParticles = a;
            d._totalParticles = a;
            if (d._batchNode)for (e =
                                      0; e < a; e++)g[e].atlasIndex = e;
            this._quadsArrayBuffer = f;
            this.initIndices(a);
            this._setupVBO();
            d._texture && this.initTexCoordsWithRect(cc.rect(0, 0, d._texture.width, d._texture.height))
        } else d._totalParticles = a;
        d.resetSystem()
    };
    a.addParticle = function () {
        var a = this._node;
        return a._particles[a.particleCount]
    };
    a._setupVBO = function () {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        this._buffersVBO[1] =
            a.createBuffer();
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    };
    a._allocMemory = function () {
        var a = this._node;
        if (a._batchNode)return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, a = a._totalParticles, e = this._quads;
        e.length = 0;
        this._indices = new Uint16Array(6 * a);
        for (var f = new ArrayBuffer(d * a), g = 0; g < a; g++)e[g] = new cc.V3F_C4B_T2F_Quad(null,
            null, null, null, f, g * d);
        if (!e || !this._indices)return cc.log("cocos2d: Particle system: not enough memory"), !1;
        this._quadsArrayBuffer = f;
        return !0
    };
    a.postStep = function () {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
        a.bufferSubData(a.ARRAY_BUFFER, 0, this._quadsArrayBuffer)
    };
    a._setBlendAdditive = function () {
        var a = this._node._blendFunc;
        this._texture && !this._texture.hasPremultipliedAlpha() ? (a.src = cc.SRC_ALPHA, a.dst = cc.ONE_MINUS_SRC_ALPHA) : (a.src = cc.BLEND_SRC, a.dst = cc.BLEND_DST)
    };
    a._initWithTotalParticles =
        function (a) {
            if (!this._allocMemory())return !1;
            this.initIndices(a);
            this._setupVBO();
            this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
        };
    a._updateDeltaColor = function (a, d) {
        a.color.r += a.deltaColor.r * d;
        a.color.g += a.deltaColor.g * d;
        a.color.b += a.deltaColor.b * d;
        a.color.a += a.deltaColor.a * d;
        a.isChangeColor = !0
    }
})();
cc.ParticleFire = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 300 : 150)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10),
            a = cc.director.getWinSize(), this.setPosition(a.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFire.create = function () {
    return new cc.ParticleFire
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1500 : 150)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), a = cc.director.getWinSize(),
            this.setPosition(a.width / 2, a.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleFireworks.create = function () {
    return new cc.ParticleFireworks
};
cc.ParticleSun = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 350 : 150)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)),
            !0) : !1
    }
});
cc.ParticleSun.create = function () {
    return new cc.ParticleSun
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0,
            0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleGalaxy.create = function () {
    return new cc.ParticleGalaxy
};
cc.ParticleFlower = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 250 : 100)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)),
            this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFlower.create = function () {
    return new cc.ParticleFlower
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 150 : 100)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0,
            0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleMeteor.create = function () {
    return new cc.ParticleMeteor
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 500 : 100)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)),
            this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSpiral.create = function () {
    return new cc.ParticleSpiral
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 300)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(0.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128,
            128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleExplosion.create = function () {
    return new cc.ParticleExplosion
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90),
            this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1),
            !0) : !1
    }
});
cc.ParticleSmoke.create = function () {
    return new cc.ParticleSmoke
};
cc.ParticleSnow = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 250)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0),
            this.setTangentialAccelVar(1), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height + 10), this.setPosVar(cc.p(a.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0,
            0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSnow.create = function () {
    return new cc.ParticleSnow
};
cc.ParticleRain = cc.ParticleSystem.extend({
    ctor: function () {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1E3 : 300)
    }, initWithTotalParticles: function (a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1),
            this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height), this.setPosVar(cc.p(a.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0,
            0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleRain.create = function () {
    return new cc.ParticleRain
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null, _blendFunc: null, _className: "ParticleBatchNode", ctor: function (a, b) {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        cc.isString(a) ? this.init(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this)
    }, initWithTexture: function (a, b) {
        this.textureAtlas =
            new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, b);
        this._children.length = 0;
        this._renderCmd._initWithTexture();
        return !0
    }, initWithFile: function (a, b) {
        var d = cc.textureCache.addImage(a);
        return this.initWithTexture(d, b)
    }, init: function (a, b) {
        var d = cc.textureCache.addImage(a);
        return this.initWithTexture(d, b)
    }, addChild: function (a, b, d) {
        if (!a)throw Error("cc.ParticleBatchNode.addChild() : child should be non-null");
        if (!(a instanceof cc.ParticleSystem))throw Error("cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children");
        b = null == b ? a.zIndex : b;
        d = null == d ? a.tag : d;
        if (a.getTexture() !== this.textureAtlas.texture)throw Error("cc.ParticleSystem.addChild() : the child is not using the same texture id");
        var e = a.getBlendFunc();
        if (0 === this._children.length)this.setBlendFunc(e); else if (e.src !== this._blendFunc.src || e.dst !== this._blendFunc.dst) {
            cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
            return
        }
        b = this._addChildHelper(a, b, d);
        d = 0;
        0 !== b ? (b = this._children[b - 1], d = b.getAtlasIndex() +
            b.getTotalParticles()) : d = 0;
        this.insertChild(a, d);
        a.setBatchNode(this)
    }, insertChild: function (a, b) {
        var d = a.getTotalParticles(), e = this.textureAtlas, f = e.totalQuads;
        a.setAtlasIndex(b);
        f + d > e.getCapacity() && (this._increaseAtlasCapacityTo(f + d), e.fillWithEmptyQuadsFromIndex(e.getCapacity() - d, d));
        a.getAtlasIndex() + d !== f && e.moveQuadsFromIndex(b, b + d);
        e.increaseTotalQuadsWith(d);
        this._updateAllAtlasIndexes()
    }, removeChild: function (a, b) {
        if (null != a) {
            if (!(a instanceof cc.ParticleSystem))throw Error("cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children");
            if (-1 === this._children.indexOf(a))cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it"); else {
                cc.Node.prototype.removeChild.call(this, a, b);
                var d = this.textureAtlas;
                d.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles());
                d.fillWithEmptyQuadsFromIndex(d.totalQuads, a.getTotalParticles());
                a.setBatchNode(null);
                this._updateAllAtlasIndexes()
            }
        }
    }, reorderChild: function (a, b) {
        if (!a)throw Error("cc.ParticleBatchNode.reorderChild(): child should be non-null");
        if (!(a instanceof cc.ParticleSystem))throw Error("cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children");
        if (-1 === this._children.indexOf(a))cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch"); else if (b !== a.zIndex) {
            if (1 < this._children.length) {
                var d = this._getCurrentIndex(a, b);
                if (d.oldIndex !== d.newIndex) {
                    this._children.splice(d.oldIndex, 1);
                    this._children.splice(d.newIndex, 0, a);
                    d = a.getAtlasIndex();
                    this._updateAllAtlasIndexes();
                    for (var e = 0, f = this._children, g = 0; g <
                    f.length; g++)if (f[g] === a) {
                        e = a.getAtlasIndex();
                        break
                    }
                    this.textureAtlas.moveQuadsFromIndex(d, a.getTotalParticles(), e);
                    a.updateWithNoTime()
                }
            }
            a._setLocalZOrder(b)
        }
    }, removeChildAtIndex: function (a, b) {
        this.removeChild(this._children[i], b)
    }, removeAllChildren: function (a) {
        for (var b = this._children, d = 0; d < b.length; d++)b[d].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this.textureAtlas.removeAllQuads()
    }, disableParticle: function (a) {
        a = this.textureAtlas.quads[a];
        a.br.vertices.x = a.br.vertices.y =
            a.tr.vertices.x = a.tr.vertices.y = a.tl.vertices.x = a.tl.vertices.y = a.bl.vertices.x = a.bl.vertices.y = 0;
        this.textureAtlas._setDirty(!0)
    }, getTexture: function () {
        return this.textureAtlas.texture
    }, setTexture: function (a) {
        this.textureAtlas.texture = a;
        var b = this._blendFunc;
        a && !a.hasPremultipliedAlpha() && b.src === cc.BLEND_SRC && b.dst === cc.BLEND_DST && (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA)
    }, setBlendFunc: function (a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a,
            this._blendFunc.src = b)
    }, getBlendFunc: function () {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    }, _updateAllAtlasIndexes: function () {
        for (var a = 0, b = this._children, d = 0; d < b.length; d++) {
            var e = b[d];
            e.setAtlasIndex(a);
            a += e.getTotalParticles()
        }
    }, _increaseAtlasCapacityTo: function (a) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + a + "].");
        this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
    },
    _searchNewPositionInChildrenForZ: function (a) {
        for (var b = this._children, d = b.length, e = 0; e < d; e++)if (b[e].zIndex > a)return e;
        return d
    }, _getCurrentIndex: function (a, b) {
        for (var d = !1, e = !1, f = 0, g = 0, h = 0, n = this._children, p = n.length, r = 0; r < p; r++) {
            var s = n[r];
            if (s.zIndex > b && !e && (f = r, e = !0, d && e))break;
            if (a === s && (g = r, d = !0, e || (h = -1), d && e))break
        }
        e || (f = p);
        return {newIndex: f + h, oldIndex: g}
    }, _addChildHelper: function (a, b, d) {
        if (!a)throw Error("cc.ParticleBatchNode._addChildHelper(): child should be non-null");
        if (a.parent)return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"),
            null;
        this._children || (this._children = []);
        var e = this._searchNewPositionInChildrenForZ(b);
        this._children.splice(e, 0, a);
        a.tag = d;
        a._setLocalZOrder(b);
        a.parent = this;
        this._running && (a.onEnter(), a.onEnterTransitionDidFinish());
        return e
    }, _updateBlendFunc: function () {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    }, getTextureAtlas: function () {
        return this.textureAtlas
    }, setTextureAtlas: function (a) {
        this.textureAtlas = a
    }
});
_p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function (a, b) {
    return new cc.ParticleBatchNode(a, b)
};
(function () {
    cc.ParticleBatchNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ParticleBatchNode.CanvasRenderCmd;
    a._initWithTexture = function () {
    }
})();
(function () {
    cc.ParticleBatchNode.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ParticleBatchNode.WebGLRenderCmd;
    a.rendering = function (a) {
        a = this._node;
        0 !== a.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFuncForParticle(a._blendFunc.src, a._blendFunc.dst), a.textureAtlas.drawQuads())
    };
    a._initWithTexture = function () {
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a.visit = function (a) {
        if (this._node._visible) {
            var d = cc.current_stack;
            d.stack.push(d.top);
            this._syncStatus(a);
            d.top = this._stackMatrix;
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0;
            cc.kmGLPopMatrix()
        }
    }
})();
cc.IMEKeyboardNotificationInfo = function (a, b, d) {
    this.begin = a || cc.rect(0, 0, 0, 0);
    this.end = b || cc.rect(0, 0, 0, 0);
    this.duration = d || 0
};
cc.IMEDelegate = cc.Class.extend({
    ctor: function () {
        cc.imeDispatcher.addDelegate(this)
    }, removeDelegate: function () {
        cc.imeDispatcher.removeDelegate(this)
    }, attachWithIME: function () {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    }, detachWithIME: function () {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    }, canAttachWithIME: function () {
        return !1
    }, didAttachWithIME: function () {
    }, canDetachWithIME: function () {
        return !1
    }, didDetachWithIME: function () {
    }, insertText: function (a, b) {
    }, deleteBackward: function () {
    }, getContentText: function () {
        return ""
    },
    keyboardWillShow: function (a) {
    }, keyboardDidShow: function (a) {
    }, keyboardWillHide: function (a) {
    }, keyboardDidHide: function (a) {
    }
});
cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null, impl: null, _currentInputString: "", _lastClickPosition: null, ctor: function () {
        this.impl = new cc.IMEDispatcher.Impl;
        this._lastClickPosition = cc.p(0, 0)
    }, init: function () {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput");
            this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0,
                0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
            var a = this;
            this._domInputControl.addEventListener("input", function () {
                a._processDomInputString(a._domInputControl.value)
            }, !1);
            this._domInputControl.addEventListener("keydown", function (b) {
                b.keyCode === cc.KEY.tab ?
                    (b.stopPropagation(), b.preventDefault()) : b.keyCode === cc.KEY.enter && (a.dispatchInsertText("\n", 1), b.stopPropagation(), b.preventDefault())
            }, !1);
            /msie/i.test(navigator.userAgent) && this._domInputControl.addEventListener("keyup", function (b) {
                b.keyCode === cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
            }, !1);
            window.addEventListener("mousedown", function (b) {
                var d = b.pageY || 0;
                a._lastClickPosition.x = b.pageX || 0;
                a._lastClickPosition.y = d
            }, !1)
        }
    }, _processDomInputString: function (a) {
        var b, d;
        b = this._currentInputString.length <
        a.length ? this._currentInputString.length : a.length;
        for (d = 0; d < b && a[d] === this._currentInputString[d]; d++);
        var e = this._currentInputString.length - d, f = a.length - d;
        for (b = 0; b < e; b++)this.dispatchDeleteBackward();
        for (b = 0; b < f; b++)this.dispatchInsertText(a[d + b], 1);
        this._currentInputString = a
    }, dispatchInsertText: function (a, b) {
        !this.impl || !a || 0 >= b || this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, b)
    }, dispatchDeleteBackward: function () {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function () {
        if (this.impl && this.impl._delegateWithIme) {
            var a = this.impl._delegateWithIme.getContentText();
            return a ? a : ""
        }
        return ""
    }, dispatchKeyboardWillShow: function (a) {
        if (this.impl)for (var b = 0; b < this.impl._delegateList.length; b++) {
            var d = this.impl._delegateList[b];
            d && d.keyboardWillShow(a)
        }
    }, dispatchKeyboardDidShow: function (a) {
        if (this.impl)for (var b = 0; b < this.impl._delegateList.length; b++) {
            var d = this.impl._delegateList[b];
            d && d.keyboardDidShow(a)
        }
    }, dispatchKeyboardWillHide: function (a) {
        if (this.impl)for (var b =
            0; b < this.impl._delegateList.length; b++) {
            var d = this.impl._delegateList[b];
            d && d.keyboardWillHide(a)
        }
    }, dispatchKeyboardDidHide: function (a) {
        if (this.impl)for (var b = 0; b < this.impl._delegateList.length; b++) {
            var d = this.impl._delegateList[b];
            d && d.keyboardDidHide(a)
        }
    }, addDelegate: function (a) {
        a && this.impl && (-1 < this.impl._delegateList.indexOf(a) || this.impl._delegateList.splice(0, 0, a))
    }, attachDelegateWithIME: function (a) {
        if (!this.impl || !a || -1 === this.impl._delegateList.indexOf(a))return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() || !a.canAttachWithIME())return !1;
            var b = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            b.didDetachWithIME();
            this._focusDomInput(a);
            return !0
        }
        if (!a.canAttachWithIME())return !1;
        this._focusDomInput(a);
        return !0
    }, _focusDomInput: function (a) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "", a = a.getTipMessage ? a.getTipMessage() : "please enter your word:", a = window.Window && Window.prototype.prompt != prompt ? Window.prototype.prompt.call(window, a, this._currentInputString) :
            prompt(a, this._currentInputString), null != a && this._processDomInputString(a), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
    }, _domInputControlTranslate: function () {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y +
            "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    }, detachDelegateWithIME: function (a) {
        if (!this.impl || !a || this.impl._delegateWithIme !== a || !a.canDetachWithIME())return !1;
        this.impl._delegateWithIme = null;
        a.didDetachWithIME();
        cc._canvas.focus();
        return !0
    }, removeDelegate: function (a) {
        this.impl && a && -1 !== this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a === this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList,
            a))
    }, processKeycode: function (a) {
        32 > a ? a === cc.KEY.backspace ? this.dispatchDeleteBackward() : a === cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
    }
});
cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null, _delegateList: null, ctor: function () {
        this._delegateList = []
    }, findDelegate: function (a) {
        for (var b = 0; b < this._delegateList.length; b++)if (this._delegateList[b] === a)return b;
        return null
    }
});
cc.imeDispatcher = new cc.IMEDispatcher;
document.body ? cc.imeDispatcher.init() : window.addEventListener("load", function () {
    cc.imeDispatcher.init()
}, !1);
cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function (a) {
        return !1
    }, onTextFieldDetachWithIME: function (a) {
        return !1
    }, onTextFieldInsertText: function (a, b, d) {
        return !1
    }, onTextFieldDeleteBackward: function (a, b, d) {
        return !1
    }, onDraw: function (a) {
        return !1
    }
});
cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _colorText: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function (a, b, d, e, f) {
        this.colorSpaceHolder = cc.color(127, 127, 127);
        this._colorText = cc.color(255, 255, 255, 255);
        cc.LabelTTF.prototype.ctor.call(this);
        void 0 !== f ? (this.initWithPlaceHolder("", b, d, e, f), a && this.setPlaceHolder(a)) : void 0 === e && void 0 !== d && (this.initWithString("", b, d), a && this.setPlaceHolder(a))
    },
    onEnter: function () {
        cc.LabelTTF.prototype.onEnter.call(this);
        cc.imeDispatcher.addDelegate(this)
    },
    onExit: function () {
        cc.LabelTTF.prototype.onExit.call(this);
        cc.imeDispatcher.removeDelegate(this)
    },
    getDelegate: function () {
        return this.delegate
    },
    setDelegate: function (a) {
        this.delegate = a
    },
    getCharCount: function () {
        return this._charCount
    },
    getColorSpaceHolder: function () {
        return cc.color(this.colorSpaceHolder)
    },
    setColorSpaceHolder: function (a) {
        this.colorSpaceHolder.r = a.r;
        this.colorSpaceHolder.g = a.g;
        this.colorSpaceHolder.b = a.b;
        this.colorSpaceHolder.a = cc.isUndefined(a.a) ? 255 :
            a.a;
        this._inputText.length || this.setColor(this.colorSpaceHolder)
    },
    setTextColor: function (a) {
        this._colorText.r = a.r;
        this._colorText.g = a.g;
        this._colorText.b = a.b;
        this._colorText.a = cc.isUndefined(a.a) ? 255 : a.a;
        this._inputText.length && this.setColor(this._colorText)
    },
    initWithPlaceHolder: function (a, b, d, e, f) {
        switch (arguments.length) {
            case 5:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, e, f, b, d);
            case 3:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, arguments[1],
                    arguments[2]);
            default:
                throw Error("Argument must be non-nil ");
        }
    },
    setString: function (a) {
        this._inputText = (a = String(a)) || "";
        this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText), this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder));
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._renderCmd._updateTexture();
        this._charCount = this._inputText.length
    },
    getString: function () {
        return this._inputText
    },
    setPlaceHolder: function (a) {
        this._placeHolder =
            a || "";
        this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder))
    },
    getPlaceHolder: function () {
        return this._placeHolder
    },
    draw: function (a) {
        a = a || cc._renderContext;
        this.delegate && this.delegate.onDraw(this) || cc.LabelTTF.prototype.draw.call(this, a)
    },
    visit: function (a) {
        this._super(a)
    },
    attachWithIME: function () {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function () {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function () {
        return this.delegate ?
            !this.delegate.onTextFieldAttachWithIME(this) : !0
    },
    didAttachWithIME: function () {
    },
    canDetachWithIME: function () {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
    },
    didDetachWithIME: function () {
    },
    deleteBackward: function () {
        var a = this._inputText.length;
        0 === a || this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - 1], 1) || (1 >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder)) : this.string =
            this._inputText.substring(0, a - 1))
    },
    removeDelegate: function () {
        cc.imeDispatcher.removeDelegate(this)
    },
    _tipMessage: "please enter your word:",
    setTipMessage: function (a) {
        null != a && (this._tipMessage = a)
    },
    getTipMessage: function () {
        return this._tipMessage
    },
    insertText: function (a, b) {
        var d = a, e = d.indexOf("\n");
        -1 < e && (d = d.substring(0, e));
        if (0 < d.length) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, d, d.length))return;
            d = this._inputText + d;
            this._charCount = d.length;
            this.string = d
        }
        -1 !== e && (this.delegate && this.delegate.onTextFieldInsertText(this,
            "\n", 1) || this.detachWithIME())
    },
    getContentText: function () {
        return this._inputText
    },
    keyboardWillShow: function (a) {
    },
    keyboardDidShow: function (a) {
    },
    keyboardWillHide: function (a) {
    },
    keyboardDidHide: function (a) {
    }
});
_p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function (a, b, d, e, f) {
    return new cc.TextFieldTTF(a, b, d, e, f)
};
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
    _enabled: !1, _target: null, _callback: null, _isSelected: !1, _className: "MenuItem", ctor: function (a, b) {
        var d = cc.Node.prototype;
        d.ctor.call(this);
        this._callback = this._target = null;
        this._enabled = this._isSelected = !1;
        d.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = b || null;
        if (this._callback = a || null)this._enabled = !0
    }, isSelected: function () {
        return this._isSelected
    }, setOpacityModifyRGB: function (a) {
    }, isOpacityModifyRGB: function () {
        return !1
    }, setTarget: function (a, b) {
        this._target = b;
        this._callback =
            a
    }, isEnabled: function () {
        return this._enabled
    }, setEnabled: function (a) {
        this._enabled = a
    }, initWithCallback: function (a, b) {
        this.anchorY = this.anchorX = 0.5;
        this._target = b;
        this._callback = a;
        this._enabled = !0;
        this._isSelected = !1;
        return !0
    }, rect: function () {
        var a = this._position, b = this._contentSize, d = this._anchorPoint;
        return cc.rect(a.x - b.width * d.x, a.y - b.height * d.y, b.width, b.height)
    }, selected: function () {
        this._isSelected = !0
    }, unselected: function () {
        this._isSelected = !1
    }, setCallback: function (a, b) {
        this._target = b;
        this._callback =
            a
    }, activate: function () {
        if (this._enabled) {
            var a = this._target, b = this._callback;
            if (b)if (a && cc.isString(b))a[b](this); else a && cc.isFunction(b) ? b.call(a, this) : b(this)
        }
    }
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function (a, b) {
    return new cc.MenuItem(a, b)
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null, _label: null, _originalScale: 0, _colorBackup: null, ctor: function (a, b, d) {
        cc.MenuItem.prototype.ctor.call(this, b, d);
        this._colorBackup = this._label = this._disabledColor = null;
        a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0))
    }, getDisabledColor: function () {
        return this._disabledColor
    }, setDisabledColor: function (a) {
        this._disabledColor =
            a
    }, getLabel: function () {
        return this._label
    }, setLabel: function (a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height, a.setCascadeColorEnabled(!0));
        this._label && this.removeChild(this._label, !0);
        this._label = a
    }, setEnabled: function (a) {
        this._enabled !== a && (a ? this.setColor(this._colorBackup) : (this._colorBackup = this.color, this.setColor(this._disabledColor)));
        cc.MenuItem.prototype.setEnabled.call(this, a)
    }, initWithLabel: function (a, b, d) {
        this.initWithCallback(b, d);
        this._originalScale =
            1;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(a);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    }, setString: function (a) {
        this._label.string = a;
        this.width = this._label.width;
        this.height = this._label.height
    }, getString: function () {
        return this._label.string
    }, activate: function () {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
    }, selected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale;
            a = cc.scaleTo(0.1, 1.2 * this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    }, unselected: function () {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.scaleTo(0.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    }
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function (a, b, d) {
    return new cc.MenuItemLabel(a, b, d)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function (a, b, d, e, f, g, h) {
        var n;
        a && 0 < a.length && (n = new cc.LabelAtlas(a, b, d, e, f));
        cc.MenuItemLabel.prototype.ctor.call(this, n, g, h)
    }, initWithString: function (a, b, d, e, f, g, h) {
        if (!a || 0 === a.length)throw Error("cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0");
        var n = new cc.LabelAtlas;
        n.initWithString(a, b, d, e, f);
        this.initWithLabel(n, g, h);
        return !0
    }
});
cc.MenuItemAtlasFont.create = function (a, b, d, e, f, g, h) {
    return new cc.MenuItemAtlasFont(a, b, d, e, f, g, h)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null, _fontName: null, ctor: function (a, b, d) {
        var e;
        a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, e = new cc.LabelTTF(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
        cc.MenuItemLabel.prototype.ctor.call(this, e, b, d)
    }, initWithString: function (a, b, d) {
        if (!a || 0 === a.length)throw Error("Value should be non-null and its length should be greater than 0");
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        a = new cc.LabelTTF(a, this._fontName, this._fontSize);
        this.initWithLabel(a, b, d);
        return !0
    }, setFontSize: function (a) {
        this._fontSize = a;
        this._recreateLabel()
    }, getFontSize: function () {
        return this._fontSize
    }, setFontName: function (a) {
        this._fontName = a;
        this._recreateLabel()
    }, getFontName: function () {
        return this._fontName
    }, _recreateLabel: function () {
        var a = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
});
cc.MenuItemFont.setFontSize = function (a) {
    cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function () {
    return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function (a) {
    cc._globalFontNameRelease && (cc._globalFontName = "");
    cc._globalFontName = a;
    cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function () {
    return cc._globalFontName
};
cc.MenuItemFont.create = function (a, b, d) {
    return new cc.MenuItemFont(a, b, d)
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null, _selectedImage: null, _disabledImage: null, ctor: function (a, b, d, e, f) {
        cc.MenuItem.prototype.ctor.call(this);
        this._disabledImage = this._selectedImage = this._normalImage = null;
        if (void 0 !== a) {
            b = b || null;
            var g, h, n;
            void 0 !== f ? (g = d, n = e, h = f) : void 0 !== e && cc.isFunction(e) ? (g = d, n = e) : void 0 !== e && cc.isFunction(d) ? (h = e, n = d, g = null) : void 0 === d && (g = null);
            this.initWithNormalSprite(a, b, g, n, h)
        }
    }, getNormalImage: function () {
        return this._normalImage
    }, setNormalImage: function (a) {
        this._normalImage !==
        a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a) && (this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function (a) {
            this.width = a.width;
            this.height = a.height
        }, this))
    }, getSelectedImage: function () {
        return this._selectedImage
    }, setSelectedImage: function (a) {
        this._selectedImage !== a && (a && (this.addChild(a,
            0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    }, getDisabledImage: function () {
        return this._disabledImage
    }, setDisabledImage: function (a) {
        this._disabledImage !== a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    }, initWithNormalSprite: function (a, b, d, e, f) {
        this.initWithCallback(e,
            f);
        this.setNormalImage(a);
        this.setSelectedImage(b);
        this.setDisabledImage(d);
        if (a = this._normalImage)this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function (a) {
            this.width = a.width;
            this.height = a.height;
            this.setCascadeColorEnabled(!0);
            this.setCascadeOpacityEnabled(!0)
        }, this);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    }, selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        this._normalImage && (this._disabledImage &&
        (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    }, unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    }, setEnabled: function (a) {
        this._enabled !== a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    }, _updateImagesVisibility: function () {
        var a =
            this._normalImage, b = this._selectedImage, d = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), d && (d.visible = !1)) : d ? (a && (a.visible = !1), b && (b.visible = !1), d && (d.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
    }
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function (a, b, d, e, f) {
    return new cc.MenuItemSprite(a, b, d, e, f || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function (a, b, d, e, f) {
        var g = null, h = null, n = null, p = null, r = null;
        void 0 === a || null === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (g = new cc.Sprite(a), b && (h = new cc.Sprite(b)), void 0 === e ? p = d : void 0 === f ? (p = d, r = e) : f && (n = new cc.Sprite(d), p = e, r = f), cc.MenuItemSprite.prototype.ctor.call(this, g, h, n, p, r))
    }, setNormalSpriteFrame: function (a) {
        this.setNormalImage(new cc.Sprite(a))
    }, setSelectedSpriteFrame: function (a) {
        this.setSelectedImage(new cc.Sprite(a))
    }, setDisabledSpriteFrame: function (a) {
        this.setDisabledImage(new cc.Sprite(a))
    },
    initWithNormalImage: function (a, b, d, e, f) {
        var g = null, h = null, n = null;
        a && (g = new cc.Sprite(a));
        b && (h = new cc.Sprite(b));
        d && (n = new cc.Sprite(d));
        return this.initWithNormalSprite(g, h, n, e, f)
    }
});
cc.MenuItemImage.create = function (a, b, d, e, f) {
    return new cc.MenuItemImage(a, b, d, e, f)
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null, _selectedIndex: 0, _opacity: null, _color: null, ctor: function () {
        cc.MenuItem.prototype.ctor.call(this);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
    }, getOpacity: function () {
        return this._opacity
    }, setOpacity: function (a) {
        this._opacity = a;
        if (this.subItems && 0 < this.subItems.length)for (var b = 0; b < this.subItems.length; b++)this.subItems[b].opacity = a;
        this._color.a = a
    }, getColor: function () {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    }, setColor: function (a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if (this.subItems && 0 < this.subItems.length)for (b = 0; b < this.subItems.length; b++)this.subItems[b].setColor(a);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    }, getSelectedIndex: function () {
        return this._selectedIndex
    }, setSelectedIndex: function (a) {
        if (a !== this._selectedIndex) {
            this._selectedIndex = a;
            (a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
            a = this.subItems[this._selectedIndex];
            this.addChild(a, 0, cc.CURRENT_ITEM);
            var b = a.width, d = a.height;
            this.width = b;
            this.height = d;
            a.setPosition(b / 2, d / 2)
        }
    }, getSubItems: function () {
        return this.subItems
    }, setSubItems: function (a) {
        this.subItems = a
    }, initWithItems: function (a) {
        var b = a.length;
        cc.isFunction(a[a.length - 2]) ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : cc.isFunction(a[a.length - 1]) ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
        for (var d = this.subItems, e = d.length =
            0; e < b; e++)a[e] && d.push(a[e]);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    }, addSubItem: function (a) {
        this.subItems.push(a)
    }, activate: function () {
        this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
        cc.MenuItem.prototype.activate.call(this)
    }, selected: function () {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected()
    }, unselected: function () {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected()
    }, setEnabled: function (a) {
        if (this._enabled !== a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var b = this.subItems;
            if (b && 0 < b.length)for (var d = 0; d < b.length; d++)b[d].enabled = a
        }
    }, selectedItem: function () {
        return this.subItems[this._selectedIndex]
    }, getSelectedItem: function () {
        return this.subItems[this._selectedIndex]
    }, onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex)
    }
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function () {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    a.initWithItems(Array.prototype.slice.apply(arguments));
    return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
    enabled: !1, _selectedItem: null, _state: -1, _touchListener: null, _className: "Menu", ctor: function (a) {
        cc.Layer.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = !1;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        0 < arguments.length &&
        null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var b = arguments.length, d;
        if (0 === b)d = []; else if (1 === b)d = a instanceof Array ? a : [a]; else if (1 < b) {
            d = [];
            for (var e = 0; e < b; e++)arguments[e] && d.push(arguments[e])
        }
        this.initWithArray(d)
    }, onEnter: function () {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    }, isEnabled: function () {
        return this.enabled
    }, setEnabled: function (a) {
        this.enabled = a
    }, initWithItems: function (a) {
        var b =
            [];
        if (a)for (var d = 0; d < a.length; d++)a[d] && b.push(a[d]);
        return this.initWithArray(b)
    }, initWithArray: function (a) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var b = cc.winSize;
            this.setPosition(b.width / 2, b.height / 2);
            this.setContentSize(b);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(!0);
            if (a)for (b = 0; b < a.length; b++)this.addChild(a[b], b);
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    }, addChild: function (a, b, d) {
        if (!(a instanceof cc.MenuItem))throw Error("cc.Menu.addChild() : Menu only supports MenuItem objects as children");
        cc.Layer.prototype.addChild.call(this, a, b, d)
    }, alignItemsVertically: function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    }, alignItemsVerticallyWithPadding: function (a) {
        var b = -a, d = this._children, e, f, g, h;
        if (d && 0 < d.length) {
            f = 0;
            for (e = d.length; f < e; f++)b += d[f].height * d[f].scaleY + a;
            var n = b / 2;
            f = 0;
            for (e = d.length; f < e; f++)h = d[f], g = h.height, b = h.scaleY, h.setPosition(0, n - g * b / 2), n -= g * b + a
        }
    }, alignItemsHorizontally: function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function (a) {
        var b = -a, d = this._children, e, f, g, h;
        if (d && 0 < d.length) {
            e = 0;
            for (f = d.length; e < f; e++)b += d[e].width * d[e].scaleX + a;
            var n = -b / 2;
            e = 0;
            for (f = d.length; e < f; e++)h = d[e], b = h.scaleX, g = d[e].width, h.setPosition(n + g * b / 2, 0), n += g * b + a
        }
    }, alignItemsInColumns: function () {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], b = 0; b < arguments.length; b++)a.push(arguments[b]);
        var d = -5, e = 0, f = 0, g = 0, h, n, p, r =
            this._children;
        if (r && 0 < r.length)for (b = 0, p = r.length; b < p; b++)e >= a.length || !(h = a[e]) || (n = r[b].height, f = f >= n || isNaN(n) ? f : n, ++g, g >= h && (d += f + 5, f = g = 0, ++e));
        var s = cc.director.getWinSize(), t = h = f = e = 0, v = 0, d = d / 2;
        if (r && 0 < r.length)for (b = 0, p = r.length; b < p; b++) {
            var u = r[b];
            0 === h && (h = a[e], v = t = s.width / (1 + h));
            n = u._getHeight();
            f = f >= n || isNaN(n) ? f : n;
            u.setPosition(v - s.width / 2, d - n / 2);
            v += t;
            ++g;
            g >= h && (d -= f + 5, f = h = g = 0, ++e)
        }
    }, alignItemsInRows: function () {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a = [], b;
        for (b = 0; b < arguments.length; b++)a.push(arguments[b]);
        var d = [], e = [], f = -10, g = -5, h = 0, n = 0, p = 0, r, s, t, v, u = this._children;
        if (u && 0 < u.length)for (b = 0, t = u.length; b < t; b++)(s = u[b], h >= a.length || !(r = a[h])) || (v = s.width, n = n >= v || isNaN(v) ? n : v, g += s.height + 5, ++p, p >= r && (d.push(n), e.push(g), f += n + 10, n = p = 0, g = -5, ++h));
        g = cc.director.getWinSize();
        r = n = h = 0;
        var f = -f / 2, x = 0;
        if (u && 0 < u.length)for (b = 0, t = u.length; b < t; b++)s = u[b], 0 === r && (r = a[h], x = e[h]), v = s._getWidth(), n = n >= v || isNaN(v) ? n : v, s.setPosition(f + d[h] / 2, x - g.height / 2),
            x -= s.height + 10, ++p, p >= r && (f += n + 5, n = r = p = 0, ++h)
    }, removeChild: function (a, b) {
        null != a && (a instanceof cc.MenuItem ? (this._selectedItem === a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    }, _onTouchBegan: function (a, b) {
        var d = b.getCurrentTarget();
        if (d._state !== cc.MENU_STATE_WAITING || !d._visible || !d.enabled)return !1;
        for (var e = d.parent; null != e; e = e.parent)if (!e.isVisible())return !1;
        d._selectedItem = d._itemForTouch(a);
        return d._selectedItem ? (d._state = cc.MENU_STATE_TRACKING_TOUCH, d._selectedItem.selected(), d._selectedItem.setNodeDirty(), !0) : !1
    }, _onTouchEnded: function (a, b) {
        var d = b.getCurrentTarget();
        d._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (d._selectedItem && (d._selectedItem.unselected(), d._selectedItem.setNodeDirty(), d._selectedItem.activate()), d._state = cc.MENU_STATE_WAITING)
    }, _onTouchCancelled: function (a, b) {
        var d = b.getCurrentTarget();
        d._state !== cc.MENU_STATE_TRACKING_TOUCH ?
            cc.log("cc.Menu.onTouchCancelled(): invalid state") : (d._selectedItem && (d._selectedItem.unselected(), d._selectedItem.setNodeDirty()), d._state = cc.MENU_STATE_WAITING)
    }, _onTouchMoved: function (a, b) {
        var d = b.getCurrentTarget();
        if (d._state !== cc.MENU_STATE_TRACKING_TOUCH)cc.log("cc.Menu.onTouchMoved(): invalid state"); else {
            var e = d._itemForTouch(a);
            e !== d._selectedItem && (d._selectedItem && (d._selectedItem.unselected(), d._selectedItem.setNodeDirty()), d._selectedItem = e, d._selectedItem && (d._selectedItem.selected(),
                d._selectedItem.setNodeDirty()))
        }
    }, onExit: function () {
        this._state === cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
        cc.Node.prototype.onExit.call(this)
    }, setOpacityModifyRGB: function (a) {
    }, isOpacityModifyRGB: function () {
        return !1
    }, _itemForTouch: function (a) {
        a = a.getLocation();
        var b = this._children, d;
        if (b && 0 < b.length)for (var e = b.length - 1; 0 <= e; e--)if (d = b[e], d.isVisible() && d.isEnabled()) {
            var f = d.convertToNodeSpace(a),
                g = d.rect();
            g.x = 0;
            g.y = 0;
            if (cc.rectContainsPoint(g, f))return d
        }
        return null
    }
});
_p = cc.Menu.prototype;
cc.Menu.create = function (a) {
    var b = arguments.length;
    0 < b && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript");
    return 0 === b ? new cc.Menu : 1 === b ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function (a, b, d, e, f, g, h) {
    this.status = a || 0;
    this.type = b || 0;
    this.pixelDepth = d || 0;
    this.width = e || 0;
    this.height = f || 0;
    this.imageData = g || [];
    this.flipped = h || 0
};
cc.tgaLoadHeader = function (a, b, d) {
    var e = 2;
    if (e + 1 > b)return !1;
    a = new cc.BinaryStreamReader(a);
    a.setOffset(e);
    d.type = a.readByte();
    e += 10;
    if (e + 4 + 1 > b)return !1;
    a.setOffset(e);
    d.width = a.readUnsignedShort();
    d.height = a.readUnsignedInteger();
    d.pixelDepth = a.readByte();
    if (e + 5 + 1 > b)return !1;
    b = a.readByte();
    d.flipped = 0;
    b & 32 && (d.flipped = 1);
    return !0
};
cc.tgaLoadImageData = function (a, b, d) {
    var e, f;
    e = 0 | d.pixelDepth / 2;
    f = d.height * d.width * e;
    if (18 + f > b)return !1;
    d.imageData = cc.__getSubArray(a, 18, 18 + f);
    if (3 <= e)for (a = 0; a < f; a += e)b = d.imageData[a], d.imageData[a] = d.imageData[a + 2], d.imageData[a + 2] = b;
    return !0
};
cc.tgaRGBtogreyscale = function (a) {
    var b, d;
    if (8 !== a.pixelDepth) {
        var e = a.pixelDepth / 8, f = new Uint8Array(a.height * a.width);
        if (null !== f) {
            for (d = b = 0; d < a.width * a.height; b += e, d++)f[d] = 0.3 * a.imageData[b] + 0.59 * a.imageData[b + 1] + 0.11 * a.imageData[b + 2];
            a.pixelDepth = 8;
            a.type = 3;
            a.imageData = f
        }
    }
};
cc.tgaDestroy = function (a) {
    a && (a.imageData = null)
};
cc.tgaLoadRLEImageData = function (a, b, d) {
    var e, f, g, h = 0, n = 0, p = 0, r = [], s = 0, t = 18;
    e = d.pixelDepth / 8;
    f = d.height * d.width;
    for (g = 0; g < f; g++) {
        if (0 !== s)s--, n = 0 !== p; else {
            if (t + 1 > b)break;
            s = a[t];
            t += 1;
            (p = s & 128) && (s -= 128);
            n = 0
        }
        if (!n) {
            if (t + e > b)break;
            r = cc.__getSubArray(a, t, t + e);
            t += e;
            3 <= e && (n = r[0], r[0] = r[2], r[2] = n)
        }
        for (n = 0; n < e; n++)d.imageData[h + n] = r[n];
        h += e
    }
    return !0
};
cc.tgaFlipImage = function (a) {
    for (var b = a.pixelDepth / 8 * a.width, d = 0; d < a.height / 2; d++) {
        var e = cc.__getSubArray(a.imageData, d * b, d * b + b);
        cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (d + 1)) * b, b), a.imageData, d * b);
        cc.__setDataToArray(e, a.imageData, (a.height - (d + 1)) * b)
    }
    a.flipped = 0
};
cc.__getSubArray = function (a, b, d) {
    return a instanceof Array ? a.slice(b, d) : a.subarray(b, d)
};
cc.__setDataToArray = function (a, b, d) {
    for (var e = 0; e < a.length; e++)b[d + e] = a[e]
};
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null, _offset: 0, ctor: function (a) {
        this._binaryData = a
    }, setBinaryData: function (a) {
        this._binaryData = a;
        this._offset = 0
    }, getBinaryData: function () {
        return this._binaryData
    }, _checkSize: function (a) {
        if (!(this._offset + Math.ceil(a / 8) < this._data.length))throw Error("Index out of bound");
    }, _decodeFloat: function (a, b) {
        var d = a + b + 1, e = d >> 3;
        this._checkSize(d);
        var d = Math.pow(2, b - 1) - 1, f = this._readBits(a + b, 1, e), g = this._readBits(a, b, e), h = 0, n = 2, p = 0;
        do for (var r = this._readByte(++p,
            e), s = a % 8 || 8, t = 1 << s; t >>= 1;)r & t && (h += 1 / n), n *= 2; while (a -= s);
        this._offset += e;
        return g === (d << 1) + 1 ? h ? NaN : f ? -Infinity : Infinity : (1 + -2 * f) * (g || h ? g ? Math.pow(2, g - d) * (1 + h) : Math.pow(2, -d + 1) * h : 0)
    }, _readByte: function (a, b) {
        return this._data[this._offset + b - a - 1]
    }, _decodeInt: function (a, b) {
        var d = this._readBits(0, a, a / 8), e = Math.pow(2, a);
        this._offset += a / 8;
        return b && d >= e / 2 ? d - e : d
    }, _shl: function (a, b) {
        for (++b; --b; a = 1073741824 === ((a %= 2147483648) & 1073741824) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    }, _readBits: function (a, b, d) {
        var e =
            (a + b) % 8, f = a % 8, g = d - (a >> 3) - 1;
        a = d + (-(a + b) >> 3);
        var h = g - a;
        b = this._readByte(g, d) >> f & (1 << (h ? 8 - f : b)) - 1;
        for (h && e && (b += (this._readByte(a++, d) & (1 << e) - 1) << (h-- << 3) - f); h;)b += this._shl(this._readByte(a++, d), (h-- << 3) - f);
        return b
    }, readInteger: function () {
        return this._decodeInt(32, !0)
    }, readUnsignedInteger: function () {
        return this._decodeInt(32, !1)
    }, readSingle: function () {
        return this._decodeFloat(23, 8)
    }, readShort: function () {
        return this._decodeInt(16, !0)
    }, readUnsignedShort: function () {
        return this._decodeInt(16, !1)
    }, readByte: function () {
        var a =
            this._data[this._offset];
        this._offset += 1;
        return a
    }, readData: function (a, b) {
        return this._binaryData instanceof Array ? this._binaryData.slice(a, b) : this._binaryData.subarray(a, b)
    }, setOffset: function (a) {
        this._offset = a
    }, getOffset: function () {
        return this._offset
    }
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function (a, b) {
        cc.Node.prototype.ctor.call(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getMapSize: function () {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function (a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function () {
        return this._mapSize.width
    },
    _setMapWidth: function (a) {
        this._mapSize.width = a
    },
    _getMapHeight: function () {
        return this._mapSize.height
    },
    _setMapHeight: function (a) {
        this._mapSize.height = a
    },
    getTileSize: function () {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function (a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function () {
        return this._tileSize.width
    },
    _setTileWidth: function (a) {
        this._tileSize.width = a
    },
    _getTileHeight: function () {
        return this._tileSize.height
    },
    _setTileHeight: function (a) {
        this._tileSize.height =
            a
    },
    getMapOrientation: function () {
        return this.mapOrientation
    },
    setMapOrientation: function (a) {
        this.mapOrientation = a
    },
    getObjectGroups: function () {
        return this.objectGroups
    },
    setObjectGroups: function (a) {
        this.objectGroups = a
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties = a
    },
    initWithTMXFile: function (a) {
        if (!a || 0 === a.length)throw Error("cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.");
        this.height = this.width = 0;
        a = new cc.TMXMapInfo(a);
        if (!a)return !1;
        var b = a.getTilesets();
        b && 0 !== b.length || cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
        this._buildWithMapInfo(a);
        return !0
    },
    initWithXML: function (a, b) {
        this.height = this.width = 0;
        var d = new cc.TMXMapInfo(a, b), e = d.getTilesets();
        e && 0 !== e.length || cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
        this._buildWithMapInfo(d);
        return !0
    },
    _buildWithMapInfo: function (a) {
        this._mapSize = a.getMapSize();
        this._tileSize = a.getTileSize();
        this.mapOrientation =
            a.orientation;
        this.objectGroups = a.getObjectGroups();
        this.properties = a.properties;
        this._tileProperties = a.getTileProperties();
        var b = 0, d = a.getLayers();
        if (d)for (var e = null, f = 0, g = d.length; f < g; f++)(e = d[f]) && e.visible && (e = this._parseLayer(e, a), this.addChild(e, b, b), this.width = Math.max(this.width, e.width), this.height = Math.max(this.height, e.height), b++)
    },
    allLayers: function () {
        for (var a = [], b = this._children, d = 0, e = b.length; d < e; d++) {
            var f = b[d];
            f && f instanceof cc.TMXLayer && a.push(f)
        }
        return a
    },
    getLayer: function (a) {
        if (!a ||
            0 === a.length)throw Error("cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.");
        for (var b = this._children, d = 0; d < b.length; d++) {
            var e = b[d];
            if (e && e.layerName === a)return e
        }
        return null
    },
    getObjectGroup: function (a) {
        if (!a || 0 === a.length)throw Error("cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.");
        if (this.objectGroups)for (var b = 0; b < this.objectGroups.length; b++) {
            var d = this.objectGroups[b];
            if (d && d.groupName === a)return d
        }
        return null
    },
    getProperty: function (a) {
        return this.properties[a.toString()]
    },
    propertiesForGID: function (a) {
        cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead.");
        return this.getPropertiesForGID[a]
    },
    getPropertiesForGID: function (a) {
        return this._tileProperties[a]
    },
    _parseLayer: function (a, b) {
        var d = this._tilesetForLayer(a, b), d = new cc.TMXLayer(d, a, b);
        a.ownTiles = !1;
        d.setupTiles();
        return d
    },
    _tilesetForLayer: function (a, b) {
        var d = a._layerSize, e = b.getTilesets();
        if (e)for (var f = e.length - 1; 0 <= f; f--) {
            var g = e[f];
            if (g)for (var h = 0; h < d.height; h++)for (var n = 0; n < d.width; n++) {
                var p =
                    a._tiles[n + d.width * h];
                if (0 !== p && (p & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= g.firstGid)return g
            }
        }
        cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles");
        return null
    }
});
_p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function (a, b) {
    return new cc.TMXTiledMap(a, b)
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1E5,
    _maxGID: 0,
    offset: null,
    ctor: function () {
        this.properties = [];
        this.name = "";
        this._layerSize = null;
        this._tiles = [];
        this.visible = !0;
        this._opacity = 0;
        this.ownTiles = !0;
        this._minGID = 1E5;
        this._maxGID = 0;
        this.offset = cc.p(0, 0)
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties = a
    }
});
cc.TMXTilesetInfo = cc.Class.extend({
    name: "", firstGid: 0, _tileSize: null, spacing: 0, margin: 0, sourceImage: "", imageSize: null, ctor: function () {
        this._tileSize = cc.size(0, 0);
        this.imageSize = cc.size(0, 0)
    }, rectForGID: function (a) {
        var b = cc.rect(0, 0, 0, 0);
        b.width = this._tileSize.width;
        b.height = this._tileSize.height;
        a &= cc.TMX_TILE_FLIPPED_MASK;
        a -= parseInt(this.firstGid, 10);
        var d = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        b.x = parseInt(a % d * (this._tileSize.width + this.spacing) +
            this.margin, 10);
        b.y = parseInt(parseInt(a / d, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
        return b
    }
});
cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function (a, b) {
        cc.SAXParser.prototype.ctor.apply(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        this._layers = [];
        this._tilesets = [];
        this._objectGroups = [];
        this.properties = [];
        this._tileProperties =
        {};
        this._currentFirstGID = 0;
        void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getOrientation: function () {
        return this.orientation
    },
    setOrientation: function (a) {
        this.orientation = a
    },
    getMapSize: function () {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function (a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function () {
        return this._mapSize.width
    },
    _setMapWidth: function (a) {
        this._mapSize.width = a
    },
    _getMapHeight: function () {
        return this._mapSize.height
    },
    _setMapHeight: function (a) {
        this._mapSize.height = a
    },
    getTileSize: function () {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function (a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function () {
        return this._tileSize.width
    },
    _setTileWidth: function (a) {
        this._tileSize.width = a
    },
    _getTileHeight: function () {
        return this._tileSize.height
    },
    _setTileHeight: function (a) {
        this._tileSize.height = a
    },
    getLayers: function () {
        return this._layers
    },
    setLayers: function (a) {
        this._layers.push(a)
    },
    getTilesets: function () {
        return this._tilesets
    },
    setTilesets: function (a) {
        this._tilesets.push(a)
    },
    getObjectGroups: function () {
        return this._objectGroups
    },
    setObjectGroups: function (a) {
        this._objectGroups.push(a)
    },
    getParentElement: function () {
        return this.parentElement
    },
    setParentElement: function (a) {
        this.parentElement = a
    },
    getParentGID: function () {
        return this.parentGID
    },
    setParentGID: function (a) {
        this.parentGID = a
    },
    getLayerAttribs: function () {
        return this.layerAttrs
    },
    setLayerAttribs: function (a) {
        this.layerAttrs = a
    },
    getStoringCharacters: function () {
        return this.storingCharacters
    },
    setStoringCharacters: function (a) {
        this.storingCharacters = a
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties = a
    },
    initWithTMXFile: function (a) {
        this._internalInit(a, null);
        return this.parseXMLFile(a)
    },
    initWithXML: function (a, b) {
        this._internalInit(null, b);
        return this.parseXMLString(a)
    },
    parseXMLFile: function (a, b) {
        var d = (b = b || !1) ? a : cc.loader.getRes(a);
        if (!d)throw Error("Please load the resource first : " + a);
        var e, f, d = this._parseXML(d).documentElement;
        e = d.getAttribute("version");
        f = d.getAttribute("orientation");
        if ("map" === d.nodeName && ("1.0" !== e && null !== e && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + e), "orthogonal" === f ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" === f ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" === f ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== f && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + f), e = cc.size(0, 0), e.width = parseFloat(d.getAttribute("width")), e.height = parseFloat(d.getAttribute("height")), this.setMapSize(e), e = cc.size(0,
                0), e.width = parseFloat(d.getAttribute("tilewidth")), e.height = parseFloat(d.getAttribute("tileheight")), this.setTileSize(e), f = d.querySelectorAll("map \x3e properties \x3e  property"))) {
            var g = {};
            for (e = 0; e < f.length; e++)g[f[e].getAttribute("name")] = f[e].getAttribute("value");
            this.properties = g
        }
        g = d.getElementsByTagName("tileset");
        "map" !== d.nodeName && (g = [], g.push(d));
        for (e = 0; e < g.length; e++) {
            f = g[e];
            var h = f.getAttribute("source");
            if (h)f = b ? cc.path.join(this._resources, h) : cc.path.changeBasename(a, h), this.parseXMLFile(f);
            else {
                h = new cc.TMXTilesetInfo;
                h.name = f.getAttribute("name") || "";
                h.firstGid = parseInt(f.getAttribute("firstgid")) || 0;
                h.spacing = parseInt(f.getAttribute("spacing")) || 0;
                h.margin = parseInt(f.getAttribute("margin")) || 0;
                var n = cc.size(0, 0);
                n.width = parseFloat(f.getAttribute("tilewidth"));
                n.height = parseFloat(f.getAttribute("tileheight"));
                h._tileSize = n;
                var n = f.getElementsByTagName("image")[0].getAttribute("source"), p = -1;
                this.tmxFileName && (p = this.tmxFileName.lastIndexOf("/"));
                -1 !== p ? (p = this.tmxFileName.substr(0,
                    p + 1), h.sourceImage = p + n) : h.sourceImage = this._resources + (this._resources ? "/" : "") + n;
                this.setTilesets(h);
                if (n = f.getElementsByTagName("tile"))for (p = 0; p < n.length; p++) {
                    f = n[p];
                    this.parentGID = parseInt(h.firstGid) + parseInt(f.getAttribute("id") || 0);
                    var r = f.querySelectorAll("properties \x3e property");
                    if (r) {
                        var s = {};
                        for (f = 0; f < r.length; f++) {
                            var t = r[f].getAttribute("name");
                            s[t] = r[f].getAttribute("value")
                        }
                        this._tileProperties[this.parentGID] = s
                    }
                }
            }
        }
        if (g = d.getElementsByTagName("layer"))for (e = 0; e < g.length; e++) {
            n = g[e];
            p = n.getElementsByTagName("data")[0];
            h = new cc.TMXLayerInfo;
            h.name = n.getAttribute("name");
            f = cc.size(0, 0);
            f.width = parseFloat(n.getAttribute("width"));
            f.height = parseFloat(n.getAttribute("height"));
            h._layerSize = f;
            f = n.getAttribute("visible");
            h.visible = "0" != f;
            f = n.getAttribute("opacity") || 1;
            h._opacity = f ? parseInt(255 * parseFloat(f)) : 255;
            h.offset = cc.p(parseFloat(n.getAttribute("x")) || 0, parseFloat(n.getAttribute("y")) || 0);
            r = "";
            for (f = 0; f < p.childNodes.length; f++)r += p.childNodes[f].nodeValue;
            r = r.trim();
            f = p.getAttribute("compression");
            s = p.getAttribute("encoding");
            if (f && "gzip" !== f && "zlib" !== f)return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
            switch (f) {
                case "gzip":
                    h._tiles = cc.unzipBase64AsArray(r, 4);
                    break;
                case "zlib":
                    f = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(r, 1));
                    h._tiles = cc.uint8ArrayToUint32Array(f.decompress());
                    break;
                case null:
                case "":
                    if ("base64" === s)h._tiles = cc.Codec.Base64.decodeAsArray(r, 4); else if ("csv" === s)for (h._tiles = [], f = r.split(","), p = 0; p < f.length; p++)h._tiles.push(parseInt(f[p]));
                    else for (f = p.getElementsByTagName("tile"), h._tiles = [], p = 0; p < f.length; p++)h._tiles.push(parseInt(f[p].getAttribute("gid")));
                    break;
                default:
                    this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
            }
            if (n = n.querySelectorAll("properties \x3e property")) {
                p = {};
                for (f = 0; f < n.length; f++)p[n[f].getAttribute("name")] = n[f].getAttribute("value");
                h.properties = p
            }
            this.setLayers(h)
        }
        if (g = d.getElementsByTagName("objectgroup"))for (e = 0; e < g.length; e++) {
            n =
                g[e];
            h = new cc.TMXObjectGroup;
            h.groupName = n.getAttribute("name");
            h.setPositionOffset(cc.p(parseFloat(n.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(n.getAttribute("y")) * this.getTileSize().height || 0));
            if (p = n.querySelectorAll("objectgroup \x3e properties \x3e property"))for (f = 0; f < p.length; f++)r = {}, r[p[f].getAttribute("name")] = p[f].getAttribute("value"), h.properties = r;
            n = n.querySelectorAll("object");
            p = cc.director.getContentScaleFactor();
            if (n)for (f = 0; f < n.length; f++) {
                s = n[f];
                r = {};
                r.name = s.getAttribute("name") ||
                    "";
                r.type = s.getAttribute("type") || "";
                r.width = parseInt(s.getAttribute("width")) || 0;
                r.height = parseInt(s.getAttribute("height")) || 0;
                r.x = (((s.getAttribute("x") || 0) | 0) + h.getPositionOffset().x) / p;
                t = ((s.getAttribute("y") || 0) | 0) + h.getPositionOffset().y / p;
                r.y = (parseInt(this.getMapSize().height * this.getTileSize().height) - t - r.height) / cc.director.getContentScaleFactor();
                r.rotation = parseInt(s.getAttribute("rotation")) || 0;
                if (t = s.querySelectorAll("properties \x3e property"))for (var v = 0; v < t.length; v++)r[t[v].getAttribute("name")] =
                    t[v].getAttribute("value");
                (t = s.querySelectorAll("polygon")) && 0 < t.length && (t = t[0].getAttribute("points")) && (r.points = this._parsePointsString(t));
                (s = s.querySelectorAll("polyline")) && 0 < s.length && (s = s[0].getAttribute("points")) && (r.polylinePoints = this._parsePointsString(s));
                h.setObjects(r)
            }
            this.setObjectGroups(h)
        }
        return d
    },
    _parsePointsString: function (a) {
        if (!a)return null;
        var b = [];
        a = a.split(" ");
        for (var d = 0; d < a.length; d++) {
            var e = a[d].split(",");
            b.push({x: e[0], y: e[1]})
        }
        return b
    },
    parseXMLString: function (a) {
        return this.parseXMLFile(a,
            !0)
    },
    getTileProperties: function () {
        return this._tileProperties
    },
    setTileProperties: function (a) {
        this._tileProperties.push(a)
    },
    getCurrentString: function () {
        return this.currentString
    },
    setCurrentString: function (a) {
        this.currentString = a
    },
    getTMXFileName: function () {
        return this.tmxFileName
    },
    setTMXFileName: function (a) {
        this.tmxFileName = a
    },
    _internalInit: function (a, b) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this.tmxFileName = a;
        b && (this._resources = b);
        this._objectGroups.length = 0;
        this.properties.length = 0;
        this._tileProperties.length =
            0;
        this.currentString = "";
        this.storingCharacters = !1;
        this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
        this.parentElement = cc.TMX_PROPERTY_NONE;
        this._currentFirstGID = 0
    }
});
_p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function (a, b) {
    return new cc.TMXMapInfo(a, b)
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1;
cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
cc.TMXLayerInfo.ATTRIB_GZIP = 4;
cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
cc.TMXObjectGroup = cc.Class.extend({
    properties: null, groupName: "", _positionOffset: null, _objects: null, ctor: function () {
        this.groupName = "";
        this._positionOffset = cc.p(0, 0);
        this.properties = [];
        this._objects = []
    }, getPositionOffset: function () {
        return cc.p(this._positionOffset)
    }, setPositionOffset: function (a) {
        this._positionOffset.x = a.x;
        this._positionOffset.y = a.y
    }, getProperties: function () {
        return this.properties
    }, setProperties: function (a) {
        this.properties.push(a)
    }, getGroupName: function () {
        return this.groupName.toString()
    },
    setGroupName: function (a) {
        this.groupName = a
    }, propertyNamed: function (a) {
        return this.properties[a]
    }, objectNamed: function (a) {
        return this.getObject(a)
    }, getObject: function (a) {
        if (this._objects && 0 < this._objects.length)for (var b = this._objects, d = 0, e = b.length; d < e; d++) {
            var f = b[d].name;
            if (f && f === a)return b[d]
        }
        return null
    }, getObjects: function () {
        return this._objects
    }, setObjects: function (a) {
        this._objects.push(a)
    }
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _className: "TMXLayer",
    ctor: function (a, b, d) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._descendants = [];
        this._layerSize = cc.size(0, 0);
        this._mapTileSize = cc.size(0, 0);
        void 0 !== d && this.initWithTilesetInfo(a,
            b, d)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.TMXLayer.CanvasRenderCmd(this) : new cc.TMXLayer.WebGLRenderCmd(this)
    },
    setContentSize: function (a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b);
        this._renderCmd._updateCacheContext(a, b)
    },
    getTexture: function () {
        return this._renderCmd.getTexture()
    },
    getLayerSize: function () {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function (a) {
        this._layerSize.width = a.width;
        this._layerSize.height =
            a.height
    },
    _getLayerWidth: function () {
        return this._layerSize.width
    },
    _setLayerWidth: function (a) {
        this._layerSize.width = a
    },
    _getLayerHeight: function () {
        return this._layerSize.height
    },
    _setLayerHeight: function (a) {
        this._layerSize.height = a
    },
    getMapTileSize: function () {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function (a) {
        this._mapTileSize.width = a.width;
        this._mapTileSize.height = a.height
    },
    _getTileWidth: function () {
        return this._mapTileSize.width
    },
    _setTileWidth: function (a) {
        this._mapTileSize.width =
            a
    },
    _getTileHeight: function () {
        return this._mapTileSize.height
    },
    _setTileHeight: function (a) {
        this._mapTileSize.height = a
    },
    getTiles: function () {
        return this.tiles
    },
    setTiles: function (a) {
        this.tiles = a
    },
    getTileset: function () {
        return this.tileset
    },
    setTileset: function (a) {
        this.tileset = a
    },
    getLayerOrientation: function () {
        return this.layerOrientation
    },
    setLayerOrientation: function (a) {
        this.layerOrientation = a
    },
    getProperties: function () {
        return this.properties
    },
    setProperties: function (a) {
        this.properties = a
    },
    initWithTilesetInfo: function (a,
                                   b, d) {
        var e = b._layerSize, f = 0.35 * parseInt(e.width * e.height) + 1, g;
        a && (g = cc.textureCache.addImage(a.sourceImage));
        return this.initWithTexture(g, f) ? (this.layerName = b.name, this._layerSize = e, this.tiles = b._tiles, this._minGID = b._minGID, this._maxGID = b._maxGID, this._opacity = b._opacity, this.properties = b.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = d.getTileSize(), this.layerOrientation = d.orientation, a = this._calculateLayerOffset(b.offset), this.setPosition(cc.pointPixelsToPoints(a)),
            this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
    },
    releaseMap: function () {
        this.tiles && (this.tiles = null);
        this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function (a, b) {
        if (!a)throw Error("cc.TMXLayer.getTileAt(): pos should be non-null");
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height ||
            0 > a.x || 0 > a.y)throw Error("cc.TMXLayer.getTileAt(): invalid position");
        if (!this.tiles || !this._atlasIndexArray)return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
        var d = null, e = this.getTileGIDAt(a);
        if (0 === e)return d;
        var f = 0 | a.x + a.y * this._layerSize.width, d = this.getChildByTag(f);
        d || (e = this.tileset.rectForGID(e), e = cc.rectPixelsToPoints(e), d = new cc.Sprite, d.initWithTexture(this.texture, e), d.batchNode = this, d.setPosition(this.getPositionAt(a)), d.vertexZ = this._vertexZForPos(a),
            d.anchorX = 0, d.anchorY = 0, d.opacity = this._opacity, e = this._atlasIndexForExistantZ(f), this.addSpriteWithoutQuad(d, e, f));
        return d
    },
    getTileGIDAt: function (a, b) {
        if (null == a)throw Error("cc.TMXLayer.getTileGIDAt(): pos should be non-null");
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y)throw Error("cc.TMXLayer.getTileGIDAt(): invalid position");
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>>
        0 : (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null)
    },
    getTileFlagsAt: function (a, b) {
        if (!a)throw Error("cc.TMXLayer.getTileFlagsAt(): pos should be non-null");
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y)throw Error("cc.TMXLayer.getTileFlagsAt(): invalid position");
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0 : (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"),
            null)
    },
    setTileGID: function (a, b, d, e) {
        if (!b)throw Error("cc.TMXLayer.setTileGID(): pos should be non-null");
        void 0 !== e ? b = cc.p(b, d) : e = d;
        if (b.x >= this._layerSize.width || b.y >= this._layerSize.height || 0 > b.x || 0 > b.y)throw Error("cc.TMXLayer.setTileGID(): invalid position");
        if (this.tiles && this._atlasIndexArray)if (0 !== a && a < this.tileset.firstGid)cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a); else {
            e = e || 0;
            this._setNodeDirtyForCache();
            d = this.getTileFlagsAt(b);
            var f = this.getTileGIDAt(b);
            if (f !== a || d !== e)if (d = (a |
                    e) >>> 0, 0 === a)this.removeTileAt(b); else if (0 === f)this._insertTileForGID(d, b); else {
                var f = b.x + b.y * this._layerSize.width, g = this.getChildByTag(f);
                g ? (a = this.tileset.rectForGID(a), a = cc.rectPixelsToPoints(a), g.setTextureRect(a, !1), null != e && this._setupTileSprite(g, b, d), this.tiles[f] = d) : this._updateTileForGID(d, b)
            }
        } else cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released")
    },
    removeTileAt: function (a, b) {
        if (!a)throw Error("cc.TMXLayer.removeTileAt(): pos should be non-null");
        void 0 !== b &&
        (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y)throw Error("cc.TMXLayer.removeTileAt(): invalid position");
        if (!this.tiles || !this._atlasIndexArray)cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released"); else if (0 !== this.getTileGIDAt(a)) {
            cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var d = 0 | a.x + a.y * this._layerSize.width, e = this._atlasIndexForExistantZ(d);
            this.tiles[d] = 0;
            this._atlasIndexArray.splice(e, 1);
            if (d =
                    this.getChildByTag(d))cc.SpriteBatchNode.prototype.removeChild.call(this, d, !0); else if (cc._renderType === cc.game.RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(e), this._children)for (var d = this._children, f = 0, g = d.length; f < g; f++) {
                var h = d[f];
                if (h) {
                    var n = h.atlasIndex;
                    n >= e && (h.atlasIndex = n - 1)
                }
            }
        }
    },
    getPositionAt: function (a, b) {
        void 0 !== b && (a = cc.p(a, b));
        var d = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                d = this._positionForOrthoAt(a);
                break;
            case cc.TMX_ORIENTATION_ISO:
                d = this._positionForIsoAt(a);
                break;
            case cc.TMX_ORIENTATION_HEX:
                d = this._positionForHexAt(a)
        }
        return cc.pointPixelsToPoints(d)
    },
    getProperty: function (a) {
        return this.properties[a]
    },
    setupTiles: function () {
        this._renderCmd.initImageSize();
        this._parseInternalProperties();
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var a = this._layerSize.height, b = this._layerSize.width, d = 0; d < a; d++)for (var e = 0; e < b; e++) {
            var f = this.tiles[e + b * d];
            0 !== f && (this._appendTileForGID(f, cc.p(e, d)), this._minGID = Math.min(f, this._minGID),
                this._maxGID = Math.max(f, this._maxGID))
        }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function (a, b, d) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function (a, b) {
        if (a)if (-1 === this._children.indexOf(a))cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer"); else {
            cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var d = a.atlasIndex;
            this.tiles[this._atlasIndexArray[d]] = 0;
            this._atlasIndexArray.splice(d, 1);
            cc.SpriteBatchNode.prototype.removeChild.call(this, a, b);
            cc.renderer.childrenOrderDirty = !0
        }
    },
    getLayerName: function () {
        return this.layerName
    },
    setLayerName: function (a) {
        this.layerName = a
    },
    _positionForIsoAt: function (a) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
    },
    _positionForOrthoAt: function (a) {
        return cc.p(a.x * this._mapTileSize.width,
            (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function (a) {
        return cc.p(a.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height + (1 === a.x % 2 ? -this._mapTileSize.height / 2 : 0))
    },
    _calculateLayerOffset: function (a) {
        var b = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                b = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
                break;
            case cc.TMX_ORIENTATION_ISO:
                b = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height /
                    2 * (-a.x - a.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                0 === a.x && 0 === a.y || cc.log("offset for hexagonal map not implemented yet")
        }
        return b
    },
    _appendTileForGID: function (a, b) {
        var d = this.tileset.rectForGID(a), d = cc.rectPixelsToPoints(d), e = 0 | b.x + b.y * this._layerSize.width, d = this._renderCmd._reusedTileWithRect(d);
        this._setupTileSprite(d, b, a);
        var f = this._atlasIndexArray.length;
        this.insertQuadFromSprite(d, f);
        this._atlasIndexArray.splice(f, 0, e);
        return d
    },
    _insertTileForGID: function (a, b) {
        var d = this.tileset.rectForGID(a),
            d = cc.rectPixelsToPoints(d), e = 0 | b.x + b.y * this._layerSize.width, d = this._renderCmd._reusedTileWithRect(d);
        this._setupTileSprite(d, b, a);
        var f = this._atlasIndexForNewZ(e);
        this.insertQuadFromSprite(d, f);
        this._atlasIndexArray.splice(f, 0, e);
        if (this._children)for (var g = this._children, h = 0, n = g.length; h < n; h++) {
            var p = g[h];
            if (p) {
                var r = p.atlasIndex;
                r >= f && (p.atlasIndex = r + 1)
            }
        }
        this.tiles[e] = a;
        return d
    },
    _updateTileForGID: function (a, b) {
        var d = this.tileset.rectForGID(a), e = this._contentScaleFactor, d = cc.rect(d.x / e, d.y / e, d.width /
            e, d.height / e), e = b.x + b.y * this._layerSize.width, d = this._renderCmd._reusedTileWithRect(d);
        this._setupTileSprite(d, b, a);
        d.atlasIndex = this._atlasIndexForExistantZ(e);
        d.dirty = !0;
        d.updateTransform();
        this.tiles[e] = a;
        return d
    },
    _parseInternalProperties: function () {
        var a = this.getProperty("cc_vertexz");
        if (a)if ("automatic" === a) {
            this._useAutomaticVertexZ = !0;
            var a = this.getProperty("cc_alpha_func"), b = 0;
            a && (b = parseFloat(a));
            cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(cc.UNIFORM_ALPHA_TEST_VALUE_S, b))
        } else this._vertexZvalue = parseInt(a, 10)
    },
    _setupTileSprite: function (a, b, d) {
        var e = b.x + b.y * this._layerSize.width;
        a.setPosition(this.getPositionAt(b));
        cc._renderType === cc.game.RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(b) : a.tag = e;
        a.anchorX = 0;
        a.anchorY = 0;
        a.opacity = this._opacity;
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.rotation = 0);
        a.setFlippedX(!1);
        a.setFlippedY(!1);
        (d & cc.TMX_TILE_DIAGONAL_FLAG) >>>
        0 ? (a.anchorX = 0.5, a.anchorY = 0.5, a.x = this.getPositionAt(b).x + a.width / 2, a.y = this.getPositionAt(b).y + a.height / 2, b = (d & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0, b === cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : b === cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : (a.rotation = b === (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, a.setFlippedX(!0))) : ((d & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (d & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0))
    },
    _vertexZForPos: function (a) {
        var b =
            0, d = 0;
        if (this._useAutomaticVertexZ)switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                d = this._layerSize.width + this._layerSize.height;
                b = -(d - (a.x + a.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                b = -(this._layerSize.height - a.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value")
        } else b = this._vertexZvalue;
        return b
    },
    _atlasIndexForExistantZ: function (a) {
        var b;
        if (this._atlasIndexArray)for (var d = this._atlasIndexArray, e = 0, f = d.length; e < f && (b = d[e],
        b !== a); e++);
        cc.isNumber(b) || cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
        return e
    },
    _atlasIndexForNewZ: function (a) {
        for (var b = this._atlasIndexArray, d = 0, e = b.length; d < e && !(a < b[d]); d++);
        return d
    }
});
_p = cc.TMXLayer.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function (a, b, d) {
    return new cc.TMXLayer(a, b, d)
};
(function () {
    cc.TMXLayer.CanvasRenderCmd = function (a) {
        cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._realWorldTransform = {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0};
        var d = cc._canvas;
        a = document.createElement("canvas");
        a.width = d.width;
        a.height = d.height;
        this._cacheCanvas = a;
        this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
        d = new cc.Texture2D;
        d.initWithElement(a);
        d.handleLoadedTexture();
        this._cacheTexture = d;
        this._cacheDirty = !1
    };
    var a = cc.TMXLayer.CanvasRenderCmd.prototype =
        Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
    a.constructor = cc.TMXLayer.CanvasRenderCmd;
    a._setNodeDirtyForCache = function () {
        this._cacheDirty = !0
    };
    a._renderingChildToCache = function () {
        if (this._cacheDirty) {
            var a = this._cacheContext, d = a.getContext(), e = this._cacheCanvas;
            d.setTransform(1, 0, 0, 1, 0, 0);
            d.clearRect(0, 0, e.width, e.height);
            for (var d = this._node._children, e = 0, f = d.length; e < f; e++)if (d[e]) {
                var g = d[e]._renderCmd;
                g && (g.rendering(a, 1, 1), g._cacheDirty = !1)
            }
            this._cacheDirty = !1
        }
    };
    a.rendering = function (a,
                            d, e) {
        var f = this._displayedOpacity / 255;
        if (!(0 >= f)) {
            var g = this._node;
            this._renderingChildToCache();
            var h = a || cc._renderContext;
            a = h.getContext();
            h.setGlobalAlpha(f);
            (f = this._cacheCanvas) && 0 !== f.width && 0 !== f.height && (h.setTransform(this._realWorldTransform, d, e), h = f.height * e, g.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(f, 0, 0, f.width, f.height, 0, -h + 0.5 * g._mapTileSize.height * e, f.width * d, h) : a.drawImage(f, 0, 0, f.width, f.height, 0, -h, f.width * d, h));
            cc.g_NumberOfDraws++
        }
    };
    a._updateCacheContext = function (a,
                                      d) {
        var e = this._node, f = e._contentSize, g = this._cacheCanvas, h = cc.contentScaleFactor();
        g.width = 0 | 1.5 * f.width * h;
        g.height = 0 | 1.5 * f.height * h;
        e.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.setOffset(0, 0.5 * -e._mapTileSize.height) : this._cacheContext.setOffset(0, 0);
        e = this._cacheTexture._contentSize;
        e.width = g.width;
        e.height = g.height
    };
    a.getTexture = function () {
        return this._cacheTexture
    };
    a.visit = function (a) {
        var d = this._node, e, f = d._children;
        if (d._visible && f && 0 !== f.length) {
            if (a = a || this.getParentRenderCmd())this._curLevel =
                a._curLevel + 1;
            this._syncStatus(a);
            if (this._cacheDirty) {
                a = this._cacheContext;
                var g = this._cacheCanvas, h = a.getContext(), n = d.__instanceId, p = cc.renderer;
                p._turnToCacheMode(n);
                d.sortAllChildren();
                d = 0;
                for (e = f.length; d < e; d++)if (f[d]) {
                    var r = f[d]._renderCmd;
                    r && (r.visit(this), r._cacheDirty = !1)
                }
                h.setTransform(1, 0, 0, 1, 0, 0);
                h.clearRect(0, 0, g.width, g.height);
                p._renderingToCacheCanvas(a, n);
                this._cacheDirty = !1
            }
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0
        }
    };
    a.transform = function (a, d) {
        var e = this.getNodeToParentTransform(),
            f = this._realWorldTransform;
        if (a) {
            var g = a._worldTransform;
            f.a = e.a * g.a + e.b * g.c;
            f.b = e.a * g.b + e.b * g.d;
            f.c = e.c * g.a + e.d * g.c;
            f.d = e.c * g.b + e.d * g.d;
            f.tx = g.a * e.tx + g.c * e.ty + g.tx;
            f.ty = g.d * e.ty + g.ty + g.b * e.tx
        } else f.a = e.a, f.b = e.b, f.c = e.c, f.d = e.d, f.tx = e.tx, f.ty = e.ty;
        if (d && (e = this._node._children) && 0 !== e.length)for (f = 0, g = e.length; f < g; f++)e[f]._renderCmd.transform(this, d)
    };
    a.initImageSize = function () {
        this._node.tileset.imageSize = this._texture.getContentSizeInPixels()
    };
    a._reusedTileWithRect = function (a) {
        var d = this._node;
        d._reusedTile = new cc.Sprite;
        d._reusedTile.initWithTexture(this._texture, a, !1);
        d._reusedTile.batchNode = d;
        d._reusedTile.parent = d;
        d._reusedTile._renderCmd._cachedParent = d._renderCmd;
        return d._reusedTile
    }
})();
(function () {
    cc.TMXLayer.WebGLRenderCmd = function (a) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    a.constructor = cc.TMXLayer.WebGLRenderCmd;
    a._updateCacheContext = function () {
    };
    a.initImageSize = function () {
        this._node.tileset.imageSize = this._textureAtlas.texture.getContentSizeInPixels();
        this._textureAtlas.texture.setAliasTexParameters()
    };
    a._reusedTileWithRect = function (a) {
        var d = this._node;
        d._reusedTile ? (d._reusedTile.batchNode = null, d._reusedTile.setTextureRect(a, !1)) : (d._reusedTile = new cc.Sprite, d._reusedTile.initWithTexture(d.texture, a, !1));
        d._reusedTile.batchNode = d;
        return d._reusedTile
    }
})();
cc.PointObject = cc.Class.extend({
    _ratio: null, _offset: null, _child: null, ctor: function (a, b) {
        this.initWithCCPoint(a, b)
    }, getRatio: function () {
        return this._ratio
    }, setRatio: function (a) {
        this._ratio = a
    }, getOffset: function () {
        return this._offset
    }, setOffset: function (a) {
        this._offset = a
    }, getChild: function () {
        return this._child
    }, setChild: function (a) {
        this._child = a
    }, initWithCCPoint: function (a, b) {
        this._ratio = a;
        this._offset = b;
        this._child = null;
        return !0
    }
});
cc.PointObject.create = function (a, b) {
    return new cc.PointObject(a, b)
};
cc.ParallaxNode = cc.Node.extend({
    parallaxArray: null, _lastPosition: null, _className: "ParallaxNode", getParallaxArray: function () {
        return this.parallaxArray
    }, setParallaxArray: function (a) {
        this.parallaxArray = a
    }, ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this.parallaxArray = [];
        this._lastPosition = cc.p(-100, -100)
    }, addChild: function (a, b, d, e) {
        if (3 === arguments.length)cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead"); else {
            if (!a)throw Error("cc.ParallaxNode.addChild(): child should be non-null");
            var f = new cc.PointObject(d, e);
            f.setChild(a);
            this.parallaxArray.push(f);
            a.setPosition(this._position.x * d.x + e.x, this._position.y * d.y + e.y);
            cc.Node.prototype.addChild.call(this, a, b, a.tag)
        }
    }, removeChild: function (a, b) {
        for (var d = this.parallaxArray, e = 0; e < d.length; e++)if (d[e].getChild() === a) {
            d.splice(e, 1);
            break
        }
        cc.Node.prototype.removeChild.call(this, a, b)
    }, removeAllChildren: function (a) {
        this.parallaxArray.length = 0;
        cc.Node.prototype.removeAllChildren.call(this, a)
    }, _updateParallaxPosition: function () {
        var a = this._absolutePosition();
        if (!cc.pointEqualToPoint(a, this._lastPosition)) {
            for (var b = this.parallaxArray, d = 0, e = b.length; d < e; d++) {
                var f = b[d];
                f.getChild().setPosition(-a.x + a.x * f.getRatio().x + f.getOffset().x, -a.y + a.y * f.getRatio().y + f.getOffset().y)
            }
            this._lastPosition = a
        }
    }, _absolutePosition: function () {
        for (var a = this._position, b = this; null !== b.parent;)b = b.parent, a = cc.pAdd(a, b.getPosition());
        return a
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParallaxNode.CanvasRenderCmd(this) : new cc.ParallaxNode.WebGLRenderCmd(this)
    }
});
cc.ParallaxNode.create = function () {
    return new cc.ParallaxNode
};
(function () {
    cc.ParallaxNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ParallaxNode.CanvasRenderCmd;
    a.updateStatus = function () {
        this._node._updateParallaxPosition();
        cc.Node.CanvasRenderCmd.prototype.updateStatus.call(this)
    };
    a._syncStatus = function (a) {
        this._node._updateParallaxPosition();
        cc.Node.CanvasRenderCmd.prototype._syncStatus.call(this, a)
    }
})();
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.ParallaxNode.WebGLRenderCmd = function (a) {
            cc.Node.WebGLRenderCmd.call(this, a);
            this._needDraw = !1
        };
        var a = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        a.constructor = cc.ParallaxNode.WebGLRenderCmd;
        a.updateStatus = function () {
            this._node._updateParallaxPosition();
            cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this)
        };
        a._syncStatus = function (a) {
            this._node._updateParallaxPosition();
            cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, a)
        }
    }
});
(function () {
    var a = cc.sys, b = {
        ONLY_ONE: !1,
        WEB_AUDIO: !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext),
        DELAY_CREATE_CTX: !1,
        ONE_SOURCE: !1
    };
    a.browserType === a.BROWSER_TYPE_FIREFOX && (b.DELAY_CREATE_CTX = !0, b.USE_LOADER_EVENT = "canplay");
    a.os === a.OS_ANDROID && a.browserType === a.BROWSER_TYPE_UC && (b.ONE_SOURCE = !0);
    window.__audioSupport = b
})();
cc.Audio = cc.Class.extend({
    src: null, _element: null, _AUDIO_TYPE: "AUDIO", ctor: function (a) {
        this.src = a
    }, setBuffer: function (a) {
        this._AUDIO_TYPE = "WEBAUDIO";
        this._element = new cc.Audio.WebAudio(a)
    }, setElement: function (a) {
        this._AUDIO_TYPE = "AUDIO";
        this._element = a;
        a.addEventListener("ended", function () {
            a.loop || (a.paused = !0)
        })
    }, play: function (a, b) {
        this._element && (this._element.loop = b, this._element.play(), "AUDIO" === this._AUDIO_TYPE && this._element.paused && (this.stop(), cc.Audio.touchPlayList.push({
            loop: b,
            offset: a,
            audio: this._element
        })),
        !1 === cc.Audio.bindTouch && (cc.Audio.bindTouch = !0, cc.game.canvas.addEventListener("touchstart", cc.Audio.touchStart)))
    }, getPlaying: function () {
        return this._element ? !this._element.paused : !0
    }, stop: function () {
        if (this._element) {
            this._element.pause();
            try {
                this._element.currentTime = 0
            } catch (a) {
            }
        }
    }, pause: function () {
        this._element && this._element.pause()
    }, resume: function () {
        this._element && this._element.play()
    }, setVolume: function (a) {
        this._element && (this._element.volume = a)
    }, getVolume: function () {
        if (this._element)return this._element.volume
    },
    cloneNode: function () {
        var a = new cc.Audio(this.src);
        if ("AUDIO" === this._AUDIO_TYPE) {
            for (var b = document.createElement("audio"), d = b.getElementsByTagName("source"), e = 0; e < d.length; e++)b.appendChild(d[e]);
            b.src = this.src;
            a.setElement(b)
        } else a.setBuffer(this._element.buffer);
        return a
    }
});
cc.Audio.touchPlayList = [];
cc.Audio.bindTouch = !1;
cc.Audio.touchStart = function () {
    for (var a = cc.Audio.touchPlayList, b = null; b = a.pop();)b.audio.loop = !!b.loop, b.audio.play(b.offset)
};
cc.Audio.WebAudio = function (a) {
    this.buffer = a;
    this.context = cc.Audio._context;
    a = this.context.createGain();
    a.gain.value = 1;
    a.connect(this.context.destination);
    this._volume = a;
    this._loop = !1;
    this._startTime = -1;
    this._currentSource = null;
    this.playedLength = 0;
    this._currextTimer = null
};
cc.Audio.WebAudio.prototype = {
    constructor: cc.Audio.WebAudio, get paused() {
        return this._currentSource && this._currentSource.loop ? !1 : -1 === this._startTime ? !0 : this.context.currentTime - this._startTime > this.buffer.duration
    }, set paused(a) {
    }, get loop() {
        return this._loop
    }, set loop(a) {
        return this._loop = a
    }, get volume() {
        return this._volume.gain.value
    }, set volume(a) {
        return this._volume.gain.value = a
    }, get currentTime() {
        return this.playedLength
    }, set currentTime(a) {
        return this.playedLength = a
    }, play: function (a) {
        this._currentSource && !this.paused && (this._currentSource.stop(0), this.playedLength = 0);
        var b = this.context.createBufferSource();
        b.buffer = this.buffer;
        b.connect(this._volume);
        b.loop = this._loop;
        this._startTime = this.context.currentTime;
        a = a || this.playedLength;
        var d = this.buffer.duration;
        this._loop ? b.start ? b.start(0) : b.notoGrainOn ? b.noteGrainOn(0) : b.noteOn(0) : b.start ? b.start(0, a, d - a) : b.notoGrainOn ? b.noteGrainOn(0, a, d - a) : b.noteOn(0, a, d - a);
        this._currentSource = b;
        if (0 === this.context.currentTime) {
            var e = this;
            clearTimeout(this._currextTimer);
            this._currextTimer = setTimeout(function () {
                0 === e.context.currentTime && cc.Audio.touchPlayList.push({offset: a, audio: e})
            }, 10)
        }
    }, pause: function () {
        this.playedLength = this.context.currentTime - this._startTime;
        this.playedLength %= this.buffer.duration;
        var a = this._currentSource;
        this._currentSource = null;
        this._startTime = -1;
        a && a.stop(0)
    }
};
(function (a) {
    var b = a.WEB_AUDIO, d = a.ONLY_ONE, e = [];
    (function () {
        var a = document.createElement("audio");
        if (a.canPlayType) {
            var b = a.canPlayType('audio/ogg; codecs\x3d"vorbis"');
            b && "" !== b && e.push(".ogg");
            (b = a.canPlayType("audio/mpeg")) && "" !== b && e.push(".mp3");
            (b = a.canPlayType('audio/wav; codecs\x3d"1"')) && "" !== b && e.push(".wav");
            (b = a.canPlayType("audio/mp4")) && "" !== b && e.push(".mp4");
            (a = a.canPlayType("audio/x-m4a")) && "" !== a && e.push(".m4a")
        }
    })();
    try {
        if (b) {
            var f = new (window.AudioContext || window.webkitAudioContext ||
            window.mozAudioContext);
            cc.Audio._context = f;
            a.DELAY_CREATE_CTX && setTimeout(function () {
                f = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
                cc.Audio._context = f
            }, 0)
        }
    } catch (g) {
        b = !1, cc.log("browser don't support web audio")
    }
    var h = {
        cache: {}, useWebAudio: !1, loadBuffer: function (a, d) {
            if (b) {
                var e = new XMLHttpRequest;
                e.open("GET", a, !0);
                e.responseType = "arraybuffer";
                e.onload = function () {
                    f.decodeAudioData(e.response, function (a) {
                        d(null, a)
                    }, function () {
                        d("decode error - " + a)
                    })
                };
                e.onerror = function () {
                    d("request error - " +
                        a)
                };
                e.send()
            }
        }, load: function (a, b, d, f) {
            if (0 === e.length)return f("can not support audio!");
            var g = cc.loader.getRes(b);
            if (g)return f(null, g);
            cc.loader.audioPath && (a = cc.path.join(cc.loader.audioPath, a));
            var h = cc.path.extname(a);
            d = [h];
            for (g = 0; g < e.length; g++)h !== e[g] && d.push(e[g]);
            g = new cc.Audio(a);
            cc.loader.cache[b] = g;
            this.loadAudioFromExtList(a, d, g, f);
            return g
        }, loadAudioFromExtList: function (d, f, g, h) {
            if (0 === f.length) {
                var t = "can not found the resource of audio! Last match url is : ", t = t + d.replace(/\.(.*)?$/,
                        "(");
                e.forEach(function (a) {
                    t += a + "|"
                });
                t = t.replace(/\|$/, ")");
                return h({status: 520, errorMessage: t}, null)
            }
            if (b && this.useWebAudio)this.loadBuffer(d, function (a, b) {
                a && cc.log(a);
                b && g.setBuffer(b);
                h(null, g)
            }); else {
                for (var v = a.ONE_SOURCE ? 1 : f.length, u = document.createElement("audio"), x = 0; x < v; x++) {
                    var w = document.createElement("source");
                    w.src = cc.path.changeExtname(d, f[x]);
                    u.appendChild(w)
                }
                g.setElement(u);
                var y = setTimeout(function () {
                    0 === u.readyState ? D() : A()
                }, 8E3), A = function () {
                    u.removeEventListener("canplaythrough",
                        A, !1);
                    u.removeEventListener("error", D, !1);
                    u.removeEventListener("emptied", A, !1);
                    a.USE_LOADER_EVENT && u.removeEventListener(a.USE_LOADER_EVENT, A, !1);
                    clearTimeout(y);
                    h(null, g)
                }, D = function () {
                    cc.log("load audio failure - " + d);
                    A()
                };
                u.addEventListener("canplaythrough", A, !1);
                u.addEventListener("error", D, !1);
                a.USE_LOADER_EVENT && u.addEventListener(a.USE_LOADER_EVENT, A, !1)
            }
        }
    };
    cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], h);
    cc.audioEngine = {
        _currMusic: null, _musicVolume: 1, features: a, willPlayMusic: function () {
            return !1
        },
        playMusic: function (a, b) {
            var d = this._currMusic;
            d && d.getPlaying() && d.stop();
            d = cc.loader.getRes(a);
            d || (cc.loader.load(a), d = cc.loader.getRes(a));
            d.setVolume(this._musicVolume);
            d.play(0, b || !1);
            this._currMusic = d
        }, stopMusic: function (a) {
            var b = this._currMusic;
            b && (b.stop(), a && cc.loader.release(b.src))
        }, pauseMusic: function () {
            var a = this._currMusic;
            a && a.pause()
        }, resumeMusic: function () {
            var a = this._currMusic;
            a && a.resume()
        }, rewindMusic: function () {
            var a = this._currMusic;
            a && (a.stop(), a.play())
        }, getMusicVolume: function () {
            return this._musicVolume
        },
        setMusicVolume: function (a) {
            a -= 0;
            isNaN(a) && (a = 1);
            1 < a && (a = 1);
            0 > a && (a = 0);
            this._musicVolume = a;
            var b = this._currMusic;
            b && b.setVolume(a)
        }, isMusicPlaying: function () {
            var a = this._currMusic;
            return a ? a.getPlaying() : !1
        }, _audioPool: {}, _maxAudioInstance: 10, _effectVolume: 1, playEffect: function (a, e) {
            if (d && this._currMusic && this._currMusic.getPlaying())return cc.log("Browser is only allowed to play one audio"), null;
            var f = this._audioPool[a];
            f || (f = this._audioPool[a] = []);
            var g;
            for (g = 0; g < f.length && f[g].getPlaying(); g++);
            !b && g > this._maxAudioInstance && (g = f.shift(), g.stop(), f.push(g), g = f.length - 1);
            var t;
            if (f[g])return t = f[g], t.setVolume(this._effectVolume), t.play(0, e || !1), t;
            (t = cc.loader.getRes(a)) && b && "AUDIO" === t._AUDIO_TYPE && (cc.loader.release(a), t = null);
            if (t)if (b && "AUDIO" === t._AUDIO_TYPE)h.loadBuffer(a, function (a, b) {
                t.setBuffer(b);
                t.setVolume(cc.audioEngine._effectVolume);
                t.getPlaying() || t.play(0, e || !1)
            }); else return t = t.cloneNode(), t.setVolume(this._effectVolume), t.play(0, e || !1), f.push(t), t;
            h.useWebAudio = !0;
            cc.loader.load(a,
                function (b) {
                    b = cc.loader.getRes(a);
                    b = b.cloneNode();
                    b.setVolume(cc.audioEngine._effectVolume);
                    b.play(0, e || !1);
                    f.push(b)
                });
            h.useWebAudio = !1;
            return t
        }, setEffectsVolume: function (a) {
            a -= 0;
            isNaN(a) && (a = 1);
            1 < a && (a = 1);
            0 > a && (a = 0);
            this._effectVolume = a;
            var b = this._audioPool, d;
            for (d in b) {
                var e = b[d];
                if (Array.isArray(e))for (var f = 0; f < e.length; f++)e[f].setVolume(a)
            }
        }, getEffectsVolume: function () {
            return this._effectVolume
        }, pauseEffect: function (a) {
            a && a.pause()
        }, pauseAllEffects: function () {
            var a = this._audioPool, b;
            for (b in a)for (var d =
                a[b], e = 0; e < a[b].length; e++)d[e].getPlaying() && d[e].pause()
        }, resumeEffect: function (a) {
            a && a.resume()
        }, resumeAllEffects: function () {
            var a = this._audioPool, b;
            for (b in a)for (var d = a[b], e = 0; e < a[b].length; e++)d[e].resume()
        }, stopEffect: function (a) {
            a && a.stop()
        }, stopAllEffects: function () {
            var a = this._audioPool, b;
            for (b in a)for (var d = a[b], e = 0; e < a[b].length; e++)d[e].stop()
        }, unloadEffect: function (a) {
            if (a) {
                cc.loader.release(a);
                var b = this._audioPool[a];
                b && (b.length = 0);
                delete this._audioPool[a]
            }
        }, end: function () {
            this.stopMusic();
            this.stopAllEffects()
        }, _pauseCache: [], _pausePlaying: function () {
            var a = this._currMusic;
            a && a.getPlaying() && (a.pause(), this._pauseCache.push(a));
            var a = this._audioPool, b;
            for (b in a)for (var d = a[b], e = 0; e < a[b].length; e++)d[e].getPlaying() && (d[e].pause(), this._pauseCache.push(d[e]))
        }, _resumePlaying: function () {
            for (var a = this._pauseCache, b = 0; b < a.length; b++)a[b].resume();
            a.length = 0
        }
    }
})(window.__audioSupport);
cc.CONTROL_EVENT_TOTAL_NUMBER = 9;
cc.CONTROL_EVENT_TOUCH_DOWN = 1;
cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE = 2;
cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE = 4;
cc.CONTROL_EVENT_TOUCH_DRAG_ENTER = 8;
cc.CONTROL_EVENT_TOUCH_DRAG_EXIT = 16;
cc.CONTROL_EVENT_TOUCH_UP_INSIDE = 32;
cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE = 64;
cc.CONTROL_EVENT_TOUCH_CANCEL = 128;
cc.CONTROL_EVENT_VALUECHANGED = 256;
cc.CONTROL_STATE_NORMAL = 1;
cc.CONTROL_STATE_HIGHLIGHTED = 2;
cc.CONTROL_STATE_DISABLED = 4;
cc.CONTROL_STATE_SELECTED = 8;
cc.CONTROL_STATE_INITIAL = 8;
cc.Control = cc.Layer.extend({
    _isOpacityModifyRGB: !1,
    _hasVisibleParents: !1,
    _touchListener: null,
    _className: "Control",
    isOpacityModifyRGB: function () {
        return this._isOpacityModifyRGB
    },
    setOpacityModifyRGB: function (a) {
        this._isOpacityModifyRGB = a;
        for (var b = this.getChildren(), d = 0, e = b.length; d < e; d++) {
            var f = b[d];
            f && f.setOpacityModifyRGB(a)
        }
    },
    _state: cc.CONTROL_STATE_NORMAL,
    getState: function () {
        return this._state
    },
    _enabled: !1,
    _selected: !1,
    _highlighted: !1,
    _dispatchTable: null,
    setEnabled: function (a) {
        this._state = (this._enabled =
            a) ? cc.CONTROL_STATE_NORMAL : cc.CONTROL_STATE_DISABLED;
        this.needsLayout()
    },
    isEnabled: function () {
        return this._enabled
    },
    setSelected: function (a) {
        this._selected = a;
        this.needsLayout()
    },
    isSelected: function () {
        return this._selected
    },
    setHighlighted: function (a) {
        this._highlighted = a;
        this.needsLayout()
    },
    isHighlighted: function () {
        return this._highlighted
    },
    hasVisibleParents: function () {
        for (var a = this.getParent(); null != a; a = a.getParent())if (!a.isVisible())return !1;
        return !0
    },
    ctor: function () {
        cc.Layer.prototype.ctor.call(this);
        this._dispatchTable = {};
        this._color = cc.color.WHITE
    },
    init: function () {
        if (cc.Layer.prototype.init.call(this)) {
            this._state = cc.CONTROL_STATE_NORMAL;
            this._enabled = !0;
            this._highlighted = this._selected = !1;
            var a = cc.EventListener.create({event: cc.EventListener.TOUCH_ONE_BY_ONE, swallowTouches: !0});
            this.onTouchBegan && (a.onTouchBegan = this.onTouchBegan.bind(this));
            this.onTouchMoved && (a.onTouchMoved = this.onTouchMoved.bind(this));
            this.onTouchEnded && (a.onTouchEnded = this.onTouchEnded.bind(this));
            this.onTouchCancelled &&
            (a.onTouchCancelled = this.onTouchCancelled.bind(this));
            this._touchListener = a;
            return !0
        }
        return !1
    },
    onEnter: function () {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    },
    sendActionsForControlEvents: function (a) {
        for (var b = 0, d = cc.CONTROL_EVENT_TOTAL_NUMBER; b < d; b++)if (a & 1 << b)for (var e = this._dispatchListforControlEvent(1 << b), f = 0, g = e.length; f < g; f++)e[f].invoke(this)
    },
    addTargetWithActionForControlEvents: function (a, b, d) {
        for (var e = 0, f = cc.CONTROL_EVENT_TOTAL_NUMBER; e <
        f; e++)d & 1 << e && this._addTargetWithActionForControlEvent(a, b, 1 << e)
    },
    removeTargetWithActionForControlEvents: function (a, b, d) {
        for (var e = 0, f = cc.CONTROL_EVENT_TOTAL_NUMBER; e < f; e++)d & 1 << e && this._removeTargetWithActionForControlEvent(a, b, 1 << e)
    },
    getTouchLocation: function (a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    isTouchInside: function (a) {
        a = a.getLocation();
        a = this.getParent().convertToNodeSpace(a);
        return cc.rectContainsPoint(this.getBoundingBox(), a)
    },
    _invocationWithTargetAndActionForControlEvent: function (a,
                                                             b, d) {
        return null
    },
    _dispatchListforControlEvent: function (a) {
        a = a.toString();
        this._dispatchTable[a] || (this._dispatchTable[a] = []);
        return this._dispatchTable[a]
    },
    _addTargetWithActionForControlEvent: function (a, b, d) {
        a = new cc.Invocation(a, b, d);
        this._dispatchListforControlEvent(d).push(a)
    },
    _removeTargetWithActionForControlEvent: function (a, b, d) {
        d = this._dispatchListforControlEvent(d);
        if (a || b)for (var e = 0; e < d.length;) {
            var f = d[e], g = !0;
            a && (g = a === f.getTarget());
            b && (g = g && b === f.getAction());
            g ? cc.arrayRemoveObject(d,
                f) : e++
        } else d.length = 0
    },
    needsLayout: function () {
    }
});
_p = cc.Control.prototype;
cc.defineGetterSetter(_p, "state", _p.getState);
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
cc.defineGetterSetter(_p, "highlighted", _p.isHighlighted, _p.setHighlighted);
_p = null;
cc.Control.create = function () {
    var a = new cc.Control;
    return a && a.init() ? a : null
};
cc.CONTROL_ZOOM_ACTION_TAG = 3435855873;
cc.ControlButton = cc.Control.extend({
    _doesAdjustBackgroundImage: !1,
    zoomOnTouchDown: !1,
    _preferredSize: null,
    _labelAnchorPoint: null,
    _currentTitle: null,
    _currentTitleColor: null,
    _titleLabel: null,
    _backgroundSprite: null,
    _opacity: 0,
    _isPushed: !1,
    _titleDispatchTable: null,
    _titleColorDispatchTable: null,
    _titleLabelDispatchTable: null,
    _backgroundSpriteDispatchTable: null,
    _parentInited: !1,
    _marginV: 0,
    _marginH: 0,
    _className: "ControlButton",
    ctor: function (a, b, d) {
        cc.Control.prototype.ctor.call(this);
        this._preferredSize = cc.size(0,
            0);
        this._labelAnchorPoint = cc.p(0, 0);
        this._currentTitle = "";
        this._currentTitleColor = cc.color.WHITE;
        this._titleDispatchTable = {};
        this._titleColorDispatchTable = {};
        this._titleLabelDispatchTable = {};
        this._backgroundSpriteDispatchTable = {};
        void 0 != d ? this.initWithTitleAndFontNameAndFontSize(a, b, d) : void 0 != b ? this.initWithLabelAndBackgroundSprite(a, b) : void 0 != a ? this.initWithBackgroundSprite(a) : this.init()
    },
    init: function () {
        return this.initWithLabelAndBackgroundSprite(new cc.LabelTTF("", "Arial", 12), new cc.Scale9Sprite)
    },
    needsLayout: function () {
        if (this._parentInited) {
            this._titleLabel && this._titleLabel.setVisible(!1);
            this._backgroundSprite && this._backgroundSprite.setVisible(!1);
            this.setLabelAnchorPoint(this._labelAnchorPoint);
            var a = this._state;
            this._currentTitle = this.getTitleForState(a);
            this._currentTitleColor = this.getTitleColorForState(a);
            var b = this._titleLabel = this.getTitleLabelForState(a);
            b && b.setString && b.setString(this._currentTitle);
            b && b.setColor(this._currentTitleColor);
            var d = this.getContentSize();
            b && b.setPosition(d.width /
                2, d.height / 2);
            (a = this._backgroundSprite = this.getBackgroundSpriteForState(a)) && a.setPosition(d.width / 2, d.height / 2);
            d = cc.size(0, 0);
            if (b) {
                var e = b.getBoundingBox();
                d.width = e.width;
                d.height = e.height
            }
            this._doesAdjustBackgroundImage ? a && a.setContentSize(d.width + 2 * this._marginH, d.height + 2 * this._marginV) : a && (e = a.getPreferredSize(), e = cc.size(e.width, e.height), 0 >= e.width && (e.width = d.width), 0 >= e.height && (e.height = d.height), a.setContentSize(e));
            d = b ? b.getBoundingBox() : cc.rect(0, 0, 0, 0);
            e = a ? a.getBoundingBox() : cc.rect(0,
                0, 0, 0);
            d = cc.rectUnion(d, e);
            this.setContentSize(d.width, d.height);
            d = this.getContentSize();
            b && (b.setPosition(d.width / 2, d.height / 2), b.setVisible(!0));
            a && (a.setPosition(d.width / 2, d.height / 2), a.setVisible(!0))
        }
    },
    initWithLabelAndBackgroundSprite: function (a, b) {
        if (!a)throw Error("cc.ControlButton.initWithLabelAndBackgroundSprite(): label should be non-null");
        if (!b)throw Error("cc.ControlButton.initWithLabelAndBackgroundSprite(): backgroundSprite should be non-null");
        if (cc.Control.prototype.init.call(this,
                !0)) {
            this._parentInited = !0;
            this._titleDispatchTable = {};
            this._titleColorDispatchTable = {};
            this._titleLabelDispatchTable = {};
            this._backgroundSpriteDispatchTable = {};
            this._isPushed = !1;
            this.zoomOnTouchDown = !0;
            this._currentTitle = null;
            this.setAdjustBackgroundImage(!0);
            this.setPreferredSize(cc.size(0, 0));
            this.zoomOnTouchDown = !0;
            this.ignoreAnchorPointForPosition(!1);
            this.setAnchorPoint(0.5, 0.5);
            this._titleLabel = a;
            this._backgroundSprite = b;
            this.setOpacity(255);
            this.setOpacityModifyRGB(!0);
            var d = a.getString();
            this.setTitleForState(d, cc.CONTROL_STATE_NORMAL);
            this.setTitleColorForState(a.getColor(), cc.CONTROL_STATE_NORMAL);
            this.setTitleLabelForState(a, cc.CONTROL_STATE_NORMAL);
            this.setBackgroundSpriteForState(b, cc.CONTROL_STATE_NORMAL);
            this._state = cc.CONTROL_STATE_NORMAL;
            this._marginH = 24;
            this._marginV = 12;
            this._labelAnchorPoint = cc.p(0.5, 0.5);
            this.setPreferredSize(cc.size(0, 0));
            this.needsLayout();
            return !0
        }
        return !1
    },
    initWithTitleAndFontNameAndFontSize: function (a, b, d) {
        a = new cc.LabelTTF(a, b, d);
        return this.initWithLabelAndBackgroundSprite(a,
            new cc.Scale9Sprite)
    },
    initWithBackgroundSprite: function (a) {
        var b = new cc.LabelTTF("", "Arial", 30);
        return this.initWithLabelAndBackgroundSprite(b, a)
    },
    doesAdjustBackgroundImage: function () {
        return this._doesAdjustBackgroundImage
    },
    setAdjustBackgroundImage: function (a) {
        this._doesAdjustBackgroundImage = a;
        this.needsLayout()
    },
    getZoomOnTouchDown: function () {
        return this.zoomOnTouchDown
    },
    setZoomOnTouchDown: function (a) {
        return this.zoomOnTouchDown = a
    },
    getPreferredSize: function () {
        return this._preferredSize
    },
    setPreferredSize: function (a) {
        if (0 ===
            a.width && 0 === a.height)this._doesAdjustBackgroundImage = !0; else {
            this._doesAdjustBackgroundImage = !1;
            var b = this._backgroundSpriteDispatchTable, d;
            for (d in b)b[d].setPreferredSize(a)
        }
        this._preferredSize = a;
        this.needsLayout()
    },
    getLabelAnchorPoint: function () {
        return this._labelAnchorPoint
    },
    setLabelAnchorPoint: function (a) {
        this._labelAnchorPoint = a;
        this._titleLabel && this._titleLabel.setAnchorPoint(a)
    },
    _getCurrentTitle: function () {
        return this._currentTitle
    },
    _getCurrentTitleColor: function () {
        return this._currentTitleColor
    },
    getOpacity: function () {
        return this._opacity
    },
    setOpacity: function (a) {
        cc.Control.prototype.setOpacity.call(this, a);
        var b = this._backgroundSpriteDispatchTable, d;
        for (d in b)b[d].setOpacity(a)
    },
    setColor: function (a) {
        cc.Control.prototype.setColor.call(this, a);
        var b = this._backgroundSpriteDispatchTable, d;
        for (d in b)b[d].setColor(a)
    },
    getColor: function () {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    isPushed: function () {
        return this._isPushed
    },
    _getVerticalMargin: function () {
        return this._marginV
    },
    _getHorizontalOrigin: function () {
        return this._marginH
    },
    setMargins: function (a, b) {
        this._marginV = b;
        this._marginH = a;
        this.needsLayout()
    },
    setEnabled: function (a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this.needsLayout()
    },
    setSelected: function (a) {
        cc.Control.prototype.setSelected.call(this, a);
        this.needsLayout()
    },
    setHighlighted: function (a) {
        this._state = a ? cc.CONTROL_STATE_HIGHLIGHTED : cc.CONTROL_STATE_NORMAL;
        cc.Control.prototype.setHighlighted.call(this, a);
        (a = this.getActionByTag(cc.CONTROL_ZOOM_ACTION_TAG)) && this.stopAction(a);
        this.zoomOnTouchDown && (a = this.isHighlighted() &&
        this.isEnabled() && !this.isSelected() ? 1.1 : 1, a = cc.scaleTo(0.05, a), a.setTag(cc.CONTROL_ZOOM_ACTION_TAG), this.runAction(a))
    },
    onTouchBegan: function (a, b) {
        if (!(this.isTouchInside(a) && this.isEnabled() && this.isVisible() && this.hasVisibleParents()))return !1;
        this._isPushed = !0;
        this.setHighlighted(!0);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DOWN);
        return !0
    },
    onTouchMoved: function (a, b) {
        if (this._enabled && this._isPushed && !this._selected) {
            var d = this.isTouchInside(a);
            d && !this._highlighted ? (this.setHighlighted(!0),
                this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_ENTER)) : d && this._highlighted ? this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE) : !d && this._highlighted ? (this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_EXIT)) : d || this._highlighted || this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE)
        } else this._highlighted && this.setHighlighted(!1)
    },
    onTouchEnded: function (a, b) {
        this._isPushed = !1;
        this.setHighlighted(!1);
        this.isTouchInside(a) ?
            this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_INSIDE) : this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE)
    },
    onTouchCancelled: function (a, b) {
        this._isPushed = !1;
        this.setHighlighted(!1);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_CANCEL)
    },
    getTitleForState: function (a) {
        var b = this._titleDispatchTable;
        return b ? b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL] : ""
    },
    setTitleForState: function (a, b) {
        this._titleDispatchTable[b] = a || "";
        this.getState() === b && this.needsLayout()
    },
    getTitleColorForState: function (a) {
        return (a =
            this._titleColorDispatchTable[a]) ? a : (a = this._titleColorDispatchTable[cc.CONTROL_STATE_NORMAL]) ? a : cc.color.WHITE
    },
    setTitleColorForState: function (a, b) {
        this._titleColorDispatchTable[b] = a;
        this.getState() === b && this.needsLayout()
    },
    getTitleLabelForState: function (a) {
        var b = this._titleLabelDispatchTable;
        return b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL]
    },
    setTitleLabelForState: function (a, b) {
        var d = this._titleLabelDispatchTable;
        if (d[b]) {
            var e = d[b];
            e && this.removeChild(e, !0)
        }
        d[b] = a;
        a.setVisible(!1);
        a.setAnchorPoint(0.5,
            0.5);
        this.addChild(a, 1);
        this.getState() === b && this.needsLayout()
    },
    setTitleTTFForState: function (a, b) {
        var d = this.getTitleForState(b);
        d || (d = "");
        this.setTitleLabelForState(new cc.LabelTTF(d, a, 12), b)
    },
    getTitleTTFForState: function (a) {
        a = this.getTitleLabelForState(a);
        return null != a && a instanceof cc.LabelTTF ? a.getFontName() : ""
    },
    setTitleTTFSizeForState: function (a, b) {
        var d = this.getTitleLabelForState(b);
        null != d && d instanceof cc.LabelTTF && d.setFontSize(a)
    },
    getTitleTTFSizeForState: function (a) {
        a = this.getTitleLabelForState(a);
        return null != a && a instanceof cc.LabelTTF ? a.getFontSize() : 0
    },
    setTitleBMFontForState: function (a, b) {
        var d = this.getTitleForState(b);
        d || (d = "");
        this.setTitleLabelForState(new cc.LabelBMFont(d, a), b)
    },
    getTitleBMFontForState: function (a) {
        a = this.getTitleLabelForState(a);
        return null != a && a instanceof cc.LabelBMFont ? a.getFntFile() : ""
    },
    getBackgroundSpriteForState: function (a) {
        var b = this._backgroundSpriteDispatchTable;
        return b[a] ? b[a] : b[cc.CONTROL_STATE_NORMAL]
    },
    setBackgroundSpriteForState: function (a, b) {
        var d = this._backgroundSpriteDispatchTable;
        if (d[b]) {
            var e = d[b];
            e && this.removeChild(e, !0)
        }
        d[b] = a;
        a.setVisible(!1);
        a.setAnchorPoint(0.5, 0.5);
        this.addChild(a);
        d = this._preferredSize;
        0 === d.width && 0 === d.height || a.setPreferredSize(d);
        this._state === b && this.needsLayout()
    },
    setBackgroundSpriteFrameForState: function (a, b) {
        var d = cc.Scale9Sprite.createWithSpriteFrame(a);
        this.setBackgroundSpriteForState(d, b)
    }
});
_p = cc.ControlButton.prototype;
cc.defineGetterSetter(_p, "adjustBackground", _p.getAdjustBackgroundImage, _p.setAdjustBackgroundImage);
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
cc.defineGetterSetter(_p, "labelAnchor", _p.getLabelAnchorPoint, _p.setLabelAnchorPoint);
_p = null;
cc.ControlButton.create = function (a, b, d) {
    return new cc.ControlButton(a, b, d)
};
cc.RGBA = function (a, b, d, e) {
    this.r = a;
    this.g = b;
    this.b = d;
    this.a = e
};
cc.HSV = function (a, b, d) {
    this.h = a;
    this.s = b;
    this.v = d
};
cc.ControlUtils = {};
cc.ControlUtils.addSpriteToTargetWithPosAndAnchor = function (a, b, d, e) {
    a = new cc.Sprite("#" + a);
    if (!a)return null;
    a.setPosition(d);
    a.setAnchorPoint(e);
    b.addChild(a);
    return a
};
cc.ControlUtils.HSVfromRGB = function (a) {
    var b = new cc.HSV, d, e;
    d = a.r < a.g ? a.r : a.g;
    d = d < a.b ? d : a.b;
    e = a.r > a.g ? a.r : a.g;
    e = e > a.b ? e : a.b;
    b.v = e;
    d = e - d;
    if (0 < e)b.s = d / e; else return b.s = 0, b.h = -1, b;
    b.h = a.r >= e ? (a.g - a.b) / d : a.g >= e ? 2 + (a.b - a.r) / d : 4 + (a.r - a.g) / d;
    b.h *= 60;
    0 > b.h && (b.h += 360);
    return b
};
cc.ControlUtils.RGBfromHSV = function (a) {
    var b, d, e, f, g = new cc.RGBA;
    g.a = 1;
    if (0 >= a.s) {
        if (!a.h)return g.r = a.v, g.g = a.v, g.b = a.v, g;
        g.r = 0;
        g.g = 0;
        g.b = 0;
        return g
    }
    b = a.h;
    360 <= b && (b = 0);
    b /= 60;
    f = 0 | b;
    e = b - f;
    b = a.v * (1 - a.s);
    d = a.v * (1 - a.s * e);
    e = a.v * (1 - a.s * (1 - e));
    switch (f) {
        case 0:
            g.r = a.v;
            g.g = e;
            g.b = b;
            break;
        case 1:
            g.r = d;
            g.g = a.v;
            g.b = b;
            break;
        case 2:
            g.r = b;
            g.g = a.v;
            g.b = e;
            break;
        case 3:
            g.r = b;
            g.g = d;
            g.b = a.v;
            break;
        case 4:
            g.r = e;
            g.g = b;
            g.b = a.v;
            break;
        default:
            g.r = a.v, g.g = b, g.b = d
    }
    return g
};
cc.ControlUtils.CCRectUnion = function (a, b) {
    return cc.rectUnion(a, b)
};
cc.Invocation = cc.Class.extend({
    _action: null, _target: null, _controlEvent: null, ctor: function (a, b, d) {
        this._target = a;
        this._action = b;
        this._controlEvent = d
    }, getAction: function () {
        return this._action
    }, getTarget: function () {
        return this._target
    }, getControlEvent: function () {
        return this._controlEvent
    }, invoke: function (a) {
        if (this._target && this._action)if (cc.isString(this._action))this._target[this._action](a, this._controlEvent); else this._action.call(this._target, a, this._controlEvent)
    }
});
cc.Spacer = cc.Layer.extend({});
cc.Spacer.verticalSpacer = function (a) {
    var b = new cc.Spacer;
    b.init();
    b.setContentSize(0, a);
    return b
};
cc.Spacer.horizontalSpacer = function (a) {
    var b = new cc.Spacer;
    b.init();
    b.setContentSize(a, 0);
    return b
};
cc.MenuPassive = cc.Layer.extend({
    _color: null, _opacity: 0, _className: "MenuPassive", ctor: function () {
    }, getColor: function () {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    }, setColor: function (a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if (this._children && 0 < this._children.length)for (b = 0; b < this._children.length; b++)this._children[b] && this._children[b].setColor(a);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    }, getOpacity: function () {
        return this._opacity
    }, setOpacity: function (a) {
        this._opacity = a;
        if (this._children &&
            0 < this._children.length)for (var b = 0; b < this._children.length; b++)this._children[b] && this._children[b].setOpacity(a);
        this._color.a = a
    }, initWithItems: function (a, b) {
        if (this.init()) {
            var d = cc.director.getWinSize();
            this.ignoreAnchorPointForPosition(!0);
            this.setAnchorPoint(0.5, 0.5);
            this.setContentSize(d);
            this.setPosition(d.width / 2, d.height / 2);
            d = 0;
            if (a) {
                this.addChild(a, d);
                for (var e = 0; e < b.length; e++)b[e] && (d++, this.addChild(b[e], d))
            }
            return !0
        }
        return !1
    }, alignItemsVertically: function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function (a) {
        var b = -a, d;
        if (this._children && 0 < this._children.length)for (d = 0; d < this._children.length; d++)this._children[d] && (b += this._children[d].getContentSize().height * this._children[d].getScaleY() + a);
        var e = 0, f = b / 2;
        if (this._children && 0 < this._children.length)for (d = 0; d < this._children.length; d++)this._children[d] && (e = Math.max(e, this._children[d].getContentSize().width), this._children[d].setPosition(0, f - this._children[d].getContentSize().height * this._children[d].getScaleY() /
            2), f -= this._children[d].getContentSize().height * this._children[d].getScaleY() + a);
        this.setContentSize(e, b)
    }, alignItemsHorizontally: function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    }, alignItemsHorizontallyWithPadding: function (a) {
        var b = -a, d;
        if (this._children && 0 < this._children.length)for (d = 0; d < this._children.length; d++)this._children[d] && (b += this._children[d].getContentSize().width * this._children[d].getScaleX() + a);
        var e = 0, f = -b / 2;
        if (this._children && 0 < this._children.length)for (d = 0; d <
        this._children.length; d++)this._children[d] && (e = Math.max(e, this._children[d].getContentSize().height), this._children[d].setPosition(f + this._children[d].getContentSize().width * this._children[d].getScaleX() / 2, 0), f += this._children[d].getContentSize().width * this._children[d].getScaleX() + a);
        this.setContentSize(b, e)
    }, alignItemsInColumns: function (a) {
        var b = [], d;
        for (d = 1; d < arguments.length; d++)b.push(arguments[d]);
        var e = -5, f = 0, g = 0, h = 0, n, p;
        if (this._children && 0 < this._children.length)for (d = 0; d < this._children.length; d++)this._children[d] &&
        (f >= b.length ? cc.log("cc.MenuPassive.alignItemsInColumns(): invalid row index") : (n = b[f]) ? (p = this._children[d].getContentSize().height, g = 0 | (g >= p || null == p ? g : p), ++h, h >= n && (e += g + 5, g = h = 0, ++f)) : cc.log("cc.MenuPassive.alignItemsInColumns(): can not have zero columns on a row"));
        var r = cc.director.getWinSize(), s = n = g = f = 0, t = 0, e = e / 2;
        if (this._children && 0 < this._children.length)for (d = 0; d < this._children.length; d++)this._children[d] && (0 === n && (n = b[f], t = s = r.width / (1 + n)), p = this._children[d].getContentSize().height, g =
            0 | (g >= p || null == p ? g : p), this._children[d].setPosition(t - r.width / 2, e - this._children[d].getContentSize().height / 2), t += s, ++h, h >= n && (e -= g + 5, g = n = h = 0, ++f))
    }, alignItemsInRows: function (a) {
        var b = [], d;
        for (d = 1; d < arguments.length; d++)b.push(arguments[d]);
        var e = [], f = [], g = -10, h = -5, n = 0, p = 0, r = 0, s, t;
        if (this._children && 0 < this._children.length)for (d = 0; d < this._children.length; d++)this._children[d] && (n >= b.length ? cc.log("cc.MenuPassive.alignItemsInRows(): invalid row index") : (s = b[n]) ? (t = this._children[d].getContentSize().width,
            p = 0 | (p >= t || null == t ? p : t), h += 0 | this._children[d].getContentSize().height + 5, ++r, r >= s && (e.push(p), f.push(h), g += p + 10, p = r = 0, h = -5, ++n)) : cc.log("cc.MenuPassive.alignItemsInColumns(): can't have zero rows on a column"));
        h = cc.director.getWinSize();
        p = n = 0;
        s = null;
        var g = -g / 2, v = 0;
        if (this._children && 0 < this._children.length)for (d = 0; d < this._children.length; d++)this._children[d] && (null == s && (s = b[n], v = f[n]), t = this._children[d].getContentSize().width, p = 0 | (p >= t || null == t ? p : t), this._children[d].setPosition(g + e[n] / 2, v - h.height /
            2), v -= this._children[d].getContentSize().height + 10, ++r, r >= s && (g += p + 5, p = s = r = 0, ++n))
    }, setOpacityModifyRGB: function (a) {
    }, isOpacityModifyRGB: function () {
        return !1
    }
});
cc.MenuPassive.create = function (a) {
    a || (a = null);
    for (var b = [], d = 1; d < arguments.length; d++)b.push(arguments[d]);
    return (d = new cc.MenuPassive) && d.initWithItems(a, b) ? d : null
};
cc.MenuPassive.createWithItem = function (a) {
    return cc.MenuPassive.create(a, null)
};
cc.ControlSaturationBrightnessPicker = cc.Control.extend({
    _saturation: 0,
    _brightness: 0,
    _background: null,
    _overlay: null,
    _shadow: null,
    _slider: null,
    _startPos: null,
    _boxPos: 0,
    _boxSize: 0,
    _className: "ControlSaturationBrightnessPicker",
    ctor: function (a, b) {
        cc.Control.prototype.ctor.call(this);
        b && this.initWithTargetAndPos(a, b)
    },
    getSaturation: function () {
        return this._saturation
    },
    getBrightness: function () {
        return this._brightness
    },
    getBackground: function () {
        return this._background
    },
    getOverlay: function () {
        return this._brightness
    },
    getShadow: function () {
        return this._shadow
    },
    getSlider: function () {
        return this._slider
    },
    getStartPos: function () {
        return this._startPos
    },
    initWithTargetAndPos: function (a, b) {
        return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerBackground.png", a, b, cc.p(0, 0)), this._overlay = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerOverlay.png", a, b, cc.p(0, 0)), this._shadow = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerShadow.png",
            a, b, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, b, cc.p(0.5, 0.5)), this._startPos = b, this._boxPos = 35, this._boxSize = this._background.getContentSize().width / 2, !0) : !1
    },
    setEnabled: function (a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this._slider && this._slider.setOpacity(a ? 255 : 128)
    },
    updateWithHSV: function (a) {
        var b = new cc.HSV;
        b.s = 1;
        b.h = a.h;
        b.v = 1;
        a = cc.ControlUtils.RGBfromHSV(b);
        this._background.setColor(cc.color(0 | 255 * a.r, 0 | 255 * a.g, 0 | 255 * a.b))
    },
    updateDraggerWithHSV: function (a) {
        a =
            cc.p(this._startPos.x + this._boxPos + this._boxSize * (1 - a.s), this._startPos.y + this._boxPos + this._boxSize * a.v);
        this._updateSliderPosition(a)
    },
    _updateSliderPosition: function (a) {
        var b = this._startPos.x + 0.5 * this._background.getBoundingBox().width, d = this._startPos.y + 0.5 * this._background.getBoundingBox().height, e = a.x - b, f = a.y - d, g = Math.sqrt(e * e + f * f), e = Math.atan2(f, e), f = 0.5 * this._background.getBoundingBox().width;
        g > f && (a.x = b + f * Math.cos(e), a.y = d + f * Math.sin(e));
        this._slider.setPosition(a);
        a.x < this._startPos.x + this._boxPos ?
            a.x = this._startPos.x + this._boxPos : a.x > this._startPos.x + this._boxPos + this._boxSize - 1 && (a.x = this._startPos.x + this._boxPos + this._boxSize - 1);
        a.y < this._startPos.y + this._boxPos ? a.y = this._startPos.y + this._boxPos : a.y > this._startPos.y + this._boxPos + this._boxSize && (a.y = this._startPos.y + this._boxPos + this._boxSize);
        this._saturation = 1 - Math.abs((this._startPos.x + this._boxPos - a.x) / this._boxSize);
        this._brightness = Math.abs((this._startPos.y + this._boxPos - a.y) / this._boxSize)
    },
    _checkSliderPosition: function (a) {
        var b = this._startPos.x +
            0.5 * this._background.getBoundingBox().width, d = this._startPos.y + 0.5 * this._background.getBoundingBox().height, b = a.x - b, d = a.y - d;
        return Math.sqrt(b * b + d * d) <= 0.5 * this._background.getBoundingBox().width ? (this._updateSliderPosition(a), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), !0) : !1
    },
    onTouchBegan: function (a, b) {
        if (!this.isEnabled() || !this.isVisible())return !1;
        var d = this.getTouchLocation(a);
        return this._checkSliderPosition(d)
    },
    onTouchMoved: function (a, b) {
        var d = this.getTouchLocation(a);
        this._checkSliderPosition(d)
    }
});
_p = cc.ControlSaturationBrightnessPicker.prototype;
cc.defineGetterSetter(_p, "saturation", _p.getSaturation);
cc.defineGetterSetter(_p, "brightness", _p.getBrightness);
cc.defineGetterSetter(_p, "background", _p.getBackground);
cc.defineGetterSetter(_p, "overlay", _p.getOverlay);
cc.defineGetterSetter(_p, "shadow", _p.getShadow);
cc.defineGetterSetter(_p, "slider", _p.getSlider);
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlSaturationBrightnessPicker.create = function (a, b) {
    return new cc.ControlSaturationBrightnessPicker(a, b)
};
cc.ControlHuePicker = cc.Control.extend({
    _hue: 0,
    _huePercentage: 0,
    _background: null,
    _slider: null,
    _startPos: null,
    _className: "ControlHuePicker",
    ctor: function (a, b) {
        cc.Control.prototype.ctor.call(this);
        b && this.initWithTargetAndPos(a, b)
    },
    getHue: function () {
        return this._hue
    },
    setHue: function (a) {
        this._hue = a;
        this.setHuePercentage(this._hue / 360)
    },
    getHuePercentage: function () {
        return this._huePercentage
    },
    setHuePercentage: function (a) {
        this._huePercentage = a;
        this._hue = 360 * this._huePercentage;
        var b = this._background.getBoundingBox(),
            d = this._startPos.x + 0.5 * b.width;
        a = this._startPos.y + 0.5 * b.height;
        var b = 0.5 * b.width - 15, e = cc.degreesToRadians(360 * this._huePercentage - 180), d = d + b * Math.cos(e);
        a += b * Math.sin(e);
        this._slider.setPosition(d, a)
    },
    setEnabled: function (a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this._slider && this._slider.setOpacity(a ? 255 : 128)
    },
    getBackground: function () {
        return this._background
    },
    getSlider: function () {
        return this._slider
    },
    getStartPos: function () {
        return this._startPos
    },
    initWithTargetAndPos: function (a, b) {
        return cc.Control.prototype.init.call(this) ?
            (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("huePickerBackground.png", a, b, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", a, b, cc.p(0.5, 0.5)), this._slider.setPosition(b.x, b.y + 0.5 * this._background.getBoundingBox().height), this._startPos = b, this._huePercentage = this._hue = 0, !0) : !1
    },
    _updateSliderPosition: function (a) {
        var b = this._background.getBoundingBox();
        a = Math.atan2(a.y - (this._startPos.y + 0.5 * b.height), a.x - (this._startPos.x + 0.5 * b.width));
        a = cc.radiansToDegrees(a) + 180;
        this.setHue(a);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    _checkSliderPosition: function (a) {
        var b = Math.sqrt(Math.pow(a.x + 10, 2) + Math.pow(a.y, 2));
        return 80 > b && 59 < b ? (this._updateSliderPosition(a), !0) : !1
    },
    onTouchBegan: function (a, b) {
        if (!this.isEnabled() || !this.isVisible())return !1;
        var d = this.getTouchLocation(a);
        return this._checkSliderPosition(d)
    },
    onTouchMoved: function (a, b) {
        var d = this.getTouchLocation(a);
        this._checkSliderPosition(d)
    }
});
_p = cc.ControlHuePicker.prototype;
cc.defineGetterSetter(_p, "hue", _p.getHue, _p.setHue);
cc.defineGetterSetter(_p, "huePercent", _p.getHuePercentage, _p.setHuePercentage);
cc.defineGetterSetter(_p, "background", _p.getBackground);
cc.defineGetterSetter(_p, "slider", _p.getSlider);
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlHuePicker.create = function (a, b) {
    return new cc.ControlHuePicker(a, b)
};
cc.ControlColourPicker = cc.Control.extend({
    _hsv: null,
    _colourPicker: null,
    _huePicker: null,
    _background: null,
    _className: "ControlColourPicker",
    ctor: function () {
        cc.Control.prototype.ctor.call(this);
        this.init()
    },
    hueSliderValueChanged: function (a, b) {
        this._hsv.h = a.getHue();
        var d = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * d.r, 0 | 255 * d.g, 0 | 255 * d.b));
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
        this._updateControlPicker()
    },
    colourSliderValueChanged: function (a,
                                        b) {
        this._hsv.s = a.getSaturation();
        this._hsv.v = a.getBrightness();
        var d = cc.ControlUtils.RGBfromHSV(this._hsv);
        cc.Control.prototype.setColor.call(this, cc.color(0 | 255 * d.r, 0 | 255 * d.g, 0 | 255 * d.b));
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    setColor: function (a) {
        cc.Control.prototype.setColor.call(this, a);
        var b = new cc.RGBA;
        b.r = a.r / 255;
        b.g = a.g / 255;
        b.b = a.b / 255;
        b.a = 1;
        this._hsv = cc.ControlUtils.HSVfromRGB(b);
        this._updateHueAndControlPicker()
    },
    getBackground: function () {
        return this._background
    },
    init: function () {
        if (cc.Control.prototype.init.call(this)) {
            cc.spriteFrameCache.addSpriteFrames(res.CCControlColourPickerSpriteSheet_plist);
            var a = new cc.SpriteBatchNode(res.CCControlColourPickerSpriteSheet_png);
            this.addChild(a);
            this._hsv = new cc.HSV(0, 0, 0);
            this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("menuColourPanelBackground.png", a, cc.p(0, 0), cc.p(0.5, 0.5));
            var b = cc.pSub(this._background.getPosition(), cc.p(this._background.getContentSize().width / 2, this._background.getContentSize().height /
                2));
            this._huePicker = new cc.ControlHuePicker(a, cc.p(b.x + 8, b.y + 8));
            this._colourPicker = new cc.ControlSaturationBrightnessPicker(a, cc.p(b.x + 28, b.y + 28));
            this._huePicker.addTargetWithActionForControlEvents(this, this.hueSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
            this._colourPicker.addTargetWithActionForControlEvents(this, this.colourSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED);
            this._updateHueAndControlPicker();
            this.addChild(this._huePicker);
            this.addChild(this._colourPicker);
            this.setContentSize(this._background.getContentSize());
            return !0
        }
        return !1
    },
    _updateControlPicker: function () {
        this._huePicker.setHue(this._hsv.h);
        this._colourPicker.updateWithHSV(this._hsv)
    },
    _updateHueAndControlPicker: function () {
        this._huePicker.setHue(this._hsv.h);
        this._colourPicker.updateWithHSV(this._hsv);
        this._colourPicker.updateDraggerWithHSV(this._hsv)
    },
    setEnabled: function (a) {
        cc.Control.prototype.setEnabled.call(this, a);
        null !== this._huePicker && this._huePicker.setEnabled(a);
        this._colourPicker && this._colourPicker.setEnabled(a)
    },
    onTouchBegan: function () {
        return !1
    }
});
_p = cc.ControlColourPicker.prototype;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p = null;
cc.ControlColourPicker.create = function () {
    return new cc.ControlColourPicker
};
var res = res || {};
res.CCControlColourPickerSpriteSheet_plist = res.CCControlColourPickerSpriteSheet_plist || "res/extensions/CCControlColourPickerSpriteSheet.plist";
res.CCControlColourPickerSpriteSheet_png = res.CCControlColourPickerSpriteSheet_png || "res/extensions/CCControlColourPickerSpriteSheet.png";
cc.SLIDER_MARGIN_H = 24;
cc.SLIDER_MARGIN_V = 8;
cc.ControlSlider = cc.Control.extend({
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 0,
    _minimumAllowedValue: 0,
    _maximumAllowedValue: 0,
    _thumbSprite: null,
    _progressSprite: null,
    _backgroundSprite: null,
    _className: "ControlSlider",
    ctor: function (a, b, d) {
        cc.Control.prototype.ctor.call(this);
        void 0 != d && (a = new cc.Sprite(a), b = new cc.Sprite(b), d = new cc.Sprite(d), this.initWithSprites(a, b, d))
    },
    getValue: function () {
        return this._value
    },
    setValue: function (a) {
        a = Math.max(a, this._minimumValue);
        this._value = a = Math.min(a, this._maximumValue);
        this.needsLayout();
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getMinimumValue: function () {
        return this._minimumValue
    },
    setMinimumValue: function (a) {
        this._minimumAllowedValue = this._minimumValue = a;
        this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1);
        this.setValue(this._value)
    },
    getMaximumValue: function () {
        return this._maximumValue
    },
    setMaximumValue: function (a) {
        this._maximumAllowedValue = this._maximumValue = a;
        this._maximumValue <= this._minimumValue && (this._minimumValue =
            this._maximumValue - 1);
        this.setValue(this._value)
    },
    isTouchInside: function (a) {
        a = a.getLocation();
        a = this.getParent().convertToNodeSpace(a);
        var b = this.getBoundingBox();
        b.width += this._thumbSprite.getContentSize().width;
        b.x -= this._thumbSprite.getContentSize().width / 2;
        return cc.rectContainsPoint(b, a)
    },
    locationFromTouch: function (a) {
        a = a.getLocation();
        a = this.convertToNodeSpace(a);
        0 > a.x ? a.x = 0 : a.x > this._backgroundSprite.getContentSize().width && (a.x = this._backgroundSprite.getContentSize().width);
        return a
    },
    getMinimumAllowedValue: function () {
        return this._minimumAllowedValue
    },
    setMinimumAllowedValue: function (a) {
        this._minimumAllowedValue = a
    },
    getMaximumAllowedValue: function () {
        return this._maximumAllowedValue
    },
    setMaximumAllowedValue: function (a) {
        this._maximumAllowedValue = a
    },
    getThumbSprite: function () {
        return this._thumbSprite
    },
    getProgressSprite: function () {
        return this._progressSprite
    },
    getBackgroundSprite: function () {
        return this._backgroundSprite
    },
    initWithSprites: function (a, b, d) {
        return cc.Control.prototype.init.call(this) ? (this.ignoreAnchorPointForPosition(!1), this._backgroundSprite =
            a, this._progressSprite = b, this._thumbSprite = d, a = cc.ControlUtils.CCRectUnion(a.getBoundingBox(), d.getBoundingBox()), this.setContentSize(a.width, a.height), this._backgroundSprite.setAnchorPoint(0.5, 0.5), this._backgroundSprite.setPosition(a.width / 2, a.height / 2), this.addChild(this._backgroundSprite), this._progressSprite.setAnchorPoint(0, 0.5), this._progressSprite.setPosition(0, a.height / 2), this.addChild(this._progressSprite), this._thumbSprite.setPosition(0, a.height / 2), this.addChild(this._thumbSprite), this._minimumValue =
            0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1
    },
    setEnabled: function (a) {
        cc.Control.prototype.setEnabled.call(this, a);
        this._thumbSprite && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    sliderBegan: function (a) {
        this.setSelected(!0);
        this._thumbSprite.setColor(cc.color.GRAY);
        this.setValue(this.valueForLocation(a))
    },
    sliderMoved: function (a) {
        this.setValue(this.valueForLocation(a))
    },
    sliderEnded: function (a) {
        this.isSelected() && this.setValue(this.valueForLocation(this._thumbSprite.getPosition()));
        this._thumbSprite.setColor(cc.color.WHITE);
        this.setSelected(!1)
    },
    getTouchLocationInControl: function (a) {
        a = a.getLocation();
        a = this.convertToNodeSpace(a);
        0 > a.x ? a.x = 0 : a.x > this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H && (a.x = this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H);
        return a
    },
    onTouchBegan: function (a, b) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible())return !1;
        var d = this.locationFromTouch(a);
        this.sliderBegan(d);
        return !0
    },
    onTouchMoved: function (a, b) {
        var d = this.locationFromTouch(a);
        this.sliderMoved(d)
    },
    onTouchEnded: function (a, b) {
        this.sliderEnded(cc.p(0, 0))
    },
    needsLayout: function () {
        this._thumbSprite.setPositionX((this._value - this._minimumValue) / (this._maximumValue - this._minimumValue) * this._backgroundSprite.getContentSize().width);
        var a = this._progressSprite.getTextureRect(), a = cc.rect(a.x, a.y, this._thumbSprite.getPositionX(), a.height);
        this._progressSprite.setTextureRect(a, this._progressSprite.isTextureRectRotated());
        this._thumbSprite._renderCmd.transform(this._renderCmd)
    },
    valueForLocation: function (a) {
        a =
            a.x / this._backgroundSprite.getContentSize().width;
        return Math.max(Math.min(this._minimumValue + a * (this._maximumValue - this._minimumValue), this._maximumAllowedValue), this._minimumAllowedValue)
    }
});
_p = cc.ControlSlider.prototype;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
cc.defineGetterSetter(_p, "minAllowedValue", _p.getMinimumAllowedValue, _p.setMinimumAllowedValue);
cc.defineGetterSetter(_p, "maxAllowedValue", _p.getMaximumAllowedValue, _p.setMaximumAllowedValue);
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite);
cc.defineGetterSetter(_p, "progressSprite", _p.getProgressSprite);
cc.defineGetterSetter(_p, "backgroundSprite", _p.getBackgroundSprite);
_p = null;
cc.ControlSlider.create = function (a, b, d) {
    return new cc.ControlSlider(a, b, d)
};
cc.ControlSwitch = cc.Control.extend({
    _switchSprite: null,
    _initialTouchXPosition: 0,
    _moved: !1,
    _on: !1,
    _className: "ControlSwitch",
    ctor: function (a, b, d, e, f, g) {
        cc.Control.prototype.ctor.call(this);
        g && this.initWithMaskSprite(a, b, d, e, f, g)
    },
    initWithMaskSprite: function (a, b, d, e, f, g) {
        if (!a)throw Error("cc.ControlSwitch.initWithMaskSprite(): maskSprite should be non-null.");
        if (!b)throw Error("cc.ControlSwitch.initWithMaskSprite(): onSprite should be non-null.");
        if (!d)throw Error("cc.ControlSwitch.initWithMaskSprite(): offSprite should be non-null.");
        if (!e)throw Error("cc.ControlSwitch.initWithMaskSprite(): thumbSprite should be non-null.");
        return this.init() ? (this._on = !0, this._switchSprite = new cc.ControlSwitchSprite, this._switchSprite.initWithMaskSprite(a, b, d, e, f, g), this._switchSprite.setPosition(this._switchSprite.getContentSize().width / 2, this._switchSprite.getContentSize().height / 2), this.addChild(this._switchSprite), this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(0.5, 0.5), this.setContentSize(this._switchSprite.getContentSize()), !0) :
            !1
    },
    setOn: function (a, b) {
        b = b || !1;
        var d = (this._on = a) ? this._switchSprite.getOnPosition() : this._switchSprite.getOffPosition();
        b ? this._switchSprite.runAction(new cc.ActionTween(0.2, "sliderXPosition", this._switchSprite.getSliderXPosition(), d)) : this._switchSprite.setSliderXPosition(d);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    isOn: function () {
        return this._on
    },
    hasMoved: function () {
        return this._moved
    },
    setEnabled: function (a) {
        this._enabled = a;
        this._switchSprite.setOpacity(a ? 255 : 128)
    },
    locationFromTouch: function (a) {
        a =
            a.getLocation();
        return a = this.convertToNodeSpace(a)
    },
    onTouchBegan: function (a, b) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible())return !1;
        this._moved = !1;
        this._initialTouchXPosition = this.locationFromTouch(a).x - this._switchSprite.getSliderXPosition();
        this._switchSprite.getThumbSprite().setColor(cc.color.GRAY);
        this._switchSprite.needsLayout();
        return !0
    },
    onTouchMoved: function (a, b) {
        var d = this.locationFromTouch(a), d = cc.p(d.x - this._initialTouchXPosition, 0);
        this._moved = !0;
        this._switchSprite.setSliderXPosition(d.x)
    },
    onTouchEnded: function (a, b) {
        var d = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE);
        this.hasMoved() ? this.setOn(!(d.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    },
    onTouchCancelled: function (a, b) {
        var d = this.locationFromTouch(a);
        this._switchSprite.getThumbSprite().setColor(cc.color.WHITE);
        this.hasMoved() ? this.setOn(!(d.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0)
    }
});
cc.ControlSwitch.create = function (a, b, d, e, f, g) {
    return new cc.ControlSwitch(a, b, d, e, f, g)
};
cc.ControlSwitchSprite = cc.Sprite.extend({
    _sliderXPosition: 0,
    _onPosition: 0,
    _offPosition: 0,
    _textureLocation: 0,
    _maskLocation: 0,
    _maskSize: null,
    _onSprite: null,
    _offSprite: null,
    _thumbSprite: null,
    _onLabel: null,
    _offLabel: null,
    _clipper: null,
    _stencil: null,
    _backRT: null,
    ctor: function () {
        cc.Sprite.prototype.ctor.call(this);
        this._maskLocation = this._offPosition = this._onPosition = this._sliderXPosition = 0;
        this._maskSize = cc.size(0, 0);
        this._offLabel = this._onLabel = this._thumbSprite = this._offSprite = this._onSprite = null
    },
    initWithMaskSprite: function (a,
                                  b, d, e, f, g) {
        return cc.Sprite.prototype.init.call(this) ? (this.setSpriteFrame(a.displayFrame()), this._onPosition = 0, this._offPosition = -b.getContentSize().width + e.getContentSize().width / 2, this._sliderXPosition = this._onPosition, this.setOnSprite(b), this.setOffSprite(d), this.setThumbSprite(e), this.setOnLabel(f), this.setOffLabel(g), this._stencil = a, a = this._maskSize = this._stencil.getContentSize(), this._stencil.setPosition(0, 0), this._clipper = new cc.ClippingNode, this._clipper.setAnchorPoint(0.5, 0.5), this._clipper.setPosition(a.width /
            2, a.height / 2), this._clipper.setStencil(this._stencil), this.addChild(this._clipper), this._clipper.addChild(b), this._clipper.addChild(d), this._clipper.addChild(f), this._clipper.addChild(g), this.addChild(this._thumbSprite), this.needsLayout(), !0) : !1
    },
    needsLayout: function () {
        var a = this._maskSize;
        this._onSprite.setPosition(this._onSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._onSprite.getContentSize().height / 2 - a.height / 2);
        this._offSprite.setPosition(this._onSprite.getContentSize().width +
            this._offSprite.getContentSize().width / 2 + this._sliderXPosition - a.width / 2, this._offSprite.getContentSize().height / 2 - a.height / 2);
        this._onLabel && this._onLabel.setPosition(this._onSprite.getPositionX() - this._thumbSprite.getContentSize().width / 6, this._onSprite.getContentSize().height / 2 - a.height / 2);
        this._offLabel && this._offLabel.setPosition(this._offSprite.getPositionX() + this._thumbSprite.getContentSize().width / 6, this._offSprite.getContentSize().height / 2 - a.height / 2);
        this._thumbSprite.setPosition(this._onSprite.getContentSize().width +
            this._sliderXPosition, this._maskSize.height / 2)
    },
    setSliderXPosition: function (a) {
        a <= this._offPosition ? a = this._offPosition : a >= this._onPosition && (a = this._onPosition);
        this._sliderXPosition = a;
        this.needsLayout()
    },
    getSliderXPosition: function () {
        return this._sliderXPosition
    },
    _getOnSideWidth: function () {
        return this._onSprite.getContentSize().width
    },
    _getOffSideWidth: function () {
        return this._offSprite.getContentSize().height
    },
    updateTweenAction: function (a, b) {
        "sliderXPosition" === b && this.setSliderXPosition(a)
    },
    setOnPosition: function (a) {
        this._onPosition =
            a
    },
    getOnPosition: function () {
        return this._onPosition
    },
    setOffPosition: function (a) {
        this._offPosition = a
    },
    getOffPosition: function () {
        return this._offPosition
    },
    setMaskTexture: function (a) {
        this._stencil.setTexture(a)
    },
    getMaskTexture: function () {
        return this._stencil.getTexture()
    },
    setTextureLocation: function (a) {
        this._textureLocation = a
    },
    getTextureLocation: function () {
        return this._textureLocation
    },
    setMaskLocation: function (a) {
        this._maskLocation = a
    },
    getMaskLocation: function () {
        return this._maskLocation
    },
    setOnSprite: function (a) {
        this._onSprite =
            a
    },
    getOnSprite: function () {
        return this._onSprite
    },
    setOffSprite: function (a) {
        this._offSprite = a
    },
    getOffSprite: function () {
        return this._offSprite
    },
    setThumbSprite: function (a) {
        this._thumbSprite = a
    },
    getThumbSprite: function () {
        return this._thumbSprite
    },
    setOnLabel: function (a) {
        this._onLabel = a
    },
    getOnLabel: function () {
        return this._onLabel
    },
    setOffLabel: function (a) {
        this._offLabel = a
    },
    getOffLabel: function () {
        return this._offLabel
    }
});
_p = cc.ControlSwitchSprite.prototype;
cc.defineGetterSetter(_p, "sliderX", _p.getSliderXPosition, _p.setSliderXPosition);
cc.defineGetterSetter(_p, "onPos", _p.getOnPosition, _p.setOnPosition);
cc.defineGetterSetter(_p, "offPos", _p.getOffPosition, _p.setOffPosition);
cc.defineGetterSetter(_p, "maskTexture", _p.getMaskTexture, _p.setMaskTexture);
cc.defineGetterSetter(_p, "maskPos", _p.getMaskLocation, _p.setMaskLocation);
cc.defineGetterSetter(_p, "onSprite", _p.getOnSprite, _p.setOnSprite);
cc.defineGetterSetter(_p, "offSprite", _p.getOffSprite, _p.setOffSprite);
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
cc.defineGetterSetter(_p, "onLabel", _p.getOnLabel, _p.setOnLabel);
cc.defineGetterSetter(_p, "offLabel", _p.getOffLabel, _p.setOffLabel);
cc.defineGetterSetter(_p, "onSideWidth", _p._getOnSideWidth);
cc.defineGetterSetter(_p, "offSideWidth", _p._getOffSideWidth);
_p = null;
cc.CONTROL_STEPPER_PARTMINUS = 0;
cc.CONTROL_STEPPER_PARTPLUS = 1;
cc.CONTROL_STEPPER_PARTNONE = 2;
cc.CONTROL_STEPPER_LABELCOLOR_ENABLED = cc.color(55, 55, 55);
cc.CONTROL_STEPPER_LABELCOLOR_DISABLED = cc.color(147, 147, 147);
cc.CONTROL_STEPPER_LABELFONT = "CourierNewPSMT";
cc.AUTOREPEAT_DELTATIME = 0.15;
cc.AUTOREPEAT_INCREASETIME_INCREMENT = 12;
cc.ControlStepper = cc.Control.extend({
    _minusSprite: null,
    _plusSprite: null,
    _minusLabel: null,
    _plusLabel: null,
    _value: 0,
    _continuous: !1,
    _autorepeat: !1,
    _wraps: !1,
    _minimumValue: 0,
    _maximumValue: 0,
    _stepValue: 0,
    _touchInsideFlag: !1,
    _touchedPart: cc.CONTROL_STEPPER_PARTNONE,
    _autorepeatCount: 0,
    _className: "ControlStepper",
    ctor: function (a, b) {
        cc.Control.prototype.ctor.call(this);
        this._plusLabel = this._minusLabel = this._plusSprite = this._minusSprite = null;
        this._value = 0;
        this._wraps = this._autorepeat = this._continuous = !1;
        this._stepValue =
            this._maximumValue = this._minimumValue = 0;
        this._touchInsideFlag = !1;
        this._touchedPart = cc.CONTROL_STEPPER_PARTNONE;
        this._autorepeatCount = 0;
        b && this.initWithMinusSpriteAndPlusSprite(a, b)
    },
    initWithMinusSpriteAndPlusSprite: function (a, b) {
        if (!a)throw Error("cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Minus sprite should be non-null.");
        if (!b)throw Error("cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Plus sprite should be non-null.");
        if (this.init()) {
            this._continuous = this._autorepeat = !0;
            this._minimumValue =
                0;
            this._maximumValue = 100;
            this._value = 0;
            this._stepValue = 1;
            this._wraps = !1;
            this.ignoreAnchorPointForPosition(!1);
            this.setMinusSprite(a);
            this._minusSprite.setPosition(a.getContentSize().width / 2, a.getContentSize().height / 2);
            this.addChild(this._minusSprite);
            this.setMinusLabel(new cc.LabelTTF("-", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER));
            this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_DISABLED);
            this._minusLabel.setPosition(this._minusSprite.getContentSize().width /
                2, this._minusSprite.getContentSize().height / 2);
            this._minusSprite.addChild(this._minusLabel);
            this.setPlusSprite(b);
            this._plusSprite.setPosition(a.getContentSize().width + b.getContentSize().width / 2, a.getContentSize().height / 2);
            this.addChild(this._plusSprite);
            this.setPlusLabel(new cc.LabelTTF("+", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER));
            this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED);
            this._plusLabel.setPosition(this._plusSprite.getContentSize().width /
                2, this._plusSprite.getContentSize().height / 2);
            this._plusSprite.addChild(this._plusLabel);
            var d = cc.ControlUtils.CCRectUnion(this._minusSprite.getBoundingBox(), this._plusSprite.getBoundingBox());
            this.setContentSize(this._minusSprite.getContentSize().width + this._plusSprite.getContentSize().height, d.height);
            return !0
        }
        return !1
    },
    setWraps: function (a) {
        if (this._wraps = a)this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED);
        this.setValue(this._value)
    },
    getWraps: function () {
        return this._wraps
    },
    setMinimumValue: function (a) {
        if (a >= this._maximumValue)throw Error("cc.ControlStepper.setMinimumValue(): minimumValue should be numerically less than maximumValue.");
        this._minimumValue = a;
        this.setValue(this._value)
    },
    getMinimumValue: function () {
        return this._minimumValue
    },
    setMaximumValue: function (a) {
        if (a <= this._minimumValue)throw Error("cc.ControlStepper.setMaximumValue(): maximumValue should be numerically less than maximumValue.");
        this._maximumValue = a;
        this.setValue(this._value)
    },
    getMaximumValue: function () {
        return this._maximumValue
    },
    setValue: function (a) {
        this.setValueWithSendingEvent(a, !0)
    },
    getValue: function () {
        return this._value
    },
    setStepValue: function (a) {
        if (0 >= a)throw Error("cc.ControlStepper.setMaximumValue(): stepValue should be numerically greater than 0.");
        this._stepValue = a
    },
    getStepValue: function () {
        return this._stepValue
    },
    isContinuous: function () {
        return this._continuous
    },
    setValueWithSendingEvent: function (a, b) {
        a < this._minimumValue ? a = this._wraps ? this._maximumValue : this._minimumValue :
        a > this._maximumValue && (a = this._wraps ? this._minimumValue : this._maximumValue);
        this._value = a;
        this._wraps || (this._minusLabel.setColor(a === this._minimumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(a === this._maximumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED));
        b && this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    startAutorepeat: function () {
        this._autorepeatCount = -1;
        this.schedule(this.update,
            cc.AUTOREPEAT_DELTATIME, cc.REPEAT_FOREVER, 3 * cc.AUTOREPEAT_DELTATIME)
    },
    stopAutorepeat: function () {
        this.unschedule(this.update)
    },
    update: function (a) {
        this._autorepeatCount++;
        this._autorepeatCount < cc.AUTOREPEAT_INCREASETIME_INCREMENT && 0 !== this._autorepeatCount % 3 || (this._touchedPart === cc.CONTROL_STEPPER_PARTMINUS ? this.setValueWithSendingEvent(this._value - this._stepValue, this._continuous) : this._touchedPart === cc.CONTROL_STEPPER_PARTPLUS && this.setValueWithSendingEvent(this._value + this._stepValue, this._continuous))
    },
    updateLayoutUsingTouchLocation: function (a) {
        a.x < this._minusSprite.getContentSize().width && this._value > this._minimumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTMINUS, this._minusSprite.setColor(cc.color.GRAY), this._plusSprite.setColor(cc.color.WHITE)) : a.x >= this._minusSprite.getContentSize().width && this._value < this._maximumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTPLUS, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.GRAY)) : (this._touchedPart = cc.CONTROL_STEPPER_PARTNONE,
            this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE))
    },
    onTouchBegan: function (a, b) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible())return !1;
        var d = this.getTouchLocation(a);
        this.updateLayoutUsingTouchLocation(d);
        this._touchInsideFlag = !0;
        this._autorepeat && this.startAutorepeat();
        return !0
    },
    onTouchMoved: function (a, b) {
        if (this.isTouchInside(a)) {
            var d = this.getTouchLocation(a);
            this.updateLayoutUsingTouchLocation(d);
            this._touchInsideFlag || (this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat())
        } else this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat()
    },
    onTouchEnded: function (a, b) {
        this._minusSprite.setColor(cc.color.WHITE);
        this._plusSprite.setColor(cc.color.WHITE);
        this._autorepeat && this.stopAutorepeat();
        if (this.isTouchInside(a)) {
            var d = this.getTouchLocation(a);
            this.setValue(this._value + (d.x < this._minusSprite.getContentSize().width ?
                0 - this._stepValue : this._stepValue))
        }
    },
    setMinusSprite: function (a) {
        this._minusSprite = a
    },
    getMinusSprite: function () {
        return this._minusSprite
    },
    setPlusSprite: function (a) {
        this._plusSprite = a
    },
    getPlusSprite: function () {
        return this._plusSprite
    },
    setMinusLabel: function (a) {
        this._minusLabel = a
    },
    getMinusLabel: function () {
        return this._minusLabel
    },
    setPlusLabel: function (a) {
        this._plusLabel = a
    },
    getPlusLabel: function () {
        return this._plusLabel
    }
});
_p = cc.ControlStepper.prototype;
cc.defineGetterSetter(_p, "wraps", _p.getWraps, _p.setWraps);
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
cc.defineGetterSetter(_p, "stepValue", _p.getStepValue, _p.setStepValue);
cc.defineGetterSetter(_p, "continuous", _p.isContinuous);
cc.defineGetterSetter(_p, "minusSprite", _p.getMinusSprite, _p.setMinusSprite);
cc.defineGetterSetter(_p, "plusSprite", _p.getPlusSprite, _p.setPlusSprite);
cc.defineGetterSetter(_p, "minusLabel", _p.getMinusLabel, _p.setMinusLabel);
cc.defineGetterSetter(_p, "plusLabel", _p.getPlusLabel, _p.setPlusLabel);
_p = null;
cc.ControlStepper.create = function (a, b) {
    return new cc.ControlStepper(a, b)
};
cc.ControlPotentiometer = cc.Control.extend({
    _thumbSprite: null,
    _progressTimer: null,
    _previousLocation: null,
    _value: 0,
    _minimumValue: 0,
    _maximumValue: 1,
    _className: "ControlPotentiometer",
    ctor: function (a, b, d) {
        cc.Control.prototype.ctor.call(this);
        void 0 != d && (a = new cc.Sprite(a), d = new cc.Sprite(d), b = new cc.ProgressTimer(new cc.Sprite(b)), this.initWithTrackSprite_ProgressTimer_ThumbSprite(a, b, d))
    },
    initWithTrackSprite_ProgressTimer_ThumbSprite: function (a, b, d) {
        return this.init() ? (this.setProgressTimer(b), this.setThumbSprite(d),
            this._thumbSprite.setPosition(b.getPosition()), this.addChild(d, 2), this.addChild(b, 1), this.addChild(a), this.setContentSize(a.getContentSize()), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1
    },
    setEnabled: function (a) {
        this.setEnabled(a);
        null !== this._thumbSprite && this._thumbSprite.setOpacity(a ? 255 : 128)
    },
    setValue: function (a) {
        a < this._minimumValue && (a = this._minimumValue);
        a > this._maximumValue && (a = this._maximumValue);
        this._value = a;
        a = (a - this._minimumValue) / (this._maximumValue -
            this._minimumValue);
        this._progressTimer.setPercentage(100 * a);
        this._thumbSprite.setRotation(360 * a);
        this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED)
    },
    getValue: function () {
        return this._value
    },
    setMinimumValue: function (a) {
        this._minimumValue = a;
        this._minimumValue >= this._maximumValue && (this._maximumValue = this._minimumValue + 1);
        this.setValue(this._maximumValue)
    },
    getMinimumValue: function () {
        return this._minimumValue
    },
    setMaximumValue: function (a) {
        this._maximumValue = a;
        this._maximumValue <= this._minimumValue &&
        (this._minimumValue = this._maximumValue - 1);
        this.setValue(this._minimumValue)
    },
    getMaximumValue: function () {
        return this._maximumValue
    },
    isTouchInside: function (a) {
        a = this.getTouchLocation(a);
        return this.distanceBetweenPointAndPoint(this._progressTimer.getPosition(), a) < Math.min(this.getContentSize().width / 2, this.getContentSize().height / 2)
    },
    onTouchBegan: function (a, b) {
        if (!this.isTouchInside(a) || !this.isEnabled() || !this.isVisible())return !1;
        this._previousLocation = this.getTouchLocation(a);
        this.potentiometerBegan(this._previousLocation);
        return !0
    },
    onTouchMoved: function (a, b) {
        var d = this.getTouchLocation(a);
        this.potentiometerMoved(d)
    },
    onTouchEnded: function (a, b) {
        this.potentiometerEnded(cc.p(0, 0))
    },
    distanceBetweenPointAndPoint: function (a, b) {
        var d = a.x - b.x, e = a.y - b.y;
        return Math.sqrt(d * d + e * e)
    },
    angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint: function (a, b, d, e) {
        var f = e.x - d.x;
        d = e.y - d.y;
        a = Math.atan2(b.x - a.x, b.y - a.y);
        f = Math.atan2(f, d);
        return 180 * (a - f) / Math.PI
    },
    potentiometerBegan: function (a) {
        this.setSelected(!0);
        this.getThumbSprite().setColor(cc.color.GRAY)
    },
    potentiometerMoved: function (a) {
        var b = this.angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(this._progressTimer.getPosition(), a, this._progressTimer.getPosition(), this._previousLocation);
        180 < b ? b -= 360 : -180 > b && (b += 360);
        this.setValue(this._value + b / 360 * (this._maximumValue - this._minimumValue));
        this._previousLocation = a
    },
    potentiometerEnded: function (a) {
        this.getThumbSprite().setColor(cc.color.WHITE);
        this.setSelected(!1)
    },
    setThumbSprite: function (a) {
        this._thumbSprite = a
    },
    getThumbSprite: function () {
        return this._thumbSprite
    },
    setProgressTimer: function (a) {
        this._progressTimer = a
    },
    getProgressTimer: function () {
        return this._progressTimer
    },
    setPreviousLocation: function (a) {
        this._previousLocation = a
    },
    getPreviousLocation: function () {
        return this._previousLocation
    }
});
_p = cc.ControlPotentiometer.prototype;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
cc.defineGetterSetter(_p, "progressTimer", _p.getProgressTimer, _p.setProgressTimer);
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
cc.defineGetterSetter(_p, "prevLocation", _p.getPreviousLocation, _p.setPreviousLocation);
_p = null;
cc.ControlPotentiometer.create = function (a, b, d) {
    return new cc.ControlPotentiometer(a, b, d)
};
cc.SCROLLVIEW_DIRECTION_NONE = -1;
cc.SCROLLVIEW_DIRECTION_HORIZONTAL = 0;
cc.SCROLLVIEW_DIRECTION_VERTICAL = 1;
cc.SCROLLVIEW_DIRECTION_BOTH = 2;
var SCROLL_DEACCEL_RATE = 0.95, SCROLL_DEACCEL_DIST = 1, BOUNCE_DURATION = 0.15, INSET_RATIO = 0.2, MOVE_INCH = 0.04375, BOUNCE_BACK_FACTOR = 0.35;
cc.convertDistanceFromPointToInch = function (a) {
    var b = cc.view, b = (b.getScaleX() + b.getScaleY()) / 2;
    return a * b / 160
};
cc.ScrollViewDelegate = cc.Class.extend({
    scrollViewDidScroll: function (a) {
    }, scrollViewDidZoom: function (a) {
    }
});
cc.ScrollView = cc.Layer.extend({
    _zoomScale: 0,
    _minZoomScale: 0,
    _maxZoomScale: 0,
    _delegate: null,
    _direction: cc.SCROLLVIEW_DIRECTION_BOTH,
    _dragging: !1,
    _contentOffset: null,
    _container: null,
    _touchMoved: !1,
    _maxInset: null,
    _minInset: null,
    _bounceable: !1,
    _clippingToBounds: !1,
    _scrollDistance: null,
    _touchPoint: null,
    _touchLength: 0,
    _touches: null,
    _viewSize: null,
    _minScale: 0,
    _maxScale: 0,
    _parentScissorRect: null,
    _scissorRestored: !1,
    _tmpViewRect: null,
    _touchListener: null,
    _className: "ScrollView",
    ctor: function (a, b) {
        cc.Layer.prototype.ctor.call(this);
        this._contentOffset = cc.p(0, 0);
        this._maxInset = cc.p(0, 0);
        this._minInset = cc.p(0, 0);
        this._scrollDistance = cc.p(0, 0);
        this._touchPoint = cc.p(0, 0);
        this._touches = [];
        this._viewSize = cc.size(0, 0);
        this._parentScissorRect = new cc.Rect(0, 0, 0, 0);
        this._tmpViewRect = new cc.Rect(0, 0, 0, 0);
        void 0 != b ? this.initWithViewSize(a, b) : this.initWithViewSize(cc.size(200, 200), null)
    },
    init: function () {
        return this.initWithViewSize(cc.size(200, 200), null)
    },
    initWithViewSize: function (a, b) {
        var d = cc.p(0, 0);
        return cc.Layer.prototype.init.call(this) ?
            (b || this._container || (b = new cc.Layer), b && this.setContainer(b), this.setViewSize(a), this.setTouchEnabled(!0), this._touches.length = 0, this._delegate = null, this._clippingToBounds = this._bounceable = !0, this._direction = cc.SCROLLVIEW_DIRECTION_BOTH, this._container.setPosition(d), this._touchLength = 0, this._minScale = this._maxScale = 1, !0) : !1
    },
    setContentOffset: function (a, b) {
        if (b)this.setContentOffsetInDuration(a, BOUNCE_DURATION); else {
            if (!this._bounceable) {
                var d = this.minContainerOffset(), e = this.maxContainerOffset();
                a.x = Math.max(d.x, Math.min(e.x, a.x));
                a.y = Math.max(d.y, Math.min(e.y, a.y))
            }
            this._container.setPosition(a);
            d = this._delegate;
            null != d && d.scrollViewDidScroll && d.scrollViewDidScroll(this)
        }
    },
    getContentOffset: function () {
        var a = this._container.getPosition();
        return cc.p(a.x, a.y)
    },
    setContentOffsetInDuration: function (a, b) {
        var d = cc.moveTo(b, a), e = cc.callFunc(this._stoppedAnimatedScroll, this);
        this._container.runAction(cc.sequence(d, e));
        this.schedule(this._performedAnimatedScroll)
    },
    setZoomScale: function (a, b) {
        if (b)this.setZoomScaleInDuration(a,
            BOUNCE_DURATION); else {
            var d = this._container;
            if (d.getScale() !== a) {
                var e, f;
                0 === this._touchLength ? (f = this._viewSize, f = cc.p(0.5 * f.width, 0.5 * f.height), f = this.convertToWorldSpace(f)) : f = this._touchPoint;
                e = d.convertToNodeSpace(f);
                d.setScale(Math.max(this._minScale, Math.min(this._maxScale, a)));
                e = d.convertToWorldSpace(e);
                f = cc.pSub(f, e);
                this._delegate && this._delegate.scrollViewDidZoom && this._delegate.scrollViewDidZoom(this);
                this.setContentOffset(cc.pAdd(d.getPosition(), f))
            }
        }
    },
    getZoomScale: function () {
        return this._container.getScale()
    },
    setZoomScaleInDuration: function (a, b) {
        if (0 < b) {
            var d = this._container.getScale();
            d !== a && (d = cc.actionTween(b, "zoomScale", d, a), this.runAction(d))
        } else this.setZoomScale(a)
    },
    minContainerOffset: function () {
        var a = this._container, b = a.getContentSize(), d = this._viewSize;
        return cc.p(d.width - b.width * a.getScaleX(), d.height - b.height * a.getScaleY())
    },
    maxContainerOffset: function () {
        return cc.p(0, 0)
    },
    isNodeVisible: function (a) {
        var b = this.getContentOffset(), d = this.getViewSize(), e = this.getZoomScale(), b = cc.rect(-b.x / e, -b.y /
            e, d.width / e, d.height / e);
        return cc.rectIntersectsRect(b, a.getBoundingBox())
    },
    pause: function (a) {
        this._container.pause();
        a = this._container.getChildren();
        for (var b = 0; b < a.length; b++)a[b].pause();
        this._super()
    },
    resume: function (a) {
        a = this._container.getChildren();
        for (var b = 0, d = a.length; b < d; b++)a[b].resume();
        this._container.resume();
        this._super()
    },
    isDragging: function () {
        return this._dragging
    },
    isTouchMoved: function () {
        return this._touchMoved
    },
    isBounceable: function () {
        return this._bounceable
    },
    setBounceable: function (a) {
        this._bounceable =
            a
    },
    getViewSize: function () {
        return this._viewSize
    },
    setViewSize: function (a) {
        this._viewSize = a;
        cc.Node.prototype.setContentSize.call(this, a)
    },
    getContainer: function () {
        return this._container
    },
    setContainer: function (a) {
        a && (this.removeAllChildren(!0), this._container = a, a.ignoreAnchorPointForPosition(!1), a.setAnchorPoint(0, 0), this.addChild(a), this.setViewSize(this._viewSize))
    },
    getDirection: function () {
        return this._direction
    },
    setDirection: function (a) {
        this._direction = a
    },
    getDelegate: function () {
        return this._delegate
    },
    setDelegate: function (a) {
        this._delegate = a
    },
    onTouchBegan: function (a, b) {
        for (var d = this; null != d; d = d.parent)if (!d.isVisible())return !1;
        var d = this._getViewRect(), e = this._container, f = e.convertToWorldSpace(e.convertTouchToNodeSpace(a)), g = this._touches;
        if (2 < g.length || this._touchMoved || !cc.rectContainsPoint(d, f))return !1;
        g.push(a);
        1 === g.length ? (this._touchPoint = this.convertTouchToNodeSpace(a), this._touchMoved = !1, this._dragging = !0, this._scrollDistance.x = 0, this._touchLength = this._scrollDistance.y = 0) : 2 === g.length &&
        (this._touchPoint = cc.pMidpoint(this.convertTouchToNodeSpace(g[0]), this.convertTouchToNodeSpace(g[1])), this._touchLength = cc.pDistance(e.convertTouchToNodeSpace(g[0]), e.convertTouchToNodeSpace(g[1])), this._dragging = !1);
        return !0
    },
    onTouchMoved: function (a, b) {
        if (this.isVisible())if (this.setNodeDirty(), 1 === this._touches.length && this._dragging) {
            this._touchMoved = !0;
            this._getViewRect();
            var d = this.convertTouchToNodeSpace(a), e = cc.pSub(d, this._touchPoint), f = 0, g = this._direction, h;
            if (g === cc.SCROLLVIEW_DIRECTION_VERTICAL)f =
                e.y, h = this._container.getPositionY(), this.minContainerOffset().y <= h && h <= this.maxContainerOffset().y || (e.y *= BOUNCE_BACK_FACTOR); else if (g === cc.SCROLLVIEW_DIRECTION_HORIZONTAL)f = e.x, h = this._container.getPositionX(), this.minContainerOffset().x <= h && h <= this.maxContainerOffset().x || (e.x *= BOUNCE_BACK_FACTOR); else {
                f = Math.sqrt(e.x * e.x + e.y * e.y);
                h = this._container.getPositionY();
                var n = this.minContainerOffset(), p = this.maxContainerOffset();
                n.y <= h && h <= p.y || (e.y *= BOUNCE_BACK_FACTOR);
                h = this._container.getPositionX();
                n.x <= h && h <= p.x || (e.x *= BOUNCE_BACK_FACTOR)
            }
            if (this._touchMoved || !(Math.abs(cc.convertDistanceFromPointToInch(f)) < MOVE_INCH))if (this._touchMoved || (e.x = 0, e.y = 0), this._touchPoint = d, this._touchMoved = !0, this._dragging) {
                switch (g) {
                    case cc.SCROLLVIEW_DIRECTION_VERTICAL:
                        e.x = 0;
                        break;
                    case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                        e.y = 0
                }
                f = this._container.getPosition();
                d = f.x + e.x;
                f = f.y + e.y;
                this._scrollDistance = e;
                this.setContentOffset(cc.p(d, f))
            }
        } else 2 !== this._touches.length || this._dragging || (e = cc.pDistance(this._container.convertTouchToNodeSpace(this._touches[0]),
            this._container.convertTouchToNodeSpace(this._touches[1])), this.setZoomScale(this.getZoomScale() * e / this._touchLength))
    },
    onTouchEnded: function (a, b) {
        this.isVisible() && (1 === this._touches.length && this._touchMoved && this.schedule(this._deaccelerateScrolling), this._touches.length = 0, this._touchMoved = this._dragging = !1)
    },
    onTouchCancelled: function (a, b) {
        this.isVisible() && (this._touches.length = 0, this._touchMoved = this._dragging = !1)
    },
    setContentSize: function (a, b) {
        null !== this.getContainer() && (void 0 === b ? this.getContainer().setContentSize(a) :
            this.getContainer().setContentSize(a, b), this.updateInset())
    },
    _setWidth: function (a) {
        var b = this.getContainer();
        null !== b && (b._setWidth(a), this.updateInset())
    },
    _setHeight: function (a) {
        var b = this.getContainer();
        null !== b && (b._setHeight(a), this.updateInset())
    },
    getContentSize: function () {
        return this._container.getContentSize()
    },
    updateInset: function () {
        if (null !== this.getContainer()) {
            var a = this._viewSize, b = this.maxContainerOffset();
            this._maxInset.x = b.x + a.width * INSET_RATIO;
            this._maxInset.y = b.y + a.height * INSET_RATIO;
            b = this.minContainerOffset();
            this._minInset.x = b.x - a.width * INSET_RATIO;
            this._minInset.y = b.y - a.height * INSET_RATIO
        }
    },
    isClippingToBounds: function () {
        return this._clippingToBounds
    },
    setClippingToBounds: function (a) {
        this._clippingToBounds = a
    },
    visit: function (a) {
        this.isVisible() && this._renderCmd.visit(a)
    },
    addChild: function (a, b, d) {
        if (!a)throw Error("child must not nil!");
        b = b || a.getLocalZOrder();
        d = d || a.getTag();
        this._container !== a ? this._container.addChild(a, b, d) : cc.Layer.prototype.addChild.call(this, a, b, d)
    },
    isTouchEnabled: function () {
        return null !==
            this._touchListener
    },
    setTouchEnabled: function (a) {
        this._touchListener && cc.eventManager.removeListener(this._touchListener);
        this._touchListener = null;
        a ? (a = cc.EventListener.create({event: cc.EventListener.TOUCH_ONE_BY_ONE}), this.onTouchBegan && (a.onTouchBegan = this.onTouchBegan.bind(this)), this.onTouchMoved && (a.onTouchMoved = this.onTouchMoved.bind(this)), this.onTouchEnded && (a.onTouchEnded = this.onTouchEnded.bind(this)), this.onTouchCancelled && (a.onTouchCancelled = this.onTouchCancelled.bind(this)), this._touchListener =
            a, cc.eventManager.addListener(a, this)) : (this._touchMoved = this._dragging = !1, this._touches.length = 0)
    },
    _initWithViewSize: function (a) {
        return null
    },
    _relocateContainer: function (a) {
        var b = this.minContainerOffset(), d = this.maxContainerOffset(), e = this._direction, f = this._container.getPosition(), g = f.x, h = f.y;
        if (e === cc.SCROLLVIEW_DIRECTION_BOTH || e === cc.SCROLLVIEW_DIRECTION_HORIZONTAL)g = Math.max(g, b.x), g = Math.min(g, d.x);
        if (e === cc.SCROLLVIEW_DIRECTION_BOTH || e === cc.SCROLLVIEW_DIRECTION_VERTICAL)h = Math.min(h, d.y), h =
            Math.max(h, b.y);
        h === f.y && g === f.x || this.setContentOffset(cc.p(g, h), a)
    },
    _deaccelerateScrolling: function (a) {
        if (this._dragging)this.unschedule(this._deaccelerateScrolling); else {
            var b, d;
            b = this._container.getPosition();
            a = this._scrollDistance;
            this._container.setPosition(b.x + a.x, b.y + a.y);
            this._bounceable ? (b = this._maxInset, d = this._minInset) : (b = this.maxContainerOffset(), d = this.minContainerOffset());
            var e = this._container.getPositionX(), f = this._container.getPositionY();
            a.x *= SCROLL_DEACCEL_RATE;
            a.y *= SCROLL_DEACCEL_RATE;
            this.setContentOffset(cc.p(e, f));
            if (Math.abs(a.x) <= SCROLL_DEACCEL_DIST && Math.abs(a.y) <= SCROLL_DEACCEL_DIST || f > b.y || f < d.y || e > b.x || e < d.x || e === b.x || e === d.x || f === b.y || f === d.y)this.unschedule(this._deaccelerateScrolling), this._relocateContainer(!0)
        }
    },
    _performedAnimatedScroll: function (a) {
        this._dragging ? this.unschedule(this._performedAnimatedScroll) : this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this)
    },
    _stoppedAnimatedScroll: function (a) {
        this.unschedule(this._performedAnimatedScroll);
        this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this)
    },
    _handleZoom: function () {
    },
    _getViewRect: function () {
        for (var a = this.convertToWorldSpace(cc.p(0, 0)), b = this._viewSize, d = this.getScaleX(), e = this.getScaleY(), f = this._parent; null != f; f = f.getParent())d *= f.getScaleX(), e *= f.getScaleY();
        0 > d && (a.x += b.width * d, d = -d);
        0 > e && (a.y += b.height * e, e = -e);
        f = this._tmpViewRect;
        f.x = a.x;
        f.y = a.y;
        f.width = b.width * d;
        f.height = b.height * e;
        return f
    },
    _createRenderCmd: function () {
        return cc._renderType ===
        cc.game.RENDER_TYPE_CANVAS ? new cc.ScrollView.CanvasRenderCmd(this) : new cc.ScrollView.WebGLRenderCmd(this)
    }
});
_p = cc.ScrollView.prototype;
cc.defineGetterSetter(_p, "minOffset", _p.minContainerOffset);
cc.defineGetterSetter(_p, "maxOffset", _p.maxContainerOffset);
cc.defineGetterSetter(_p, "bounceable", _p.isBounceable, _p.setBounceable);
cc.defineGetterSetter(_p, "viewSize", _p.getViewSize, _p.setViewSize);
cc.defineGetterSetter(_p, "container", _p.getContainer, _p.setContainer);
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
cc.defineGetterSetter(_p, "clippingToBounds", _p.isClippingToBounds, _p.setClippingToBounds);
_p = null;
cc.ScrollView.create = function (a, b) {
    return new cc.ScrollView(a, b)
};
(function () {
    cc.ScrollView.CanvasRenderCmd = function (a) {
        cc.Layer.CanvasRenderCmd.call(this, a);
        this._needDraw = !1;
        this.startCmd = new cc.CustomRenderCmd(this, this._startCmd);
        this.endCmd = new cc.CustomRenderCmd(this, this._endCmd)
    };
    var a = cc.ScrollView.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
    a.constructor = cc.ScrollView.CanvasRenderCmd;
    a._startCmd = function (a, d, e) {
        var f = this._node, g = a || cc._renderContext;
        a = g.getContext();
        g.save();
        if (f._clippingToBounds) {
            this._scissorRestored = !1;
            g.setTransform(this._worldTransform, d, e);
            var h = f.getScaleX(), g = f.getScaleY();
            d *= f._viewSize.width * h;
            e *= f._viewSize.height * g;
            a.beginPath();
            a.rect(0, 0, d, -e);
            a.closePath();
            a.clip()
        }
    };
    a._endCmd = function (a) {
        a = a || cc._renderContext;
        a.restore()
    };
    a.visit = function (a) {
        var d = this._node;
        if (d._visible) {
            var e = d._children;
            this.transform(a);
            cc.renderer.pushRenderCommand(this.startCmd);
            if (e && 0 < e.length)for (a = e.length, d.sortAllChildren(), d = 0; d < a; d++)e[d]._renderCmd.visit(this);
            cc.renderer.pushRenderCommand(this.endCmd)
        }
    }
})();
(function () {
    cc.ScrollView.WebGLRenderCmd = function (a) {
        cc.Layer.WebGLRenderCmd.call(this, a);
        this._needDraw = !1;
        this.startCmd = new cc.CustomRenderCmd(this, this._startCmd);
        this.endCmd = new cc.CustomRenderCmd(this, this._endCmd)
    };
    var a = cc.ScrollView.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
    a.constructor = cc.ScrollView.WebGLRenderCmd;
    a._startCmd = function () {
        var a = this._node, d = cc.view, e = a._getViewRect();
        if (d.isScissorEnabled()) {
            if (a._scissorRestored = !0, a._parentScissorRect = d.getScissorRect(),
                    cc.rectIntersection(e, a._parentScissorRect)) {
                var f = a._parentScissorRect, a = Math.max(e.x, f.x), g = Math.max(e.y, f.y), h = Math.min(e.x + e.width, f.x + f.width), e = Math.min(e.y + e.height, f.y + f.height);
                d.setScissorInPoints(a, g, h - a, e - g)
            }
        } else a = cc._renderContext, a.enable(a.SCISSOR_TEST), d.setScissorInPoints(e.x, e.y, e.width, e.height)
    };
    a._endCmd = function () {
        var a = this._node;
        a._scissorRestored ? (a = a._parentScissorRect, cc.view.setScissorInPoints(a.x, a.y, a.width, a.height)) : (a = cc._renderContext, a.disable(a.SCISSOR_TEST))
    };
    a.visit = function (a) {
        var d = this._node;
        if (d._visible) {
            var e = d._children, f, g;
            cc.kmGLPushMatrix();
            this.transform(a);
            d._clippingToBounds && cc.renderer.pushRenderCommand(this.startCmd);
            if (e && 0 < e.length) {
                g = e.length;
                for (a = 0; a < g; a++)if ((f = e[a]) && 0 > f._localZOrder)f._renderCmd.visit(); else break;
                for (; a < g; a++)e[a]._renderCmd.visit()
            }
            d._clippingToBounds && cc.renderer.pushRenderCommand(this.endCmd);
            this._dirtyFlag = 0;
            cc.kmGLPopMatrix()
        }
    }
})();
cc.SortableObject = cc.Class.extend({
    setObjectID: function (a) {
    }, getObjectID: function () {
        return 0
    }
});
cc.SortedObject = cc.SortableObject.extend({
    _objectID: 0, ctor: function () {
        this._objectID = 0
    }, setObjectID: function (a) {
        this._objectID = a
    }, getObjectID: function () {
        return this._objectID
    }
});
var _compareObject = function (a, b) {
    return a.getObjectID() - b.getObjectID()
};
cc.ArrayForObjectSorting = cc.Class.extend({
    _saveObjectArr: null, ctor: function () {
        this._saveObjectArr = []
    }, insertSortedObject: function (a) {
        if (!a)throw Error("cc.ArrayForObjectSorting.insertSortedObject(): addObject should be non-null.");
        var b = this.indexOfSortedObject(a);
        this.insertObject(a, b)
    }, removeSortedObject: function (a) {
        if (0 !== this.count()) {
            var b = this.indexOfSortedObject(a);
            b < this.count() && b !== cc.INVALID_INDEX && this.objectAtIndex(b).getObjectID() === a.getObjectID() && this.removeObjectAtIndex(b)
        }
    }, setObjectID_ofSortedObject: function (a,
                                             b) {
        var d = this.indexOfSortedObject(b);
        if (d < this.count() && d !== cc.INVALID_INDEX) {
            var e = this.objectAtIndex(d);
            e.getObjectID() === b.getObjectID() && (this.removeObjectAtIndex(d), e.setObjectID(a), this.insertSortedObject(e))
        }
    }, objectWithObjectID: function (a) {
        if (0 === this.count())return null;
        var b = new cc.SortedObject;
        b.setObjectID(a);
        var d = this.indexOfSortedObject(b);
        d < this.count() && d !== cc.INVALID_INDEX && (b = this.objectAtIndex(d), b.getObjectID() !== a && (b = null));
        return b
    }, getObjectWithObjectID: function (a) {
        return null
    },
    indexOfSortedObject: function (a) {
        var b = 0;
        if (a) {
            var d = 0;
            a = a.getObjectID();
            for (var e = this._saveObjectArr, f = 0; f < e.length; f++) {
                var g = e[f].getObjectID();
                if (a === g || a >= d && a < g)break;
                d = g;
                b++
            }
        } else b = cc.INVALID_INDEX;
        return b
    }, count: function () {
        return this._saveObjectArr.length
    }, lastObject: function () {
        var a = this._saveObjectArr;
        return 0 === a.length ? null : a[a.length - 1]
    }, objectAtIndex: function (a) {
        return this._saveObjectArr[a]
    }, addObject: function (a) {
        this._saveObjectArr.push(a);
        this._saveObjectArr.sort(_compareObject)
    },
    removeObjectAtIndex: function (a) {
        this._saveObjectArr.splice(a, 1);
        this._saveObjectArr.sort(_compareObject)
    }, insertObject: function (a, b) {
        this._saveObjectArr.splice(b, 0, a);
        this._saveObjectArr.sort(_compareObject)
    }
});
cc.TABLEVIEW_FILL_TOPDOWN = 0;
cc.TABLEVIEW_FILL_BOTTOMUP = 1;
cc.TableViewCell = cc.Node.extend({
    _idx: 0, _className: "TableViewCell", getIdx: function () {
        return this._idx
    }, setIdx: function (a) {
        this._idx = a
    }, reset: function () {
        this._idx = cc.INVALID_INDEX
    }, setObjectID: function (a) {
        this._idx = a
    }, getObjectID: function () {
        return this._idx
    }
});
_p = cc.TableViewCell.prototype;
cc.defineGetterSetter(_p, "objectId", _p.getObjectID, _p.setObjectID);
_p = null;
cc.TableViewDelegate = cc.ScrollViewDelegate.extend({
    tableCellTouched: function (a, b) {
    }, tableCellHighlight: function (a, b) {
    }, tableCellUnhighlight: function (a, b) {
    }, tableCellWillRecycle: function (a, b) {
    }
});
cc.TableViewDataSource = cc.Class.extend({
    tableCellSizeForIndex: function (a, b) {
        return this.cellSizeForTable(a)
    }, cellSizeForTable: function (a) {
        return cc.size(0, 0)
    }, tableCellAtIndex: function (a, b) {
        return null
    }, numberOfCellsInTableView: function (a) {
        return 0
    }
});
cc.TableView = cc.ScrollView.extend({
    _vOrdering: null,
    _indices: null,
    _cellsFreed: null,
    _dataSource: null,
    _tableViewDelegate: null,
    _oldDirection: null,
    _cellsPositions: null,
    _touchedCell: null,
    ctor: function (a, b, d) {
        cc.ScrollView.prototype.ctor.call(this);
        this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
        this._cellsPositions = [];
        this.initWithViewSize(b, d);
        this.setDataSource(a);
        this._updateCellPositions();
        this._updateContentSize()
    },
    __indexFromOffset: function (a) {
        var b = 0, d = this._dataSource.numberOfCellsInTableView(this) -
            1;
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = a.x;
                break;
            default:
                a = a.y
        }
        for (var e = this._cellsPositions; d >= b;) {
            var f = 0 | b + (d - b) / 2, g = e[f], h = e[f + 1];
            if (a >= g && a <= h)return f;
            a < g ? d = f - 1 : b = f + 1
        }
        return 0 >= b ? 0 : -1
    },
    _indexFromOffset: function (a) {
        var b = {x: a.x, y: a.y};
        a = this._dataSource.numberOfCellsInTableView(this) - 1;
        this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (b.y = this.getContainer().getContentSize().height - b.y);
        b = this.__indexFromOffset(b);
        -1 !== b && (b = Math.max(0, b), b > a && (b = cc.INVALID_INDEX));
        return b
    },
    __offsetFromIndex: function (a) {
        switch (this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = cc.p(this._cellsPositions[a], 0);
                break;
            default:
                a = cc.p(0, this._cellsPositions[a])
        }
        return a
    },
    _offsetFromIndex: function (a) {
        var b = this.__offsetFromIndex(a);
        a = this._dataSource.tableCellSizeForIndex(this, a);
        this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (b.y = this.getContainer().getContentSize().height - b.y - a.height);
        return b
    },
    _updateCellPositions: function () {
        var a = this._dataSource.numberOfCellsInTableView(this),
            b = this._cellsPositions;
        if (0 < a) {
            for (var d = 0, e, f = this._dataSource, g = 0; g < a; g++)switch (b[g] = d, e = f.tableCellSizeForIndex(this, g), this.getDirection()) {
                case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                    d += e.width;
                    break;
                default:
                    d += e.height
            }
            this._cellsPositions[a] = d
        }
    },
    _updateContentSize: function () {
        var a = cc.size(0, 0), b = this._dataSource.numberOfCellsInTableView(this);
        if (0 < b)switch (a = this._cellsPositions[b], this.getDirection()) {
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
                a = cc.size(a, this._viewSize.height);
                break;
            default:
                a =
                    cc.size(this._viewSize.width, a)
        }
        this.setContentSize(a);
        this._oldDirection !== this._direction && (this._direction === cc.SCROLLVIEW_DIRECTION_HORIZONTAL ? this.setContentOffset(cc.p(0, 0)) : this.setContentOffset(cc.p(0, this.minContainerOffset().y)), this._oldDirection = this._direction)
    },
    _moveCellOutOfSight: function (a) {
        this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, a);
        this._cellsFreed.addObject(a);
        this._cellsUsed.removeSortedObject(a);
        cc.arrayRemoveObject(this._indices,
            a.getIdx());
        a.reset();
        a.getParent() === this.getContainer() && this.getContainer().removeChild(a, !0)
    },
    _setIndexForCell: function (a, b) {
        b.setAnchorPoint(0, 0);
        b.setPosition(this._offsetFromIndex(a));
        b.setIdx(a)
    },
    _addCellIfNecessary: function (a) {
        a.getParent() !== this.getContainer() && this.getContainer().addChild(a);
        this._cellsUsed.insertSortedObject(a);
        var b = this._indices;
        a = a.getIdx();
        -1 === b.indexOf(a) && (b.push(a), b.sort(function (a, b) {
            return a - b
        }))
    },
    getDataSource: function () {
        return this._dataSource
    },
    setDataSource: function (a) {
        this._dataSource =
            a
    },
    getDelegate: function () {
        return this._tableViewDelegate
    },
    setDelegate: function (a) {
        this._tableViewDelegate = a
    },
    setVerticalFillOrder: function (a) {
        this._vOrdering !== a && (this._vOrdering = a, 0 < this._cellsUsed.count() && this.reloadData())
    },
    getVerticalFillOrder: function () {
        return this._vOrdering
    },
    initWithViewSize: function (a, b) {
        return cc.ScrollView.prototype.initWithViewSize.call(this, a, b) ? (this._cellsUsed = new cc.ArrayForObjectSorting, this._cellsFreed = new cc.ArrayForObjectSorting, this._indices = [], this._tableViewDelegate =
            null, this._vOrdering = cc.TABLEVIEW_FILL_BOTTOMUP, this.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL), cc.ScrollView.prototype.setDelegate.call(this, this), !0) : !1
    },
    updateCellAtIndex: function (a) {
        if (!(a === cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b = this.cellAtIndex(a);
            b && this._moveCellOutOfSight(b);
            b = this._dataSource.tableCellAtIndex(this, a);
            this._setIndexForCell(a, b);
            this._addCellIfNecessary(b)
        }
    },
    insertCellAtIndex: function (a) {
        if (!(a === cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) -
            1)) {
            var b, d = this._cellsUsed;
            if (b = d.objectWithObjectID(a))for (var e = b = d.indexOfSortedObject(b); e < d.count(); e++)b = d.objectAtIndex(e), this._setIndexForCell(b.getIdx() + 1, b);
            b = this._dataSource.tableCellAtIndex(this, a);
            this._setIndexForCell(a, b);
            this._addCellIfNecessary(b);
            this._updateCellPositions();
            this._updateContentSize()
        }
    },
    removeCellAtIndex: function (a) {
        if (!(a === cc.INVALID_INDEX || a > this._dataSource.numberOfCellsInTableView(this) - 1)) {
            var b = this.cellAtIndex(a);
            if (b) {
                var d = this._cellsUsed, e = d.indexOfSortedObject(b);
                this._moveCellOutOfSight(b);
                cc.arrayRemoveObject(this._indices, a);
                this._updateCellPositions();
                for (a = d.count() - 1; a > e; a--)b = d.objectAtIndex(a), this._setIndexForCell(b.getIdx() - 1, b)
            }
        }
    },
    reloadData: function () {
        this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
        for (var a = this._cellsUsed, b = this._cellsFreed, d = this.getContainer(), e = 0, f = a.count(); e < f; e++) {
            var g = a.objectAtIndex(e);
            this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, g);
            b.addObject(g);
            g.reset();
            g.getParent() === d && d.removeChild(g, !0)
        }
        this._indices = [];
        this._cellsUsed = new cc.ArrayForObjectSorting;
        this._updateCellPositions();
        this._updateContentSize();
        0 < this._dataSource.numberOfCellsInTableView(this) && this.scrollViewDidScroll(this)
    },
    dequeueCell: function () {
        if (0 === this._cellsFreed.count())return null;
        var a = this._cellsFreed.objectAtIndex(0);
        this._cellsFreed.removeObjectAtIndex(0);
        return a
    },
    cellAtIndex: function (a) {
        return -1 === this._indices.indexOf(a) ? null : this._cellsUsed.objectWithObjectID(a)
    },
    scrollViewDidScroll: function (a) {
        var b = this._dataSource.numberOfCellsInTableView(this);
        if (0 !== b) {
            null !== this._tableViewDelegate && this._tableViewDelegate.scrollViewDidScroll && this._tableViewDelegate.scrollViewDidScroll(this);
            var d = 0, e = this._viewSize, d = this.getContainer(), f = this.getContentOffset();
            f.x *= -1;
            f.y *= -1;
            var g = Math.max(b - 1, 0);
            this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (f.y += e.height / d.getScaleY());
            a = this._indexFromOffset(f);
            a === cc.INVALID_INDEX && (a = b - 1);
            f.y = this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN ?
            f.y - e.height / d.getScaleY() : f.y + e.height / d.getScaleY();
            f.x += e.width / d.getScaleX();
            e = this._indexFromOffset(f);
            e === cc.INVALID_INDEX && (e = b - 1);
            f = this._cellsUsed;
            if (0 < f.count())for (b = f.objectAtIndex(0), d = b.getIdx(); d < a;)if (this._moveCellOutOfSight(b), 0 < f.count())b = f.objectAtIndex(0), d = b.getIdx(); else break;
            if (0 < f.count())for (b = f.lastObject(), d = b.getIdx(); d <= g && d > e;)if (this._moveCellOutOfSight(b), 0 < f.count())b = f.lastObject(), d = b.getIdx(); else break;
            for (g = this._indices; a <= e; a++)-1 === g.indexOf(a) && this.updateCellAtIndex(a)
        }
    },
    scrollViewDidZoom: function (a) {
    },
    onTouchEnded: function (a, b) {
        if (this.isVisible()) {
            if (this._touchedCell) {
                var d = this.getBoundingBox(), e = cc.p(d.x, d.y), e = this._parent.convertToWorldSpace(e);
                d.x = e.x;
                d.y = e.y;
                e = this._tableViewDelegate;
                cc.rectContainsPoint(d, a.getLocation()) && null !== e && (e.tableCellUnhighlight && e.tableCellUnhighlight(this, this._touchedCell), e.tableCellTouched && e.tableCellTouched(this, this._touchedCell));
                this._touchedCell = null
            }
            cc.ScrollView.prototype.onTouchEnded.call(this, a, b)
        }
    },
    onTouchBegan: function (a,
                            b) {
        for (var d = this; null != d; d = d.parent)if (!d.isVisible())return !1;
        d = cc.ScrollView.prototype.onTouchBegan.call(this, a, b);
        if (1 === this._touches.length) {
            var e;
            e = this.getContainer().convertTouchToNodeSpace(a);
            e = this._indexFromOffset(e);
            (this._touchedCell = e === cc.INVALID_INDEX ? null : this.cellAtIndex(e)) && null !== this._tableViewDelegate && this._tableViewDelegate.tableCellHighlight && this._tableViewDelegate.tableCellHighlight(this, this._touchedCell)
        } else this._touchedCell && (null !== this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight &&
        this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null);
        return d
    },
    onTouchMoved: function (a, b) {
        cc.ScrollView.prototype.onTouchMoved.call(this, a, b);
        this._touchedCell && this.isTouchMoved() && (null !== this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    },
    onTouchCancelled: function (a, b) {
        cc.ScrollView.prototype.onTouchCancelled.call(this, a, b);
        this._touchedCell &&
        (null !== this._tableViewDelegate && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null)
    }
});
_p = cc.TableView.prototype;
cc.defineGetterSetter(_p, "dataSource", _p.getDataSource, _p.setDataSource);
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
cc.defineGetterSetter(_p, "verticalFillOrder", _p.getVerticalFillOrder, _p.setVerticalFillOrder);
_p = null;
cc.TableView.create = function (a, b, d) {
    return new cc.TableView(a, b, d)
};
var PROPERTY_POSITION = "position", PROPERTY_CONTENTSIZE = "contentSize", PROPERTY_SKEW = "skew", PROPERTY_ANCHORPOINT = "anchorPoint", PROPERTY_SCALE = "scale", PROPERTY_ROTATION = "rotation", PROPERTY_TAG = "tag", PROPERTY_IGNOREANCHORPOINTFORPOSITION = "ignoreAnchorPointForPosition", PROPERTY_VISIBLE = "visible", ASSERT_FAIL_UNEXPECTED_PROPERTY = function (a) {
    cc.log("Unexpected property: '" + a + "'!")
}, ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE = function (a) {
    cc.log("Unexpected property type: '" + a + "'!")
};
function BlockData(a, b) {
    this.selMenuHander = a;
    this.target = b
}
function BlockCCControlData(a, b, d) {
    this.selCCControlHandler = a;
    this.target = b;
    this.controlEvents = d
}
cc.NodeLoader = cc.Class.extend({
    _customProperties: null, ctor: function () {
        this._customProperties = new cc._Dictionary
    }, loadCCNode: function (a, b) {
        return this._createCCNode(a, b)
    }, parseProperties: function (a, b, d) {
        for (var e = d.readInt(!1), f = d.readInt(!1), f = e + f, g = 0; g < f; g++) {
            var h = g >= e, n = d.readInt(!1), p = d.readCachedString(), r = !1, s = d.readByte();
            if (s === CCB_PLATFORM_ALL || s === CCB_PLATFORM_IOS || s === CCB_PLATFORM_MAC)r = !0;
            a instanceof cc.BuilderFile ? a.getCCBFileNode() && h && (a = a.getCCBFileNode(), r = -1 !== a.userObject.indexOf(p)) :
            h && a === d.getAnimationManager().getRootNode() && (h = a.userObject, h || (h = [], a.userObject = h), h.push(p));
            switch (n) {
                case CCB_PROPTYPE_POSITION:
                    n = this.parsePropTypePosition(a, b, d, p);
                    if (r)this.onHandlePropTypePosition(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_POINT:
                    n = this.parsePropTypePoint(a, b, d);
                    if (r)this.onHandlePropTypePoint(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_POINTLOCK:
                    n = this.parsePropTypePointLock(a, b, d);
                    if (r)this.onHandlePropTypePointLock(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_SIZE:
                    n = this.parsePropTypeSize(a, b,
                        d);
                    if (r)this.onHandlePropTypeSize(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_SCALELOCK:
                    n = this.parsePropTypeScaleLock(a, b, d, p);
                    if (r)this.onHandlePropTypeScaleLock(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_FLOATXY:
                    n = this.parsePropTypeFloatXY(a, b, d);
                    if (r)this.onHandlePropTypeFloatXY(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_FLOAT:
                    n = this.parsePropTypeFloat(a, b, d);
                    if (r)this.onHandlePropTypeFloat(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_DEGREES:
                    n = this.parsePropTypeDegrees(a, b, d, p);
                    if (r)this.onHandlePropTypeDegrees(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_FLOATSCALE:
                    n = this.parsePropTypeFloatScale(a, b, d);
                    if (r)this.onHandlePropTypeFloatScale(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_INTEGER:
                    n = this.parsePropTypeInteger(a, b, d);
                    if (r)this.onHandlePropTypeInteger(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_INTEGERLABELED:
                    n = this.parsePropTypeIntegerLabeled(a, b, d);
                    if (r)this.onHandlePropTypeIntegerLabeled(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_FLOATVAR:
                    n = this.parsePropTypeFloatVar(a, b, d);
                    if (r)this.onHandlePropTypeFloatVar(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_CHECK:
                    n =
                        this.parsePropTypeCheck(a, b, d, p);
                    if (r)this.onHandlePropTypeCheck(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_SPRITEFRAME:
                    n = this.parsePropTypeSpriteFrame(a, b, d, p);
                    if (r)this.onHandlePropTypeSpriteFrame(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_ANIMATION:
                    n = this.parsePropTypeAnimation(a, b, d);
                    if (r)this.onHandlePropTypeAnimation(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_TEXTURE:
                    n = this.parsePropTypeTexture(a, b, d);
                    if (r)this.onHandlePropTypeTexture(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_BYTE:
                    n = this.parsePropTypeByte(a, b, d, p);
                    if (r)this.onHandlePropTypeByte(a,
                        b, p, n, d);
                    break;
                case CCB_PROPTYPE_COLOR3:
                    n = this.parsePropTypeColor3(a, b, d, p);
                    if (r)this.onHandlePropTypeColor3(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_COLOR4VAR:
                    n = this.parsePropTypeColor4FVar(a, b, d);
                    if (r)this.onHandlePropTypeColor4FVar(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_FLIP:
                    n = this.parsePropTypeFlip(a, b, d);
                    if (r)this.onHandlePropTypeFlip(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_BLENDMODE:
                    n = this.parsePropTypeBlendFunc(a, b, d);
                    if (r)this.onHandlePropTypeBlendFunc(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_FNTFILE:
                    n = d.getCCBRootPath() +
                        this.parsePropTypeFntFile(a, b, d);
                    if (r)this.onHandlePropTypeFntFile(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_FONTTTF:
                    n = this.parsePropTypeFontTTF(a, b, d);
                    if (r)this.onHandlePropTypeFontTTF(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_STRING:
                    n = this.parsePropTypeString(a, b, d);
                    if (r)this.onHandlePropTypeString(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_TEXT:
                    n = this.parsePropTypeText(a, b, d);
                    if (r)this.onHandlePropTypeText(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_BLOCK:
                    n = this.parsePropTypeBlock(a, b, d);
                    if (r)this.onHandlePropTypeBlock(a, b,
                        p, n, d);
                    break;
                case CCB_PROPTYPE_BLOCKCCCONTROL:
                    n = this.parsePropTypeBlockCCControl(a, b, d);
                    if (r && null != n)this.onHandlePropTypeBlockCCControl(a, b, p, n, d);
                    break;
                case CCB_PROPTYPE_CCBFILE:
                    n = this.parsePropTypeCCBFile(a, b, d);
                    if (r)this.onHandlePropTypeCCBFile(a, b, p, n, d);
                    break;
                default:
                    ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE(n)
            }
        }
    }, getCustomProperties: function () {
        return this._customProperties
    }, _createCCNode: function (a, b) {
        return new cc.Node
    }, parsePropTypePosition: function (a, b, d, e) {
        var f = d.readFloat(), g = d.readFloat(),
            h = d.readInt(!1), n = d.getAnimationManager().getContainerSize(b);
        b = cc._getAbsolutePosition(f, g, h, n, e);
        a.setPosition(cc.getAbsolutePosition(b, h, n, e));
        -1 < d.getAnimatedProperties().indexOf(e) && (f = [f, g, h], d.getAnimationManager().setBaseValue(f, a, e));
        return b
    }, parsePropTypePoint: function (a, b, d) {
        a = d.readFloat();
        d = d.readFloat();
        return cc.p(a, d)
    }, parsePropTypePointLock: function (a, b, d) {
        a = d.readFloat();
        d = d.readFloat();
        return cc.p(a, d)
    }, parsePropTypeSize: function (a, b, d) {
        a = d.readFloat();
        var e = d.readFloat(), f = d.readInt(!1);
        b = d.getAnimationManager().getContainerSize(b);
        switch (f) {
            case CCB_SIZETYPE_ABSOLUTE:
                break;
            case CCB_SIZETYPE_RELATIVE_CONTAINER:
                a = b.width - a;
                e = b.height - e;
                break;
            case CCB_SIZETYPE_PERCENT:
                a = b.width * a / 100;
                e = b.height * e / 100;
                break;
            case CCB_SIZETYPE_HORIZONTAL_PERCENT:
                a = b.width * a / 100;
                break;
            case CCB_SIZETYPE_VERTICAL_PERCENT:
                e = b.height * e / 100;
                break;
            case CCB_SIZETYPE_MULTIPLY_RESOLUTION:
                b = cc.BuilderReader.getResolutionScale();
                a *= b;
                e *= b;
                break;
            default:
                cc.log("Unknown CCB type.")
        }
        return cc.size(a, e)
    }, parsePropTypeScaleLock: function (a,
                                         b, d, e) {
        b = d.readFloat();
        var f = d.readFloat(), g = d.readInt(!1);
        cc.setRelativeScale(a, b, f, g, e);
        -1 < d.getAnimatedProperties().indexOf(e) && d.getAnimationManager().setBaseValue([b, f, g], a, e);
        g === CCB_SCALETYPE_MULTIPLY_RESOLUTION && (b *= cc.BuilderReader.getResolutionScale(), f *= cc.BuilderReader.getResolutionScale());
        return [b, f]
    }, parsePropTypeFloat: function (a, b, d) {
        return d.readFloat()
    }, parsePropTypeDegrees: function (a, b, d, e) {
        b = d.readFloat();
        -1 < d.getAnimatedProperties().indexOf(e) && d.getAnimationManager().setBaseValue(b,
            a, e);
        return b
    }, parsePropTypeFloatScale: function (a, b, d) {
        a = d.readFloat();
        d.readInt(!1) === CCB_SCALETYPE_MULTIPLY_RESOLUTION && (a *= cc.BuilderReader.getResolutionScale());
        return a
    }, parsePropTypeInteger: function (a, b, d) {
        return d.readInt(!0)
    }, parsePropTypeIntegerLabeled: function (a, b, d) {
        return d.readInt(!0)
    }, parsePropTypeFloatVar: function (a, b, d) {
        a = d.readFloat();
        d = d.readFloat();
        return [a, d]
    }, parsePropTypeCheck: function (a, b, d, e) {
        b = d.readBool();
        -1 < d.getAnimatedProperties().indexOf(e) && d.getAnimationManager().setBaseValue(b,
            a, e);
        return b
    }, parsePropTypeSpriteFrame: function (a, b, d, e) {
        b = d.readCachedString();
        var f = d.readCachedString(), g;
        null != f && 0 !== f.length && (0 === b.length ? (f = d.getCCBRootPath() + f, b = cc.textureCache.addImage(f), f = b.getContentSize(), f = cc.rect(0, 0, f.width, f.height), g = new cc.SpriteFrame(b, f)) : (g = cc.spriteFrameCache, b = d.getCCBRootPath() + b, -1 === d.getLoadedSpriteSheet().indexOf(b) && (g.addSpriteFrames(b), d.getLoadedSpriteSheet().push(b)), g = g.getSpriteFrame(f)), -1 < d.getAnimatedProperties().indexOf(e) && d.getAnimationManager().setBaseValue(g,
            a, e));
        return g
    }, parsePropTypeAnimation: function (a, b, d) {
        a = d.getCCBRootPath() + d.readCachedString();
        d = d.readCachedString();
        b = null;
        d = cc.BuilderReader.lastPathComponent(d);
        a = cc.BuilderReader.lastPathComponent(a);
        null != d && "" !== d && (b = cc.animationCache, b.addAnimations(a), b = b.getAnimation(d));
        return b
    }, parsePropTypeTexture: function (a, b, d) {
        a = d.getCCBRootPath() + d.readCachedString();
        return "" !== a ? cc.textureCache.addImage(a) : null
    }, parsePropTypeByte: function (a, b, d, e) {
        b = d.readByte();
        -1 < d.getAnimatedProperties().indexOf(e) &&
        d.getAnimationManager().setBaseValue(b, a, e);
        return b
    }, parsePropTypeColor3: function (a, b, d, e) {
        b = d.readByte();
        var f = d.readByte(), g = d.readByte();
        b = {r: b, g: f, b: g};
        -1 < d.getAnimatedProperties().indexOf(e) && d.getAnimationManager().setBaseValue(cc.Color3BWapper.create(b), a, e);
        return b
    }, parsePropTypeColor4FVar: function (a, b, d) {
        a = 0 | 255 * d.readFloat();
        b = 0 | 255 * d.readFloat();
        var e = 0 | 255 * d.readFloat(), f = d.readFloat(), f = 1 >= f ? 0 | 255 * f : f, g = 0 | 255 * d.readFloat(), h = 0 | 255 * d.readFloat(), n = 0 | 255 * d.readFloat();
        d = d.readFloat();
        var p = [];
        p[0] = {r: a, g: b, b: e, a: f};
        p[1] = {r: g, g: h, b: n, a: 1 >= d ? 0 | 255 * d : d};
        return p
    }, parsePropTypeFlip: function (a, b, d) {
        a = d.readBool();
        d = d.readBool();
        return [a, d]
    }, parsePropTypeBlendFunc: function (a, b, d) {
        a = d.readInt(!1);
        d = d.readInt(!1);
        return new cc.BlendFunc(a, d)
    }, parsePropTypeFntFile: function (a, b, d) {
        return d.readCachedString()
    }, parsePropTypeString: function (a, b, d) {
        return d.readCachedString()
    }, parsePropTypeText: function (a, b, d) {
        return d.readCachedString()
    }, parsePropTypeFontTTF: function (a, b, d) {
        return d.readCachedString()
    },
    parsePropTypeBlock: function (a, b, d) {
        b = d.readCachedString();
        var e = d.readInt(!1);
        if (e !== CCB_TARGETTYPE_NONE) {
            var f = null;
            if (d.isJSControlled())e === CCB_TARGETTYPE_DOCUMENTROOT ? (d.addDocumentCallbackNode(a), d.addDocumentCallbackName(b), d.addDocumentCallbackControlEvents(0)) : (d.addOwnerCallbackNode(a), d.addOwnerCallbackName(b), d.addOwnerCallbackControlEvents(0)); else if (e === CCB_TARGETTYPE_DOCUMENTROOT ? f = d.getAnimationManager().getRootNode() : e === CCB_TARGETTYPE_OWNER && (f = d.getOwner()), null !== f)if (0 < b.length)if (a =
                    0, f.onResolveCCBCCMenuItemSelector && (a = f.onResolveCCBCCMenuItemSelector(f, b)), 0 === a && (d = d.getCCBSelectorResolver(), null != d && (a = d.onResolveCCBCCMenuItemSelector(f, b))), 0 === a)cc.log("Skipping selector '" + b + "' since no CCBSelectorResolver is present."); else return new BlockData(a, f); else cc.log("Unexpected empty selector."); else cc.log("Unexpected NULL target for selector.")
        }
        return null
    }, parsePropTypeBlockCCControl: function (a, b, d) {
        b = d.readCachedString();
        var e = d.readInt(!1), f = d.readInt(!1);
        if (e !== CCB_TARGETTYPE_NONE)if (d.isJSControlled())e ===
        CCB_TARGETTYPE_DOCUMENTROOT ? (d.addDocumentCallbackNode(a), d.addDocumentCallbackName(b), d.addDocumentCallbackControlEvents(f)) : (d.addOwnerCallbackNode(a), d.addOwnerCallbackName(b), d.addOwnerCallbackControlEvents(f)); else if (a = null, e === CCB_TARGETTYPE_DOCUMENTROOT ? a = d.getAnimationManager().getRootNode() : e === CCB_TARGETTYPE_OWNER && (a = d.getOwner()), null !== a)if (0 < b.length)if (e = 0, a.onResolveCCBCCControlSelector && (e = a.onResolveCCBCCControlSelector(a, b)), 0 === e && (d = d.getCCBSelectorResolver(), null != d && (e = d.onResolveCCBCCControlSelector(a,
                b))), 0 === e)cc.log("Skipping selector '" + b + "' since no CCBSelectorResolver is present."); else return new BlockCCControlData(e, a, f); else cc.log("Unexpected empty selector."); else cc.log("Unexpected NULL target for selector.");
        return null
    }, parsePropTypeCCBFile: function (a, b, d) {
        var e = d.getCCBRootPath() + d.readCachedString(), e = cc.BuilderReader.deletePathExtension(e) + ".ccbi";
        a = new cc.BuilderReader(d);
        var f = cc.loader.getRes(e);
        f || (f = cc.loader.getUrl(e), f = cc.loader.loadBinarySync(f), cc.loader.cache[e] = f);
        a.initWithData(f,
            d.getOwner());
        a.getAnimationManager().setRootContainerSize(b.getContentSize());
        a.setAnimationManagers(d.getAnimationManagers());
        a.getAnimationManager().setOwner(d.getOwner());
        b = a.readFileWithCleanUp(!1);
        d.setAnimationManagers(a.getAnimationManagers());
        b && -1 !== a.getAnimationManager().getAutoPlaySequenceId() && a.getAnimationManager().runAnimations(a.getAnimationManager().getAutoPlaySequenceId(), 0);
        return b
    }, parsePropTypeFloatXY: function (a, b, d) {
        a = d.readFloat();
        d = d.readFloat();
        return [a, d]
    }, onHandlePropTypePosition: function (a,
                                           b, d, e, f) {
        d === PROPERTY_POSITION ? a.setPosition(e) : ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypePoint: function (a, b, d, e, f) {
        d === PROPERTY_ANCHORPOINT ? a.setAnchorPoint(e) : ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypePointLock: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeSize: function (a, b, d, e, f) {
        d === PROPERTY_CONTENTSIZE ? a.setContentSize(e) : ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeScaleLock: function (a, b, d, e, f) {
        d === PROPERTY_SCALE ? (a.setScaleX(e[0]), a.setScaleY(e[1])) :
            ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeFloatXY: function (a, b, d, e, f) {
        d === PROPERTY_SKEW ? (a.setSkewX(e[0]), a.setSkewY(e[1])) : (b = d + "X", f = d + "Y", a[b] && a[f] || ASSERT_FAIL_UNEXPECTED_PROPERTY(d), a[b](e[0]), a[f](e[1]))
    }, onHandlePropTypeFloat: function (a, b, d, e, f) {
        this._customProperties.setObject(e, d)
    }, onHandlePropTypeDegrees: function (a, b, d, e, f) {
        d === PROPERTY_ROTATION ? a.setRotation(e) : ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeFloatScale: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    },
    onHandlePropTypeInteger: function (a, b, d, e, f) {
        d === PROPERTY_TAG ? a.setTag(e) : ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeIntegerLabeled: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeFloatVar: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeCheck: function (a, b, d, e, f) {
        d === PROPERTY_VISIBLE ? a.setVisible(e) : d === PROPERTY_IGNOREANCHORPOINTFORPOSITION ? a.ignoreAnchorPointForPosition(e) : ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeSpriteFrame: function (a,
                                              b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeAnimation: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeTexture: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeByte: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeColor4FVar: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeFlip: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    },
    onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeFntFile: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeString: function (a, b, d, e, f) {
        this._customProperties.setObject(e, d)
    }, onHandlePropTypeText: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeFontTTF: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeBlock: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeBlockCCControl: function (a,
                                                 b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }, onHandlePropTypeCCBFile: function (a, b, d, e, f) {
        ASSERT_FAIL_UNEXPECTED_PROPERTY(d)
    }
});
cc.NodeLoader.loader = function () {
    return new cc.NodeLoader
};
cc.NodeLoaderListener = cc.Class.extend({
    onNodeLoaded: function (a, b) {
    }
});
cc.BuilderSelectorResolver = cc.Class.extend({
    onResolveCCBCCMenuItemSelector: function (a, b) {
    }, onResolveCCBCCCallFuncSelector: function (a, b) {
    }, onResolveCCBCCControlSelector: function (a, b) {
    }
});
cc.BuilderScriptOwnerProtocol = cc.Class.extend({
    createNew: function () {
    }
});
cc.BuilderMemberVariableAssigner = cc.Class.extend({
    onAssignCCBMemberVariable: function (a, b, d) {
        return !1
    }, onAssignCCBCustomProperty: function (a, b, d) {
        return !1
    }
});
var PROPERTY_CCBFILE = "ccbFile";
cc.BuilderFileLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        return cc.BuilderFile.create()
    }, onHandlePropTypeCCBFile: function (a, b, d, e, f) {
        d === PROPERTY_CCBFILE ? a.setCCBFileNode(e) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, a, b, d, e, f)
    }
});
cc.BuilderFileLoader.loader = function () {
    return new cc.BuilderFileLoader
};
var PROPERTY_ENABLED = "enabled", PROPERTY_SELECTED = "selected", PROPERTY_CCCONTROL = "ccControl";
cc.ControlLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
    }, onHandlePropTypeBlockCCControl: function (a, b, d, e, f) {
        d === PROPERTY_CCCONTROL ? a.addTargetWithActionForControlEvents(e.target, e.selCCControlHandler, e.controlEvents) : cc.NodeLoader.prototype.onHandlePropTypeBlockCCControl.call(this, a, b, d, e, f)
    }, onHandlePropTypeCheck: function (a, b, d, e, f) {
        d === PROPERTY_ENABLED ? a.setEnabled(e) : d === PROPERTY_SELECTED ? a.setSelected(e) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, d, e, f)
    }
});
var PROPERTY_ZOOMONTOUCHDOWN = "zoomOnTouchDown", PROPERTY_TITLE_NORMAL = "title|1", PROPERTY_TITLE_HIGHLIGHTED = "title|2", PROPERTY_TITLE_DISABLED = "title|3", PROPERTY_TITLECOLOR_NORMAL = "titleColor|1", PROPERTY_TITLECOLOR_HIGHLIGHTED = "titleColor|2", PROPERTY_TITLECOLOR_DISABLED = "titleColor|3", PROPERTY_TITLETTF_NORMAL = "titleTTF|1", PROPERTY_TITLETTF_HIGHLIGHTED = "titleTTF|2", PROPERTY_TITLETTF_DISABLED = "titleTTF|3", PROPERTY_TITLETTFSIZE_NORMAL = "titleTTFSize|1", PROPERTY_TITLETTFSIZE_HIGHLIGHTED = "titleTTFSize|2",
    PROPERTY_TITLETTFSIZE_DISABLED = "titleTTFSize|4", PROPERTY_LABELANCHORPOINT = "labelAnchorPoint", PROPERTY_PREFEREDSIZE = "preferedSize", PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL = "backgroundSpriteFrame|1", PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED = "backgroundSpriteFrame|2", PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED = "backgroundSpriteFrame|3";
cc.ControlButtonLoader = cc.ControlLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.ControlButton
    }, onHandlePropTypeCheck: function (a, b, d, e, f) {
        d === PROPERTY_ZOOMONTOUCHDOWN ? a.setZoomOnTouchDown(e) : cc.ControlLoader.prototype.onHandlePropTypeCheck.call(this, a, b, d, e, f)
    }, onHandlePropTypeString: function (a, b, d, e, f) {
        d === PROPERTY_TITLE_NORMAL ? a.setTitleForState(e, cc.CONTROL_STATE_NORMAL) : d === PROPERTY_TITLE_HIGHLIGHTED ? a.setTitleForState(e, cc.CONTROL_STATE_HIGHLIGHTED) : d === PROPERTY_TITLE_DISABLED ? a.setTitleForState(e,
            cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeString.call(this, a, b, d, e, f)
    }, onHandlePropTypeFontTTF: function (a, b, d, e, f) {
        d === PROPERTY_TITLETTF_NORMAL ? a.setTitleTTFForState(e, cc.CONTROL_STATE_NORMAL) : d === PROPERTY_TITLETTF_HIGHLIGHTED ? a.setTitleTTFForState(e, cc.CONTROL_STATE_HIGHLIGHTED) : d === PROPERTY_TITLETTF_DISABLED ? a.setTitleTTFForState(e, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFontTTF.call(this, a, b, d, e, f)
    }, onHandlePropTypeFloatScale: function (a,
                                             b, d, e, f) {
        d === PROPERTY_TITLETTFSIZE_NORMAL ? a.setTitleTTFSizeForState(e, cc.CONTROL_STATE_NORMAL) : d === PROPERTY_TITLETTFSIZE_HIGHLIGHTED ? a.setTitleTTFSizeForState(e, cc.CONTROL_STATE_HIGHLIGHTED) : d === PROPERTY_TITLETTFSIZE_DISABLED ? a.setTitleTTFSizeForState(e, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFloatScale.call(this, a, b, d, e, f)
    }, onHandlePropTypePoint: function (a, b, d, e, f) {
        d === PROPERTY_LABELANCHORPOINT ? a.setLabelAnchorPoint(e) : cc.ControlLoader.prototype.onHandlePropTypePoint.call(this,
            a, b, d, e, f)
    }, onHandlePropTypeSize: function (a, b, d, e, f) {
        d === PROPERTY_PREFEREDSIZE ? a.setPreferredSize(e) : cc.ControlLoader.prototype.onHandlePropTypeSize.call(this, a, b, d, e, f)
    }, onHandlePropTypeSpriteFrame: function (a, b, d, e, f) {
        d === PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL ? null != e && a.setBackgroundSpriteFrameForState(e, cc.CONTROL_STATE_NORMAL) : d === PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED ? null != e && a.setBackgroundSpriteFrameForState(e, cc.CONTROL_STATE_HIGHLIGHTED) : d === PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED ? null !=
        e && a.setBackgroundSpriteFrameForState(e, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, d, e, f)
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        d === PROPERTY_TITLECOLOR_NORMAL ? a.setTitleColorForState(e, cc.CONTROL_STATE_NORMAL) : d === PROPERTY_TITLECOLOR_HIGHLIGHTED ? a.setTitleColorForState(e, cc.CONTROL_STATE_HIGHLIGHTED) : d === PROPERTY_TITLECOLOR_DISABLED ? a.setTitleColorForState(e, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeColor3.call(this,
            a, b, d, e, f)
    }
});
cc.ControlButtonLoader.loader = function () {
    return new cc.ControlButtonLoader
};
var PROPERTY_CONTAINER = "container", PROPERTY_DIRECTION = "direction", PROPERTY_CLIPSTOBOUNDS = "clipsToBounds", PROPERTY_BOUNCES = "bounces", PROPERTY_SCALE = "scale";
cc.ScrollViewLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.ScrollView
    }, onHandlePropTypeSize: function (a, b, d, e, f) {
        d === PROPERTY_CONTENTSIZE ? a.setViewSize(e) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, d, e, f)
    }, onHandlePropTypeCCBFile: function (a, b, d, e, f) {
        d === PROPERTY_CONTAINER ? (a.setContainer(e), a.updateInset()) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, a, b, d, e, f)
    }, onHandlePropTypeCheck: function (a, b, d, e, f) {
        d === PROPERTY_CLIPSTOBOUNDS ? a.setClippingToBounds(e) :
            d === PROPERTY_BOUNCES ? a.setBounceable(e) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, d, e, f)
    }, onHandlePropTypeFloat: function (a, b, d, e, f) {
        d === PROPERTY_SCALE ? a.setScale(e) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, d, e, f)
    }, onHandlePropTypeIntegerLabeled: function (a, b, d, e, f) {
        d === PROPERTY_DIRECTION ? a.setDirection(e) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, d, e, f)
    }
});
cc.ScrollViewLoader.loader = function () {
    return new cc.ScrollViewLoader
};
var PROPERTY_CONTENTSIZE = "contentSize", PROPERTY_SPRITEFRAME = "spriteFrame", PROPERTY_COLOR = "color", PROPERTY_OPACITY = "opacity", PROPERTY_BLENDFUNC = "blendFunc", PROPERTY_INSETLEFT = "insetLeft", PROPERTY_INSETTOP = "insetTop", PROPERTY_INSETRIGHT = "insetRight", PROPERTY_INSETBOTTOM = "insetBottom";
cc.Scale9SpriteLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        var d = new cc.Scale9Sprite;
        d.setAnchorPoint(0, 0);
        return d
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        d === PROPERTY_COLOR ? 255 === e.r && 255 === e.g && 255 === e.b || a.setColor(e) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, d, e, f)
    }, onHandlePropTypeByte: function (a, b, d, e, f) {
        d === PROPERTY_OPACITY ? a.setOpacity(e) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, d, e, f)
    }, onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        d !==
        PROPERTY_BLENDFUNC && cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, d, e, f)
    }, onHandlePropTypeSpriteFrame: function (a, b, d, e, f) {
        d === PROPERTY_SPRITEFRAME ? a.setSpriteFrame(e) : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, d, e, f)
    }, onHandlePropTypeSize: function (a, b, d, e, f) {
        d !== PROPERTY_CONTENTSIZE && (d === PROPERTY_PREFEREDSIZE ? a.setPreferredSize(e) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, d, e, f))
    }, onHandlePropTypeFloat: function (a, b, d, e, f) {
        d === PROPERTY_INSETLEFT ?
            a.setInsetLeft(e) : d === PROPERTY_INSETTOP ? a.setInsetTop(e) : d === PROPERTY_INSETRIGHT ? a.setInsetRight(e) : d === PROPERTY_INSETBOTTOM ? a.setInsetBottom(e) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, d, e, f)
    }
});
cc.Scale9SpriteLoader.loader = function () {
    return new cc.Scale9SpriteLoader
};
var PROPERTY_FLIP = "flip", PROPERTY_DISPLAYFRAME = "displayFrame", PROPERTY_COLOR = "color", PROPERTY_OPACITY = "opacity", PROPERTY_BLENDFUNC = "blendFunc";
cc.SpriteLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.Sprite
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        d === PROPERTY_COLOR ? 255 === e.r && 255 === e.g && 255 === e.b || a.setColor(e) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, d, e, f)
    }, onHandlePropTypeByte: function (a, b, d, e, f) {
        d === PROPERTY_OPACITY ? a.setOpacity(e) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, d, e, f)
    }, onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        d === PROPERTY_BLENDFUNC ? a.setBlendFunc(e) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this,
            a, b, d, e, f)
    }, onHandlePropTypeSpriteFrame: function (a, b, d, e, f) {
        d === PROPERTY_DISPLAYFRAME ? e ? a.setSpriteFrame(e) : cc.log("ERROR: SpriteFrame is null") : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, d, e, f)
    }, onHandlePropTypeFlip: function (a, b, d, e, f) {
        d === PROPERTY_FLIP ? (a.setFlippedX(e[0]), a.setFlippedY(e[1])) : cc.NodeLoader.prototype.onHandlePropTypeFlip.call(this, a, b, d, e, f)
    }
});
cc.SpriteLoader.loader = function () {
    return new cc.SpriteLoader
};
var PROPERTY_TOUCH_ENABLED = "touchEnabled", PROPERTY_IS_TOUCH_ENABLED = "isTouchEnabled", PROPERTY_ACCELEROMETER_ENABLED = "accelerometerEnabled", PROPERTY_IS_ACCELEROMETER_ENABLED = "isAccelerometerEnabled", PROPERTY_IS_MOUSE_ENABLED = "isMouseEnabled", PROPERTY_MOUSE_ENABLED = "mouseEnabled", PROPERTY_KEYBOARD_ENABLED = "keyboardEnabled", PROPERTY_IS_KEYBOARD_ENABLED = "isKeyboardEnabled";
cc.LayerLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        var d = new cc.Layer;
        d.setContentSize(0, 0);
        return d
    }, onHandlePropTypeCheck: function (a, b, d, e, f) {
        d !== PROPERTY_TOUCH_ENABLED && d !== PROPERTY_IS_TOUCH_ENABLED && d !== PROPERTY_ACCELEROMETER_ENABLED && d !== PROPERTY_IS_ACCELEROMETER_ENABLED && d !== PROPERTY_MOUSE_ENABLED && d !== PROPERTY_IS_MOUSE_ENABLED && (d === PROPERTY_KEYBOARD_ENABLED || d === PROPERTY_IS_KEYBOARD_ENABLED ? a.setKeyboardEnabled && !cc.sys.isNative ? a.setKeyboardEnabled(e) : cc.log("The property '" +
            PROPERTY_IS_KEYBOARD_ENABLED + "' is not supported!") : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, d, e, f))
    }
});
cc.LayerLoader.loader = function () {
    return new cc.LayerLoader
};
cc.LayerColorLoader = cc.LayerLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.LayerColor
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        d === PROPERTY_COLOR ? a.setColor(e) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, a, b, d, e, f)
    }, onHandlePropTypeByte: function (a, b, d, e, f) {
        d === PROPERTY_OPACITY ? a.setOpacity(e) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, a, b, d, e, f)
    }, onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        d === PROPERTY_BLENDFUNC ? a.setBlendFunc(e) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this,
            a, b, d, e, f)
    }
});
cc.LayerColorLoader.loader = function () {
    return new cc.LayerColorLoader
};
var PROPERTY_STARTCOLOR = "startColor", PROPERTY_ENDCOLOR = "endColor", PROPERTY_STARTOPACITY = "startOpacity", PROPERTY_ENDOPACITY = "endOpacity", PROPERTY_VECTOR = "vector";
cc.LayerGradientLoader = cc.LayerLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.LayerGradient
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        d === PROPERTY_STARTCOLOR ? a.setStartColor(e) : d === PROPERTY_ENDCOLOR ? a.setEndColor(e) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, a, b, d, e, f)
    }, onHandlePropTypeByte: function (a, b, d, e, f) {
        d === PROPERTY_STARTOPACITY ? a.setStartOpacity(e) : d === PROPERTY_ENDOPACITY ? a.setEndOpacity(e) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, a, b, d, e, f)
    }, onHandlePropTypePoint: function (a,
                                        b, d, e, f) {
        d === PROPERTY_VECTOR ? a.setVector(e) : cc.LayerLoader.prototype.onHandlePropTypePoint.call(this, a, b, d, e, f)
    }, onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        d === PROPERTY_BLENDFUNC ? a.setBlendFunc(e) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, d, e, f)
    }
});
cc.LayerGradientLoader.loader = function () {
    return new cc.LayerGradientLoader
};
cc.MenuLoader = cc.LayerLoader.extend({
    _createCCNode: function (a, b) {
        var d = new cc.Menu;
        d.setContentSize(0, 0);
        return d
    }
});
cc.MenuLoader.loader = function () {
    return new cc.MenuLoader
};
var PROPERTY_BLOCK = "block", PROPERTY_ISENABLED = "isEnabled";
cc.MenuItemLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        return null
    }, onHandlePropTypeBlock: function (a, b, d, e, f) {
        d === PROPERTY_BLOCK ? null != e && a.setTarget(e.selMenuHander, e.target) : cc.NodeLoader.prototype.onHandlePropTypeBlock.call(this, a, b, d, e, f)
    }, onHandlePropTypeCheck: function (a, b, d, e, f) {
        d === PROPERTY_ISENABLED ? a.setEnabled(e) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, a, b, d, e, f)
    }
});
var PROPERTY_NORMALDISPLAYFRAME = "normalSpriteFrame", PROPERTY_SELECTEDDISPLAYFRAME = "selectedSpriteFrame", PROPERTY_DISABLEDDISPLAYFRAME = "disabledSpriteFrame";
cc.MenuItemImageLoader = cc.MenuItemLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.MenuItemImage
    }, onHandlePropTypeSpriteFrame: function (a, b, d, e, f) {
        d === PROPERTY_NORMALDISPLAYFRAME ? null != e && a.setNormalSpriteFrame(e) : d === PROPERTY_SELECTEDDISPLAYFRAME ? null != e && a.setSelectedSpriteFrame(e) : d === PROPERTY_DISABLEDDISPLAYFRAME ? null != e && a.setDisabledSpriteFrame(e) : cc.MenuItemLoader.prototype.onHandlePropTypeSpriteFrame.call(this, a, b, d, e, f)
    }
});
cc.MenuItemImageLoader.loader = function () {
    return new cc.MenuItemImageLoader
};
var PROPERTY_FONTNAME = "fontName", PROPERTY_FONTSIZE = "fontSize", PROPERTY_HORIZONTALALIGNMENT = "horizontalAlignment", PROPERTY_VERTICALALIGNMENT = "verticalAlignment", PROPERTY_STRING = "string", PROPERTY_DIMENSIONS = "dimensions";
cc.LabelTTFLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.LabelTTF
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        d === PROPERTY_COLOR ? 255 === e.r && 255 === e.g && 255 === e.b || a.setColor(e) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, d, e, f)
    }, onHandlePropTypeByte: function (a, b, d, e, f) {
        d === PROPERTY_OPACITY ? a.setOpacity(e) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, d, e, f)
    }, onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        d === PROPERTY_BLENDFUNC ? a.setBlendFunc(e) :
            cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, d, e, f)
    }, onHandlePropTypeFontTTF: function (a, b, d, e, f) {
        d === PROPERTY_FONTNAME ? a.setFontName(e) : cc.NodeLoader.prototype.onHandlePropTypeFontTTF.call(this, a, b, d, e, f)
    }, onHandlePropTypeText: function (a, b, d, e, f) {
        d === PROPERTY_STRING ? a.setString(e) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, a, b, d, e, f)
    }, onHandlePropTypeFloatScale: function (a, b, d, e, f) {
        d === PROPERTY_FONTSIZE ? a.setFontSize(e) : cc.NodeLoader.prototype.onHandlePropTypeFloatScale.call(this,
            a, b, d, e, f)
    }, onHandlePropTypeIntegerLabeled: function (a, b, d, e, f) {
        d === PROPERTY_HORIZONTALALIGNMENT ? a.setHorizontalAlignment(e) : d === PROPERTY_VERTICALALIGNMENT ? a.setVerticalAlignment(e) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, d, e, f)
    }, onHandlePropTypeSize: function (a, b, d, e, f) {
        d === PROPERTY_DIMENSIONS ? a.setDimensions(e) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, a, b, d, e, f)
    }
});
cc.LabelTTFLoader.loader = function () {
    return new cc.LabelTTFLoader
};
var PROPERTY_FNTFILE = "fntFile";
cc.LabelBMFontLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.LabelBMFont
    }, onHandlePropTypeColor3: function (a, b, d, e, f) {
        d === PROPERTY_COLOR ? 255 === e.r && 255 === e.g && 255 === e.b || a.setColor(e) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, a, b, d, e, f)
    }, onHandlePropTypeByte: function (a, b, d, e, f) {
        d === PROPERTY_OPACITY ? a.setOpacity(e) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, a, b, d, e, f)
    }, onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        d === PROPERTY_BLENDFUNC ? a.setBlendFunc(e) :
            cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, d, e, f)
    }, onHandlePropTypeFntFile: function (a, b, d, e, f) {
        d === PROPERTY_FNTFILE ? a.setFntFile(e) : cc.NodeLoader.prototype.onHandlePropTypeFntFile.call(this, a, b, d, e, f)
    }, onHandlePropTypeText: function (a, b, d, e, f) {
        d === PROPERTY_STRING ? a.setString(e) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, a, b, d, e, f)
    }
});
cc.LabelBMFontLoader.loader = function () {
    return new cc.LabelBMFontLoader
};
var PROPERTY_EMITERMODE = "emitterMode", PROPERTY_POSVAR = "posVar", PROPERTY_EMISSIONRATE = "emissionRate", PROPERTY_DURATION = "duration", PROPERTY_TOTALPARTICLES = "totalParticles", PROPERTY_LIFE = "life", PROPERTY_STARTSIZE = "startSize", PROPERTY_ENDSIZE = "endSize", PROPERTY_STARTSPIN = "startSpin", PROPERTY_ENDSPIN = "endSpin", PROPERTY_ANGLE = "angle", PROPERTY_GRAVITY = "gravity", PROPERTY_SPEED = "speed", PROPERTY_TANGENTIALACCEL = "tangentialAccel", PROPERTY_RADIALACCEL = "radialAccel", PROPERTY_TEXTURE = "texture", PROPERTY_STARTRADIUS =
    "startRadius", PROPERTY_ENDRADIUS = "endRadius", PROPERTY_ROTATEPERSECOND = "rotatePerSecond";
cc.ParticleSystemLoader = cc.NodeLoader.extend({
    _createCCNode: function (a, b) {
        return new cc.ParticleSystem
    }, onHandlePropTypeIntegerLabeled: function (a, b, d, e, f) {
        d === PROPERTY_EMITERMODE ? a.setEmitterMode(e) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, a, b, d, e, f)
    }, onHandlePropTypePoint: function (a, b, d, e, f) {
        d === PROPERTY_POSVAR ? a.setPosVar(e) : d === PROPERTY_GRAVITY ? a.setGravity(e) : cc.NodeLoader.prototype.onHandlePropTypePoint.call(this, a, b, d, e, f)
    }, onHandlePropTypeFloat: function (a, b, d, e, f) {
        d ===
        PROPERTY_EMISSIONRATE ? a.setEmissionRate(e) : d === PROPERTY_DURATION ? a.setDuration(e) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, a, b, d, e, f)
    }, onHandlePropTypeInteger: function (a, b, d, e, f) {
        d === PROPERTY_TOTALPARTICLES ? a.setTotalParticles(e) : cc.NodeLoader.prototype.onHandlePropTypeInteger.call(this, a, b, d, e, f)
    }, onHandlePropTypeFloatVar: function (a, b, d, e, f) {
        d === PROPERTY_LIFE ? (a.setLife(e[0]), a.setLifeVar(e[1])) : d === PROPERTY_STARTSIZE ? (a.setStartSize(e[0]), a.setStartSizeVar(e[1])) : d === PROPERTY_ENDSIZE ?
            (a.setEndSize(e[0]), a.setEndSizeVar(e[1])) : d === PROPERTY_STARTSPIN ? (a.setStartSpin(e[0]), a.setStartSpinVar(e[1])) : d === PROPERTY_ENDSPIN ? (a.setEndSpin(e[0]), a.setEndSpinVar(e[1])) : d === PROPERTY_ANGLE ? (a.setAngle(e[0]), a.setAngleVar(e[1])) : d === PROPERTY_SPEED ? (a.setSpeed(e[0]), a.setSpeedVar(e[1])) : d === PROPERTY_TANGENTIALACCEL ? (a.setTangentialAccel(e[0]), a.setTangentialAccelVar(e[1])) : d === PROPERTY_RADIALACCEL ? (a.setRadialAccel(e[0]), a.setRadialAccelVar(e[1])) : d === PROPERTY_STARTRADIUS ? (a.setStartRadius(e[0]),
            a.setStartRadiusVar(e[1])) : d === PROPERTY_ENDRADIUS ? (a.setEndRadius(e[0]), a.setEndRadiusVar(e[1])) : d === PROPERTY_ROTATEPERSECOND ? (a.setRotatePerSecond(e[0]), a.setRotatePerSecondVar(e[1])) : cc.NodeLoader.prototype.onHandlePropTypeFloatVar.call(this, a, b, d, e, f)
    }, onHandlePropTypeColor4FVar: function (a, b, d, e, f) {
        d === PROPERTY_STARTCOLOR ? (a.setStartColor(e[0]), a.setStartColorVar(e[1])) : d === PROPERTY_ENDCOLOR ? (a.setEndColor(e[0]), a.setEndColorVar(e[1])) : cc.NodeLoader.prototype.onHandlePropTypeColor4FVar.call(this,
            a, b, d, e, f)
    }, onHandlePropTypeBlendFunc: function (a, b, d, e, f) {
        d === PROPERTY_BLENDFUNC ? a.setBlendFunc(e) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, a, b, d, e, f)
    }, onHandlePropTypeTexture: function (a, b, d, e, f) {
        d === PROPERTY_TEXTURE ? a.setTexture(e) : cc.NodeLoader.prototype.onHandlePropTypeTexture.call(this, a, b, d, e, f)
    }
});
cc.ParticleSystemLoader.loader = function () {
    return new cc.ParticleSystemLoader
};
cc.NodeLoaderLibrary = cc.Class.extend({
    _ccNodeLoaders: null, ctor: function () {
        this._ccNodeLoaders = {}
    }, registerDefaultCCNodeLoaders: function () {
        this.registerCCNodeLoader("CCNode", cc.NodeLoader.loader());
        this.registerCCNodeLoader("CCLayer", cc.LayerLoader.loader());
        this.registerCCNodeLoader("CCLayerColor", cc.LayerColorLoader.loader());
        this.registerCCNodeLoader("CCLayerGradient", cc.LayerGradientLoader.loader());
        this.registerCCNodeLoader("CCSprite", cc.SpriteLoader.loader());
        this.registerCCNodeLoader("CCLabelBMFont",
            cc.LabelBMFontLoader.loader());
        this.registerCCNodeLoader("CCLabelTTF", cc.LabelTTFLoader.loader());
        this.registerCCNodeLoader("CCScale9Sprite", cc.Scale9SpriteLoader.loader());
        this.registerCCNodeLoader("CCScrollView", cc.ScrollViewLoader.loader());
        this.registerCCNodeLoader("CCBFile", cc.BuilderFileLoader.loader());
        this.registerCCNodeLoader("CCMenu", cc.MenuLoader.loader());
        this.registerCCNodeLoader("CCMenuItemImage", cc.MenuItemImageLoader.loader());
        this.registerCCNodeLoader("CCControlButton", cc.ControlButtonLoader.loader());
        this.registerCCNodeLoader("CCParticleSystemQuad", cc.ParticleSystemLoader.loader())
    }, registerCCNodeLoader: function (a, b) {
        this._ccNodeLoaders[a] = b
    }, unregisterCCNodeLoader: function (a) {
        this._ccNodeLoaders[a] && delete this._ccNodeLoaders[a]
    }, getCCNodeLoader: function (a) {
        return this._ccNodeLoaders[a] ? this._ccNodeLoaders[a] : null
    }, purge: function (a) {
        if (a)for (var b in this._ccNodeLoaders)delete this._ccNodeLoaders[b];
        this._ccNodeLoaders = {}
    }
});
cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null;
cc.NodeLoaderLibrary.library = function () {
    return new cc.NodeLoaderLibrary
};
cc.NodeLoaderLibrary.sharedCCNodeLoaderLibrary = function () {
    null == cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary && (cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = new cc.NodeLoaderLibrary, cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary.registerDefaultCCNodeLoaders());
    return cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary
};
cc.NodeLoaderLibrary.purgeSharedCCNodeLoaderLibrary = function () {
    cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null
};
cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary = function () {
    var a = cc.NodeLoaderLibrary.library();
    a.registerDefaultCCNodeLoaders();
    return a
};
var CCB_VERSION = 5, CCB_PROPTYPE_POSITION = 0, CCB_PROPTYPE_SIZE = 1, CCB_PROPTYPE_POINT = 2, CCB_PROPTYPE_POINTLOCK = 3, CCB_PROPTYPE_SCALELOCK = 4, CCB_PROPTYPE_DEGREES = 5, CCB_PROPTYPE_INTEGER = 6, CCB_PROPTYPE_FLOAT = 7, CCB_PROPTYPE_FLOATVAR = 8, CCB_PROPTYPE_CHECK = 9, CCB_PROPTYPE_SPRITEFRAME = 10, CCB_PROPTYPE_TEXTURE = 11, CCB_PROPTYPE_BYTE = 12, CCB_PROPTYPE_COLOR3 = 13, CCB_PROPTYPE_COLOR4VAR = 14, CCB_PROPTYPE_FLIP = 15, CCB_PROPTYPE_BLENDMODE = 16, CCB_PROPTYPE_FNTFILE = 17, CCB_PROPTYPE_TEXT = 18, CCB_PROPTYPE_FONTTTF = 19, CCB_PROPTYPE_INTEGERLABELED =
    20, CCB_PROPTYPE_BLOCK = 21, CCB_PROPTYPE_ANIMATION = 22, CCB_PROPTYPE_CCBFILE = 23, CCB_PROPTYPE_STRING = 24, CCB_PROPTYPE_BLOCKCCCONTROL = 25, CCB_PROPTYPE_FLOATSCALE = 26, CCB_PROPTYPE_FLOATXY = 27, CCB_FLOAT0 = 0, CCB_FLOAT1 = 1, CCB_FLOAT_MINUS1 = 2, CCB_FLOAT05 = 3, CCB_FLOAT_INTEGER = 4, CCB_FLOAT_FULL = 5, CCB_PLATFORM_ALL = 0, CCB_PLATFORM_IOS = 1, CCB_PLATFORM_MAC = 2, CCB_TARGETTYPE_NONE = 0, CCB_TARGETTYPE_DOCUMENTROOT = 1, CCB_TARGETTYPE_OWNER = 2, CCB_KEYFRAME_EASING_INSTANT = 0, CCB_KEYFRAME_EASING_LINEAR = 1, CCB_KEYFRAME_EASING_CUBIC_IN = 2, CCB_KEYFRAME_EASING_CUBIC_OUT =
    3, CCB_KEYFRAME_EASING_CUBIC_INOUT = 4, CCB_KEYFRAME_EASING_ELASTIC_IN = 5, CCB_KEYFRAME_EASING_ELASTIC_OUT = 6, CCB_KEYFRAME_EASING_ELASTIC_INOUT = 7, CCB_KEYFRAME_EASING_BOUNCE_IN = 8, CCB_KEYFRAME_EASING_BOUNCE_OUT = 9, CCB_KEYFRAME_EASING_BOUNCE_INOUT = 10, CCB_KEYFRAME_EASING_BACK_IN = 11, CCB_KEYFRAME_EASING_BACK_OUT = 12, CCB_KEYFRAME_EASING_BACK_INOUT = 13, CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT = 0, CCB_POSITIONTYPE_RELATIVE_TOP_LEFT = 1, CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT = 2, CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT = 3, CCB_POSITIONTYPE_PERCENT =
    4, CCB_POSITIONTYPE_MULTIPLY_RESOLUTION = 5, CCB_SIZETYPE_ABSOLUTE = 0, CCB_SIZETYPE_PERCENT = 1, CCB_SIZETYPE_RELATIVE_CONTAINER = 2, CCB_SIZETYPE_HORIZONTAL_PERCENT = 3, CCB_SIZETYPE_VERTICAL_PERCENT = 4, CCB_SIZETYPE_MULTIPLY_RESOLUTION = 5, CCB_SCALETYPE_ABSOLUTE = 0, CCB_SCALETYPE_MULTIPLY_RESOLUTION = 1;
cc.BuilderFile = cc.Node.extend({
    _ccbFileNode: null, getCCBFileNode: function () {
        return this._ccbFileNode
    }, setCCBFileNode: function (a) {
        this._ccbFileNode = a
    }
});
cc.BuilderFile.create = function () {
    return new cc.BuilderFile
};
cc.BuilderReader = cc.Class.extend({
    _jsControlled: !1,
    _data: null,
    _ccbRootPath: "",
    _bytes: 0,
    _currentByte: 0,
    _currentBit: 0,
    _stringCache: null,
    _loadedSpriteSheets: null,
    _owner: null,
    _animationManager: null,
    _animationManagers: null,
    _animatedProps: null,
    _ccNodeLoaderLibrary: null,
    _ccNodeLoaderListener: null,
    _ccbMemberVariableAssigner: null,
    _ccbSelectorResolver: null,
    _ownerOutletNames: null,
    _ownerOutletNodes: null,
    _nodesWithAnimationManagers: null,
    _animationManagerForNodes: null,
    _ownerCallbackNames: null,
    _ownerCallbackNodes: null,
    _ownerCallbackEvents: null,
    _readNodeGraphFromData: !1,
    ctor: function (a, b, d, e) {
        this._stringCache = [];
        this._loadedSpriteSheets = [];
        this._currentByte = this._currentBit = -1;
        0 !== arguments.length && (a instanceof cc.BuilderReader ? (this._loadedSpriteSheets = a._loadedSpriteSheets, this._ccNodeLoaderLibrary = a._ccNodeLoaderLibrary, this._ccbMemberVariableAssigner = a._ccbMemberVariableAssigner, this._ccbSelectorResolver = a._ccbSelectorResolver, this._ccNodeLoaderListener = a._ccNodeLoaderListener, this._ownerCallbackNames = a._ownerCallbackNames,
            this._ownerCallbackNodes = a._ownerCallbackNodes, this._ownerCallbackEvents = a._ownerCallbackEvents, this._ownerOutletNames = a._ownerOutletNames, this._ownerOutletNodes = a._ownerOutletNodes, this._ccbRootPath = a._ccbRootPath) : (this._ccNodeLoaderLibrary = a, this._ccbMemberVariableAssigner = b, this._ccbSelectorResolver = d, this._ccNodeLoaderListener = e))
    },
    getCCBRootPath: function () {
        return this._ccbRootPath
    },
    setCCBRootPath: function (a) {
        this._ccbRootPath = a
    },
    initWithData: function (a, b) {
        this._animationManager = new cc.BuilderAnimationManager;
        this._data = a;
        this._bytes = a.length;
        this._currentByte = this._currentBit = 0;
        this._owner = b;
        this._animationManager.setRootContainerSize(cc.director.getWinSize());
        return !0
    },
    _loadBinarySync: function (a) {
        var b = this.getXMLHttpRequest(), d = "load " + a + " failed!";
        b.open("GET", a, !1);
        var e = null;
        if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
            b.setRequestHeader("Accept-Charset", "x-user-defined");
            b.send(null);
            if (200 !== b.status)return cc.log(d), null;
            if (b = cc._convertResponseBodyToText(b.responseBody))e =
                this._stringConvertToArray(b), this._fileDataCache[a] = e
        } else {
            b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dx-user-defined");
            b.send(null);
            if (200 !== b.status)return cc.log(d), null;
            e = this._stringConvertToArray(b.responseText);
            this._fileDataCache[a] = e
        }
        return e
    },
    readNodeGraphFromFile: function (a, b, d, e) {
        null == d ? d = cc.director.getWinSize() : d instanceof cc.BuilderAnimationManager && (e = d, d = cc.director.getWinSize());
        var f = cc.loader.getRes(a);
        f || (f = cc.loader.getUrl(a), f = cc.loader.loadBinarySync(f),
            cc.loader.cache[a] = f);
        return this.readNodeGraphFromData(f, b, d, e)
    },
    readNodeGraphFromData: function (a, b, d) {
        this.initWithData(a, b);
        a = this._animationManager;
        a.setRootContainerSize(d);
        a.setOwner(b);
        this._ownerOutletNames = [];
        this._ownerOutletNodes = [];
        this._ownerCallbackNames = [];
        this._ownerCallbackNodes = [];
        this._ownerCallbackEvents = [];
        this._animationManagers = new cc._Dictionary;
        (b = this.readFileWithCleanUp(!0)) && -1 !== a.getAutoPlaySequenceId() && a.runAnimations(a.getAutoPlaySequenceId(), 0);
        if (this._jsControlled) {
            d =
                [];
            a = [];
            for (var e = this._animationManagers, f = e.allKeys(), g = 0; g < f.length; g++)d.push(f[g]), a.push(e.objectForKey(f[g]));
            this._nodesWithAnimationManagers = d;
            this._animationManagerForNodes = a
        }
        return b
    },
    createSceneWithNodeGraphFromFile: function (a, b, d, e) {
        a = this.readNodeGraphFromFile(a, b, d, e);
        b = new cc.Scene;
        b.addChild(a);
        return b
    },
    getCCBMemberVariableAssigner: function () {
        return this._ccbMemberVariableAssigner
    },
    getCCBSelectorResolver: function () {
        return this._ccbSelectorResolver
    },
    getAnimationManager: function () {
        return this._animationManager
    },
    setAnimationManager: function (a) {
        this._animationManager = a
    },
    getAnimatedProperties: function () {
        return this._animatedProps
    },
    getLoadedSpriteSheet: function () {
        return this._loadedSpriteSheets
    },
    getOwner: function () {
        return this._owner
    },
    readInt: function (a) {
        for (var b = 0; !this._getBit();)b++;
        for (var d = 0, e = b - 1; 0 <= e; e--)this._getBit() && (d |= 1 << e);
        d |= 1 << b;
        a = a ? d % 2 ? 0 | d / 2 : 0 | -d / 2 : d - 1;
        this._alignBits();
        return a
    },
    readByte: function () {
        var a = this._data[this._currentByte];
        this._currentByte++;
        return a
    },
    readBool: function () {
        return 0 !==
            this.readByte()
    },
    readFloat: function () {
        switch (this.readByte()) {
            case CCB_FLOAT0:
                return 0;
            case CCB_FLOAT1:
                return 1;
            case CCB_FLOAT_MINUS1:
                return -1;
            case CCB_FLOAT05:
                return 0.5;
            case CCB_FLOAT_INTEGER:
                return this.readInt(!0);
            default:
                return this._decodeFloat(23, 8)
        }
    },
    _decodeFloat: function (a, b) {
        var d = a + b + 1, e = d >> 3;
        this._checkSize(d);
        var d = Math.pow(2, b - 1) - 1, f = this._readBitsOnly(a + b, 1, e), g = this._readBitsOnly(a, b, e), h = 0, n = 2, p = 0;
        do for (var r = this._readByteOnly(++p, e), s = a % 8 || 8, t = 1 << s; t >>= 1;)r & t && (h += 1 / n), n *= 2; while (a -=
            s);
        this._currentByte += e;
        return g === (d << 1) + 1 ? h ? NaN : f ? -Infinity : Infinity : (1 + -2 * f) * (g || h ? g ? Math.pow(2, g - d) * (1 + h) : Math.pow(2, -d + 1) * h : 0)
    },
    _readBitsOnly: function (a, b, d) {
        var e = (a + b) % 8, f = a % 8, g = d - (a >> 3) - 1;
        a = d + (-(a + b) >> 3);
        var h = g - a;
        b = this._readByteOnly(g, d) >> f & (1 << (h ? 8 - f : b)) - 1;
        for (h && e && (b += (this._readByteOnly(a++, d) & (1 << e) - 1) << (h-- << 3) - f); h;)b += this._shl(this._readByteOnly(a++, d), (h-- << 3) - f);
        return b
    },
    _readByteOnly: function (a, b) {
        return this._data[this._currentByte + b - a - 1]
    },
    _shl: function (a, b) {
        for (++b; --b; a =
            1073741824 === ((a %= 2147483648) & 1073741824) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    },
    _checkSize: function (a) {
        if (!(this._currentByte + Math.ceil(a / 8) < this._data.length))throw Error("Index out of bound");
    },
    readCachedString: function () {
        return this._stringCache[this.readInt(!1)]
    },
    isJSControlled: function () {
        return this._jsControlled
    },
    getOwnerCallbackNames: function () {
        return this._ownerCallbackNames
    },
    getOwnerCallbackNodes: function () {
        return this._ownerCallbackNodes
    },
    getOwnerCallbackControlEvents: function () {
        return this._ownerCallbackEvents
    },
    getOwnerOutletNames: function () {
        return this._ownerOutletNames
    },
    getOwnerOutletNodes: function () {
        return this._ownerOutletNodes
    },
    getNodesWithAnimationManagers: function () {
        return this._nodesWithAnimationManagers
    },
    getAnimationManagersForNodes: function () {
        return this._animationManagerForNodes
    },
    getAnimationManagers: function () {
        return this._animationManagers
    },
    setAnimationManagers: function (a) {
        this._animationManagers = a
    },
    addOwnerCallbackName: function (a) {
        this._ownerCallbackNames.push(a)
    },
    addOwnerCallbackNode: function (a) {
        this._ownerCallbackNodes.push(a)
    },
    addOwnerCallbackControlEvents: function (a) {
        this._ownerCallbackEvents.push(a)
    },
    addDocumentCallbackName: function (a) {
        this._animationManager.addDocumentCallbackName(a)
    },
    addDocumentCallbackNode: function (a) {
        this._animationManager.addDocumentCallbackNode(a)
    },
    addDocumentCallbackControlEvents: function (a) {
        this._animationManager.addDocumentCallbackControlEvents(a)
    },
    readFileWithCleanUp: function (a) {
        if (!this._readHeader() || !this._readStringCache() || !this._readSequences())return null;
        var b = this._readNodeGraph();
        this._animationManagers.setObject(this._animationManager, b);
        a && this._cleanUpNodeGraph(b);
        return b
    },
    addOwnerOutletName: function (a) {
        this._ownerOutletNames.push(a)
    },
    addOwnerOutletNode: function (a) {
        null != a && this._ownerOutletNodes.push(a)
    },
    _cleanUpNodeGraph: function (a) {
        a.userObject = null;
        a = a.getChildren();
        for (var b = 0, d = a.length; b < d; b++)this._cleanUpNodeGraph(a[b])
    },
    _readCallbackKeyframesForSeq: function (a) {
        var b = this.readInt(!1);
        if (!b)return !0;
        for (var d = new cc.BuilderSequenceProperty, e = this._jsControlled,
                 f = this._animationManager, g = d.getKeyframes(), h = 0; h < b; h++) {
            var n = this.readFloat(), p = this.readCachedString(), r = this.readInt(!1), s = [p, r], t = new cc.BuilderKeyframe;
            t.setTime(n);
            t.setValue(s);
            e && f.getKeyframeCallbacks().push(r + ":" + p);
            g.push(t)
        }
        a.setCallbackChannel(d);
        return !0
    },
    _readSoundKeyframesForSeq: function (a) {
        var b = this.readInt(!1);
        if (!b)return !0;
        for (var d = new cc.BuilderSequenceProperty, e = d.getKeyframes(), f = 0; f < b; f++) {
            var g = this.readFloat(), h = this.readCachedString(), n = this.readFloat(), p = this.readFloat(),
                r = this.readFloat(), h = [h, n, p, r], n = new cc.BuilderKeyframe;
            n.setTime(g);
            n.setValue(h);
            e.push(n)
        }
        a.setSoundChannel(d);
        return !0
    },
    _readSequences: function () {
        for (var a = this._animationManager.getSequences(), b = this.readInt(!1), d = 0; d < b; d++) {
            var e = new cc.BuilderSequence;
            e.setDuration(this.readFloat());
            e.setName(this.readCachedString());
            e.setSequenceId(this.readInt(!1));
            e.setChainedSequenceId(this.readInt(!0));
            if (!this._readCallbackKeyframesForSeq(e) || !this._readSoundKeyframesForSeq(e))return !1;
            a.push(e)
        }
        this._animationManager.setAutoPlaySequenceId(this.readInt(!0));
        return !0
    },
    readKeyframe: function (a) {
        var b = new cc.BuilderKeyframe;
        b.setTime(this.readFloat());
        var d = this.readInt(!1), e = 0, f = null;
        if (d === CCB_KEYFRAME_EASING_CUBIC_IN || d === CCB_KEYFRAME_EASING_CUBIC_OUT || d === CCB_KEYFRAME_EASING_CUBIC_INOUT || d === CCB_KEYFRAME_EASING_ELASTIC_IN || d === CCB_KEYFRAME_EASING_ELASTIC_OUT || d === CCB_KEYFRAME_EASING_ELASTIC_INOUT)e = this.readFloat();
        b.setEasingType(d);
        b.setEasingOpt(e);
        a === CCB_PROPTYPE_CHECK ? f = this.readBool() : a === CCB_PROPTYPE_BYTE ? f = this.readByte() : a === CCB_PROPTYPE_COLOR3 ?
            (a = cc.color(this.readByte(), this.readByte(), this.readByte()), f = cc.Color3BWapper.create(a)) : a === CCB_PROPTYPE_FLOATXY ? f = [this.readFloat(), this.readFloat()] : a === CCB_PROPTYPE_DEGREES ? f = this.readFloat() : a === CCB_PROPTYPE_SCALELOCK || a === CCB_PROPTYPE_POSITION || a === CCB_PROPTYPE_FLOATXY ? f = [this.readFloat(), this.readFloat()] : a === CCB_PROPTYPE_SPRITEFRAME && (a = this.readCachedString(), d = this.readCachedString(), "" === a ? (d = this._ccbRootPath + d, a = cc.textureCache.addImage(d), d = a.getContentSize(), d = cc.rect(0, 0, d.width,
            d.height), f = new cc.SpriteFrame(a, d)) : (a = this._ccbRootPath + a, e = cc.spriteFrameCache, -1 === this._loadedSpriteSheets.indexOf(a) && (e.addSpriteFrames(a), this._loadedSpriteSheets.push(a)), f = e.getSpriteFrame(d)));
        b.setValue(f);
        return b
    },
    _readHeader: function () {
        if (!this._data)return !1;
        var a = this._readStringFromBytes(this._currentByte, 4, !0);
        this._currentByte += 4;
        if ("ccbi" !== a)return !1;
        a = this.readInt(!1);
        if (a !== CCB_VERSION)return cc.log("WARNING! Incompatible ccbi file version (file: " + a + " reader: " + CCB_VERSION +
            ")"), !1;
        this._jsControlled = this.readBool();
        this._animationManager._jsControlled = this._jsControlled;
        return !0
    },
    _readStringFromBytes: function (a, b, d) {
        a = "";
        var e = this._data, f = this._currentByte;
        if (d)for (d = b - 1; 0 <= d; d--)a += String.fromCharCode(e[f + d]); else for (d = 0; d < b; d++)a += String.fromCharCode(e[f + d]);
        return a
    },
    _readStringCache: function () {
        for (var a = this.readInt(!1), b = 0; b < a; b++)this._readStringCacheEntry();
        return !0
    },
    _readStringCacheEntry: function () {
        for (var a = this.readByte(), b = this.readByte(), a = a << 8 | b, b = "",
                 d = this._data, e = this._currentByte, f = 0; f < a; f++)var g = d[e + f].toString("16").toUpperCase(), g = 1 < g.length ? g : "0" + g, b = b + ("%" + g);
        b = decodeURIComponent(b);
        this._currentByte += a;
        this._stringCache.push(b)
    },
    _readNodeGraph: function (a) {
        var b = this.readCachedString(), d, e = this._jsControlled, f = this._animationManager;
        e && (d = this.readCachedString());
        var g = this.readInt(!1), h;
        g !== CCB_TARGETTYPE_NONE && (h = this.readCachedString());
        (b = this._ccNodeLoaderLibrary.getCCNodeLoader(b)) || (b = this._ccNodeLoaderLibrary.getCCNodeLoader("CCNode"));
        var n = b.loadCCNode(a, this);
        f.getRootNode() || f.setRootNode(n);
        e && n === f.getRootNode() && f.setDocumentControllerName(d);
        var p = new cc._Dictionary, r = this._animatedProps = [], s = this.readInt(!1);
        for (d = 0; d < s; ++d) {
            for (var t = this.readInt(!1), v = new cc._Dictionary, u = this.readInt(!1), x = 0; x < u; ++x) {
                var w = new cc.BuilderSequenceProperty;
                w.setName(this.readCachedString());
                w.setType(this.readInt(!1));
                r.push(w.getName());
                for (var y = this.readInt(!1), A = w.getKeyframes(), D = 0; D < y; ++D) {
                    var G = this.readKeyframe(w.getType());
                    A.push(G)
                }
                v.setObject(w,
                    w.getName())
            }
            p.setObject(v, t)
        }
        0 < p.count() && f.addNode(n, p);
        b.parseProperties(n, a, this);
        if (a = n instanceof cc.BuilderFile)d = n.getCCBFileNode(), d.setPosition(n.getPosition()), d.setRotation(n.getRotation()), d.setScaleX(n.getScaleX()), d.setScaleY(n.getScaleY()), d.setTag(n.getTag()), d.setVisible(!0), f.moveAnimationsFromNode(n, d), n.setCCBFileNode(null), n = d;
        r = p = null;
        if (g !== CCB_TARGETTYPE_NONE)if (e)g === CCB_TARGETTYPE_DOCUMENTROOT ? (f.addDocumentOutletName(h), f.addDocumentOutletNode(n)) : (this._ownerOutletNames.push(h),
            this._ownerOutletNodes.push(n)); else if (g === CCB_TARGETTYPE_DOCUMENTROOT ? p = f.getRootNode() : g === CCB_TARGETTYPE_OWNER && (p = this._owner), !p && (d = !1, p.onAssignCCBMemberVariable && (d = p.onAssignCCBMemberVariable(p, h, n)), r = this._ccbMemberVariableAssigner, !d && null != r && r.onAssignCCBMemberVariable))r.onAssignCCBMemberVariable(p, h, n);
        if (0 < b.getCustomProperties().length && (h = !1, !e && (p = n, null != p && null != p.onAssignCCBCustomProperty)))for (e = b.getCustomProperties(), f = e.allKeys(), d = 0; d < f.length; d++)if (g = e.objectForKey(f[d]),
                h = p.onAssignCCBCustomProperty(p, f[d], g), r = this._ccbMemberVariableAssigner, !h && null != r && null != r.onAssignCCBCustomProperty)r.onAssignCCBCustomProperty(p, f[d], g);
        this._animatedProps = null;
        e = this.readInt(!1);
        for (d = 0; d < e; d++)h = this._readNodeGraph(n), n.addChild(h);
        if (!a)if (null != n && n.onNodeLoaded)n.onNodeLoaded(n, b); else if (null != this._ccNodeLoaderListener)this._ccNodeLoaderListener.onNodeLoaded(n, b);
        return n
    },
    _getBit: function () {
        var a = 0 !== (this._data[this._currentByte] & 1 << this._currentBit);
        this._currentBit++;
        if (8 <= this._currentBit && (this._currentBit = 0, this._currentByte++, this._currentByte > this._data.length))throw Error("out of the data bound");
        return a
    },
    _alignBits: function () {
        this._currentBit && (this._currentBit = 0, this._currentByte++)
    },
    _readUTF8: function () {
    }
});
cc.BuilderReader._ccbResolutionScale = 1;
cc.BuilderReader.setResolutionScale = function (a) {
    cc.BuilderReader._ccbResolutionScale = a
};
cc.BuilderReader.getResolutionScale = function () {
    return cc.BuilderReader._ccbResolutionScale
};
cc.BuilderReader.loadAsScene = function (a, b, d, e) {
    e = e || cc.BuilderReader.getResourcePath();
    a = cc.BuilderReader.load(a, b, d, e);
    b = new cc.Scene;
    b.addChild(a);
    return b
};
cc.BuilderReader._controllerClassCache = {};
cc.BuilderReader.registerController = function (a, b) {
    cc.BuilderReader._controllerClassCache[a] = cc.Class.extend(b)
};
cc.BuilderReader.load = function (a, b, d, e) {
    e = e || cc.BuilderReader.getResourcePath();
    var f = new cc.BuilderReader(cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary());
    f.setCCBRootPath(e);
    if (5 > a.length || a.toLowerCase().lastIndexOf(".ccbi") !== a.length - 5)a += ".ccbi";
    a = f.readNodeGraphFromFile(a, b, d);
    var g, h, n;
    if (b) {
        e = f.getOwnerCallbackNames();
        var p = f.getOwnerCallbackNodes(), r = f.getOwnerCallbackControlEvents();
        for (d = 0; d < e.length; d++)g = e[d], h = p[d], n = r[d], h instanceof cc.ControlButton ? h.addTargetWithActionForControlEvents(b,
            b[g], n) : h.setCallback(b[g], b);
        e = f.getOwnerOutletNames();
        p = f.getOwnerOutletNodes();
        for (d = 0; d < e.length; d++)g = e[d], h = p[d], b[g] = h
    }
    e = f.getNodesWithAnimationManagers();
    f = f.getAnimationManagersForNodes();
    if (!e || !f)return a;
    p = cc.BuilderReader._controllerClassCache;
    for (d = 0; d < e.length; d++) {
        var s = e[d], t = f[d];
        s.animationManager = t;
        if (g = t.getDocumentControllerName()) {
            r = p[g];
            if (!r)throw Error("Can not find controller : " + g);
            r = new r;
            r.controllerName = g;
            s.controller = r;
            r.rootNode = s;
            for (var v = t.getDocumentCallbackNames(),
                     u = t.getDocumentCallbackNodes(), x = t.getDocumentCallbackControlEvents(), s = 0; s < v.length; s++)g = v[s], h = u[s], n = x[s], h instanceof cc.ControlButton ? h.addTargetWithActionForControlEvents(r, r[g], n) : h.setCallback(r[g], r);
            n = t.getDocumentOutletNames();
            v = t.getDocumentOutletNodes();
            for (s = 0; s < n.length; s++)g = n[s], h = v[s], r[g] = h;
            if (r.onDidLoadFromCCB && cc.isFunction(r.onDidLoadFromCCB))r.onDidLoadFromCCB();
            g = t.getKeyframeCallbacks();
            for (s = 0; s < g.length; s++)n = g[s].split(":"), h = n[0], n = n[1], 1 == h ? t.setCallFunc(cc.callFunc(r[n],
                r), g[s]) : 2 == h && b && t.setCallFunc(cc.callFunc(b[n], b), g[s])
        }
    }
    t.runAnimations(t.getAutoPlaySequenceId(), 0);
    return a
};
cc.BuilderReader._resourcePath = "";
cc.BuilderReader.setResourcePath = function (a) {
    cc.BuilderReader._resourcePath = a
};
cc.BuilderReader.getResourcePath = function () {
    return cc.BuilderReader._resourcePath
};
cc.BuilderReader.lastPathComponent = function (a) {
    var b = a.lastIndexOf("/");
    return -1 !== b ? a.substring(b + 1, a.length - b) : a
};
cc.BuilderReader.deletePathExtension = function (a) {
    var b = a.lastIndexOf(".");
    return -1 !== b ? a.substring(0, b) : a
};
cc.BuilderReader.toLowerCase = function (a) {
    return a.toLowerCase()
};
cc.BuilderReader.endsWith = function (a, b) {
    return a.length >= b.length ? 0 === a.lastIndexOf(b) : !1
};
cc.BuilderReader.concat = function (a, b) {
    return a + b
};
cc.loader.register(["ccbi"], cc._binaryLoader);
cc.INT_VALUE = 0;
cc.FLOAT_VALUE = 1;
cc.POINTER_VALUE = 2;
cc.BOOL_VALUE = 3;
cc.UNSIGNEDCHAR_VALUE = 4;
cc.Color3BWapper = cc.Class.extend({
    _color: null, ctor: function () {
        this._color = cc.color(0, 0, 0)
    }, getColor: function () {
        return this._color
    }
});
cc.Color3BWapper.create = function (a) {
    var b = new cc.Color3BWapper;
    b && (b._color.r = a.r, b._color.g = a.g, b._color.b = a.b);
    return b
};
cc.BuilderValue = cc.Class.extend({
    _value: null, _type: 0, getIntValue: function () {
    }, getFloatValue: function () {
    }, getBoolValue: function () {
    }, getByteValue: function () {
    }, getPointer: function () {
    }, getValue: function () {
        return this._value
    }
});
cc.BuilderValue.create = function (a) {
    return new cc.BuilderValue
};
cc.BuilderKeyframe = cc.Class.extend({
    _value: null, _time: 0, _easingType: 0, _easingOpt: 0, getValue: function () {
        return this._value
    }, setValue: function (a) {
        this._value = a
    }, getTime: function () {
        return this._time
    }, setTime: function (a) {
        this._time = a
    }, getEasingType: function () {
        return this._easingType
    }, setEasingType: function (a) {
        this._easingType = a
    }, getEasingOpt: function () {
        return this._easingOpt
    }, setEasingOpt: function (a) {
        this._easingOpt = a
    }
});
cc.BuilderSequence = cc.Class.extend({
    _duration: 0,
    _name: "",
    _sequenceId: 0,
    _chainedSequenceId: 0,
    _callbackChannel: null,
    _soundChannel: null,
    ctor: function () {
        this._name = ""
    },
    getDuration: function () {
        return this._duration
    },
    setDuration: function (a) {
        this._duration = a
    },
    getName: function () {
        return this._name
    },
    setName: function (a) {
        this._name = a
    },
    getSequenceId: function () {
        return this._sequenceId
    },
    setSequenceId: function (a) {
        this._sequenceId = a
    },
    getChainedSequenceId: function () {
        return this._chainedSequenceId
    },
    setChainedSequenceId: function (a) {
        this._chainedSequenceId =
            a
    },
    getCallbackChannel: function () {
        return this._callbackChannel
    },
    setCallbackChannel: function (a) {
        this._callbackChannel = a
    },
    getSoundChannel: function () {
        return this._soundChannel
    },
    setSoundChannel: function (a) {
        this._soundChannel = a
    }
});
cc.BuilderSequenceProperty = cc.Class.extend({
    _name: null, _type: 0, _keyFrames: null, ctor: function () {
        this.init()
    }, init: function () {
        this._keyFrames = [];
        this._name = ""
    }, getName: function () {
        return this._name
    }, setName: function (a) {
        this._name = a
    }, getType: function () {
        return this._type
    }, setType: function (a) {
        this._type = a
    }, getKeyframes: function () {
        return this._keyFrames
    }
});
cc.getAbsolutePosition = function (a, b, d, e) {
    e = cc.p(0, 0);
    b === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT ? e = a : b === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT ? (e.x = a.x, e.y = d.height - a.y) : b === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT ? (e.x = d.width - a.x, e.y = d.height - a.y) : b === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT ? (e.x = d.width - a.x, e.y = a.y) : b === CCB_POSITIONTYPE_PERCENT ? (e.x = d.width * a.x / 100, e.y = d.height * a.y / 100) : b === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION && (b = cc.BuilderReader.getResolutionScale(), e.x = a.x * b, e.y = a.y * b);
    return e
};
cc._getAbsolutePosition = function (a, b, d, e, f) {
    f = cc.p(0, 0);
    d === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT ? (f.x = a, f.y = b) : d === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT ? (f.x = a, f.y = e.height - b) : d === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT ? (f.x = e.width - a, f.y = e.height - b) : d === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT ? (f.x = e.width - a, f.y = b) : d === CCB_POSITIONTYPE_PERCENT ? (f.x = e.width * a / 100, f.y = e.height * b / 100) : d === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION && (d = cc.BuilderReader.getResolutionScale(), f.x = a * d, f.y = b * d);
    return f
};
cc.setRelativeScale = function (a, b, d, e, f) {
    if (!a)throw Error("cc.setRelativeScale(): node should be non-null");
    e === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION && (e = cc.BuilderReader.getResolutionScale(), b *= e, d *= e);
    a.setScaleX(b);
    a.setScaleY(d)
};
cc.BuilderAnimationManagerDelegate = cc.Class.extend({
    completedAnimationSequenceNamed: function (a) {
    }
});
cc.BuilderAnimationManager = cc.Class.extend({
    _sequences: null,
    _nodeSequences: null,
    _baseValues: null,
    _autoPlaySequenceId: 0,
    _rootNode: null,
    _owner: null,
    _rootContainerSize: null,
    _delegate: null,
    _runningSequence: null,
    _documentOutletNames: null,
    _documentOutletNodes: null,
    _documentCallbackNames: null,
    _documentCallbackNodes: null,
    _documentCallbackControlEvents: null,
    _documentControllerName: "",
    _lastCompletedSequenceName: "",
    _keyframeCallbacks: null,
    _keyframeCallFuncs: null,
    _animationCompleteCallbackFunc: null,
    _target: null,
    _jsControlled: !1,
    ctor: function () {
        this._rootContainerSize = cc.size(0, 0);
        this.init()
    },
    init: function () {
        this._sequences = [];
        this._nodeSequences = new cc._Dictionary;
        this._baseValues = new cc._Dictionary;
        this._documentOutletNames = [];
        this._documentOutletNodes = [];
        this._documentCallbackNames = [];
        this._documentCallbackNodes = [];
        this._documentCallbackControlEvents = [];
        this._keyframeCallbacks = [];
        this._keyframeCallFuncs = {};
        return !0
    },
    getSequences: function () {
        return this._sequences
    },
    setSequences: function (a) {
        this._sequences =
            a
    },
    getAutoPlaySequenceId: function () {
        return this._autoPlaySequenceId
    },
    setAutoPlaySequenceId: function (a) {
        this._autoPlaySequenceId = a
    },
    getRootNode: function () {
        return this._rootNode
    },
    setRootNode: function (a) {
        this._rootNode = a
    },
    getOwner: function () {
        return this._owner
    },
    setOwner: function (a) {
        this._owner = a
    },
    addDocumentCallbackNode: function (a) {
        this._documentCallbackNodes.push(a)
    },
    addDocumentCallbackName: function (a) {
        this._documentCallbackNames.push(a)
    },
    addDocumentCallbackControlEvents: function (a) {
        this._documentCallbackControlEvents.push(a)
    },
    addDocumentOutletNode: function (a) {
        this._documentOutletNodes.push(a)
    },
    addDocumentOutletName: function (a) {
        this._documentOutletNames.push(a)
    },
    setDocumentControllerName: function (a) {
        this._documentControllerName = a
    },
    getDocumentControllerName: function () {
        return this._documentControllerName
    },
    getDocumentCallbackNames: function () {
        return this._documentCallbackNames
    },
    getDocumentCallbackNodes: function () {
        return this._documentCallbackNodes
    },
    getDocumentCallbackControlEvents: function () {
        return this._documentCallbackControlEvents
    },
    getDocumentOutletNames: function () {
        return this._documentOutletNames
    },
    getDocumentOutletNodes: function () {
        return this._documentOutletNodes
    },
    getLastCompletedSequenceName: function () {
        return this._lastCompletedSequenceName
    },
    getKeyframeCallbacks: function () {
        return this._keyframeCallbacks
    },
    getRootContainerSize: function () {
        return this._rootContainerSize
    },
    setRootContainerSize: function (a) {
        this._rootContainerSize = cc.size(a.width, a.height)
    },
    getDelegate: function () {
        return this._delegate
    },
    setDelegate: function (a) {
        this._delegate =
            a
    },
    getRunningSequenceName: function () {
        return this._runningSequence ? this._runningSequence.getName() : null
    },
    getContainerSize: function (a) {
        return a ? a.getContentSize() : this._rootContainerSize
    },
    addNode: function (a, b) {
        this._nodeSequences.setObject(b, a)
    },
    setBaseValue: function (a, b, d) {
        var e = this._baseValues.objectForKey(b);
        e || (e = new cc._Dictionary, this._baseValues.setObject(e, b));
        e.setObject(a, d)
    },
    moveAnimationsFromNode: function (a, b) {
        var d = this._baseValues, e = d.objectForKey(a);
        null !== e && (d.setObject(e, b), d.removeObjectForKey(a));
        d = this._nodeSequences;
        e = d.objectForKey(a);
        null != e && (d.setObject(e, b), d.removeObjectForKey(a))
    },
    getActionForCallbackChannel: function (a) {
        var b = 0, d = [];
        a = a.getKeyframes();
        for (var e = a.length, f = 0; f < e; ++f) {
            var g = a[f], h = g.getTime() - b, b = g.getTime();
            0 < h && d.push(cc.delayTime(h));
            h = g.getValue();
            g = h[0];
            h = h[1];
            if (this._jsControlled)g = this._keyframeCallFuncs[h + ":" + g], null != g && d.push(g); else {
                var n;
                h === CCB_TARGETTYPE_DOCUMENTROOT ? n = this._rootNode : h === CCB_TARGETTYPE_OWNER && (n = this._owner);
                null != n && (0 < g.length ? (h = 0,
                null != n.onResolveCCBCCCallFuncSelector && (h = n.onResolveCCBCCCallFuncSelector(n, g)), 0 === h ? cc.log("Skipping selector '" + g + "' since no CCBSelectorResolver is present.") : d.push(cc.callFunc(h, n))) : cc.log("Unexpected empty selector."))
            }
        }
        return 1 > d.length ? null : cc.sequence(d)
    },
    getActionForSoundChannel: function (a) {
        var b = 0, d = [];
        a = a.getKeyframes();
        for (var e = a.length, f = 0; f < e; ++f) {
            var g = a[f], h = g.getTime() - b, b = g.getTime();
            0 < h && d.push(cc.delayTime(h));
            var n = g.getValue(), g = cc.BuilderReader.getResourcePath() + n[0],
                h = parseFloat(n[1]), p = parseFloat(n[2]), n = parseFloat(n[3]);
            d.push(cc.BuilderSoundEffect.create(g, h, p, n))
        }
        return 1 > d.length ? null : cc.sequence(d)
    },
    runAnimationsForSequenceNamed: function (a) {
        this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(a), 0)
    },
    runAnimationsForSequenceNamedTweenDuration: function (a, b) {
        this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(a), b)
    },
    runAnimationsForSequenceIdTweenDuration: function (a, b) {
        if (-1 === a)throw Error("cc.BuilderAnimationManager.runAnimationsForSequenceIdTweenDuration(): Sequence id should not be -1");
        b = b || 0;
        this._rootNode.stopAllActions();
        for (var d = this._nodeSequences.allKeys(), e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            g.stopAllActions();
            var h = this._nodeSequences.objectForKey(g).objectForKey(a), n, p = [];
            if (h) {
                var r = h.allKeys();
                for (n = 0; n < r.length; n++) {
                    var s = r[n], t = h.objectForKey(s);
                    p.push(s);
                    this._setFirstFrame(g, t, b);
                    this._runAction(g, t, b)
                }
            }
            if (h = this._baseValues.objectForKey(g))for (r = h.allKeys(), n = 0; n < r.length; n++)s = r[n], -1 === p.indexOf(s) && (t = h.objectForKey(s), null != t && this._setAnimatedProperty(s, g, t,
                b))
        }
        d = this._getSequence(a);
        e = cc.sequence(cc.delayTime(d.getDuration() + b), cc.callFunc(this._sequenceCompleted, this));
        this._rootNode.runAction(e);
        d.getCallbackChannel() && (e = this.getActionForCallbackChannel(d.getCallbackChannel())) && this._rootNode.runAction(e);
        d.getSoundChannel() && (e = this.getActionForSoundChannel(d.getSoundChannel())) && this._rootNode.runAction(e);
        this._runningSequence = this._getSequence(a)
    },
    runAnimations: function (a, b) {
        b = b || 0;
        var d;
        d = cc.isString(a) ? this._getSequenceId(a) : a;
        this.runAnimationsForSequenceIdTweenDuration(d,
            b)
    },
    setAnimationCompletedCallback: function (a, b) {
        this._target = a;
        this._animationCompleteCallbackFunc = b
    },
    setCompletedAnimationCallback: function (a, b) {
        this.setAnimationCompletedCallback(a, b)
    },
    setCallFunc: function (a, b) {
        this._keyframeCallFuncs[b] = a
    },
    debug: function () {
    },
    _getBaseValue: function (a, b) {
        var d = this._baseValues.objectForKey(a);
        return d ? d.objectForKey(b) : null
    },
    _getSequenceId: function (a) {
        for (var b = null, d = this._sequences, e = 0, f = d.length; e < f; e++)if ((b = d[e]) && b.getName() === a)return b.getSequenceId();
        return -1
    },
    _getSequence: function (a) {
        for (var b = null, d = this._sequences, e = 0, f = d.length; e < f; e++)if ((b = d[e]) && b.getSequenceId() === a)return b;
        return null
    },
    _getAction: function (a, b, d, e) {
        a = b.getTime() - (a ? a.getTime() : 0);
        var f, g;
        if ("rotation" === d)return cc.BuilderRotateTo.create(a, b.getValue());
        if ("rotationX" === d)return cc.BuilderRotateXTo.create(a, b.getValue());
        if ("rotationY" === d)return cc.BuilderRotateYTo.create(a, b.getValue());
        if ("opacity" === d)return cc.fadeTo(a, b.getValue());
        if ("color" === d)return d = b.getValue().getColor(),
            cc.tintTo(a, d.r, d.g, d.b);
        if ("visible" === d)return b.getValue() ? cc.sequence(cc.delayTime(a), cc.show()) : cc.sequence(cc.delayTime(a), cc.hide());
        if ("displayFrame" === d)return cc.sequence(cc.delayTime(a), cc.BuilderSetSpriteFrame.create(b.getValue()));
        if ("position" === d)return f = this._getBaseValue(e, d), f = f[2], g = b.getValue(), b = g[0], g = g[1], e = this.getContainerSize(e.getParent()), d = cc._getAbsolutePosition(b, g, f, e, d), cc.moveTo(a, d);
        if ("scale" === d)return f = this._getBaseValue(e, d), f = f[2], g = b.getValue(), b = g[0], g =
            g[1], f === CCB_SCALETYPE_MULTIPLY_RESOLUTION && (d = cc.BuilderReader.getResolutionScale(), b *= d, g *= d), cc.scaleTo(a, b, g);
        if ("skew" === d)return g = b.getValue(), b = g[0], g = g[1], cc.skewTo(a, b, g);
        cc.log("BuilderReader: Failed to create animation for property: " + d);
        return null
    },
    _setAnimatedProperty: function (a, b, d, e) {
        if (0 < e) {
            var f = new cc.BuilderKeyframe;
            f.setValue(d);
            f.setTime(e);
            f.setEasingType(CCB_KEYFRAME_EASING_LINEAR);
            a = this._getAction(null, f, a, b);
            b.runAction(a)
        } else"position" === a ? (e = this._getBaseValue(b, a),
            e = e[2], f = d[0], d = d[1], b.setPosition(cc._getAbsolutePosition(f, d, e, this.getContainerSize(b.getParent()), a))) : "scale" === a ? (e = this._getBaseValue(b, a), e = e[2], f = d[0], d = d[1], cc.setRelativeScale(b, f, d, e, a)) : "skew" === a ? (f = d[0], d = d[1], b.setSkewX(f), b.setSkewY(d)) : "rotation" === a ? b.setRotation(d) : "rotationX" === a ? b.setRotationSkewX(d) : "rotationY" === a ? b.setRotationSkewY(d) : "opacity" === a ? b.setOpacity(d) : "displayFrame" === a ? b.setSpriteFrame(d) : "color" === a ? (a = d.getColor(), 255 === a.r && 255 === a.g && 255 === a.b || b.setColor(a)) :
            "visible" === a ? b.setVisible(d || !1) : cc.log("unsupported property name is " + a)
    },
    _setFirstFrame: function (a, b, d) {
        var e = b.getKeyframes();
        0 === e.length ? ((e = this._getBaseValue(a, b.getName())) || cc.log("cc.BuilderAnimationManager._setFirstFrame(): No baseValue found for property"), this._setAnimatedProperty(b.getName(), a, e, d)) : (e = e[0], this._setAnimatedProperty(b.getName(), a, e.getValue(), d))
    },
    _getEaseAction: function (a, b, d) {
        if (b === CCB_KEYFRAME_EASING_LINEAR || b === CCB_KEYFRAME_EASING_INSTANT)return a;
        if (b === CCB_KEYFRAME_EASING_CUBIC_IN)return a.easing(cc.easeIn(d));
        if (b === CCB_KEYFRAME_EASING_CUBIC_OUT)return a.easing(cc.easeOut(d));
        if (b === CCB_KEYFRAME_EASING_CUBIC_INOUT)return a.easing(cc.easeInOut(d));
        if (b === CCB_KEYFRAME_EASING_BACK_IN)return a.easing(cc.easeBackIn());
        if (b === CCB_KEYFRAME_EASING_BACK_OUT)return a.easing(cc.easeBackOut());
        if (b === CCB_KEYFRAME_EASING_BACK_INOUT)return a.easing(cc.easeBackInOut());
        if (b === CCB_KEYFRAME_EASING_BOUNCE_IN)return a.easing(cc.easeBounceIn());
        if (b === CCB_KEYFRAME_EASING_BOUNCE_OUT)return a.easing(cc.easeBounceOut());
        if (b ===
            CCB_KEYFRAME_EASING_BOUNCE_INOUT)return a.easing(cc.easeBounceInOut());
        if (b === CCB_KEYFRAME_EASING_ELASTIC_IN)return a.easing(cc.easeElasticIn(d));
        if (b === CCB_KEYFRAME_EASING_ELASTIC_OUT)return a.easing(cc.easeElasticOut(d));
        if (b === CCB_KEYFRAME_EASING_ELASTIC_INOUT)return a.easing(cc.easeElasticInOut(d));
        cc.log("BuilderReader: Unknown easing type " + b);
        return a
    },
    _runAction: function (a, b, d) {
        var e = b.getKeyframes(), f = e.length;
        if (1 < f) {
            var g = [];
            d = e[0].getTime() + d;
            0 < d && g.push(cc.delayTime(d));
            for (d = 0; d < f - 1; ++d) {
                var h =
                    e[d], n = this._getAction(h, e[d + 1], b.getName(), a);
                n && (n = this._getEaseAction(n, h.getEasingType(), h.getEasingOpt()), g.push(n))
            }
            a.runAction(cc.sequence(g))
        }
    },
    _sequenceCompleted: function () {
        var a = this._runningSequence, b = a.getName();
        this._lastCompletedSequenceName != a.getName() && (this._lastCompletedSequenceName = a.getName());
        a = a.getChainedSequenceId();
        this._runningSequence = null;
        -1 !== a && this.runAnimations(a, 0);
        this._delegate && this._delegate.completedAnimationSequenceNamed(b);
        this._target && this._animationCompleteCallbackFunc &&
        this._animationCompleteCallbackFunc.call(this._target)
    }
});
cc.BuilderSetSpriteFrame = cc.ActionInstant.extend({
    _spriteFrame: null, initWithSpriteFrame: function (a) {
        this._spriteFrame = a;
        return !0
    }, update: function (a) {
        this.target.setSpriteFrame(this._spriteFrame)
    }
});
cc.BuilderSetSpriteFrame.create = function (a) {
    var b = new cc.BuilderSetSpriteFrame;
    return b && b.initWithSpriteFrame(a) ? b : null
};
cc.BuilderRotateTo = cc.ActionInterval.extend({
    _startAngle: 0,
    _dstAngle: 0,
    _diffAngle: 0,
    initWithDuration: function (a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngle = b, !0) : !1
    },
    update: function (a) {
        this.target.setRotation(this._startAngle + this._diffAngle * a)
    },
    startWithTarget: function (a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startAngle = this.target.getRotation();
        this._diffAngle = this._dstAngle - this._startAngle
    }
});
cc.BuilderRotateTo.create = function (a, b) {
    var d = new cc.BuilderRotateTo;
    return d && d.initWithDuration(a, b) ? d : null
};
cc.BuilderRotateXTo = cc.ActionInterval.extend({});
cc.BuilderRotateXTo.create = function (a, b) {
    throw Error("rotationX has not been implemented in cocos2d-html5");
};
cc.BuilderRotateYTo = cc.ActionInterval.extend({});
cc.BuilderRotateYTo.create = function (a, b) {
    throw Error("rotationY has not been implemented in cocos2d-html5");
};
cc.BuilderSoundEffect = cc.ActionInstant.extend({
    init: function (a) {
        this._file = a;
        return !0
    }, update: function (a) {
        cc.audioEngine.playEffect(this._file)
    }
});
cc.BuilderSoundEffect.create = function (a, b, d, e) {
    return (b = new cc.BuilderSoundEffect) && b.init(a) ? b : null
};
cc.DOM = {};
cc.DOM._addMethods = function (a) {
    for (var b in cc.DOM.methods)a[b] = cc.DOM.methods[b];
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
    cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
    cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
    cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
    cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
    cc.defineGetterSetter(a,
        "scaleX", a.getScaleX, a.setScaleX);
    cc.defineGetterSetter(a, "scaleY", a.getScaleY, a.setScaleY);
    cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
    cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
    cc.defineGetterSetter(a, "skewY", a.getSkewY, a.setSkewY);
    cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
    cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity)
};
cc.DOM.methods = {
    setPosition: function (a, b) {
        void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b);
        this.setNodeDirty();
        this.dom.translates(this._position.x, -this._position.y)
    }, setPositionY: function (a) {
        this._position.y = a;
        this.setNodeDirty();
        this.dom.translates(this._position.x, -this._position.y)
    }, setPositionX: function (a) {
        this._position.x = a;
        this.setNodeDirty();
        this.dom.translates(this._position.x, -this._position.y)
    }, setScale: function (a, b) {
        this._scaleX = a;
        this._scaleY =
            b || a;
        this.setNodeDirty();
        this.dom.resize(this._scaleX, this._scaleY)
    }, setScaleX: function (a) {
        this._scaleX = a;
        this.setNodeDirty();
        this.dom.resize(this._scaleX, this._scaleY)
    }, setScaleY: function (a) {
        this._scaleY = a;
        this.setNodeDirty();
        this.dom.resize(this._scaleX, this._scaleY)
    }, setAnchorPoint: function (a, b) {
        var d = this._renderCmd, e = this._anchorPoint;
        void 0 === b ? (e.x = a.x, e.y = a.y) : (e.x = a, e.y = b);
        var d = d._anchorPointInPoints, f = this._contentSize;
        d.x = f.width * e.x;
        d.y = f.height * e.y;
        this.dom.style[cc.$.pfx + "TransformOrigin"] =
            "" + d.x + "px " + -d.y + "px";
        this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : (this.dom.style.marginLeft = this.isToggler ? 0 : -d.x + "px", this.dom.style.marginBottom = -d.y + "px");
        this.setNodeDirty()
    }, _setAnchorX: function (a) {
        var b = this._anchorPoint, d = this._renderCmd;
        a !== b.x && (b.x = a, a = d._anchorPointInPoints, a.x = this._contentSize.width * b.x, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + a.x + "px " + -a.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginLeft =
            this.isToggler ? 0 : -a.x + "px", this.setNodeDirty())
    }, _setAnchorY: function (a) {
        var b = this._anchorPoint, d = this._renderCmd;
        a !== b.y && (b.y = a, a = d._anchorPointInPoints, a.y = this._contentSize.height * b.y, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + a.x + "px " + -a.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginBottom = -a.y + "px", this.setNodeDirty())
    }, setContentSize: function (a, b) {
        var d = this._renderCmd, e = this._contentSize;
        void 0 === b ? (e.width = a.width, e.height =
            a.height) : (e.width = a, e.height = b);
        var d = d._anchorPointInPoints, f = this._anchorPoint;
        d.x = e.width * f.x;
        d.y = e.height * f.y;
        this.dom.width = e.width;
        this.dom.height = e.height;
        this.setAnchorPoint(this.getAnchorPoint());
        this.canvas && (this.canvas.width = e.width, this.canvas.height = e.height);
        this.setNodeDirty();
        this.redraw()
    }, _setWidth: function (a) {
        var b = this._contentSize, d = this._renderCmd;
        a !== b.width && (b.width = a, a = this._anchorPoint, d._anchorPointInPoints.x = b.width * a.x, this.dom.width = b.width, this.anchorX = a.x, this.canvas &&
        (this.canvas.width = b.width), this.setNodeDirty(), this.redraw())
    }, _setHeight: function (a) {
        var b = this._contentSize, d = this._renderCmd;
        a !== b.height && (b.height = a, a = this._anchorPoint, d._anchorPointInPoints.y = b.height * a.y, this.dom.height = b.height, this.anchorY = a.y, this.canvas && (this.canvas.height = b.height), this.setNodeDirty(), this.redraw())
    }, setRotation: function (a) {
        this._rotation !== a && (this._rotationX = this._rotationY = a, this.setNodeDirty(), this.dom.rotate(a))
    }, setSkewX: function (a) {
        this._skewX = a;
        this.setNodeDirty();
        this.dom.setSkew(this._skewX, this._skewY)
    }, setSkewY: function (a) {
        this._skewY = a;
        this.setNodeDirty();
        this.dom.setSkew(this._skewX, this._skewY)
    }, setVisible: function (a) {
        this._visible = a;
        this.setNodeDirty();
        this.dom && (this.dom.style.display = a ? "block" : "none")
    }, _setLocalZOrder: function (a) {
        this._localZOrder = a;
        this.setNodeDirty();
        this.dom && (this.dom.zIndex = a)
    }, setParent: function (a) {
        this._parent = a;
        null !== a && (a.setAnchorPoint(a.getAnchorPoint()), this.setNodeDirty(), cc.DOM.parentDOM(this))
    }, resume: function () {
        this.getScheduler().resumeTarget(this);
        this.getActionManager().resumeTarget(this);
        cc.eventManager.resumeTarget(this);
        this.dom && !this.dom.parentNode && (this.getParent() ? cc.DOM.parentDOM(this) : "" === this.dom.id ? cc.DOM._createEGLViewDiv(this) : this.dom.appendTo(cc.container));
        this.dom && (this.dom.style.visibility = "visible")
    }, pause: function () {
        this.getScheduler().pauseTarget(this);
        this.getActionManager().pauseTarget(this);
        cc.eventManager.pauseTarget(this);
        this.dom && (this.dom.style.visibility = "hidden")
    }, cleanup: function () {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup);
        this.dom && this.dom.remove()
    }, setOpacity: function (a) {
        this._opacity = a;
        this.dom.style.opacity = a / 255
    }, redraw: function () {
        if (this.isSprite) {
            var a = this._children;
            this._children = [];
            cc.Sprite.prototype.visit.call(this, this.ctx);
            this._children = a
        } else cc.Sprite.prototype.visit.call(this, this.ctx)
    }
};
cc.DOM._resetEGLViewDiv = function () {
    var a = cc.$("#EGLViewDiv");
    if (a) {
        var b = cc.view, d = b.getDesignResolutionSize();
        b.getViewPortRect();
        var e = b.getFrameSize(), f = b.getDevicePixelRatio(), g = d.width, h = d.height;
        0 === d.width && 0 === d.height && (g = e.width, h = e.height);
        a.style.position = "absolute";
        a.style.width = g + "px";
        a.style.maxHeight = h + "px";
        a.style.margin = 0;
        a.resize(b.getScaleX() / f, b.getScaleY() / f);
        b.getResolutionPolicy() === b._rpNoBorder ? (a.style.left = (b.getFrameSize().width - g) / 2 + "px", a.style.bottom = (b.getFrameSize().height -
            h * b.getScaleY() / f) / 2 + "px") : (a.style.left = (g * b.getScaleX() / f - g) / 2 + "px", a.style.bottom = "0px")
    }
};
cc.DOM.parentDOM = function (a) {
    var b = a.getParent();
    if (!b || !a.dom)return !1;
    b.dom || (cc.DOM.placeHolder(b), b.setParent = cc.DOM.methods.setParent);
    a.dom.appendTo(b.dom);
    b.setAnchorPoint(b.getAnchorPoint());
    b.getParent() ? cc.DOM.parentDOM(b) : b.isRunning() && ((a = cc.$("#EGLViewDiv")) ? b.dom.appendTo(a) : cc.DOM._createEGLViewDiv(b));
    return !0
};
cc.DOM._createEGLViewDiv = function (a) {
    var b = cc.$("#EGLViewDiv");
    b || (b = cc.$new("div"), b.id = "EGLViewDiv");
    var d = cc.view, e = d.getDesignResolutionSize();
    d.getViewPortRect();
    var f = d.getFrameSize(), g = d.getDevicePixelRatio(), h = e.width, n = e.height;
    0 === e.width && 0 === e.height && (h = f.width, n = f.height);
    b.style.position = "absolute";
    b.style.width = h + "px";
    b.style.maxHeight = n + "px";
    b.style.margin = 0;
    b.resize(d.getScaleX() / g, d.getScaleY() / g);
    d.getResolutionPolicy() === d._rpNoBorder ? (b.style.left = (f.width - h) / 2 + "px", b.style.bottom =
        (f.height - n * d.getScaleY() / g) / 2 + "px") : (b.style.left = (h * d.getScaleX() / g - h) / 2 + "px", b.style.bottom = "0px");
    a.dom.appendTo(b);
    b.appendTo(cc.container)
};
cc.DOM.setTransform = function (a) {
    if (a.ctx)if (a.ctx.translate(a.getAnchorPointInPoints().x, a.getAnchorPointInPoints().y), a.isSprite) {
        var b = a._children;
        a._children = [];
        cc.Sprite.prototype.visit.call(a);
        a._children = b
    } else cc.Sprite.prototype.visit.call(a);
    a.dom && (a.dom.position.x = a.getPositionX(), a.dom.position.y = -a.getPositionY(), a.dom.rotation = a.getRotation(), a.dom.scale = {
        x: a.getScaleX(),
        y: a.getScaleY()
    }, a.dom.skew = {x: a.getSkewX(), y: a.getSkewY()}, a.setAnchorPoint && a.setAnchorPoint(a.getAnchorPoint()),
        a.dom.transforms())
};
cc.DOM.forSprite = function (a) {
    a.dom = cc.$new("div");
    a.canvas = cc.$new("canvas");
    var b = a.getContentSize();
    a.canvas.width = b.width;
    a.canvas.height = b.height;
    a.dom.style.position = "absolute";
    a.dom.style.bottom = 0;
    a.ctx = a.canvas.getContext("2d");
    a.dom.appendChild(a.canvas);
    a.getParent() && cc.DOM.parentDOM(a);
    a.isSprite = !0
};
cc.DOM.placeHolder = function (a) {
    a.dom = cc.$new("div");
    a.placeholder = !0;
    a.dom.style.position = "absolute";
    a.dom.style.bottom = 0;
    a.dom.style.width = (a.getContentSize().width || cc.director.getWinSize().width) + "px";
    a.dom.style.maxHeight = (a.getContentSize().height || cc.director.getWinSize().height) + "px";
    a.dom.style.margin = 0;
    cc.DOM.setTransform(a);
    a.dom.transforms();
    cc.DOM._addMethods(a)
};
cc.DOM.convert = function (a) {
    if (1 < arguments.length)cc.DOM.convert(arguments); else if (1 !== arguments.length || arguments[0].length)for (var b = arguments[0], d = 0; d < b.length; d++)b[d] instanceof cc.Sprite ? b[d].dom || cc.DOM.forSprite(b[d]) : cc.log("DOM converter only supports sprite and menuitems yet"), cc.DOM._addMethods(b[d]), b[d].visit = function () {
    }, b[d].transform = function () {
    }, cc.DOM.setTransform(b[d]), b[d].setVisible(b[d].isVisible()); else cc.DOM.convert([arguments[0]])
};
cc.KEYBOARD_RETURNTYPE_DEFAULT = 0;
cc.KEYBOARD_RETURNTYPE_DONE = 1;
cc.KEYBOARD_RETURNTYPE_SEND = 2;
cc.KEYBOARD_RETURNTYPE_SEARCH = 3;
cc.KEYBOARD_RETURNTYPE_GO = 4;
cc.EDITBOX_INPUT_MODE_ANY = 0;
cc.EDITBOX_INPUT_MODE_EMAILADDR = 1;
cc.EDITBOX_INPUT_MODE_NUMERIC = 2;
cc.EDITBOX_INPUT_MODE_PHONENUMBER = 3;
cc.EDITBOX_INPUT_MODE_URL = 4;
cc.EDITBOX_INPUT_MODE_DECIMAL = 5;
cc.EDITBOX_INPUT_MODE_SINGLELINE = 6;
cc.EDITBOX_INPUT_FLAG_PASSWORD = 0;
cc.EDITBOX_INPUT_FLAG_SENSITIVE = 1;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_WORD = 2;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_SENTENCE = 3;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_ALL_CHARACTERS = 4;
cc.EditBoxDelegate = cc.Class.extend({
    editBoxEditingDidBegin: function (a) {
    }, editBoxEditingDidEnd: function (a) {
    }, editBoxTextChanged: function (a, b) {
    }, editBoxReturn: function (a) {
    }
});
cc.EditBox = cc.ControlButton.extend({
    _domInputSprite: null,
    _delegate: null,
    _editBoxInputMode: cc.EDITBOX_INPUT_MODE_ANY,
    _editBoxInputFlag: cc.EDITBOX_INPUT_FLAG_SENSITIVE,
    _keyboardReturnType: cc.KEYBOARD_RETURNTYPE_DEFAULT,
    _text: "",
    _placeholderText: "",
    _textColor: null,
    _placeholderColor: null,
    _maxLength: 50,
    _adjustHeight: 18,
    _edTxt: null,
    _edFontSize: 14,
    _edFontName: "Arial",
    _placeholderFontName: "",
    _placeholderFontSize: 14,
    _tooltip: !1,
    _className: "EditBox",
    _onCanvasClick: null,
    _inputEvent: null,
    _keyPressEvent: null,
    _focusEvent: null,
    _blurEvent: null,
    ctor: function (a, b, d, e) {
        cc.ControlButton.prototype.ctor.call(this);
        this._textColor = cc.color.WHITE;
        this._placeholderColor = cc.color.GRAY;
        this.setContentSize(a);
        var f = this._domInputSprite = new cc.Sprite;
        f.draw = function () {
        };
        this.addChild(f);
        var g = this._edTxt = document.createElement("input");
        g.type = "text";
        g.style.fontSize = this._edFontSize + "px";
        g.style.color = "#000000";
        g.style.border = 0;
        g.style.background = "transparent";
        g.style.width = "100%";
        g.style.height = "100%";
        g.style.active =
            0;
        g.style.outline = "medium";
        g.style.padding = "0";
        this._onCanvasClick = function () {
            this._edTxt.blur()
        }.bind(this);
        this._inputEvent = function () {
            this._delegate && this._delegate.editBoxTextChanged && this._delegate.editBoxTextChanged(this, this._edTxt.value)
        }.bind(this);
        this._keyPressEvent = function (a) {
            a.keyCode === cc.KEY.enter && (a.stopPropagation(), a.preventDefault(), this._delegate && this._delegate.editBoxReturn && this._delegate.editBoxReturn(this), cc._canvas.focus())
        }.bind(this);
        this._focusEvent = function () {
            this._edTxt.value ===
            this._placeholderText && (this._edTxt.value = "", this._edTxt.style.fontSize = this._edFontSize + "px", this._edTxt.style.color = cc.colorToHex(this._textColor), this._edTxt.type = this._editBoxInputFlag === cc.EDITBOX_INPUT_FLAG_PASSWORD ? "password" : "text");
            this._delegate && this._delegate.editBoxEditingDidBegin && this._delegate.editBoxEditingDidBegin(this);
            cc._canvas.addEventListener("click", this._onCanvasClick)
        }.bind(this);
        this._blurEvent = function () {
            "" === this._edTxt.value && (this._edTxt.value = this._placeholderText,
                this._edTxt.style.fontSize = this._placeholderFontSize + "px", this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._edTxt.type = "text");
            this._delegate && this._delegate.editBoxEditingDidEnd && this._delegate.editBoxEditingDidEnd(this);
            cc._canvas.removeEventListener("click", this._onCanvasClick)
        }.bind(this);
        g.addEventListener("input", this._inputEvent);
        g.addEventListener("keypress", this._keyPressEvent);
        g.addEventListener("focus", this._focusEvent);
        g.addEventListener("blur", this._blurEvent);
        cc.DOM.convert(f);
        f.dom.appendChild(g);
        f.dom.showTooltipDiv = !1;
        f.dom.style.width = a.width - 6 + "px";
        f.dom.style.height = a.height - 6 + "px";
        f.canvas.remove();
        this.initWithSizeAndBackgroundSprite(a, b) && (d && this.setBackgroundSpriteForState(d, cc.CONTROL_STATE_HIGHLIGHTED), e && this.setBackgroundSpriteForState(e, cc.CONTROL_STATE_DISABLED))
    },
    setFont: function (a, b) {
        this._edFontSize = b;
        this._edFontName = a;
        this._setFontToEditBox()
    },
    _setFont: function (a) {
        if (a = cc.LabelTTF._fontStyleRE.exec(a))this._edFontSize = parseInt(a[1]), this._edFontName =
            a[2], this._setFontToEditBox()
    },
    setFontName: function (a) {
        this._edFontName = a;
        this._setFontToEditBox()
    },
    setFontSize: function (a) {
        this._edFontSize = a;
        this._setFontToEditBox()
    },
    _setFontToEditBox: function () {
        this._edTxt.value !== this._placeholderText && (this._edTxt.style.fontFamily = this._edFontName, this._edTxt.style.fontSize = this._edFontSize + "px", this._edTxt.type = this._editBoxInputFlag === cc.EDITBOX_INPUT_FLAG_PASSWORD ? "password" : "text")
    },
    setText: function (a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function (a) {
        null != a && ("" === a ? (this._edTxt.value = this._placeholderText, this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._edTxt.type = "text") : (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._textColor), this._edTxt.type = this._editBoxInputFlag === cc.EDITBOX_INPUT_FLAG_PASSWORD ? "password" : "text"))
    },
    setFontColor: function (a) {
        this._textColor = a;
        this._edTxt.value !== this._placeholderText && (this._edTxt.style.color = cc.colorToHex(a))
    },
    setMaxLength: function (a) {
        !isNaN(a) &&
        0 < a && (this._maxLength = a, this._edTxt.maxLength = a)
    },
    getMaxLength: function () {
        return this._maxLength
    },
    setPlaceHolder: function (a) {
        if (null != a) {
            var b = this._placeholderText;
            this._placeholderText = a;
            this._edTxt.value === b && (this._edTxt.value = a, this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._setPlaceholderFontToEditText())
        }
    },
    setPlaceholderFont: function (a, b) {
        this._placeholderFontName = a;
        this._placeholderFontSize = b;
        this._setPlaceholderFontToEditText()
    },
    _setPlaceholderFont: function (a) {
        if (a = cc.LabelTTF._fontStyleRE.exec(a))this._placeholderFontName =
            a[2], this._placeholderFontSize = parseInt(a[1]), this._setPlaceholderFontToEditText()
    },
    setPlaceholderFontName: function (a) {
        this._placeholderFontName = a;
        this._setPlaceholderFontToEditText()
    },
    setPlaceholderFontSize: function (a) {
        this._placeholderFontSize = a;
        this._setPlaceholderFontToEditText()
    },
    _setPlaceholderFontToEditText: function () {
        this._edTxt.value === this._placeholderText && (this._edTxt.style.fontFamily = this._placeholderFontName, this._edTxt.style.fontSize = this._placeholderFontSize + "px", this._edTxt.type =
            "text")
    },
    setPlaceholderFontColor: function (a) {
        this._placeholderColor = a;
        this._edTxt.value === this._placeholderText && (this._edTxt.style.color = cc.colorToHex(a))
    },
    setInputFlag: function (a) {
        this._editBoxInputFlag = a;
        this._edTxt.type = this._edTxt.value !== this._placeholderText && a === cc.EDITBOX_INPUT_FLAG_PASSWORD ? "password" : "text"
    },
    getText: function () {
        cc.log("Please use the getString");
        return this._edTxt.value
    },
    getString: function () {
        return this._edTxt.value === this._placeholderText ? "" : this._edTxt.value
    },
    initWithSizeAndBackgroundSprite: function (a,
                                               b) {
        return this.initWithBackgroundSprite(b) ? (this._domInputSprite.x = 3, this._domInputSprite.y = 3, this.setZoomOnTouchDown(!1), this.setPreferredSize(a), this.y = this.x = 0, this._addTargetWithActionForControlEvent(this, this.touchDownAction, cc.CONTROL_EVENT_TOUCH_UP_INSIDE), !0) : !1
    },
    setDelegate: function (a) {
        this._delegate = a
    },
    getPlaceHolder: function () {
        return this._placeholderText
    },
    setInputMode: function (a) {
        this._editBoxInputMode = a
    },
    setReturnType: function (a) {
        this._keyboardReturnType = a
    },
    keyboardWillShow: function (a) {
        var b =
            cc.EditBox.getRect(this);
        b.y -= 4;
        b.intersectsRect(a.end) ? this._adjustHeight = a.end.getMaxY() - b.getMinY() : cc.log("needn't to adjust view layout.")
    },
    keyboardDidShow: function (a) {
    },
    keyboardWillHide: function (a) {
    },
    keyboardDidHide: function (a) {
    },
    touchDownAction: function (a, b) {
    },
    initWithBackgroundColor: function (a, b) {
        this._edWidth = a.width;
        this.dom.style.width = this._edWidth.toString() + "px";
        this._edHeight = a.height;
        this.dom.style.height = this._edHeight.toString() + "px";
        this.dom.style.backgroundColor = cc.colorToHex(b)
    },
    cleanup: function () {
        this._edTxt.removeEventListener("input", this._inputEvent);
        this._edTxt.removeEventListener("keypress", this._keyPressEvent);
        this._edTxt.removeEventListener("focus", this._focusEvent);
        this._edTxt.removeEventListener("blur", this._blurEvent);
        cc._canvas.removeEventListener("click", this._onCanvasClick);
        this._super()
    }
});
_p = cc.EditBox.prototype;
cc.defineGetterSetter(_p, "font", null, _p._setFont);
cc.defineGetterSetter(_p, "fontName", null, _p.setFontName);
cc.defineGetterSetter(_p, "fontSize", null, _p.setFontSize);
cc.defineGetterSetter(_p, "fontColor", null, _p.setFontColor);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.defineGetterSetter(_p, "placeHolderFont", null, _p._setPlaceholderFont);
cc.defineGetterSetter(_p, "placeHolderFontName", null, _p.setPlaceholderFontName);
cc.defineGetterSetter(_p, "placeHolderFontSize", null, _p.setPlaceholderFontSize);
cc.defineGetterSetter(_p, "placeHolderFontColor", null, _p.setPlaceholderFontColor);
cc.defineGetterSetter(_p, "inputFlag", null, _p.setInputFlag);
cc.defineGetterSetter(_p, "delegate", null, _p.setDelegate);
cc.defineGetterSetter(_p, "inputMode", null, _p.setInputMode);
cc.defineGetterSetter(_p, "returnType", null, _p.setReturnType);
_p = null;
cc.EditBox.getRect = function (a) {
    var b = a.getContentSize(), b = cc.rect(0, 0, b.width, b.height);
    return cc.rectApplyAffineTransform(b, a.getNodeToWorldTransform())
};
cc.EditBox.create = function (a, b, d, e) {
    return new cc.EditBox(a, b, d, e)
};
cc.ProtectedNode = cc.Node.extend({
    _protectedChildren: null, _reorderProtectedChildDirty: !1, _insertProtectedChild: function (a, b) {
        this._reorderProtectedChildDirty = !0;
        this._protectedChildren.push(a);
        a._setLocalZOrder(b)
    }, ctor: function () {
        cc.Node.prototype.ctor.call(this);
        this._protectedChildren = []
    }, addProtectedChild: function (a, b, d) {
        cc.assert(null != a, "child must be non-nil");
        cc.assert(!a.parent, "child already added. It can't be added again");
        b = b || a.getLocalZOrder();
        d && a.setTag(d);
        this._insertProtectedChild(a,
            b);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival);
        if (this._running && (a.onEnter(), this._isTransitionFinished))a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && this._renderCmd.setCascadeColorEnabledDirty();
        this._cascadeOpacityEnabled && this._renderCmd.setCascadeOpacityEnabledDirty()
    }, getProtectedChildByTag: function (a) {
        cc.assert(a !== cc.NODE_TAG_INVALID, "Invalid tag");
        for (var b = this._protectedChildren, d = 0, e = b.length; d < e; d++)if (b.getTag() === a)return b[d];
        return null
    }, removeProtectedChild: function (a,
                                       b) {
        null == b && (b = !0);
        var d = this._protectedChildren;
        if (0 !== d.length) {
            var e = d.indexOf(a);
            -1 < e && (this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.setParent(null), d.splice(e, 1))
        }
    }, removeProtectedChildByTag: function (a, b) {
        cc.assert(a !== cc.NODE_TAG_INVALID, "Invalid tag");
        null == b && (b = !0);
        var d = this.getProtectedChildByTag(a);
        null == d ? cc.log("cocos2d: removeChildByTag(tag \x3d %d): child not found!", a) : this.removeProtectedChild(d, b)
    }, removeAllProtectedChildren: function () {
        this.removeAllProtectedChildrenWithCleanup(!0)
    },
    removeAllProtectedChildrenWithCleanup: function (a) {
        null == a && (a = !0);
        for (var b = this._protectedChildren, d = 0, e = b.length; d < e; d++) {
            var f = b[d];
            this._running && (f.onExitTransitionDidStart(), f.onExit());
            a && f.cleanup();
            f.setParent(null)
        }
        b.length = 0
    }, reorderProtectedChild: function (a, b) {
        cc.assert(null != a, "Child must be non-nil");
        this._reorderProtectedChildDirty = !0;
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        a._setLocalZOrder(b)
    }, sortAllProtectedChildren: function () {
        if (this._reorderProtectedChildDirty) {
            var a =
                this._protectedChildren, b = a.length, d, e, f;
            for (d = 1; d < b; d++) {
                f = a[d];
                for (e = d - 1; 0 <= e;) {
                    if (f._localZOrder < a[e]._localZOrder)a[e + 1] = a[e]; else if (f._localZOrder === a[e]._localZOrder && f.arrivalOrder < a[e].arrivalOrder)a[e + 1] = a[e]; else break;
                    e--
                }
                a[e + 1] = f
            }
            this._reorderProtectedChildDirty = !1
        }
    }, _changePosition: function () {
    }, cleanup: function () {
        cc.Node.prototype.cleanup.call(this);
        for (var a = this._protectedChildren, b = 0, d = a.length; b < d; b++)a[b].cleanup()
    }, onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        for (var a =
            this._protectedChildren, b = 0, d = a.length; b < d; b++)a[b].onEnter()
    }, onEnterTransitionDidFinish: function () {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        for (var a = this._protectedChildren, b = 0, d = a.length; b < d; b++)a[b].onEnterTransitionDidFinish()
    }, onExit: function () {
        cc.Node.prototype.onExit.call(this);
        for (var a = this._protectedChildren, b = 0, d = a.length; b < d; b++)a[b].onExit()
    }, onExitTransitionDidStart: function () {
        cc.Node.prototype.onExitTransitionDidStart.call(this);
        for (var a = this._protectedChildren, b =
            0, d = a.length; b < d; b++)a[b].onExitTransitionDidStart()
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ProtectedNode.CanvasRenderCmd(this) : new cc.ProtectedNode.WebGLRenderCmd(this)
    }
});
cc.ProtectedNode.create = function () {
    return new cc.ProtectedNode
};
(function () {
    cc.ProtectedNode.RenderCmd = {
        _updateDisplayColor: function (a) {
            var d = this._node, e = this._displayedColor, f = d._realColor, g, h;
            if (this._cascadeColorEnabledDirty && !d._cascadeColorEnabled) {
                e.r = f.r;
                e.g = f.g;
                e.b = f.b;
                e = new cc.Color(255, 255, 255, 255);
                g = d._children;
                f = 0;
                for (a = g.length; f < a; f++)(h = g[f]) && h._renderCmd && h._renderCmd._updateDisplayColor(e);
                this._cascadeColorEnabledDirty = !1
            } else {
                void 0 === a && (a = (a = d._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE);
                e.r = 0 | f.r * a.r / 255;
                e.g = 0 |
                    f.g * a.g / 255;
                e.b = 0 | f.b * a.b / 255;
                if (d._cascadeColorEnabled)for (g = d._children, f = 0, a = g.length; f < a; f++)(h = g[f]) && h._renderCmd && (h._renderCmd._updateDisplayColor(e), h._renderCmd._updateColor());
                g = d._protectedChildren;
                f = 0;
                for (a = g.length; f < a; f++)(h = g[f]) && h._renderCmd && (h._renderCmd._updateDisplayColor(e), h._renderCmd._updateColor())
            }
            this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
        }, _updateDisplayOpacity: function (a) {
            var d = this._node, e, f, g;
            if (this._cascadeOpacityEnabledDirty && !d._cascadeOpacityEnabled) {
                this._displayedOpacity =
                    d._realOpacity;
                f = d._children;
                a = 0;
                for (e = f.length; a < e; a++)(g = f[a]) && g._renderCmd && g._renderCmd._updateDisplayOpacity(255);
                this._cascadeOpacityEnabledDirty = !1
            } else {
                void 0 === a && (e = d._parent, a = 255, e && e._cascadeOpacityEnabled && (a = e.getDisplayedOpacity()));
                this._displayedOpacity = d._realOpacity * a / 255;
                if (d._cascadeOpacityEnabled)for (f = d._children, a = 0, e = f.length; a < e; a++)(g = f[a]) && g._renderCmd && (g._renderCmd._updateDisplayOpacity(this._displayedOpacity), g._renderCmd._updateColor());
                f = d._protectedChildren;
                a =
                    0;
                for (e = f.length; a < e; a++)(g = f[a]) && g._renderCmd && (g._renderCmd._updateDisplayOpacity(this._displayedOpacity), g._renderCmd._updateColor())
            }
            this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
        }, _changeProtectedChild: function (a) {
            a = a._renderCmd;
            var d = a._dirtyFlag, e = cc.Node._dirtyFlags;
            this._dirtyFlag & e.colorDirty && (d |= e.colorDirty);
            this._dirtyFlag & e.opacityDirty && (d |= e.opacityDirty);
            var f = d & e.colorDirty, d = d & e.opacityDirty;
            f && a._updateDisplayColor(this._displayedColor);
            d && a._updateDisplayOpacity(this._displayedOpacity);
            (f || d) && a._updateColor()
        }
    };
    cc.ProtectedNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._cachedParent = null;
        this._cacheDirty = !1
    };
    var a = cc.ProtectedNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.inject(cc.ProtectedNode.RenderCmd, a);
    a.constructor = cc.ProtectedNode.CanvasRenderCmd;
    a.visit = function (a) {
        var d = this._node;
        if (d._visible) {
            var e = d._children, f = d._protectedChildren, g = d._children.length, h = f.length;
            this._syncStatus(a);
            d.sortAllChildren();
            d.sortAllProtectedChildren();
            var n;
            for (a = 0; a < g; a++)if (d = e[a], 0 > d._localZOrder)d.visit(this); else break;
            for (d = 0; d < h; d++)if ((n = f[d]) && 0 > n._localZOrder)this._changeProtectedChild(n), n.visit(this); else break;
            for (cc.renderer.pushRenderCommand(this); a < g; a++)e[a] && e[a].visit(this);
            for (; d < h; d++)if (n = f[d])this._changeProtectedChild(n), n.visit(this);
            this._dirtyFlag = 0;
            this._cacheDirty = !1
        }
    };
    a.transform = function (a, d) {
        var e = this._node;
        e._changePosition && e._changePosition();
        var f = e.getNodeToParentTransform(), g =
            this._worldTransform;
        if (a) {
            var h = a._worldTransform;
            g.a = f.a * h.a + f.b * h.c;
            g.b = f.a * h.b + f.b * h.d;
            g.c = f.c * h.a + f.d * h.c;
            g.d = f.c * h.b + f.d * h.d;
            g.tx = h.a * f.tx + h.c * f.ty + h.tx;
            g.ty = h.d * f.ty + h.ty + h.b * f.tx
        } else g.a = f.a, g.b = f.b, g.c = f.c, g.d = f.d, g.tx = f.tx, g.ty = f.ty;
        h = e._children;
        if (d && h && 0 !== h.length)for (f = 0, g = h.length; f < g; f++)h[f]._renderCmd.transform(this, d);
        h = e._protectedChildren;
        if (d && h && 0 !== h.length)for (f = 0, g = h.length; f < g; f++)h[f]._renderCmd.transform(this, d)
    }
})();
(function () {
    if (cc.Node.WebGLRenderCmd) {
        cc.ProtectedNode.WebGLRenderCmd = function (a) {
            cc.Node.WebGLRenderCmd.call(this, a)
        };
        var a = cc.ProtectedNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        cc.inject(cc.ProtectedNode.RenderCmd, a);
        a.constructor = cc.ProtectedNode.WebGLRenderCmd;
        a.visit = function (a) {
            var d = this._node;
            if (d._visible) {
                var e, f = cc.current_stack;
                f.stack.push(f.top);
                this._syncStatus(a);
                f.top = this._stackMatrix;
                var g = d.grid;
                g && g._active && g.beforeDraw();
                var h = d._children,
                    n = d._protectedChildren, p = h.length, r = n.length;
                d.sortAllChildren();
                d.sortAllProtectedChildren();
                var s;
                for (a = 0; a < p; a++)if (h[a] && 0 > h[a]._localZOrder)h[a].visit(this); else break;
                for (e = 0; e < r; e++)if ((s = n[e]) && 0 > s._localZOrder)this._changeProtectedChild(s), s.visit(this); else break;
                for (cc.renderer.pushRenderCommand(this); a < p; a++)h[a] && h[a].visit(this);
                for (; e < r; e++)if (s = n[e])this._changeProtectedChild(s), s.visit(this);
                g && g._active && g.afterDraw(d);
                this._dirtyFlag = 0;
                f.top = f.stack.pop()
            }
        };
        a.transform = function (a,
                                d) {
            var e = this._node, f = this._transform4x4, g = this._stackMatrix, h = a ? a._stackMatrix : cc.current_stack.top, n = e.getNodeToParentTransform();
            e._changePosition && e._changePosition();
            var p = f.mat;
            p[0] = n.a;
            p[4] = n.c;
            p[12] = n.tx;
            p[1] = n.b;
            p[5] = n.d;
            p[13] = n.ty;
            cc.kmMat4Multiply(g, h, f);
            p[14] = e._vertexZ;
            if (null !== e._camera && (null === e.grid || !e.grid.isActive()))if (h = this._anchorPointInPoints.x, n = this._anchorPointInPoints.y, p = 0 !== h || 0 !== n) {
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (h |= 0, n |= 0);
                var r = cc.math.Matrix4.createByTranslation(h,
                    n, 0, f);
                g.multiply(p);
                e._camera._locateForRenderer(g);
                r = cc.math.Matrix4.createByTranslation(-h, -n, 0, r);
                g.multiply(r);
                f.identity()
            } else e._camera._locateForRenderer(g);
            h = e._children;
            if (d && h && 0 !== h.length)for (f = 0, g = h.length; f < g; f++)h[f]._renderCmd.transform(this, d);
            h = e._protectedChildren;
            if (d && h && 0 !== h.length)for (f = 0, g = h.length; f < g; f++)h[f]._renderCmd.transform(this, d)
        }
    }
})();
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class;
ccui.Class.extend = ccui.Class.extend || cc.Class.extend;
ccui.Node = ccui.Node || cc.Node;
ccui.Node.extend = ccui.Node.extend || cc.Node.extend;
ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode;
ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend;
ccui.cocosGUIVersion = "CocosGUI v1.0.0.0";
ccui._FocusNavigationController = cc.Class.extend({
    _keyboardListener: null,
    _firstFocusedWidget: null,
    _enableFocusNavigation: !1,
    _keyboardEventPriority: 1,
    enableFocusNavigation: function (a) {
        this._enableFocusNavigation !== a && ((this._enableFocusNavigation = a) ? this._addKeyboardEventListener() : this._removeKeyboardEventListener())
    },
    _setFirstFocsuedWidget: function (a) {
        this._firstFocusedWidget = a
    },
    _onKeyPressed: function (a, b) {
        this._enableFocusNavigation && this._firstFocusedWidget && (a === cc.KEY.dpadDown && (this._firstFocusedWidget =
            this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.DOWN, this._firstFocusedWidget)), a === cc.KEY.dpadUp && (this._firstFocusedWidget = this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.UP, this._firstFocusedWidget)), a === cc.KEY.dpadLeft && (this._firstFocusedWidget = this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.LEFT, this._firstFocusedWidget)), a === cc.KEY.dpadRight && (this._firstFocusedWidget = this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.RIGHT, this._firstFocusedWidget)))
    },
    _addKeyboardEventListener: function () {
        this._keyboardListener || (this._keyboardListener = cc.EventListener.create({
            event: cc.EventListener.KEYBOARD,
            onKeyReleased: this._onKeyPressed.bind(this)
        }), cc.eventManager.addListener(this._keyboardListener, this._keyboardEventPriority))
    },
    _removeKeyboardEventListener: function () {
        this._keyboardListener && (cc.eventManager.removeEventListener(this._keyboardListener), this._keyboardListener = null)
    }
});
ccui.__LAYOUT_COMPONENT_NAME = "__ui_layout";
ccui.Widget = ccui.ProtectedNode.extend({
    _enabled: !0,
    _bright: !0,
    _touchEnabled: !1,
    _brightStyle: null,
    _touchBeganPosition: null,
    _touchMovePosition: null,
    _touchEndPosition: null,
    _touchEventListener: null,
    _touchEventSelector: null,
    _name: "default",
    _widgetType: null,
    _actionTag: 0,
    _customSize: null,
    _layoutParameterDictionary: null,
    _layoutParameterType: 0,
    _focused: !1,
    _focusEnabled: !0,
    _ignoreSize: !1,
    _affectByClipping: !1,
    _sizeType: null,
    _sizePercent: null,
    _positionType: null,
    _positionPercent: null,
    _hit: !1,
    _nodes: null,
    _touchListener: null,
    _className: "Widget",
    _flippedX: !1,
    _flippedY: !1,
    _opacity: 255,
    _highlight: !1,
    _touchEventCallback: null,
    _clickEventListener: null,
    _propagateTouchEvents: !0,
    _unifySize: !1,
    _callbackName: null,
    _callbackType: null,
    _usingLayoutComponent: !1,
    _inViewRect: !0,
    ctor: function () {
        cc.ProtectedNode.prototype.ctor.call(this);
        this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE;
        this._touchBeganPosition = cc.p(0, 0);
        this._touchMovePosition = cc.p(0, 0);
        this._touchEndPosition = cc.p(0, 0);
        this._widgetType = ccui.Widget.TYPE_WIDGET;
        this._customSize =
            cc.size(0, 0);
        this._layoutParameterDictionary = {};
        this._sizeType = ccui.Widget.SIZE_ABSOLUTE;
        this._sizePercent = cc.p(0, 0);
        this._positionType = ccui.Widget.POSITION_ABSOLUTE;
        this._positionPercent = cc.p(0, 0);
        this._nodes = [];
        this._layoutParameterType = ccui.LayoutParameter.NONE;
        ccui.Widget.prototype.init.call(this)
    },
    init: function () {
        return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this._initRenderer(), this.setBright(!0), this.onFocusChanged = this.onFocusChange.bind(this), this.onNextFocusedWidget =
            null, this.setAnchorPoint(cc.p(0.5, 0.5)), this.ignoreContentAdaptWithSize(!0), !0) : !1
    },
    onEnter: function () {
        var a = this._touchListener;
        a && !a._isRegistered() && this._touchEnabled && cc.eventManager.addListener(a, this);
        this._usingLayoutComponent || this.updateSizeAndPosition();
        cc.ProtectedNode.prototype.onEnter.call(this)
    },
    onExit: function () {
        this.unscheduleUpdate();
        cc.ProtectedNode.prototype.onExit.call(this)
    },
    _getOrCreateLayoutComponent: function () {
        var a = this.getComponent(ccui.__LAYOUT_COMPONENT_NAME);
        null == a &&
        (a = new ccui.LayoutComponent, this.addComponent(a));
        return a
    },
    getWidgetParent: function () {
        var a = this.getParent();
        return a instanceof ccui.Widget ? a : null
    },
    _updateContentSizeWithTextureSize: function (a) {
        this._unifySize ? this.setContentSize(a) : this.setContentSize(this._ignoreSize ? a : this._customSize)
    },
    _isAncestorsEnabled: function () {
        var a = this._getAncensterWidget(this);
        return null == a ? !0 : a && !a.isEnabled() ? !1 : a._isAncestorsEnabled()
    },
    setPropagateTouchEvents: function (a) {
        this._propagateTouchEvents = a
    },
    isPropagateTouchEvents: function () {
        return this._propagateTouchEvents
    },
    setSwallowTouches: function (a) {
        this._touchListener && this._touchListener.setSwallowTouches(a)
    },
    isSwallowTouches: function () {
        return this._touchListener ? this._touchListener.isSwallowTouches() : !1
    },
    _getAncensterWidget: function (a) {
        if (null == a)return null;
        a = a.getParent();
        return null == a ? null : a instanceof ccui.Widget ? a : this._getAncensterWidget(a.getParent())
    },
    _isAncestorsVisible: function (a) {
        return null == a ? !0 : (a = a.getParent()) && !a.isVisible() ? !1 : this._isAncestorsVisible(a)
    },
    _cleanupWidget: function () {
        this._eventDispatcher.removeEventListener(this._touchListener);
        this._touchEnabled = !1;
        this._touchListener = null;
        ccui.Widget._focusedWidget === this && (ccui.Widget._focusedWidget = null, ccui.Widget._focusNavigationController = null)
    },
    setEnabled: function (a) {
        this._enabled = a
    },
    _initRenderer: function () {
    },
    setContentSize: function (a, b) {
        var d = void 0 === b ? a.width : a, e = void 0 === b ? a.height : b;
        cc.Node.prototype.setContentSize.call(this, d, e);
        this._customSize.width = d;
        this._customSize.height = e;
        !this._unifySize && this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        if (!this._usingLayoutComponent &&
            this._running) {
            var f = this.getWidgetParent(), f = f ? f.getContentSize() : this._parent.getContentSize();
            this._sizePercent.x = 0 < f.width ? d / f.width : 0;
            this._sizePercent.y = 0 < f.height ? e / f.height : 0
        }
        this._onSizeChanged()
    },
    _setWidth: function (a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._customSize.width = a;
        !this._unifySize && this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        !this._usingLayoutComponent && this._running && (a = (a = this.getWidgetParent()) ? a.width : this._parent.width, this._sizePercent.x =
            0 < a ? this._customSize.width / a : 0);
        this._onSizeChanged()
    },
    _setHeight: function (a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._customSize.height = a;
        !this._unifySize && this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        !this._usingLayoutComponent && this._running && (a = (a = this.getWidgetParent()) ? a.height : this._parent.height, this._sizePercent.y = 0 < a ? this._customSize.height / a : 0);
        this._onSizeChanged()
    },
    setSizePercent: function (a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setUsingPercentContentSize(!0);
            b.setPercentContentSize(a);
            b.refreshLayout()
        } else {
            this._sizePercent.x = a.x;
            this._sizePercent.y = a.y;
            var b = this._customSize.width, d = this._customSize.height;
            this._running && ((d = this.getWidgetParent()) ? (b = d.width * a.x, d = d.height * a.y) : (b = this._parent.width * a.x, d = this._parent.height * a.y));
            this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(b, d);
            this._customSize.width = b;
            this._customSize.height = d
        }
    },
    _setWidthPercent: function (a) {
        this._sizePercent.x =
            a;
        var b = this._customSize.width;
        this._running && (b = this.getWidgetParent(), b = (b ? b.width : this._parent.width) * a);
        this._ignoreSize ? this._setWidth(this.getVirtualRendererSize().width) : this._setWidth(b);
        this._customSize.width = b
    },
    _setHeightPercent: function (a) {
        this._sizePercent.y = a;
        var b = this._customSize.height;
        this._running && (b = this.getWidgetParent(), b = (b ? b.height : this._parent.height) * a);
        this._ignoreSize ? this._setHeight(this.getVirtualRendererSize().height) : this._setHeight(b);
        this._customSize.height = b
    },
    updateSizeAndPosition: function (a) {
        a ||
        (a = (a = this.getWidgetParent()) ? a.getLayoutSize() : this._parent.getContentSize());
        switch (this._sizeType) {
            case ccui.Widget.SIZE_ABSOLUTE:
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(this._customSize);
                this._sizePercent.x = 0 < a.width ? this._customSize.width / a.width : 0;
                this._sizePercent.y = 0 < a.height ? this._customSize.height / a.height : 0;
                break;
            case ccui.Widget.SIZE_PERCENT:
                var b = cc.size(a.width * this._sizePercent.x, a.height * this._sizePercent.y);
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) :
                    this.setContentSize(b);
                this._customSize.width = b.width;
                this._customSize.height = b.height
        }
        this._onSizeChanged();
        b = this.getPosition();
        switch (this._positionType) {
            case ccui.Widget.POSITION_ABSOLUTE:
                0 >= a.width || 0 >= a.height ? this._positionPercent.x = this._positionPercent.y = 0 : (this._positionPercent.x = b.x / a.width, this._positionPercent.y = b.y / a.height);
                break;
            case ccui.Widget.POSITION_PERCENT:
                b = cc.p(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
        }
        if (this._parent instanceof ccui.ImageView && (a = this._parent._imageRenderer) && !a._textureLoaded)return;
        this.setPosition(b)
    },
    setSizeType: function (a) {
        this._sizeType = a;
        this._usingLayoutComponent && this._getOrCreateLayoutComponent().setUsingPercentContentSize(this._sizeType === ccui.SIZE_PERCENT)
    },
    getSizeType: function () {
        return this._sizeType
    },
    ignoreContentAdaptWithSize: function (a) {
        this._unifySize ? this.setContentSize(this._customSize) : this._ignoreSize !== a && (this._ignoreSize = a, this.setContentSize(a ? this.getVirtualRendererSize() : this._customSize))
    },
    isIgnoreContentAdaptWithSize: function () {
        return this._ignoreSize
    },
    getCustomSize: function () {
        return cc.size(this._customSize)
    },
    getLayoutSize: function () {
        return cc.size(this._contentSize)
    },
    getSizePercent: function () {
        this._usingLayoutComponent && (this._sizePercent = this._getOrCreateLayoutComponent().getPercentContentSize());
        return this._sizePercent
    },
    _getWidthPercent: function () {
        return this._sizePercent.x
    },
    _getHeightPercent: function () {
        return this._sizePercent.y
    },
    getWorldPosition: function () {
        return this.convertToWorldSpace(cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y *
            this._contentSize.height))
    },
    getVirtualRenderer: function () {
        return this
    },
    getVirtualRendererSize: function () {
        return cc.size(this._contentSize)
    },
    _onSizeChanged: function () {
        if (!this._usingLayoutComponent)for (var a = this.getChildren(), b = 0, d = a.length; b < d; b++) {
            var e = a[b];
            e instanceof ccui.Widget && e.updateSizeAndPosition()
        }
    },
    setTouchEnabled: function (a) {
        this._touchEnabled !== a && ((this._touchEnabled = a) ? (this._touchListener || (this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this.onTouchBegan.bind(this),
            onTouchMoved: this.onTouchMoved.bind(this),
            onTouchEnded: this.onTouchEnded.bind(this)
        })), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener))
    },
    isTouchEnabled: function () {
        return this._touchEnabled
    },
    isHighlighted: function () {
        return this._highlight
    },
    setHighlighted: function (a) {
        a !== this._highlight && (this._highlight = a, this._bright ? this._highlight ? this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT) : this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL) :
            this._onPressStateChangedToDisabled())
    },
    isFocused: function () {
        return this._focused
    },
    setFocused: function (a) {
        if (this._focused = a)ccui.Widget._focusedWidget = this, ccui.Widget._focusNavigationController && ccui.Widget._focusNavigationController._setFirstFocsuedWidget(this)
    },
    isFocusEnabled: function () {
        return this._focusEnabled
    },
    setFocusEnabled: function (a) {
        this._focusEnabled = a
    },
    findNextFocusedWidget: function (a, b) {
        if (null === this.onNextFocusedWidget || null == this.onNextFocusedWidget(a)) {
            var d = b instanceof ccui.Layout;
            if (this.isFocused() || d) {
                var e = this.getParent();
                return null !== e && e instanceof ccui.Layout ? e.findNextFocusedWidget(a, b) : d ? b.findNextFocusedWidget(a, b) : b
            }
            return b
        }
        d = this.onNextFocusedWidget(a);
        this.dispatchFocusEvent(this, d);
        return d
    },
    requestFocus: function () {
        this !== ccui.Widget._focusedWidget && this.dispatchFocusEvent(ccui.Widget._focusedWidget, this)
    },
    getCurrentFocusedWidget: function () {
        return ccui.Widget._focusedWidget
    },
    onFocusChanged: null,
    onNextFocusedWidget: null,
    interceptTouchEvent: function (a, b, d) {
        var e =
            this.getWidgetParent();
        e && e.interceptTouchEvent(a, b, d)
    },
    onFocusChange: function (a, b) {
        a && a.setFocused(!1);
        b && b.setFocused(!0)
    },
    dispatchFocusEvent: function (a, b) {
        a && !a.isFocused() && (a = ccui.Widget._focusedWidget);
        if (b !== a) {
            if (b && b.onFocusChanged)b.onFocusChanged(a, b);
            if (a && b.onFocusChanged)a.onFocusChanged(a, b);
            cc.eventManager.dispatchEvent(new cc.EventFocus(a, b))
        }
    },
    setBright: function (a) {
        (this._bright = a) ? (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL)) :
            this._onPressStateChangedToDisabled()
    },
    setBrightStyle: function (a) {
        if (this._brightStyle !== a)switch (this._brightStyle = a = a || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                this._onPressStateChangedToNormal();
                break;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                this._onPressStateChangedToPressed()
        }
    },
    _onPressStateChangedToNormal: function () {
    },
    _onPressStateChangedToPressed: function () {
    },
    _onPressStateChangedToDisabled: function () {
    },
    _updateChildrenDisplayedRGBA: function () {
        this.setColor(this.getColor());
        this.setOpacity(this.getOpacity())
    },
    didNotSelectSelf: function () {
    },
    onTouchBegan: function (a, b) {
        this._hit = !1;
        if (this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
            var d = a.getLocation();
            this._touchBeganPosition.x = d.x;
            this._touchBeganPosition.y = d.y;
            this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hit = !0)
        }
        if (!this._hit)return !1;
        this.setHighlighted(!0);
        this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_BEGAN,
            this, a);
        this._pushDownEvent();
        return !0
    },
    propagateTouchEvent: function (a, b, d) {
        var e = this.getWidgetParent();
        e && e.interceptTouchEvent(a, b, d)
    },
    onTouchMoved: function (a, b) {
        var d = a.getLocation();
        this._touchMovePosition.x = d.x;
        this._touchMovePosition.y = d.y;
        this.setHighlighted(this.hitTest(d));
        this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_MOVED, this, a);
        this._moveEvent()
    },
    onTouchEnded: function (a, b) {
        var d = a.getLocation();
        this._touchEndPosition.x = d.x;
        this._touchEndPosition.y = d.y;
        this._propagateTouchEvents &&
        this.propagateTouchEvent(ccui.Widget.TOUCH_ENDED, this, a);
        d = this._highlight;
        this.setHighlighted(!1);
        d ? this._releaseUpEvent() : this._cancelUpEvent()
    },
    onTouchCancelled: function (a) {
        this.setHighlighted(!1);
        this._cancelUpEvent()
    },
    onTouchLongClicked: function (a) {
        this.longClickEvent()
    },
    _pushDownEvent: function () {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BEGAN);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN)
    },
    _moveEvent: function () {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED)
    },
    _releaseUpEvent: function () {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_ENDED);
        this._clickEventListener &&
        this._clickEventListener(this)
    },
    _cancelUpEvent: function () {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_CANCELED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED)
    },
    longClickEvent: function () {
    },
    addTouchEventListener: function (a, b) {
        void 0 === b ? this._touchEventCallback = a : (this._touchEventSelector = a, this._touchEventListener = b)
    },
    addClickEventListener: function (a) {
        this._clickEventListener =
            a
    },
    hitTest: function (a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.rectContainsPoint(b, this.convertToNodeSpace(a))
    },
    isClippingParentContainsPoint: function (a) {
        this._affectByClipping = !1;
        for (var b = this.getParent(), d = null; b;) {
            if (b instanceof ccui.Layout && b.isClippingEnabled()) {
                this._affectByClipping = !0;
                d = b;
                break
            }
            b = b.getParent()
        }
        return this._affectByClipping ? d ? d.hitTest(a) ? d.isClippingParentContainsPoint(a) : !1 : !0 : !0
    },
    checkChildInfo: function (a, b, d) {
        var e = this.getWidgetParent();
        e && e.checkChildInfo(a, b, d)
    },
    setPosition: function (a, b) {
        if (!this._usingLayoutComponent && this._running) {
            var d = this.getWidgetParent();
            d && (d = d.getContentSize(), 0 >= d.width || 0 >= d.height ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : void 0 === b ? (this._positionPercent.x = a.x / d.width, this._positionPercent.y = a.y / d.height) : (this._positionPercent.x = a / d.width, this._positionPercent.y = b / d.height))
        }
        cc.Node.prototype.setPosition.call(this, a, b)
    },
    setPositionX: function (a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.width, this._positionPercent.x = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionX.call(this, a)
    },
    setPositionY: function (a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.height, this._positionPercent.y = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionY.call(this, a)
    },
    setPositionPercent: function (a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setPositionPercentX(a.x);
            b.setPositionPercentY(a.y);
            b.refreshLayout()
        } else this._setXPercent(a.x), this._setYPercent(a.y), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    _setXPercent: function (a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setPositionPercentX(a.x);
            b.refreshLayout()
        } else this._positionPercent.x = a
    },
    _setYPercent: function (a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setPositionPercentY(a.x);
            b.refreshLayout()
        } else this._positionPercent.y = a
    },
    getPositionPercent: function () {
        if (this._usingLayoutComponent) {
            var a = this._getOrCreateLayoutComponent();
            this._positionPercent.x = a.getPositionPercentX();
            this._positionPercent.y =
                a.getPositionPercentY()
        }
        return cc.p(this._positionPercent)
    },
    _getXPercent: function () {
        if (this._usingLayoutComponent) {
            var a = this._getOrCreateLayoutComponent();
            this._positionPercent.x = a.getPositionPercentX();
            this._positionPercent.y = a.getPositionPercentY()
        }
        return this._positionPercent.x
    },
    _getYPercent: function () {
        if (this._usingLayoutComponent) {
            var a = this._getOrCreateLayoutComponent();
            this._positionPercent.x = a.getPositionPercentX();
            this._positionPercent.y = a.getPositionPercentY()
        }
        return this._positionPercent.y
    },
    setPositionType: function (a) {
        this._positionType = a;
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            a === ccui.POSITION_ABSOLUTE ? (b.setPositionPercentXEnabled(!1), b.setPositionPercentYEnabled(!1)) : (b.setPositionPercentXEnabled(!0), b.setPositionPercentYEnabled(!0))
        }
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionType: function () {
        return this._positionType
    },
    setFlippedX: function (a) {
        var b = this.getScaleX();
        this._flippedX = a;
        this.setScaleX(b)
    },
    isFlippedX: function () {
        return this._flippedX
    },
    setFlippedY: function (a) {
        var b = this.getScaleY();
        this._flippedY = a;
        this.setScaleY(b)
    },
    isFlippedY: function () {
        return this._flippedY
    },
    _adaptRenderers: function () {
    },
    isBright: function () {
        return this._bright
    },
    isEnabled: function () {
        return this._enabled
    },
    getLeftBoundary: function () {
        return this.getPositionX() - this._getAnchorX() * this._contentSize.width
    },
    getBottomBoundary: function () {
        return this.getPositionY() - this._getAnchorY() * this._contentSize.height
    },
    getRightBoundary: function () {
        return this.getLeftBoundary() + this._contentSize.width
    },
    getTopBoundary: function () {
        return this.getBottomBoundary() + this._contentSize.height
    },
    getTouchBeganPosition: function () {
        return cc.p(this._touchBeganPosition)
    },
    getTouchMovePosition: function () {
        return cc.p(this._touchMovePosition)
    },
    getTouchEndPosition: function () {
        return cc.p(this._touchEndPosition)
    },
    getWidgetType: function () {
        return this._widgetType
    },
    setLayoutParameter: function (a) {
        a && (this._layoutParameterDictionary[a.getLayoutType()] = a, this._layoutParameterType = a.getLayoutType())
    },
    getLayoutParameter: function (a) {
        a =
            a || this._layoutParameterType;
        return this._layoutParameterDictionary[a]
    },
    getDescription: function () {
        return "Widget"
    },
    clone: function () {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        a._copyClonedWidgetChildren(this);
        return a
    },
    _createCloneInstance: function () {
        return new ccui.Widget
    },
    _copyClonedWidgetChildren: function (a) {
        a = a.getChildren();
        for (var b = 0; b < a.length; b++) {
            var d = a[b];
            d instanceof ccui.Widget && this.addChild(d.clone())
        }
    },
    _copySpecialProperties: function (a) {
    },
    _copyProperties: function (a) {
        this.setEnabled(a.isEnabled());
        this.setVisible(a.isVisible());
        this.setBright(a.isBright());
        this.setTouchEnabled(a.isTouchEnabled());
        this.setLocalZOrder(a.getLocalZOrder());
        this.setTag(a.getTag());
        this.setName(a.getName());
        this.setActionTag(a.getActionTag());
        this._ignoreSize = a._ignoreSize;
        this.setContentSize(a._contentSize);
        this._customSize.width = a._customSize.width;
        this._customSize.height = a._customSize.height;
        this._copySpecialProperties(a);
        this._sizeType = a.getSizeType();
        this._sizePercent.x = a._sizePercent.x;
        this._sizePercent.y =
            a._sizePercent.y;
        this._positionType = a._positionType;
        this._positionPercent.x = a._positionPercent.x;
        this._positionPercent.y = a._positionPercent.y;
        this.setPosition(a.getPosition());
        this.setAnchorPoint(a.getAnchorPoint());
        this.setScaleX(a.getScaleX());
        this.setScaleY(a.getScaleY());
        this.setRotation(a.getRotation());
        this.setRotationX(a.getRotationX());
        this.setRotationY(a.getRotationY());
        this.setFlippedX(a.isFlippedX());
        this.setFlippedY(a.isFlippedY());
        this.setColor(a.getColor());
        this.setOpacity(a.getOpacity());
        this._touchEventCallback = a._touchEventCallback;
        this._touchEventListener = a._touchEventListener;
        this._touchEventSelector = a._touchEventSelector;
        this._clickEventListener = a._clickEventListener;
        this._focused = a._focused;
        this._focusEnabled = a._focusEnabled;
        this._propagateTouchEvents = a._propagateTouchEvents;
        for (var b in a._layoutParameterDictionary) {
            var d = a._layoutParameterDictionary[b];
            d && this.setLayoutParameter(d.clone())
        }
        this._onSizeChanged()
    },
    setActionTag: function (a) {
        this._actionTag = a
    },
    getActionTag: function () {
        return this._actionTag
    },
    getLeftInParent: function () {
        cc.log("getLeftInParent is deprecated. Please use getLeftBoundary instead.");
        return this.getLeftBoundary()
    },
    getBottomInParent: function () {
        cc.log("getBottomInParent is deprecated. Please use getBottomBoundary instead.");
        return this.getBottomBoundary()
    },
    getRightInParent: function () {
        cc.log("getRightInParent is deprecated. Please use getRightBoundary instead.");
        return this.getRightBoundary()
    },
    getTopInParent: function () {
        cc.log("getTopInParent is deprecated. Please use getTopBoundary instead.");
        return this.getTopBoundary()
    },
    getTouchEndPos: function () {
        cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead.");
        return this.getTouchEndPosition()
    },
    getTouchMovePos: function () {
        cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead.");
        return this.getTouchMovePosition()
    },
    clippingParentAreaContainPoint: function (a) {
        cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead.");
        this.isClippingParentContainsPoint(a)
    },
    getTouchStartPos: function () {
        cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead.");
        return this.getTouchBeganPosition()
    },
    setSize: function (a) {
        this.setContentSize(a)
    },
    getSize: function () {
        return this.getContentSize()
    },
    addNode: function (a, b, d) {
        a instanceof ccui.Widget ? cc.log("Please use addChild to add a Widget.") : (cc.Node.prototype.addChild.call(this, a, b, d), this._nodes.push(a))
    },
    getNodeByTag: function (a) {
        for (var b = this._nodes, d = 0; d < b.length; d++) {
            var e = b[d];
            if (e && e.getTag() ===
                a)return e
        }
        return null
    },
    getNodes: function () {
        return this._nodes
    },
    removeNode: function (a, b) {
        cc.Node.prototype.removeChild.call(this, a, b);
        cc.arrayRemoveObject(this._nodes, a)
    },
    removeNodeByTag: function (a, b) {
        var d = this.getChildByTag(a);
        d ? this.removeChild(d, b) : cc.log("cocos2d: removeNodeByTag(tag \x3d %d): child not found!", a)
    },
    removeAllNodes: function () {
        for (var a = 0; a < this._nodes.length; a++)cc.Node.prototype.removeChild.call(this, this._nodes[a]);
        this._nodes.length = 0
    },
    _findLayout: function () {
        cc.renderer.childrenOrderDirty = !0;
        for (var a = this._parent; a;)if (a._doLayout) {
            a._doLayoutDirty = !0;
            break
        } else a = a._parent
    },
    isUnifySizeEnabled: function () {
        return this._unifySize
    },
    setUnifySizeEnabled: function (a) {
        this._unifySize = a
    },
    _ccEventCallback: null,
    addCCSEventListener: function (a) {
        this._ccEventCallback = a
    },
    setScaleX: function (a) {
        this._flippedX && (a *= -1);
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function (a) {
        this._flippedY && (a *= -1);
        cc.Node.prototype.setScaleY.call(this, a)
    },
    setScale: function (a, b) {
        void 0 === b && (b = a);
        this.setScaleX(a);
        this.setScaleY(b)
    },
    getScaleX: function () {
        var a = cc.Node.prototype.getScaleX.call(this);
        this._flippedX && (a *= -1);
        return a
    },
    getScaleY: function () {
        var a = cc.Node.prototype.getScaleY.call(this);
        this._flippedY && (a *= -1);
        return a
    },
    getScale: function () {
        this.getScaleX() !== this.getScaleY() && cc.log("Widget#scale. ScaleX !\x3d ScaleY. Don't know which one to return");
        return this.getScaleX()
    },
    setCallbackName: function (a) {
        this._callbackName = a
    },
    getCallbackName: function () {
        return this._callbackName
    },
    setCallbackType: function (a) {
        this._callbackType =
            a
    },
    getCallbackType: function () {
        return this._callbackType
    },
    setLayoutComponentEnabled: function (a) {
        this._usingLayoutComponent = a
    },
    isLayoutComponentEnabled: function () {
        return this._usingLayoutComponent
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new ccui.Widget.WebGLRenderCmd(this) : new ccui.Widget.CanvasRenderCmd(this)
    }
});
_p = ccui.Widget.prototype;
cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent);
cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent);
cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent);
cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent);
cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent);
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused);
cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType);
cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType);
cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled);
cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled);
cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright);
cc.defineGetterSetter(_p, "name", _p.getName, _p.setName);
cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p = null;
ccui.Widget.create = function () {
    return new ccui.Widget
};
ccui.Widget._focusedWidget = null;
ccui.Widget._focusNavigationController = null;
ccui.Widget.enableDpadNavigation = function (a) {
    a ? (null == ccui.Widget._focusNavigationController && (ccui.Widget._focusNavigationController = new ccui._FocusNavigationController, ccui.Widget._focusedWidget && ccui.Widget._focusNavigationController._setFirstFocsuedWidget(ccui.Widget._focusedWidget)), ccui.Widget._focusNavigationController.enableFocusNavigation(!0)) : ccui.Widget._focusNavigationController && (ccui.Widget._focusNavigationController.enableFocusNavigation(!1), ccui.Widget._focusNavigationController = null)
};
ccui.Widget.getCurrentFocusedWidget = function () {
    return ccui.Widget._focusedWidget
};
ccui.Widget.BRIGHT_STYLE_NONE = -1;
ccui.Widget.BRIGHT_STYLE_NORMAL = 0;
ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1;
ccui.Widget.TYPE_WIDGET = 0;
ccui.Widget.TYPE_CONTAINER = 1;
ccui.Widget.LEFT = 0;
ccui.Widget.RIGHT = 1;
ccui.Widget.UP = 2;
ccui.Widget.DOWN = 3;
ccui.Widget.LOCAL_TEXTURE = 0;
ccui.Widget.PLIST_TEXTURE = 1;
ccui.Widget.TOUCH_BEGAN = 0;
ccui.Widget.TOUCH_MOVED = 1;
ccui.Widget.TOUCH_ENDED = 2;
ccui.Widget.TOUCH_CANCELED = 3;
ccui.Widget.SIZE_ABSOLUTE = 0;
ccui.Widget.SIZE_PERCENT = 1;
ccui.Widget.POSITION_ABSOLUTE = 0;
ccui.Widget.POSITION_PERCENT = 1;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function () {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        ccui.Widget.CanvasRenderCmd = function (a) {
            cc.ProtectedNode.CanvasRenderCmd.call(this, a);
            this._needDraw = !1
        };
        var a = ccui.Widget.CanvasRenderCmd.prototype = Object.create(cc.ProtectedNode.CanvasRenderCmd.prototype);
        a.constructor = ccui.Widget.CanvasRenderCmd;
        a.visit = function (a) {
            var d = this._node;
            d._visible && (d._adaptRenderers(), cc.ProtectedNode.CanvasRenderCmd.prototype.visit.call(this, a))
        };
        a.transform =
            function (a, d) {
                var e = this._node;
                if (e._visible) {
                    e._adaptRenderers();
                    if (!this._usingLayoutComponent) {
                        var f = e.getWidgetParent();
                        f && (f = f.getContentSize(), 0 !== f.width && 0 !== f.height && (e._position.x = f.width * e._positionPercent.x, e._position.y = f.height * e._positionPercent.y))
                    }
                    cc.ProtectedNode.CanvasRenderCmd.prototype.transform.call(this, a, d)
                }
            }
    } else ccui.Widget.WebGLRenderCmd = function (a) {
        cc.ProtectedNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !1
    }, a = ccui.Widget.WebGLRenderCmd.prototype = Object.create(cc.ProtectedNode.WebGLRenderCmd.prototype),
        a.constructor = ccui.Widget.WebGLRenderCmd, a.visit = function (a) {
        var d = this._node;
        d._visible && (d._adaptRenderers(), cc.ProtectedNode.WebGLRenderCmd.prototype.visit.call(this, a))
    }, a.transform = function (a, d) {
        var e = this._node;
        if (e._visible) {
            e._adaptRenderers();
            if (!this._usingLayoutComponent) {
                var f = e.getWidgetParent();
                f && (f = f.getContentSize(), 0 !== f.width && 0 !== f.height && (e._position.x = f.width * e._positionPercent.x, e._position.y = f.height * e._positionPercent.y))
            }
            cc.ProtectedNode.WebGLRenderCmd.prototype.transform.call(this,
                a, d)
        }
    }
});
ccui.Scale9Sprite = cc.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _scale9Enabled: !0,
    _brightState: 0,
    _renderers: null,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _opacity: 0,
    _color: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _className: "Scale9Sprite",
    _flippedX: !1,
    _flippedY: !1,
    textureLoaded: function () {
        return this._textureLoaded
    },
    addLoadedEventListener: function (a, b) {
        this.addEventListener("load", a, b)
    },
    _updateCapInset: function () {
        var a;
        a = this._insetLeft;
        var b = this._insetTop, d = this._insetRight, e = this._spriteRect, f = this._insetBottom;
        a = 0 === a && 0 === b && 0 === d && 0 === f ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(f, a, e.width - d - a, e.height - b - f) : cc.rect(a, b, e.width - a - d, e.height - b - f);
        this.setCapInsets(a)
    },
    _updatePositions: function () {
        if (this._topLeft &&
            this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize, b = this._topLeft, d = this._topRight, e = this._bottomRight, f = this._bottomLeft, g = this._left, h = this._right, n = this._top, p = this._bottom, r = this._centre, s = this._centre.getContentSize(), t = b.getContentSize(), v = f.getContentSize(), u = a.width - t.width - d.getContentSize().width, a = a.height - t.height - e.getContentSize().height, u = u / s.width, a = a / s.height, t = s.width * u, x = s.height * a, w = v.width, v = v.height, y = cc.p(this._offset.x * u, this._offset.y *
                a);
            if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                var A = Math.round(t);
                t !== A && (t = A, u = t / s.width);
                A = Math.round(x);
                x !== A && (x = A, a = x / s.height)
            }
            r.setScaleX(u);
            r.setScaleY(a);
            f.setAnchorPoint(1, 1);
            f.setPosition(w, v);
            e.setAnchorPoint(0, 1);
            e.setPosition(w + t, v);
            b.setAnchorPoint(1, 0);
            b.setPosition(w, v + x);
            d.setAnchorPoint(0, 0);
            d.setPosition(w + t, v + x);
            g.setAnchorPoint(1, 0.5);
            g.setPosition(w, v + x / 2 + y.y);
            g.setScaleY(a);
            h.setAnchorPoint(0, 0.5);
            h.setPosition(w + t, v + x / 2 + y.y);
            h.setScaleY(a);
            n.setAnchorPoint(0.5, 0);
            n.setPosition(w +
                t / 2 + y.x, v + x);
            n.setScaleX(u);
            p.setAnchorPoint(0.5, 1);
            p.setPosition(w + t / 2 + y.x, v);
            p.setScaleX(u);
            r.setAnchorPoint(0.5, 0.5);
            r.setPosition(w + t / 2 + y.x, v + x / 2 + y.y);
            r.setScaleX(u);
            r.setScaleY(a)
        }
    },
    ctor: function (a, b, d) {
        cc.Node.prototype.ctor.call(this);
        this._spriteRect = cc.rect(0, 0, 0, 0);
        this._capInsetsInternal = cc.rect(0, 0, 0, 0);
        this._originalSize = cc.size(0, 0);
        this._preferredSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._renderers = [];
        if (void 0 != a)if (a instanceof cc.SpriteFrame)this.initWithSpriteFrame(a,
            b); else {
            var e = cc.spriteFrameCache.getSpriteFrame(a);
            null != e ? this.initWithSpriteFrame(e, b) : this.initWithFile(a, b, d)
        } else this.init()
    },
    getSprite: function () {
        return this._scale9Image
    },
    getOriginalSize: function () {
        return cc.size(this._originalSize)
    },
    getPreferredSize: function () {
        return cc.size(this._preferredSize)
    },
    _getPreferredWidth: function () {
        return this._preferredSize.width
    },
    _getPreferredHeight: function () {
        return this._preferredSize.height
    },
    setPreferredSize: function (a) {
        this.setContentSize(a);
        this._preferredSize =
            a;
        this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty))
    },
    _setPreferredWidth: function (a) {
        this._setWidth(a);
        this._preferredSize.width = a
    },
    _setPreferredHeight: function (a) {
        this._setHeight(a);
        this._preferredSize.height = a
    },
    setOpacity: function (a) {
        cc.Node.prototype.setOpacity.call(this, a);
        if (this._scale9Enabled)for (var b = this._renderers, d = 0; d < b.length; d++)b[d].setOpacity(a); else this._scale9Image && this._scale9Image.setOpacity(a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty)
    },
    setColor: function (a) {
        cc.Node.prototype.setColor.call(this, a);
        if (this._scale9Enabled)for (var b = this._renderers, d = 0; d < b.length; d++) {
            var e = b[d];
            e && e.setColor(a)
        } else this._scale9Image && this._scale9Image.setColor(a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty)
    },
    getCapInsets: function () {
        return cc.rect(this._capInsets)
    },
    setCapInsets: function (a) {
        var b = this._contentSize, d = b.width, b = b.height;
        this.updateWithSprite(this._scale9Image,
            this._spriteRect, this._spriteFrameRotated, this._offset, this._originalSize, a);
        this._insetLeft = a.x;
        this._insetTop = a.y;
        this._insetRight = this._originalSize.width - this._insetLeft - a.width;
        this._insetBottom = this._originalSize.height - this._insetTop - a.height;
        this.setContentSize(d, b)
    },
    getInsetLeft: function () {
        return this._insetLeft
    },
    setInsetLeft: function (a) {
        this._insetLeft = a;
        this._updateCapInset()
    },
    getInsetTop: function () {
        return this._insetTop
    },
    setInsetTop: function (a) {
        this._insetTop = a;
        this._updateCapInset()
    },
    getInsetRight: function () {
        return this._insetRight
    },
    setInsetRight: function (a) {
        this._insetRight = a;
        this._updateCapInset()
    },
    getInsetBottom: function () {
        return this._insetBottom
    },
    setInsetBottom: function (a) {
        this._insetBottom = a;
        this._updateCapInset()
    },
    setContentSize: function (a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b);
        this._positionsAreDirty = !0
    },
    setAnchorPoint: function (a, b) {
        cc.Node.prototype.setAnchorPoint.call(this, a, b);
        !this._scale9Enabled && this._scale9Image && (this._scale9Image.setAnchorPoint(a,
            b), this._positionsAreDirty = !0)
    },
    _setWidth: function (a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._positionsAreDirty = !0
    },
    _setHeight: function (a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._positionsAreDirty = !0
    },
    init: function () {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function (a, b, d, e) {
        void 0 === e && (e = d, d = !1);
        a && this.updateWithBatchNode(a, b, d, e);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        this.setAnchorPoint(0.5, 0.5);
        return this._positionsAreDirty = !0
    },
    initWithFile: function (a, b, d) {
        a instanceof cc.Rect ? (d = a = b, b = cc.rect(0, 0, 0, 0)) : (b = b || cc.rect(0, 0, 0, 0), d = d || cc.rect(0, 0, 0, 0));
        if (!a)throw Error("ccui.Scale9Sprite.initWithFile(): file should be non-null");
        var e = cc.textureCache.getTextureForKey(a);
        e || (e = cc.textureCache.addImage(a));
        var f = e.isLoaded();
        (this._textureLoaded = f) || e.addEventListener("load", function (a) {
            var b = this._preferredSize, d = 0 !== b.width && 0 !== b.height;
            d && (b = cc.size(b.width, b.height));
            a = a.getContentSize();
            this.updateWithBatchNode(this._scale9Image,
                cc.rect(0, 0, a.width, a.height), !1, this._capInsets);
            d && this.setPreferredSize(b);
            this._positionsAreDirty = !0;
            this.setNodeDirty();
            this.dispatchEvent("load")
        }, this);
        return this.initWithBatchNode(new cc.SpriteBatchNode(a, 9), b, !1, d)
    },
    initWithSpriteFrame: function (a, b) {
        if (!a || !a.getTexture())throw Error("ccui.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null");
        b = b || cc.rect(0, 0, 0, 0);
        var d = a.textureLoaded();
        (this._textureLoaded = d) || a.addEventListener("load",
            function (a) {
                var b = this._preferredSize, d = 0 !== b.width && 0 !== b.height;
                d && (b = cc.size(b.width, b.height));
                this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
                d && this.setPreferredSize(b);
                this._positionsAreDirty = !0;
                this.setNodeDirty();
                this.dispatchEvent("load")
            }, this);
        d = new cc.SpriteBatchNode(a.getTexture(), 9);
        return this.initWithBatchNode(d, a.getRect(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.isRotated(), b)
    },
    initWithSpriteFrameName: function (a,
                                       b) {
        if (!a)throw Error("ccui.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null");
        b = b || cc.rect(0, 0, 0, 0);
        var d = cc.spriteFrameCache.getSpriteFrame(a);
        return null == d ? (cc.log("ccui.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(d, b)
    },
    resizableSpriteWithCapInsets: function (a) {
        var b = new ccui.Scale9Sprite;
        return b && b.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? b : null
    },
    setOpacityModifyRGB: function (a) {
        if (this._scale9Image) {
            this._opacityModifyRGB =
                a;
            var b = this._scale9Image.getChildren();
            if (b)for (var d = 0, e = b.length; d < e; d++)b[d].setOpacityModifyRGB(a);
            this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty)
        }
    },
    isOpacityModifyRGB: function () {
        return this._opacityModifyRGB
    },
    createSlicedSprites: function () {
        var a = this._originalSize.width, b = this._originalSize.height, d = this._spriteRect, e = Math.floor(this._offset.x + (a - d.width) / 2), f = Math.floor(this._offset.y + (b - d.height) / 2), g = d.x, h = d.y, n = this._capInsetsInternal, p = this._scale9Image.getTexture(), r = this._spriteFrameRotated,
            s = cc.rect(d.x, d.y, d.width, d.height);
        cc._rectEqualToZero(n) && (n = cc.rect(a / 3, b / 3, a / 3, b / 3));
        this._spriteFrameRotated ? (g -= f, h -= e) : (g -= e, h -= f);
        var d = cc.rect(g, h, a, b), t = n.x, v = n.width, u = d.width - (t + v), x = n.y, w = n.height, y = d.height - (x + w), A = 0, D = 0, n = d = cc.rect(A + 0.5 | 0, D + 0.5 | 0, t + 0.5 | 0, x + 0.5 | 0), A = A + t, a = cc.rect(A + 0.5 | 0, D + 0.5 | 0, v + 0.5 | 0, x + 0.5 | 0), b = cc.rect(A + v + 0.5 | 0, D + 0.5 | 0, u + 0.5 | 0, x + 0.5 | 0), A = 0, D = 0 + x, e = cc.rect(A + 0.5 | 0, D + 0.5 | 0, t + 0.5 | 0, w + 0.5 | 0), A = A + t, g = f = cc.rect(A + 0.5 | 0, D + 0.5 | 0, v + 0.5 | 0, w + 0.5 | 0), A = A + v, h = cc.rect(A + 0.5 | 0,
            D + 0.5 | 0, u + 0.5 | 0, w + 0.5 | 0), A = 0, D = 0 + x + w, x = cc.rect(A + 0.5 | 0, D + 0.5 | 0, t + 0.5 | 0, y + 0.5 | 0), A = A + t, t = cc.rect(A + 0.5 | 0, D + 0.5 | 0, v + 0.5 | 0, y + 0.5 | 0), A = A + v, u = v = cc.rect(A + 0.5 | 0, D + 0.5 | 0, u + 0.5 | 0, y + 0.5 | 0), y = d, A = f, D = v, w = g, G = u, B = x, C = b, E = n, I = h, L = e, J = t, Q = a, M = cc.affineTransformMakeIdentity();
        r ? (M = cc.affineTransformTranslate(M, s.height + s.x, s.y), M = cc.affineTransformRotate(M, 1.57079633), d = cc.rectApplyAffineTransform(d, M), f = cc.rectApplyAffineTransform(f, M), v = cc.rectApplyAffineTransform(v, M), g = cc.rectApplyAffineTransform(g, M), u = cc.rectApplyAffineTransform(u,
            M), x = cc.rectApplyAffineTransform(x, M), b = cc.rectApplyAffineTransform(b, M), n = cc.rectApplyAffineTransform(n, M), h = cc.rectApplyAffineTransform(h, M), e = cc.rectApplyAffineTransform(e, M), t = cc.rectApplyAffineTransform(t, M), a = cc.rectApplyAffineTransform(a, M), y.x = d.x, A.x = f.x, D.x = v.x, w.x = g.x, G.x = u.x, B.x = x.x, C.x = b.x, E.x = n.x, I.x = h.x, L.x = e.x, J.x = t.x, Q.x = a.x, y.y = d.y, A.y = f.y, D.y = v.y, w.y = g.y, G.y = u.y, B.y = x.y, C.y = b.y, E.y = n.y, I.y = h.y, L.y = e.y, J.y = t.y, Q.y = a.y) : (M = cc.affineTransformTranslate(M, s.x, s.y), cc.rectApplyAffineTransform(y,
            M), cc.rectApplyAffineTransform(A, M), cc.rectApplyAffineTransform(D, M), w = cc.rectApplyAffineTransform(w, M), G = cc.rectApplyAffineTransform(G, M), B = cc.rectApplyAffineTransform(B, M), C = cc.rectApplyAffineTransform(C, M), E = cc.rectApplyAffineTransform(E, M), I = cc.rectApplyAffineTransform(I, M), L = cc.rectApplyAffineTransform(L, M), J = cc.rectApplyAffineTransform(J, M), Q = cc.rectApplyAffineTransform(Q, M));
        this._centre || (this._centre = new cc.Sprite);
        this._centre.initWithTexture(p, w, r);
        0 < w.width && 0 < w.height && this._renderers.push(this._centre);
        this._top || (this._top = new cc.Sprite);
        this._top.initWithTexture(p, Q, r);
        0 < Q.width && 0 < Q.height && this._renderers.push(this._top);
        this._bottom || (this._bottom = new cc.Sprite);
        this._bottom.initWithTexture(p, J, r);
        0 < J.width && 0 < J.height && this._renderers.push(this._bottom);
        this._left || (this._left = new cc.Sprite);
        this._left.initWithTexture(p, L, r);
        0 < L.width && 0 < L.height && this._renderers.push(this._left);
        this._right || (this._right = new cc.Sprite);
        this._right.initWithTexture(p, I, r);
        0 < I.width && 0 < I.height && this._renderers.push(this._right);
        this._topLeft || (this._topLeft = new cc.Sprite);
        this._topLeft.initWithTexture(p, E, r);
        0 < E.width && 0 < E.height && this._renderers.push(this._topLeft);
        this._topRight || (this._topRight = new cc.Sprite);
        this._topRight.initWithTexture(p, C, r);
        0 < C.width && 0 < C.height && this._renderers.push(this._topRight);
        this._bottomLeft || (this._bottomLeft = new cc.Sprite);
        this._bottomLeft.initWithTexture(p, B, r);
        0 < B.width && 0 < B.height && this._renderers.push(this._bottomLeft);
        this._bottomRight || (this._bottomRight = new cc.Sprite);
        this._bottomRight.initWithTexture(p,
            G, r);
        0 < G.width && 0 < G.height && this._renderers.push(this._bottomRight)
    },
    updateWithSprite: function (a, b, d, e, f, g) {
        var h = this.getOpacity(), n = this.getColor();
        this._renderers.length = 0;
        if (a) {
            if (!a.getSpriteFrame())return !1;
            this._scale9Image || (this._scale9Image = a)
        }
        if (!this._scale9Image)return !1;
        var p = b, r = f, s = this._scale9Image.getTexture(), t = s && s.isLoaded();
        this._textureLoaded = t;
        if (!t)return s.addEventListener("load", function (h) {
            this._positionsAreDirty = !0;
            this.updateWithSprite(a, b, d, e, f, g);
            this.setVisible(!0);
            this.setNodeDirty();
            this.dispatchEvent("load")
        }, this), this.setVisible(!1), !0;
        cc._rectEqualToZero(p) && (p = s.getContentSize(), p = cc.rect(0, 0, p.width, p.height));
        0 === r.width && 0 === r.height && (r = cc.size(p.width, p.height));
        this._capInsets = g;
        this._spriteRect = p;
        this._offset = e;
        this._spriteFrameRotated = d;
        this._preferredSize = this._originalSize = r;
        this._capInsetsInternal = g;
        this._scale9Enabled ? this.createSlicedSprites() : this._scale9Image.initWithTexture(s, this._spriteRect, this._spriteFrameRotated);
        this.setState(this._brightState);
        this.setContentSize(r);
        !0 === this._spritesGenerated && (this.setOpacity(h), this.setColor(n));
        return this._spritesGenerated = !0
    },
    updateWithBatchNode: function (a, b, d, e) {
        if (!a)return !1;
        var f = new cc.Sprite(a.getTexture()), g = cc.p(0, 0), h = cc.size(b.width, b.height), n = a.getTexture(), p = n.isLoaded();
        this._textureLoaded = p;
        return p ? this.updateWithSprite(f, b, d, g, h, e) : (n.addEventListener("load", function (f) {
                this._positionsAreDirty = !0;
                this.updateWithBatchNode(a, b, d, e);
                this.setVisible(!0);
                this.setNodeDirty();
                this.dispatchEvent("load")
            },
            this), this.setVisible(!1), !0)
    },
    setSpriteFrame: function (a, b) {
        b || (b = cc.rect());
        var d = new cc.Sprite(a.getTexture()), e = a.textureLoaded();
        (this._textureLoaded = e) || a.addEventListener("load", function (a) {
                var b = this._preferredSize, d = 0 !== b.width && 0 !== b.height;
                d && (b = cc.size(b.width, b.height));
                this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
                d && this.setPreferredSize(b);
                this._positionsAreDirty = !0;
                this.setNodeDirty();
                this.dispatchEvent("load")
            },
            this);
        this.updateWithSprite(d, a.getRect(), a.isRotated(), a.getOffset(), a.getOriginalSize(), b);
        this._insetLeft = b.x;
        this._insetTop = b.y;
        this._insetRight = this._originalSize.width - this._insetLeft - b.width;
        this._insetBottom = this._originalSize.height - this._insetTop - b.height
    },
    setState: function (a) {
        this._renderCmd.setState(a)
    },
    setScale9Enabled: function (a) {
        this._scale9Enabled !== a && (this._scale9Enabled = a, this._renderers.length = 0, cc.Node.transformDirty = !0, this._scale9Enabled && this._scale9Image && this.updateWithSprite(this._scale9Image,
            this._spriteRect, this._spriteFrameRotated, this._offset, this._originalSize, this._capInsets), this._positionsAreDirty = !0)
    },
    _setRenderersPosition: function () {
        this._positionsAreDirty && (this._updatePositions(), this._adjustScale9ImagePosition(), this._positionsAreDirty = !1)
    },
    _adjustScale9ImagePosition: function () {
        var a = this._scale9Image, b = this._contentSize;
        a && (a.x = b.width * a.getAnchorPoint().x, a.y = b.height * a.getAnchorPoint().y)
    },
    _adjustScale9ImageScale: function () {
        var a = this._scale9Image, b = this._contentSize;
        a &&
        a.setScale(b.width / a.width, b.height / a.height)
    },
    setFlippedX: function (a) {
        var b = this.getScaleX();
        this._flippedX = a;
        this.setScaleX(b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty)
    },
    isFlippedX: function () {
        return this._flippedX
    },
    setFlippedY: function (a) {
        var b = this.getScaleY();
        this._flippedY = a;
        this.setScaleY(b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty)
    },
    isFlippedY: function () {
        return this._flippedY
    },
    setScaleX: function (a) {
        this._flippedX && (a *= -1);
        cc.Node.prototype.setScaleX.call(this,
            a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty)
    },
    setScaleY: function (a) {
        this._flippedY && (a *= -1);
        cc.Node.prototype.setScaleY.call(this, a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty)
    },
    setScale: function (a, b) {
        void 0 === b && (b = a);
        this.setScaleX(a);
        this.setScaleY(b)
    },
    getScaleX: function () {
        var a = cc.Node.prototype.getScaleX.call(this);
        this._flippedX && (a *= -1);
        return a
    },
    getScaleY: function () {
        var a = cc.Node.prototype.getScaleY.call(this);
        this._flippedY && (a *= -1);
        return a
    },
    getScale: function () {
        this.getScaleX() !==
        this.getScaleY() && cc.log("Scale9Sprite#scale. ScaleX !\x3d ScaleY. Don't know which one to return");
        return this.getScaleX()
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccui.Scale9Sprite.CanvasRenderCmd(this) : new ccui.Scale9Sprite.WebGLRenderCmd(this)
    }
});
_p = ccui.Scale9Sprite.prototype;
cc.EventHelper.prototype.apply(_p);
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets);
cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
_p = null;
ccui.Scale9Sprite.create = function (a, b, d) {
    return new ccui.Scale9Sprite(a, b, d)
};
ccui.Scale9Sprite.createWithSpriteFrame = function (a, b) {
    return new ccui.Scale9Sprite(a, b)
};
ccui.Scale9Sprite.createWithSpriteFrameName = function (a, b) {
    return new ccui.Scale9Sprite(a, b)
};
ccui.Scale9Sprite.POSITIONS_CENTRE = 0;
ccui.Scale9Sprite.POSITIONS_TOP = 1;
ccui.Scale9Sprite.POSITIONS_LEFT = 2;
ccui.Scale9Sprite.POSITIONS_RIGHT = 3;
ccui.Scale9Sprite.POSITIONS_BOTTOM = 4;
ccui.Scale9Sprite.POSITIONS_TOPRIGHT = 5;
ccui.Scale9Sprite.POSITIONS_TOPLEFT = 6;
ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7;
ccui.Scale9Sprite.state = {NORMAL: 0, GRAY: 1};
(function () {
    ccui.Scale9Sprite.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._cachedParent = null;
        this._cacheDirty = !1;
        this._state = ccui.Scale9Sprite.state.NORMAL;
        a = this._node;
        var d = this._cacheCanvas = document.createElement("canvas");
        d.width = 1;
        d.height = 1;
        this._cacheContext = new cc.CanvasContextWrapper(d.getContext("2d"));
        var e = this._cacheTexture = new cc.Texture2D;
        e.initWithElement(d);
        e.handleLoadedTexture();
        this._cacheSprite = new cc.Sprite(e);
        this._cacheSprite.setAnchorPoint(0, 0);
        a.addChild(this._cacheSprite)
    };
    var a = ccui.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = ccui.Scale9Sprite.CanvasRenderCmd;
    a.visit = function (a) {
        var d = this._node;
        d._visible && (d._positionsAreDirty && (d._updatePositions(), d._positionsAreDirty = !1), cc.Node.CanvasRenderCmd.prototype.visit.call(this, a))
    };
    a.transform = function (a) {
        var d = this._node;
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, a);
        d._positionsAreDirty && (d._updatePositions(), d._positionsAreDirty = !1);
        a = d._children;
        for (d = 0; d < a.length; d++)a[d].transform(this, !0)
    };
    a._updateDisplayColor = function (a) {
        cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a);
        var d = this._node;
        if (d) {
            var e = d._renderers;
            if (d._scale9Enabled)for (var d = e.length, f = 0; f < d; f++) {
                var g = e[f];
                if (g)g._renderCmd._updateDisplayColor(a), g._renderCmd._updateColor(); else break
            } else d._scale9Image && (d._scale9Image._renderCmd._updateDisplayColor(a), d._scale9Image._renderCmd._updateColor())
        }
    };
    a.updateStatus = function () {
        var a = cc.Node._dirtyFlags,
            d = this._dirtyFlag;
        cc.Node.RenderCmd.prototype.updateStatus.call(this);
        d & a.cacheDirty && (this._cacheScale9Sprite(), this._dirtyFlag ^= this._dirtyFlag & a.cacheDirty)
    };
    a._syncStatus = function (a) {
        var d = cc.Node._dirtyFlags, e = this._dirtyFlag;
        cc.Node.RenderCmd.prototype._syncStatus.call(this, a);
        e & d.cacheDirty && (this._cacheScale9Sprite(), this._dirtyFlag ^= this._dirtyFlag & d.cacheDirty)
    };
    a._cacheScale9Sprite = function () {
        var a = this._node;
        if (a._scale9Image) {
            var d = cc.contentScaleFactor(), e = a._contentSize, f = cc.size(e.width *
                d, e.height * d), g = this._cacheCanvas, h = this._cacheContext, n = h.getContext(), p = !1;
            if (g.width !== f.width || g.height !== f.height)g.width = f.width, g.height = f.height, p = !0;
            cc.renderer._turnToCacheMode(a.__instanceId);
            if (a._scale9Enabled) {
                g = a._renderers;
                a._setRenderersPosition();
                for (var r = g.length, s = 0; s < r; s++) {
                    var t = g[s];
                    if (t)t = t._renderCmd, t.updateStatus(), cc.renderer.pushRenderCommand(t); else break
                }
            } else t = a._scale9Image._renderCmd, a._adjustScale9ImagePosition(), a._adjustScale9ImageScale(), t.updateStatus(), cc.renderer.pushRenderCommand(a._scale9Image._renderCmd);
            (g = a._scale9Image.getTexture()) && this._state === ccui.Scale9Sprite.state.GRAY && g._switchToGray(!0);
            n.setTransform(1, 0, 0, 1, 0, 0);
            n.clearRect(0, 0, f.width, f.height);
            cc.renderer._renderingToCacheCanvas(h, a.__instanceId, d, d);
            cc.renderer._turnToNormalMode();
            g && this._state === ccui.Scale9Sprite.state.GRAY && g._switchToGray(!1);
            p && this._cacheSprite.setTextureRect(cc.rect(0, 0, e.width, e.height));
            this._cacheSprite.getParent() || a.addChild(this._cacheSprite, -1)
        }
    };
    a.setState = function (a) {
        this._node._scale9Image && (this._state =
            a, this.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty))
    }
})();
(function () {
    if (cc.Node.WebGLRenderCmd) {
        ccui.Scale9Sprite.WebGLRenderCmd = function (a) {
            cc.Node.WebGLRenderCmd.call(this, a);
            this._cachedParent = null;
            this._cacheDirty = !1
        };
        var a = ccui.Scale9Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        a.constructor = ccui.Scale9Sprite.WebGLRenderCmd;
        a.visit = function (a) {
            var d = this._node;
            if (d._visible && d._scale9Image) {
                d._positionsAreDirty && (d._updatePositions(), d._positionsAreDirty = !1);
                a = a || this.getParentRenderCmd();
                d._parent && d._parent._renderCmd &&
                (this._curLevel = d._parent._renderCmd._curLevel + 1);
                this._syncStatus(a);
                if (d._scale9Enabled)for (var d = d._renderers, e = d.length, f = 0; f < e; f++) {
                    var g = d[f];
                    if (g)g._renderCmd.visit(this); else break
                } else d._adjustScale9ImageScale(), d._adjustScale9ImagePosition(), d._scale9Image._renderCmd.visit(this);
                this._dirtyFlag = 0;
                cc.Node.WebGLRenderCmd.prototype.visit.call(this, a)
            }
        };
        a.transform = function (a, d) {
            var e = this._node;
            a = a || this.getParentRenderCmd();
            cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, d);
            e._positionsAreDirty &&
            (e._updatePositions(), e._positionsAreDirty = !1);
            if (e._scale9Enabled)for (var e = e._renderers, f = e.length, g = 0; g < f; g++) {
                var h = e[g];
                if (h)h._vertexZ = a._node._vertexZ, h._renderCmd.transform(this, !0); else break
            } else e._adjustScale9ImageScale(), e._adjustScale9ImagePosition(), e._scale9Image._renderCmd.transform(this, !0)
        };
        a.setDirtyFlag = function (a, d) {
            a === cc.Node._dirtyFlags.cacheDirty && (a = cc.Node._dirtyFlags.transformDirty);
            cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, a, d)
        };
        a._syncStatus = function (a) {
            cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this,
                a);
            this._updateDisplayColor(this._displayedColor);
            this._updateDisplayOpacity(this._displayedOpacity)
        };
        a._updateDisplayColor = function (a) {
            cc.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, a);
            var d = this._node, e = d._scale9Image;
            a = this._displayedColor;
            if (d._scale9Enabled)for (d = d._renderers, e = 0; e < d.length; e++)d[e]._renderCmd._updateDisplayColor(a), d[e]._renderCmd._updateColor(); else e._renderCmd._updateDisplayColor(a), e._renderCmd._updateColor()
        };
        a._updateDisplayOpacity = function (a) {
            cc.Node.WebGLRenderCmd.prototype._updateDisplayOpacity.call(this,
                a);
            var d = this._node, e = d._scale9Image;
            a = this._displayedOpacity;
            if (d._scale9Enabled)for (d = d._renderers, e = 0; e < d.length; e++)d[e]._renderCmd._updateDisplayOpacity(a), d[e]._renderCmd._updateColor(); else e._renderCmd._updateDisplayOpacity(a), e._renderCmd._updateColor()
        };
        a.setState = function (a) {
            var d = this._node._scale9Image;
            null != d && (a === ccui.Scale9Sprite.state.NORMAL ? d.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)) : a === ccui.Scale9Sprite.state.GRAY && d.setShaderProgram(ccui.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram()))
        };
        ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram = null;
        ccui.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram = function () {
            var a = ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram;
            if (a)return a;
            a = new cc.GLProgram;
            a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, ccui.Scale9Sprite.WebGLRenderCmd._grayShaderFragment);
            a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
            a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
            a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD,
                cc.VERTEX_ATTRIB_TEX_COORDS);
            a.link();
            a.updateUniforms();
            return ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram = a
        };
        ccui.Scale9Sprite.WebGLRenderCmd._grayShaderFragment = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    vec4 c \x3d texture2D(CC_Texture0, v_texCoord); \n    gl_FragColor.xyz \x3d vec3(0.2126*c.r + 0.7152*c.g + 0.0722*c.b); \n     gl_FragColor.w \x3d c.w ; \n}"
    }
})();
ccui.Layout = ccui.Widget.extend({
    _clippingEnabled: !1,
    _backGroundScale9Enabled: null,
    _backGroundImage: null,
    _backGroundImageFileName: null,
    _backGroundImageCapInsets: null,
    _colorType: null,
    _bgImageTexType: ccui.Widget.LOCAL_TEXTURE,
    _colorRender: null,
    _gradientRender: null,
    _color: null,
    _startColor: null,
    _endColor: null,
    _alongVector: null,
    _opacity: 255,
    _backGroundImageTextureSize: null,
    _layoutType: null,
    _doLayoutDirty: !0,
    _clippingRectDirty: !0,
    _clippingType: null,
    _clippingStencil: null,
    _scissorRectDirty: !1,
    _clippingRect: null,
    _clippingParent: null,
    _className: "Layout",
    _backGroundImageColor: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _backGroundImageOpacity: 0,
    _loopFocus: !1,
    __passFocusToChild: !0,
    _isFocusPassing: !1,
    _isInterceptTouch: !1,
    ctor: function () {
        this._layoutType = ccui.Layout.ABSOLUTE;
        this._widgetType = ccui.Widget.TYPE_CONTAINER;
        this._clippingType = ccui.Layout.CLIPPING_SCISSOR;
        this._colorType = ccui.Layout.BG_COLOR_NONE;
        ccui.Widget.prototype.ctor.call(this);
        this.ignoreContentAdaptWithSize(!1);
        this.setContentSize(cc.size(0, 0));
        this.setAnchorPoint(0, 0);
        this.onPassFocusToChild = this._findNearestChildWidgetIndex.bind(this);
        this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0);
        this._color = cc.color(255, 255, 255, 255);
        this._startColor = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._alongVector = cc.p(0, -1);
        this._backGroundImageTextureSize = cc.size(0, 0);
        this._clippingRect = cc.rect(0, 0, 0, 0);
        this._backGroundImageColor = cc.color(255, 255, 255, 255)
    },
    onEnter: function () {
        ccui.Widget.prototype.onEnter.call(this);
        if (this._clippingStencil)this._clippingStencil.onEnter();
        this._clippingRectDirty = this._doLayoutDirty = !0
    },
    onExit: function () {
        ccui.Widget.prototype.onExit.call(this);
        if (this._clippingStencil)this._clippingStencil.onExit()
    },
    setLoopFocus: function (a) {
        this._loopFocus = a
    },
    isLoopFocus: function () {
        return this._loopFocus
    },
    setPassFocusToChild: function (a) {
        this.__passFocusToChild = a
    },
    isPassFocusToChild: function () {
        return this.__passFocusToChild
    },
    findNextFocusedWidget: function (a, b) {
        if (this._isFocusPassing || this.isFocused()) {
            var d = this.getParent();
            this._isFocusPassing = !1;
            if (this.__passFocusToChild) {
                var e = this._passFocusToChild(a, b);
                return e instanceof ccui.Layout && d ? (d._isFocusPassing = !0, d.findNextFocusedWidget(a, this)) : e
            }
            if (null == d || !(d instanceof ccui.Layout))return this;
            d._isFocusPassing = !0;
            return d.findNextFocusedWidget(a, this)
        }
        if (b.isFocused() || b instanceof ccui.Layout)if (this._layoutType === ccui.Layout.LINEAR_HORIZONTAL)switch (a) {
            case ccui.Widget.LEFT:
                return this._getPreviousFocusedWidget(a, b);
            case ccui.Widget.RIGHT:
                return this._getNextFocusedWidget(a, b);
            case ccui.Widget.DOWN:
            case ccui.Widget.UP:
                return this._isLastWidgetInContainer(this,
                    a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this) : b : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this);
            default:
                return cc.assert(0, "Invalid Focus Direction"), b
        } else if (this._layoutType === ccui.Layout.LINEAR_VERTICAL)switch (a) {
            case ccui.Widget.LEFT:
            case ccui.Widget.RIGHT:
                return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this) : b : ccui.Widget.prototype.findNextFocusedWidget.call(this,
                    a, this);
            case ccui.Widget.DOWN:
                return this._getNextFocusedWidget(a, b);
            case ccui.Widget.UP:
                return this._getPreviousFocusedWidget(a, b);
            default:
                return cc.assert(0, "Invalid Focus Direction"), b
        } else return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), b; else return b
    },
    onPassFocusToChild: null,
    addChild: function (a, b, d) {
        a instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(a);
        ccui.Widget.prototype.addChild.call(this, a, b, d);
        this._doLayoutDirty = !0
    },
    removeChild: function (a,
                           b) {
        ccui.Widget.prototype.removeChild.call(this, a, b);
        this._doLayoutDirty = !0
    },
    removeAllChildren: function (a) {
        ccui.Widget.prototype.removeAllChildren.call(this, a);
        this._doLayoutDirty = !0
    },
    removeAllChildrenWithCleanup: function (a) {
        ccui.Widget.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._doLayoutDirty = !0
    },
    isClippingEnabled: function () {
        return this._clippingEnabled
    },
    visit: function (a) {
        if (this._visible)if (this._adaptRenderers(), this._doLayout(), this._clippingEnabled)switch (this._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                this._renderCmd.stencilClippingVisit(a);
                break;
            case ccui.Layout.CLIPPING_SCISSOR:
                this._renderCmd.scissorClippingVisit(a)
        } else ccui.Widget.prototype.visit.call(this, a)
    },
    setClippingEnabled: function (a) {
        if (a !== this._clippingEnabled)switch (this._clippingEnabled = a, this._clippingType) {
            case ccui.Layout.CLIPPING_SCISSOR:
            case ccui.Layout.CLIPPING_STENCIL:
                if (a) {
                    this._clippingStencil = new cc.DrawNode;
                    this._renderCmd.rebindStencilRendering(this._clippingStencil);
                    if (this._running)this._clippingStencil.onEnter();
                    this._setStencilClippingSize(this._contentSize)
                } else {
                    if (this._running &&
                        this._clippingStencil)this._clippingStencil.onExit();
                    this._clippingStencil = null
                }
        }
    },
    setClippingType: function (a) {
        if (a !== this._clippingType) {
            var b = this.isClippingEnabled();
            this.setClippingEnabled(!1);
            this._clippingType = a;
            this.setClippingEnabled(b)
        }
    },
    getClippingType: function () {
        return this._clippingType
    },
    _setStencilClippingSize: function (a) {
        if (this._clippingEnabled) {
            var b = [];
            b[0] = cc.p(0, 0);
            b[1] = cc.p(a.width, 0);
            b[2] = cc.p(a.width, a.height);
            b[3] = cc.p(0, a.height);
            a = cc.color.GREEN;
            this._clippingStencil.clear();
            this._clippingStencil.drawPoly(b, 4, a, 0, a)
        }
    },
    _getClippingRect: function () {
        if (this._clippingRectDirty) {
            var a = this.convertToWorldSpace(cc.p(0, 0)), b = this.getNodeToWorldTransform(), d = this._contentSize.width * b.a, b = this._contentSize.height * b.d, e;
            for (e = this; e;)if ((e = e.getParent()) && e instanceof ccui.Layout && e.isClippingEnabled()) {
                this._clippingParent = e;
                break
            }
            this._clippingParent ? (e = this._clippingParent._getClippingRect(), this._clippingRect.x = Math.max(a.x, e.x), this._clippingRect.y = Math.max(a.y, e.y), d = Math.min(a.x +
                d, e.x + e.width), a = Math.min(a.y + b, e.y + e.height), this._clippingRect.width = Math.max(0, d - this._clippingRect.x), this._clippingRect.height = Math.max(0, a - this._clippingRect.y)) : (this._clippingRect.x = a.x, this._clippingRect.y = a.y, this._clippingRect.width = d, this._clippingRect.height = b);
            this._clippingRectDirty = !1
        }
        return this._clippingRect
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._setStencilClippingSize(a);
        this._clippingRectDirty = this._doLayoutDirty = !0;
        this._backGroundImage && (this._backGroundImage.setPosition(0.5 * a.width, 0.5 * a.height), this._backGroundScale9Enabled && this._backGroundImage instanceof ccui.Scale9Sprite && this._backGroundImage.setPreferredSize(a));
        this._colorRender && this._colorRender.setContentSize(a);
        this._gradientRender && this._gradientRender.setContentSize(a)
    },
    setBackGroundImageScale9Enabled: function (a) {
        this._backGroundScale9Enabled !== a && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled =
            a, this._addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName, this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets))
    },
    isBackGroundImageScale9Enabled: function () {
        return this._backGroundScale9Enabled
    },
    setBackGroundImage: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            null === this._backGroundImage && (this._addBackGroundImage(), this.setBackGroundImageScale9Enabled(this._backGroundScale9Enabled));
            this._backGroundImageFileName = a;
            this._bgImageTexType =
                b;
            var d = this._backGroundImage;
            switch (this._bgImageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._backGroundScale9Enabled && d.setPreferredSize(this._contentSize);
            this._backGroundImageTextureSize = d.getContentSize();
            d.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height);
            this._updateBackGroundImageColor()
        }
    },
    setBackGroundImageCapInsets: function (a) {
        if (a) {
            var b = this._backGroundImageCapInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(a)
        }
    },
    getBackGroundImageCapInsets: function () {
        return cc.rect(this._backGroundImageCapInsets)
    },
    _supplyTheLayoutParameterLackToChild: function (a) {
        if (a)switch (this._layoutType) {
            case ccui.Layout.LINEAR_HORIZONTAL:
            case ccui.Layout.LINEAR_VERTICAL:
                var b = a.getLayoutParameter(ccui.LayoutParameter.LINEAR);
                b || a.setLayoutParameter(new ccui.LinearLayoutParameter);
                break;
            case ccui.Layout.RELATIVE:
                (b = a.getLayoutParameter(ccui.LayoutParameter.RELATIVE)) ||
                a.setLayoutParameter(new ccui.RelativeLayoutParameter)
        }
    },
    _addBackGroundImage: function () {
        var a = this._contentSize;
        this._backGroundScale9Enabled ? (this._backGroundImage = new ccui.Scale9Sprite, this._backGroundImage.setPreferredSize(a)) : this._backGroundImage = new cc.Sprite;
        this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1);
        this._backGroundImage.setPosition(0.5 * a.width, 0.5 * a.height)
    },
    removeBackGroundImage: function () {
        this._backGroundImage && (this.removeProtectedChild(this._backGroundImage),
            this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize.width = 0, this._backGroundImageTextureSize.height = 0)
    },
    setBackGroundColorType: function (a) {
        if (this._colorType !== a) {
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_NONE:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
                    break;
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender &&
                    (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null)
            }
            this._colorType = a;
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender = new cc.LayerColor;
                    this._colorRender.setContentSize(this._contentSize);
                    this._colorRender.setOpacity(this._opacity);
                    this._colorRender.setColor(this._color);
                    this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER,
                        -1);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender = new cc.LayerGradient(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize), this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1)
            }
        }
    },
    getBackGroundColorType: function () {
        return this._colorType
    },
    setBackGroundColor: function (a, b) {
        b ? (this._startColor.r = a.r, this._startColor.g = a.g, this._startColor.b = a.b, this._gradientRender && this._gradientRender.setStartColor(a), this._endColor.r = b.r, this._endColor.g = b.g, this._endColor.b = b.b, this._gradientRender && this._gradientRender.setEndColor(b)) : (this._color.r = a.r, this._color.g = a.g, this._color.b = a.b, this._colorRender && this._colorRender.setColor(a))
    },
    getBackGroundColor: function () {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundStartColor: function () {
        var a =
            this._startColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundEndColor: function () {
        var a = this._endColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setBackGroundColorOpacity: function (a) {
        this._opacity = a;
        switch (this._colorType) {
            case ccui.Layout.BG_COLOR_SOLID:
                this._colorRender.setOpacity(a);
                break;
            case ccui.Layout.BG_COLOR_GRADIENT:
                this._gradientRender.setOpacity(a)
        }
    },
    getBackGroundColorOpacity: function () {
        return this._opacity
    },
    setBackGroundColorVector: function (a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._gradientRender && this._gradientRender.setVector(a)
    },
    getBackGroundColorVector: function () {
        return this._alongVector
    },
    setBackGroundImageColor: function (a) {
        this._backGroundImageColor.r = a.r;
        this._backGroundImageColor.g = a.g;
        this._backGroundImageColor.b = a.b;
        this._updateBackGroundImageColor()
    },
    setBackGroundImageOpacity: function (a) {
        this._backGroundImageColor.a = a;
        this.getBackGroundImageColor()
    },
    getBackGroundImageColor: function () {
        var a = this._backGroundImageColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundImageOpacity: function () {
        return this._backGroundImageColor.a
    },
    _updateBackGroundImageColor: function () {
        this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor)
    },
    getBackGroundImageTextureSize: function () {
        return this._backGroundImageTextureSize
    },
    setLayoutType: function (a) {
        this._layoutType = a;
        a = this._children;
        for (var b = null, d = 0; d < a.length; d++)b = a[d], b instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(b);
        this._doLayoutDirty = !0
    },
    getLayoutType: function () {
        return this._layoutType
    },
    requestDoLayout: function () {
        this._doLayoutDirty = !0
    },
    _doLayout: function () {
        if (this._doLayoutDirty) {
            this.sortAllChildren();
            var a = ccui.getLayoutManager(this._layoutType);
            a && a._doLayout(this);
            this._doLayoutDirty = !1
        }
    },
    _getLayoutContentSize: function () {
        return this.getContentSize()
    },
    _getLayoutElements: function () {
        return this.getChildren()
    },
    _updateBackGroundImageOpacity: function () {
        this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity)
    },
    _updateBackGroundImageRGBA: function () {
        this._backGroundImage && (this._backGroundImage.setColor(this._backGroundImageColor),
            this._backGroundImage.setOpacity(this._backGroundImageOpacity))
    },
    _getLayoutAccumulatedSize: function () {
        for (var a = this.getChildren(), b = cc.size(0, 0), d = 0, e, f = 0, g = a.length; f < g; f++)if (e = a[f], null !== e && e instanceof ccui.Layout)e = e._getLayoutAccumulatedSize(), b.width += e.width, b.height += e.height; else if (e instanceof ccui.Widget) {
            d++;
            var h = e.getLayoutParameter().getMargin();
            e = e.getContentSize();
            b.width += e.width + 0.5 * (h.right + h.left);
            b.height += e.height + 0.5 * (h.top + h.bottom)
        }
        a = this.getLayoutType();
        a === ccui.Layout.LINEAR_HORIZONTAL &&
        (b.height -= b.height / d * (d - 1));
        a === ccui.Layout.LINEAR_VERTICAL && (b.width -= b.width / d * (d - 1));
        return b
    },
    _findNearestChildWidgetIndex: function (a, b) {
        if (null == b || b === this)return this._findFirstFocusEnabledWidgetIndex();
        var d = 0, e = this.getChildren(), f = e.length, g, h = cc.FLT_MAX, n = 0;
        if (a === ccui.Widget.LEFT || a === ccui.Widget.RIGHT || a === ccui.Widget.DOWN || a === ccui.Widget.UP) {
            for (g = this._getWorldCenterPoint(b); d < f;) {
                var p = e[d];
                p && p instanceof ccui.Widget && p.isFocusEnabled() && (p = p instanceof ccui.Layout ? p._calculateNearestDistance(b) :
                    cc.pLength(cc.pSub(this._getWorldCenterPoint(p), g)), p < h && (n = d, h = p));
                d++
            }
            return n
        }
        cc.log("invalid focus direction!");
        return 0
    },
    _findFarthestChildWidgetIndex: function (a, b) {
        if (null == b || b === this)return this._findFirstFocusEnabledWidgetIndex();
        var d = 0, e = this.getChildren(), f = e.length, g = -cc.FLT_MAX, h = 0;
        if (a === ccui.Widget.LEFT || a === ccui.Widget.RIGHT || a === ccui.Widget.DOWN || a === ccui.Widget.UP) {
            for (var n = this._getWorldCenterPoint(b); d < f;) {
                var p = e[d];
                p && p instanceof ccui.Widget && p.isFocusEnabled() && (p = p instanceof ccui.Layout ? p._calculateFarthestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(p), n)), p > g && (h = d, g = p));
                d++
            }
            return h
        }
        cc.log("invalid focus direction!!!");
        return 0
    },
    _calculateNearestDistance: function (a) {
        for (var b = cc.FLT_MAX, d = this._getWorldCenterPoint(a), e = this._children, f = 0, g = e.length; f < g; f++) {
            var h = e[f];
            if (h instanceof ccui.Layout)h = h._calculateNearestDistance(a); else if (h instanceof ccui.Widget && h.isFocusEnabled())h = cc.pLength(cc.pSub(this._getWorldCenterPoint(h), d)); else continue;
            h < b &&
            (b = h)
        }
        return b
    },
    _calculateFarthestDistance: function (a) {
        for (var b = -cc.FLT_MAX, d = this._getWorldCenterPoint(a), e = this._children, f = 0, g = e.length; f < g; f++) {
            var h = e[f];
            if (h instanceof ccui.Layout)h = h._calculateFarthestDistance(a); else if (h instanceof ccui.Widget && h.isFocusEnabled())h = this._getWorldCenterPoint(h), h = cc.pLength(cc.pSub(h, d)); else continue;
            h > b && (b = h)
        }
        return b
    },
    _findProperSearchingFunctor: function (a, b) {
        if (null != b) {
            var d = this._getWorldCenterPoint(b), e = this._getWorldCenterPoint(this._findFirstNonLayoutWidget());
            a === ccui.Widget.LEFT ? this.onPassFocusToChild = d.x > e.x ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a === ccui.Widget.RIGHT ? this.onPassFocusToChild = d.x > e.x ? this._findFarthestChildWidgetIndex.bind(this) : this._findNearestChildWidgetIndex.bind(this) : a === ccui.Widget.DOWN ? this.onPassFocusToChild = d.y > e.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a === ccui.Widget.UP ? this.onPassFocusToChild = d.y < e.y ? this._findNearestChildWidgetIndex.bind(this) :
                this._findFarthestChildWidgetIndex.bind(this) : cc.log("invalid direction!")
        }
    },
    _findFirstNonLayoutWidget: function () {
        for (var a = this._children, b = 0, d = a.length; b < d; b++) {
            var e = a[b];
            if (e instanceof ccui.Layout) {
                if (e = e._findFirstNonLayoutWidget())return e
            } else if (e instanceof ccui.Widget)return e
        }
        return null
    },
    _findFirstFocusEnabledWidgetIndex: function () {
        for (var a = 0, b = this.getChildren(), d = b.length; a < d;) {
            var e = b[a];
            if (e && e instanceof ccui.Widget && e.isFocusEnabled())return a;
            a++
        }
        return 0
    },
    _findFocusEnabledChildWidgetByIndex: function (a) {
        var b =
            this._getChildWidgetByIndex(a);
        return b ? b.isFocusEnabled() ? b : this._findFocusEnabledChildWidgetByIndex(a + 1) : null
    },
    _getWorldCenterPoint: function (a) {
        var b = a instanceof ccui.Layout ? a._getLayoutAccumulatedSize() : a.getContentSize();
        return a.convertToWorldSpace(cc.p(b.width / 2, b.height / 2))
    },
    _getNextFocusedWidget: function (a, b) {
        var d = null, d = this._children, e = d.indexOf(b), e = e + 1;
        if (e < d.length) {
            if (d = this._getChildWidgetByIndex(e)) {
                if (d.isFocusEnabled()) {
                    if (d instanceof ccui.Layout)return d._isFocusPassing = !0, d.findNextFocusedWidget(a,
                        d);
                    this.dispatchFocusEvent(b, d);
                    return d
                }
                return this._getNextFocusedWidget(a, d)
            }
            return b
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                d = this._getChildWidgetByIndex(0);
                if (d.isFocusEnabled()) {
                    if (d instanceof ccui.Layout)return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
                    this.dispatchFocusEvent(b, d);
                    return d
                }
                return this._getNextFocusedWidget(a, d)
            }
            return b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget
        }
        return this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this,
            a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this) : b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this)
    },
    _getPreviousFocusedWidget: function (a, b) {
        var d = null, d = this._children, e = d.indexOf(b), e = e - 1;
        if (0 <= e) {
            d = this._getChildWidgetByIndex(e);
            if (d.isFocusEnabled()) {
                if (d instanceof ccui.Layout)return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
                this.dispatchFocusEvent(b, d);
                return d
            }
            return this._getPreviousFocusedWidget(a, d)
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                e =
                    d.length - 1;
                d = this._getChildWidgetByIndex(e);
                if (d.isFocusEnabled()) {
                    if (d instanceof ccui.Layout)return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
                    this.dispatchFocusEvent(b, d);
                    return d
                }
                return this._getPreviousFocusedWidget(a, d)
            }
            return b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget
        }
        return this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this) : b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget : ccui.Widget.prototype.findNextFocusedWidget.call(this,
            a, this)
    },
    _getChildWidgetByIndex: function (a) {
        for (var b = this._children, d = b.length, e = 0, f = a; a < d;) {
            var g = b[a];
            if (g && g instanceof ccui.Widget)return g;
            e++;
            a++
        }
        for (a = 0; a < f;) {
            if ((d = b[a]) && d instanceof ccui.Widget)return d;
            e++;
            a++
        }
        return null
    },
    _isLastWidgetInContainer: function (a, b) {
        var d = a.getParent();
        if (null == d || !(d instanceof ccui.Layout))return !0;
        var e = d.getChildren(), f = e.indexOf(a);
        if (d.getLayoutType() === ccui.Layout.LINEAR_HORIZONTAL) {
            if (b === ccui.Widget.LEFT)return 0 === f ? this._isLastWidgetInContainer(d,
                b) : !1;
            if (b === ccui.Widget.RIGHT)return f === e.length - 1 ? this._isLastWidgetInContainer(d, b) : !1;
            if (b === ccui.Widget.DOWN || b === ccui.Widget.UP)return this._isLastWidgetInContainer(d, b)
        } else if (d.getLayoutType() === ccui.Layout.LINEAR_VERTICAL) {
            if (b === ccui.Widget.UP)return 0 === f ? this._isLastWidgetInContainer(d, b) : !1;
            if (b === ccui.Widget.DOWN)return f === e.length - 1 ? this._isLastWidgetInContainer(d, b) : !1;
            if (b === ccui.Widget.LEFT || b === ccui.Widget.RIGHT)return this._isLastWidgetInContainer(d, b)
        } else return cc.log("invalid layout Type"),
            !1
    },
    _isWidgetAncestorSupportLoopFocus: function (a, b) {
        var d = a.getParent();
        if (null == d || !(d instanceof ccui.Layout))return !1;
        if (d.isLoopFocus()) {
            var e = d.getLayoutType();
            if (e === ccui.Layout.LINEAR_HORIZONTAL)return b === ccui.Widget.LEFT || b === ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(d, b);
            if (e === ccui.Layout.LINEAR_VERTICAL)return b === ccui.Widget.DOWN || b === ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(d, b);
            cc.assert(0, "invalid layout type");
            return !1
        }
        return this._isWidgetAncestorSupportLoopFocus(d,
            b)
    },
    _passFocusToChild: function (a, b) {
        if (this._checkFocusEnabledChild()) {
            var d = ccui.Widget.getCurrentFocusedWidget();
            this._findProperSearchingFunctor(a, d);
            d = this.onPassFocusToChild(a, d);
            d = this._getChildWidgetByIndex(d);
            if (d instanceof ccui.Layout)return d._isFocusPassing = !0, d.findNextFocusedWidget(a, d);
            this.dispatchFocusEvent(b, d);
            return d
        }
        return this
    },
    _checkFocusEnabledChild: function () {
        for (var a = this._children, b = 0, d = a.length; b < d; b++) {
            var e = a[b];
            if (e && e instanceof ccui.Widget && e.isFocusEnabled())return !0
        }
        return !1
    },
    getDescription: function () {
        return "Layout"
    },
    _createCloneInstance: function () {
        return new ccui.Layout
    },
    _copyClonedWidgetChildren: function (a) {
        ccui.Widget.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function (a) {
        a instanceof ccui.Layout && (this.setBackGroundImageScale9Enabled(a._backGroundScale9Enabled), this.setBackGroundImage(a._backGroundImageFileName, a._bgImageTexType), this.setBackGroundImageCapInsets(a._backGroundImageCapInsets), this.setBackGroundColorType(a._colorType), this.setBackGroundColor(a._color),
            this.setBackGroundColor(a._startColor, a._endColor), this.setBackGroundColorOpacity(a._opacity), this.setBackGroundColorVector(a._alongVector), this.setLayoutType(a._layoutType), this.setClippingEnabled(a._clippingEnabled), this.setClippingType(a._clippingType), this._loopFocus = a._loopFocus, this.__passFocusToChild = a.__passFocusToChild, this._isInterceptTouch = a._isInterceptTouch)
    },
    forceDoLayout: function () {
        this.requestDoLayout();
        this._doLayout()
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ?
            new ccui.Layout.WebGLRenderCmd(this) : new ccui.Layout.CanvasRenderCmd(this)
    }
});
_p = ccui.Layout.prototype;
cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled);
cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType);
cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType);
_p = null;
ccui.Layout.create = function () {
    return new ccui.Layout
};
ccui.Layout.BG_COLOR_NONE = 0;
ccui.Layout.BG_COLOR_SOLID = 1;
ccui.Layout.BG_COLOR_GRADIENT = 2;
ccui.Layout.ABSOLUTE = 0;
ccui.Layout.LINEAR_VERTICAL = 1;
ccui.Layout.LINEAR_HORIZONTAL = 2;
ccui.Layout.RELATIVE = 3;
ccui.Layout.CLIPPING_STENCIL = 0;
ccui.Layout.CLIPPING_SCISSOR = 1;
ccui.Layout.BACKGROUND_IMAGE_ZORDER = -1;
ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2;
(function () {
    ccui.Layout.CanvasRenderCmd = function (a) {
        ccui.ProtectedNode.CanvasRenderCmd.call(this, a);
        this._clipElemType = this._needDraw = !1;
        this._locCache = null;
        this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._onRenderSaveCmd);
        this._rendererSaveCmdSprite = new cc.CustomRenderCmd(this, this._onRenderSaveSpriteCmd);
        this._rendererClipCmd = new cc.CustomRenderCmd(this, this._onRenderClipCmd);
        this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._onRenderRestoreCmd)
    };
    var a = ccui.Layout.CanvasRenderCmd.prototype =
        Object.create(ccui.ProtectedNode.CanvasRenderCmd.prototype);
    a.constructor = ccui.Layout.CanvasRenderCmd;
    a.visit = function (a) {
        var d = this._node;
        if (d._visible)if (d._adaptRenderers(), d._doLayout(), d._clippingEnabled)switch (d._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                this.stencilClippingVisit(a);
                break;
            case ccui.Layout.CLIPPING_SCISSOR:
                this.scissorClippingVisit(a)
        } else ccui.Widget.CanvasRenderCmd.prototype.visit.call(this, a)
    };
    a._onRenderSaveCmd = function (a, d, e) {
        a = a || cc._renderContext;
        var f = a.getContext();
        this._clipElemType ? (d = f.canvas, this._locCache = ccui.Layout.CanvasRenderCmd._getSharedCache(), this._locCache.width = d.width, this._locCache.height = d.height, this._locCache.getContext("2d").drawImage(d, 0, 0)) : (a.save(), a.save(), a.setTransform(this._worldTransform, d, e))
    };
    a._onRenderSaveSpriteCmd = function (a) {
        a = a || cc._renderContext;
        this._clipElemType && a.setCompositeOperation("destination-in")
    };
    a._onRenderClipCmd = function (a) {
        a = a || cc._renderContext;
        var d = a.getContext();
        this._clipElemType || (a.restore(), d.clip())
    };
    a._onRenderRestoreCmd = function (a) {
        a = a || cc._renderContext;
        var d = a.getContext();
        this._clipElemType ? (d.save(), d.setTransform(1, 0, 0, 1, 0, 0), d.globalCompositeOperation = "destination-over", d.drawImage(this._locCache, 0, 0), d.restore()) : a.restore()
    };
    a.rebindStencilRendering = function (a) {
        a._renderCmd.rendering = this.__stencilDraw
    };
    a.__stencilDraw = function (a, d, e) {
        a = (a || cc._renderContext).getContext();
        for (var f = this._buffer, g = 0, h = f.length; g < h; g++) {
            var n = f[g].verts, p = n[0];
            a.beginPath();
            a.moveTo(p.x * d, -p.y * e);
            for (var p =
                1, r = n.length; p < r; p++)a.lineTo(n[p].x * d, -n[p].y * e);
            a.closePath()
        }
    };
    a.stencilClippingVisit = a.scissorClippingVisit = function (a) {
        var d = this._node;
        if (d._clippingStencil && d._clippingStencil.isVisible()) {
            this._clipElemType = d._stencil instanceof cc.Sprite;
            this._syncStatus(a);
            cc.renderer.pushRenderCommand(this._rendererSaveCmd);
            this._clipElemType && (cc.ProtectedNode.prototype.visit.call(d, a), cc.renderer.pushRenderCommand(this._rendererSaveCmdSprite));
            d._clippingStencil.visit(this);
            cc.renderer.pushRenderCommand(this._rendererClipCmd);
            if (!this._clipElemType) {
                d.sortAllChildren();
                d.sortAllProtectedChildren();
                a = d._children;
                for (var e = 0, d = d._protectedChildren, f = 0, g, h = a.length, n = d.length; f < h; f++)if ((g = a[f]) && 0 > g.getLocalZOrder())g.visit(this); else break;
                for (; e < n; e++)if ((g = d[e]) && 0 > g.getLocalZOrder())g.visit(this); else break;
                for (; f < h; f++)a[f].visit(this);
                for (; e < n; e++)d[e].visit(this);
                cc.renderer.pushRenderCommand(this._rendererRestoreCmd)
            }
            this._dirtyFlag = 0
        }
    };
    ccui.Layout.CanvasRenderCmd._getSharedCache = function () {
        return cc.ClippingNode._sharedCache ||
            (cc.ClippingNode._sharedCache = document.createElement("canvas"))
    }
})();
(function () {
    if (ccui.ProtectedNode.WebGLRenderCmd) {
        ccui.Layout.WebGLRenderCmd = function (a) {
            ccui.ProtectedNode.WebGLRenderCmd.call(this, a);
            this._needDraw = !1;
            this._currentStencilEnabled = 0;
            this._scissorOldState = !1;
            this._clippingOldRect = null;
            this._mask_layer_le = 0;
            this._beforeVisitCmdStencil = new cc.CustomRenderCmd(this, this._onBeforeVisitStencil);
            this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
            this._afterVisitCmdStencil = new cc.CustomRenderCmd(this, this._onAfterVisitStencil);
            this._beforeVisitCmdScissor = new cc.CustomRenderCmd(this, this._onBeforeVisitScissor);
            this._afterVisitCmdScissor = new cc.CustomRenderCmd(this, this._onAfterVisitScissor)
        };
        var a = ccui.Layout.WebGLRenderCmd.prototype = Object.create(ccui.ProtectedNode.WebGLRenderCmd.prototype);
        a.constructor = ccui.Layout.WebGLRenderCmd;
        a.visit = function (a) {
            var d = this._node;
            if (d._visible)if (a && a._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (d._clippingRectDirty = !0), d._adaptRenderers(), d._doLayout(), d._clippingEnabled)switch (d._clippingType) {
                case ccui.Layout.CLIPPING_STENCIL:
                    this.stencilClippingVisit(a);
                    break;
                case ccui.Layout.CLIPPING_SCISSOR:
                    this.scissorClippingVisit(a)
            } else ccui.ProtectedNode.WebGLRenderCmd.prototype.visit.call(this, a)
        };
        a._onBeforeVisitStencil = function (a) {
            a = a || cc._renderContext;
            ccui.Layout.WebGLRenderCmd._layer++;
            var d = 1 << ccui.Layout.WebGLRenderCmd._layer;
            this._mask_layer_le = d | d - 1;
            this._currentStencilEnabled = a.isEnabled(a.STENCIL_TEST);
            a.clear(a.DEPTH_BUFFER_BIT);
            a.enable(a.STENCIL_TEST);
            a.depthMask(!1);
            a.stencilFunc(a.NEVER, d, d);
            a.stencilOp(a.REPLACE, a.KEEP, a.KEEP);
            a.stencilMask(d);
            a.clear(a.STENCIL_BUFFER_BIT)
        };
        a._onAfterDrawStencil = function (a) {
            a = a || cc._renderContext;
            a.depthMask(!0);
            a.stencilFunc(a.EQUAL, this._mask_layer_le, this._mask_layer_le);
            a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
        };
        a._onAfterVisitStencil = function (a) {
            a = a || cc._renderContext;
            ccui.Layout.WebGLRenderCmd._layer--;
            if (this._currentStencilEnabled) {
                var d = 1 << ccui.Layout.WebGLRenderCmd._layer, e = d | d - 1;
                a.stencilMask(d);
                a.stencilFunc(a.EQUAL, e, e)
            } else a.disable(a.STENCIL_TEST)
        };
        a._onBeforeVisitScissor = function (a) {
            this._node._clippingRectDirty = !0;
            var d = this._node._getClippingRect();
            a = a || cc._renderContext;
            (this._scissorOldState = cc.view.isScissorEnabled()) || a.enable(a.SCISSOR_TEST);
            this._clippingOldRect = cc.view.getScissorRect();
            cc.rectEqualToRect(this._clippingOldRect, d) || cc.view.setScissorInPoints(d.x, d.y, d.width, d.height)
        };
        a._onAfterVisitScissor = function (a) {
            a = a || cc._renderContext;
            this._scissorOldState ? cc.rectEqualToRect(this._clippingOldRect, this._node._clippingRect) || cc.view.setScissorInPoints(this._clippingOldRect.x, this._clippingOldRect.y,
                this._clippingOldRect.width, this._clippingOldRect.height) : a.disable(a.SCISSOR_TEST)
        };
        a.rebindStencilRendering = function (a) {
        };
        a.transform = function (a, d) {
            var e = this._node;
            ccui.ProtectedNode.WebGLRenderCmd.prototype.transform.call(this, a, d);
            e._clippingStencil && e._clippingStencil._renderCmd.transform(this, d)
        };
        a.stencilClippingVisit = function (a) {
            var d = this._node;
            if (d._clippingStencil && d._clippingStencil.isVisible())if (ccui.Layout.WebGLRenderCmd._layer + 1 === cc.stencilBits)ccui.Layout.WebGLRenderCmd._visit_once = !0, ccui.Layout.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), ccui.Layout.WebGLRenderCmd._visit_once = !1), cc.Node.prototype.visit.call(d, a); else {
                cc.renderer.pushRenderCommand(this._beforeVisitCmdStencil);
                var e = cc.current_stack;
                e.stack.push(e.top);
                this._syncStatus(a);
                this._dirtyFlag = 0;
                e.top = this._stackMatrix;
                d._clippingStencil.visit(this);
                cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
                var f = a = 0;
                d.sortAllChildren();
                d.sortAllProtectedChildren();
                for (var g = d._children, d = d._protectedChildren, h = g.length, n = d.length, p; a < h; a++)if ((p = g[a]) && 0 > p.getLocalZOrder())p.visit(this); else break;
                for (; f < n; f++)if ((p = d[f]) && 0 > p.getLocalZOrder())p.visit(this); else break;
                for (; a < h; a++)g[a].visit(this);
                for (; f < n; f++)d[f].visit(this);
                cc.renderer.pushRenderCommand(this._afterVisitCmdStencil);
                e.top = e.stack.pop()
            }
        };
        a.scissorClippingVisit = function (a) {
            cc.renderer.pushRenderCommand(this._beforeVisitCmdScissor);
            ccui.ProtectedNode.WebGLRenderCmd.prototype.visit.call(this, a);
            cc.renderer.pushRenderCommand(this._afterVisitCmdScissor)
        };
        ccui.Layout.WebGLRenderCmd._layer = -1;
        ccui.Layout.WebGLRenderCmd._visit_once = null
    }
})();
ccui.Margin = ccui.Class.extend({
    left: 0, top: 0, right: 0, bottom: 0, ctor: function (a, b, d, e) {
        void 0 !== a && void 0 === b && (this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom);
        void 0 !== e && (this.left = a, this.top = b, this.right = d, this.bottom = e)
    }, setMargin: function (a, b, d, e) {
        this.left = a;
        this.top = b;
        this.right = d;
        this.bottom = e
    }, equals: function (a) {
        return this.left === a.left && this.top === a.top && this.right === a.right && this.bottom === a.bottom
    }
});
ccui.MarginZero = function () {
    return new ccui.Margin(0, 0, 0, 0)
};
ccui.LayoutParameter = ccui.Class.extend({
    _margin: null, _layoutParameterType: null, ctor: function () {
        this._margin = new ccui.Margin;
        this._layoutParameterType = ccui.LayoutParameter.NONE
    }, setMargin: function (a, b, d, e) {
        cc.isObject(a) ? (this._margin.left = a.left, this._margin.top = a.top, this._margin.right = a.right, this._margin.bottom = a.bottom) : (this._margin.left = a, this._margin.top = b, this._margin.right = d, this._margin.bottom = e)
    }, getMargin: function () {
        return this._margin
    }, getLayoutType: function () {
        return this._layoutParameterType
    },
    clone: function () {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        return a
    }, _createCloneInstance: function () {
        return new ccui.LayoutParameter
    }, _copyProperties: function (a) {
        this._margin.bottom = a._margin.bottom;
        this._margin.left = a._margin.left;
        this._margin.right = a._margin.right;
        this._margin.top = a._margin.top
    }
});
ccui.LayoutParameter.create = function () {
    return new ccui.LayoutParameter
};
ccui.LayoutParameter.NONE = 0;
ccui.LayoutParameter.LINEAR = 1;
ccui.LayoutParameter.RELATIVE = 2;
ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({
    _linearGravity: null, ctor: function () {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._linearGravity = ccui.LinearLayoutParameter.NONE;
        this._layoutParameterType = ccui.LayoutParameter.LINEAR
    }, setGravity: function (a) {
        this._linearGravity = a
    }, getGravity: function () {
        return this._linearGravity
    }, _createCloneInstance: function () {
        return new ccui.LinearLayoutParameter
    }, _copyProperties: function (a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.LinearLayoutParameter && this.setGravity(a._linearGravity)
    }
});
ccui.LinearLayoutParameter.create = function () {
    return new ccui.LinearLayoutParameter
};
ccui.LinearLayoutParameter.NONE = 0;
ccui.LinearLayoutParameter.LEFT = 1;
ccui.LinearLayoutParameter.TOP = 2;
ccui.LinearLayoutParameter.RIGHT = 3;
ccui.LinearLayoutParameter.BOTTOM = 4;
ccui.LinearLayoutParameter.CENTER_VERTICAL = 5;
ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6;
ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({
    _relativeAlign: null, _relativeWidgetName: "", _relativeLayoutName: "", _put: !1, ctor: function () {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._relativeAlign = ccui.RelativeLayoutParameter.NONE;
        this._relativeLayoutName = this._relativeWidgetName = "";
        this._put = !1;
        this._layoutParameterType = ccui.LayoutParameter.RELATIVE
    }, setAlign: function (a) {
        this._relativeAlign = a
    }, getAlign: function () {
        return this._relativeAlign
    }, setRelativeToWidgetName: function (a) {
        this._relativeWidgetName =
            a
    }, getRelativeToWidgetName: function () {
        return this._relativeWidgetName
    }, setRelativeName: function (a) {
        this._relativeLayoutName = a
    }, getRelativeName: function () {
        return this._relativeLayoutName
    }, _createCloneInstance: function () {
        return new ccui.RelativeLayoutParameter
    }, _copyProperties: function (a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.RelativeLayoutParameter && (this.setAlign(a._relativeAlign), this.setRelativeToWidgetName(a._relativeWidgetName), this.setRelativeName(a._relativeLayoutName))
    }
});
ccui.RelativeLayoutParameter.create = function () {
    return new ccui.RelativeLayoutParameter
};
ccui.RelativeLayoutParameter.NONE = 0;
ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1;
ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3;
ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5;
ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7;
ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18;
ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19;
ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20;
ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21;
ccui.LINEAR_GRAVITY_NONE = 0;
ccui.LINEAR_GRAVITY_LEFT = 1;
ccui.LINEAR_GRAVITY_TOP = 2;
ccui.LINEAR_GRAVITY_RIGHT = 3;
ccui.LINEAR_GRAVITY_BOTTOM = 4;
ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5;
ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6;
ccui.RELATIVE_ALIGN_NONE = 0;
ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1;
ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3;
ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RELATIVE_ALIGN_PARENT_CENTER = 5;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7;
ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21;
ccui.getLayoutManager = function (a) {
    switch (a) {
        case ccui.Layout.LINEAR_VERTICAL:
            return ccui.linearVerticalLayoutManager;
        case ccui.Layout.LINEAR_HORIZONTAL:
            return ccui.linearHorizontalLayoutManager;
        case ccui.Layout.RELATIVE:
            return ccui.relativeLayoutManager
    }
    return null
};
ccui.linearVerticalLayoutManager = {
    _doLayout: function (a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var d = b.height, e = 0, f = a.length; e < f; e++) {
            var g = a[e];
            if (g) {
                var h = g.getLayoutParameter();
                if (h) {
                    var n = h.getGravity(), p = g.getAnchorPoint(), r = g.getContentSize(), s = p.x * r.width, d = d - (1 - p.y) * r.height;
                    switch (n) {
                        case ccui.LinearLayoutParameter.RIGHT:
                            s = b.width - (1 - p.x) * r.width;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
                            s = b.width / 2 - r.width * (0.5 - p.x)
                    }
                    h = h.getMargin();
                    s += h.left;
                    d -= h.top;
                    g.setPosition(s, d);
                    d = g.getPositionY() - p.y * r.height - h.bottom
                }
            }
        }
    }
};
ccui.linearHorizontalLayoutManager = {
    _doLayout: function (a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var d = 0, e = 0, f = a.length; e < f; e++) {
            var g = a[e];
            if (g) {
                var h = g.getLayoutParameter();
                if (h) {
                    var n = h.getGravity(), p = g.getAnchorPoint(), r = g.getContentSize(), d = d + p.x * r.width, s = b.height - (1 - p.y) * r.height;
                    switch (n) {
                        case ccui.LinearLayoutParameter.BOTTOM:
                            s = p.y * r.height;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_VERTICAL:
                            s = b.height / 2 - r.height * (0.5 - p.y)
                    }
                    h = h.getMargin();
                    d += h.left;
                    s -= h.top;
                    g.setPosition(d,
                        s);
                    d = g.getRightBoundary() + h.right
                }
            }
        }
    }
};
ccui.relativeLayoutManager = {
    _unlayoutChildCount: 0,
    _widgetChildren: [],
    _widget: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _relativeWidgetLP: null,
    _doLayout: function (a) {
        for (var b = this._widgetChildren = this._getAllWidgets(a); 0 < this._unlayoutChildCount;) {
            for (var d = 0, e = b.length; d < e; d++) {
                this._widget = b[d];
                var f = this._widget.getLayoutParameter();
                f && !f._put && this._calculateFinalPositionWithRelativeWidget(a) && (this._calculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX, this._finalPositionY),
                    f._put = !0)
            }
            this._unlayoutChildCount--
        }
        this._widgetChildren.length = 0
    },
    _getAllWidgets: function (a) {
        a = a._getLayoutElements();
        for (var b = this._widgetChildren, d = b.length = 0, e = a.length; d < e; d++) {
            var f = a[d];
            f && (f.getLayoutParameter()._put = !1, this._unlayoutChildCount++, b.push(f))
        }
        return b
    },
    _getRelativeWidget: function (a) {
        var b = null;
        if ((a = a.getLayoutParameter().getRelativeToWidgetName()) && 0 !== a.length)for (var d = this._widgetChildren, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g) {
                var h = g.getLayoutParameter();
                if (h && h.getRelativeName() ===
                    a) {
                    b = g;
                    this._relativeWidgetLP = h;
                    break
                }
            }
        }
        return b
    },
    _calculateFinalPositionWithRelativeWidget: function (a) {
        var b = this._widget, d = b.getAnchorPoint(), e = b.getContentSize();
        this._finalPositionY = this._finalPositionX = 0;
        var f = this._getRelativeWidget(b), b = b.getLayoutParameter().getAlign();
        a = a._getLayoutContentSize();
        switch (b) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX = d.x * e.width;
                this._finalPositionY = a.height - (1 - d.y) * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionX =
                    0.5 * a.width - e.width * (0.5 - d.x);
                this._finalPositionY = a.height - (1 - d.y) * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX = a.width - (1 - d.x) * e.width;
                this._finalPositionY = a.height - (1 - d.y) * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX = d.x * e.width;
                this._finalPositionY = 0.5 * a.height - e.height * (0.5 - d.y);
                break;
            case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
                this._finalPositionX = 0.5 * a.width - e.width * (0.5 - d.x);
                this._finalPositionY =
                    0.5 * a.height - e.height * (0.5 - d.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX = a.width - (1 - d.x) * e.width;
                this._finalPositionY = 0.5 * a.height - e.height * (0.5 - d.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX = d.x * e.width;
                this._finalPositionY = d.y * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionX = 0.5 * a.width - e.width * (0.5 - d.x);
                this._finalPositionY = d.y * e.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX =
                    a.width - (1 - d.x) * e.width;
                this._finalPositionY = d.y * e.height;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getTopBoundary() + d.y * e.height;
                    this._finalPositionX = f.getLeftBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    a = f.getContentSize();
                    this._finalPositionY = f.getTopBoundary() + d.y * e.height;
                    this._finalPositionX = f.getLeftBoundary() + 0.5 * a.width + d.x * e.width - 0.5 * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getTopBoundary() + d.y * e.height;
                    this._finalPositionX = f.getRightBoundary() - (1 - d.x) * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getTopBoundary() -
                        (1 - d.y) * e.height;
                    this._finalPositionX = f.getLeftBoundary() - (1 - d.x) * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    a = f.getContentSize();
                    this._finalPositionX = f.getLeftBoundary() - (1 - d.x) * e.width;
                    this._finalPositionY = f.getBottomBoundary() + 0.5 * a.height + d.y * e.height - 0.5 * e.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getBottomBoundary() + d.y * e.height;
                    this._finalPositionX = f.getLeftBoundary() - (1 - d.x) * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getTopBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getRightBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    a = f.getContentSize();
                    this._finalPositionX = f.getRightBoundary() + d.x * e.width;
                    this._finalPositionY = f.getBottomBoundary() + 0.5 * a.height + d.y * e.height - 0.5 * e.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getBottomBoundary() + d.y * e.height;
                    this._finalPositionX = f.getRightBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getBottomBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getLeftBoundary() + d.x * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    a = f.getContentSize();
                    this._finalPositionY = f.getBottomBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getLeftBoundary() + 0.5 * a.width + d.x * e.width - 0.5 * e.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                if (f) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put)return !1;
                    this._finalPositionY = f.getBottomBoundary() - (1 - d.y) * e.height;
                    this._finalPositionX = f.getRightBoundary() - (1 - d.x) * e.width
                }
        }
        return !0
    },
    _calculateFinalPositionWithRelativeAlign: function () {
        var a = this._widget.getLayoutParameter(), b = a.getMargin();
        switch (a.getAlign()) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX += b.left;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionY -=
                    b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX -= b.right;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX += b.left;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionY +=
                    b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX -= b.right;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                this._finalPositionY += b.bottom;
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                this._finalPositionY += b.bottom;
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                this._finalPositionX -=
                    b.right;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                this._finalPositionX -= b.right;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                this._finalPositionX += b.left;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                this._finalPositionX += b.left;
                this._finalPositionY +=
                    b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                this._finalPositionY -= b.top;
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                this._finalPositionY -= b.top;
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                this._finalPositionY -= b.top
        }
    }
};
ccui.HBox = ccui.Layout.extend({
    ctor: function (a) {
        ccui.Layout.prototype.ctor.call(this);
        this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
        a && this.setContentSize(a)
    }
});
ccui.HBox.create = function (a) {
    return new ccui.HBox(a)
};
ccui.RelativeBox = ccui.Layout.extend({
    ctor: function (a) {
        ccui.Layout.prototype.ctor.call(this);
        this.setLayoutType(ccui.Layout.RELATIVE);
        a && this.setContentSize(a)
    }
});
ccui.RelativeBox.create = function (a) {
    return new ccui.RelativeBox(a)
};
ccui.VBox = ccui.Layout.extend({
    ctor: function (a) {
        ccui.Layout.prototype.ctor.call(this);
        this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
        a && this.setContentSize(a)
    }, initWithSize: function (a) {
        return this.init() ? !0 : !1
    }
});
ccui.VBox.create = function (a) {
    return new ccui.VBox(a)
};
ccui.helper = {
    seekWidgetByTag: function (a, b) {
        if (!a)return null;
        if (a.getTag() === b)return a;
        for (var d = a.getChildren(), e = d.length, f = 0; f < e; f++) {
            var g = ccui.helper.seekWidgetByTag(d[f], b);
            if (null !== g)return g
        }
        return null
    }, seekWidgetByName: function (a, b) {
        if (!a)return null;
        if (a.getName() === b)return a;
        for (var d = a.getChildren(), e = d.length, f = 0; f < e; f++) {
            var g = ccui.helper.seekWidgetByName(d[f], b);
            if (null !== g)return g
        }
        return null
    }, seekWidgetByRelativeName: function (a, b) {
        if (!a)return null;
        for (var d = a.getChildren(),
                 e = d.length, f = 0; f < e; f++) {
            var g = d[f], h = g.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
            if (h && h.getRelativeName() === b)return g
        }
        return null
    }, seekActionWidgetByActionTag: function (a, b) {
        if (!a)return null;
        if (a.getActionTag() === b)return a;
        for (var d = a.getChildren(), e = 0; e < d.length; e++) {
            var f = ccui.helper.seekActionWidgetByActionTag(d[e], b);
            if (null !== f)return f
        }
        return null
    }, _activeLayout: !0, doLayout: function (a) {
        if (this._activeLayout) {
            a = a.getChildren();
            for (var b, d = 0, e = a.length; d < e; d++) {
                b = a[d];
                var f = b.getComponent(ccui.LayoutComponent.NAME);
                b = b.getParent();
                null != f && null !== b && f.refreshLayout && f.refreshLayout()
            }
        }
    }, changeLayoutSystemActiveState: function (a) {
        this._activeLayout = a
    }, restrictCapInsetRect: function (a, b) {
        var d = a.x, e = a.y, f = a.width, g = a.height;
        b.width < f && (f = d = 0);
        b.height < g && (g = e = 0);
        return cc.rect(d, e, f, g)
    }
};
ccui.Button = ccui.Widget.extend({
    _buttonNormalRenderer: null,
    _buttonClickedRenderer: null,
    _buttonDisableRenderer: null,
    _titleRenderer: null,
    _normalFileName: "",
    _clickedFileName: "",
    _disabledFileName: "",
    _prevIgnoreSize: !0,
    _scale9Enabled: !1,
    _capInsetsNormal: null,
    _capInsetsPressed: null,
    _capInsetsDisabled: null,
    _normalTexType: ccui.Widget.LOCAL_TEXTURE,
    _pressedTexType: ccui.Widget.LOCAL_TEXTURE,
    _disabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _normalTextureSize: null,
    _pressedTextureSize: null,
    _disabledTextureSize: null,
    pressedActionEnabled: !1,
    _titleColor: null,
    _normalTextureScaleXInSize: 1,
    _normalTextureScaleYInSize: 1,
    _pressedTextureScaleXInSize: 1,
    _pressedTextureScaleYInSize: 1,
    _zoomScale: 0.1,
    _normalTextureLoaded: !1,
    _pressedTextureLoaded: !1,
    _disabledTextureLoaded: !1,
    _className: "Button",
    _normalTextureAdaptDirty: !0,
    _pressedTextureAdaptDirty: !0,
    _disabledTextureAdaptDirty: !0,
    _fontName: "Thonburi",
    _fontSize: 12,
    _type: 0,
    ctor: function (a, b, d, e) {
        this._capInsetsNormal = cc.rect(0, 0, 0, 0);
        this._capInsetsPressed = cc.rect(0, 0, 0, 0);
        this._capInsetsDisabled =
            cc.rect(0, 0, 0, 0);
        this._normalTextureSize = cc.size(0, 0);
        this._pressedTextureSize = cc.size(0, 0);
        this._disabledTextureSize = cc.size(0, 0);
        this._titleColor = cc.color.WHITE;
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        a && this.loadTextures(a, b, d, e)
    },
    _initRenderer: function () {
        this._buttonNormalRenderer = new cc.Sprite;
        this._buttonClickedRenderer = new cc.Sprite;
        this._buttonDisableRenderer = new cc.Sprite;
        this._titleRenderer = new cc.LabelTTF("");
        this._titleRenderer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._buttonNormalRenderer,
            ccui.Button.NORMAL_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1)
    },
    setScale9Enabled: function (a) {
        this._scale9Enabled !== a && (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = a, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer),
            this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = new ccui.Scale9Sprite, this._buttonClickedRenderer = new ccui.Scale9Sprite, this._buttonDisableRenderer = new ccui.Scale9Sprite) : (this._buttonNormalRenderer = new cc.Sprite, this._buttonClickedRenderer = new cc.Sprite, this._buttonDisableRenderer = new cc.Sprite), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this.loadTextureNormal(this._normalFileName, this._normalTexType),
            this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize =
            a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright), this._disabledTextureAdaptDirty = this._pressedTextureAdaptDirty = this._normalTextureAdaptDirty = !0)
    },
    isScale9Enabled: function () {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function (a) {
        if (this._unifySize)this._updateContentSize(); else if (!this._scale9Enabled ||
            this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function () {
        return this._unifySize ? this._getNormalSize() : !this._normalTextureLoaded && 0 < this._titleRenderer.getString().length ? this._titleRenderer.getContentSize() : cc.size(this._normalTextureSize)
    },
    loadTextures: function (a, b, d, e) {
        this.loadTextureNormal(a, e);
        this.loadTexturePressed(b, e);
        this.loadTextureDisabled(d, e)
    },
    loadTextureNormal: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._normalFileName = a;
            this._normalTexType = b;
            var d = this, e = this._buttonNormalRenderer;
            e._textureLoaded || e.addEventListener("load", function () {
                d.loadTextureNormal(d._normalFileName, d._normalTexType)
            });
            switch (this._normalTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    e.initWithSpriteFrameName(a)
            }
            this._normalTextureLoaded = e._textureLoaded;
            this._normalTextureSize = this._buttonNormalRenderer.getContentSize();
            this._updateChildrenDisplayedRGBA();
            this._unifySize ?
            this._scale9Enabled && (e.setCapInsets(this._capInsetsNormal), this._updateContentSizeWithTextureSize(this._getNormalSize())) : this._updateContentSizeWithTextureSize(this._normalTextureSize);
            this._normalTextureAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTexturePressed: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._clickedFileName = a;
            this._pressedTexType = b;
            var d = this, e = this._buttonClickedRenderer;
            e._textureLoaded || e.addEventListener("load", function () {
                d.loadTexturePressed(d._clickedFileName, d._pressedTexType)
            });
            switch (this._pressedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    e.initWithSpriteFrameName(a)
            }
            this._scale9Enabled && e.setCapInsets(this._capInsetsPressed);
            this._pressedTextureSize = this._buttonClickedRenderer.getContentSize();
            this._updateChildrenDisplayedRGBA();
            this._pressedTextureAdaptDirty = this._pressedTextureLoaded = !0;
            this._findLayout()
        }
    },
    loadTextureDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._disabledFileName = a;
            this._disabledTexType =
                b;
            var d = this, e = this._buttonDisableRenderer;
            e._textureLoaded || e.addEventListener("load", function () {
                d.loadTextureDisabled(d._disabledFileName, d._disabledTexType)
            });
            switch (this._disabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    e.initWithSpriteFrameName(a)
            }
            this._scale9Enabled && e.setCapInsets(this._capInsetsDisabled);
            this._disabledTextureSize = this._buttonDisableRenderer.getContentSize();
            this._updateChildrenDisplayedRGBA();
            this._disabledTextureAdaptDirty =
                this._disabledTextureLoaded = !0;
            this._findLayout()
        }
    },
    setCapInsets: function (a) {
        this.setCapInsetsNormalRenderer(a);
        this.setCapInsetsPressedRenderer(a);
        this.setCapInsetsDisabledRenderer(a)
    },
    setCapInsetsNormalRenderer: function (a) {
        if (a) {
            var b = a.x, d = a.y, e = a.width;
            a = a.height;
            this._normalTextureSize.width < e && (e = b = 0);
            this._normalTextureSize.height < a && (a = d = 0);
            var f = this._capInsetsNormal;
            f.x = b;
            f.y = d;
            f.width = e;
            f.height = a;
            this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(f)
        }
    },
    getCapInsetsNormalRenderer: function () {
        return cc.rect(this._capInsetsNormal)
    },
    setCapInsetsPressedRenderer: function (a) {
        if (a && this._scale9Enabled) {
            var b = a.x, d = a.y, e = a.width;
            a = a.height;
            this._pressedTextureSize.width < e && (e = b = 0);
            this._pressedTextureSize.height < a && (a = d = 0);
            var f = this._capInsetsPressed;
            f.x = b;
            f.y = d;
            f.width = e;
            f.height = a;
            this._buttonClickedRenderer.setCapInsets(f)
        }
    },
    getCapInsetsPressedRenderer: function () {
        return cc.rect(this._capInsetsPressed)
    },
    setCapInsetsDisabledRenderer: function (a) {
        if (a && this._scale9Enabled) {
            var b = a.x, d = a.y, e = a.width;
            a = a.height;
            this._disabledTextureSize.width <
            e && (e = b = 0);
            this._disabledTextureSize.height < a && (a = d = 0);
            var f = this._capInsetsDisabled;
            f.x = b;
            f.y = d;
            f.width = e;
            f.height = a;
            this._buttonDisableRenderer.setCapInsets(f)
        }
    },
    getCapInsetsDisabledRenderer: function () {
        return cc.rect(this._capInsetsDisabled)
    },
    _onPressStateChangedToNormal: function () {
        this._buttonNormalRenderer.setVisible(!0);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!1);
        this._scale9Enabled && this._buttonNormalRenderer.setState(ccui.Scale9Sprite.state.NORMAL);
        if (this._pressedTextureLoaded) {
            if (this.pressedActionEnabled)if (this._buttonNormalRenderer.stopAllActions(), this._buttonClickedRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._unifySize) {
                var a = cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, 1, 1);
                this._titleRenderer.runAction(a)
            } else this._titleRenderer.setScaleX(1),
                this._titleRenderer.setScaleY(1)
        } else this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._scale9Enabled && this._buttonNormalRenderer.setColor(cc.color.WHITE), this._titleRenderer.setScaleX(1), this._titleRenderer.setScaleY(1)
    },
    _onPressStateChangedToPressed: function () {
        var a = this._buttonNormalRenderer;
        this._scale9Enabled && a.setState(ccui.Scale9Sprite.state.NORMAL);
        if (this._pressedTextureLoaded) {
            if (a.setVisible(!1),
                    this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this.pressedActionEnabled) {
                a.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var b = cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, this._pressedTextureScaleXInSize + this._zoomScale, this._pressedTextureScaleYInSize + this._zoomScale);
                this._buttonClickedRenderer.runAction(b);
                a.setScale(this._pressedTextureScaleXInSize + this._zoomScale, this._pressedTextureScaleYInSize + this._zoomScale);
                this._titleRenderer.stopAllActions();
                this._titleRenderer.runAction(cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, 1 + this._zoomScale, 1 + this._zoomScale))
            }
        } else a.setVisible(!0), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), a.stopAllActions(), a.setScale(this._normalTextureScaleXInSize + this._zoomScale, this._normalTextureScaleYInSize + this._zoomScale), this._titleRenderer.stopAllActions(), this._titleRenderer.setScaleX(1 + this._zoomScale), this._titleRenderer.setScaleY(1 + this._zoomScale)
    },
    _onPressStateChangedToDisabled: function () {
        this._disabledTextureLoaded ?
            (this._buttonNormalRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!0)) : this._normalTextureLoaded && this._scale9Enabled && this._buttonNormalRenderer.setState(ccui.Scale9Sprite.state.GRAY);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
        this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
    },
    _updateContentSize: function () {
        if (this._unifySize) {
            if (this._scale9Enabled)ccui.ProtectedNode.setContentSize(this._customSize);
            else {
                var a = this._getNormalSize();
                ccui.ProtectedNode.setContentSize(a)
            }
            this._onSizeChanged()
        } else this._ignoreSize && this.setContentSize(this.getVirtualRendererSize())
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._updateTitleLocation();
        this._disabledTextureAdaptDirty = this._pressedTextureAdaptDirty = this._normalTextureAdaptDirty = !0
    },
    getVirtualRenderer: function () {
        if (this._bright)switch (this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                return this._buttonNormalRenderer;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                return this._buttonClickedRenderer;
            default:
                return null
        } else return this._buttonDisableRenderer
    },
    _normalTextureScaleChangedWithSize: function () {
        if (this._ignoreSize && !this._unifySize)this._scale9Enabled || (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1); else if (this._scale9Enabled)this._buttonNormalRenderer.setPreferredSize(this._contentSize), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize =
            1, this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize); else {
            var a = this._normalTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonNormalRenderer.setScale(1);
                return
            }
            var b = this._contentSize.width / a.width, a = this._contentSize.height / a.height;
            this._buttonNormalRenderer.setScaleX(b);
            this._buttonNormalRenderer.setScaleY(a);
            this._normalTextureScaleXInSize = b;
            this._normalTextureScaleYInSize = a
        }
        this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height /
            2)
    },
    _pressedTextureScaleChangedWithSize: function () {
        if (this._ignoreSize && !this._unifySize)this._scale9Enabled || (this._buttonClickedRenderer.setScale(1), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1); else if (this._scale9Enabled)this._buttonClickedRenderer.setPreferredSize(this._contentSize), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1, this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize); else {
            var a = this._pressedTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonClickedRenderer.setScale(1);
                return
            }
            var b = this._contentSize.width / a.width, a = this._contentSize.height / a.height;
            this._buttonClickedRenderer.setScaleX(b);
            this._buttonClickedRenderer.setScaleY(a);
            this._pressedTextureScaleXInSize = b;
            this._pressedTextureScaleYInSize = a
        }
        this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _disabledTextureScaleChangedWithSize: function () {
        if (this._ignoreSize && !this._unifySize)this._scale9Enabled &&
        this._buttonDisableRenderer.setScale(1); else if (this._scale9Enabled)this._buttonDisableRenderer.setScale(1), this._buttonDisableRenderer.setPreferredSize(this._contentSize); else {
            var a = this._disabledTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonDisableRenderer.setScale(1);
                return
            }
            var b = this._contentSize.height / a.height;
            this._buttonDisableRenderer.setScaleX(this._contentSize.width / a.width);
            this._buttonDisableRenderer.setScaleY(b)
        }
        this._buttonDisableRenderer.setPosition(this._contentSize.width / 2,
            this._contentSize.height / 2)
    },
    _adaptRenderers: function () {
        this._normalTextureAdaptDirty && (this._normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1);
        this._pressedTextureAdaptDirty && (this._pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1);
        this._disabledTextureAdaptDirty && (this._disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1)
    },
    _updateTitleLocation: function () {
        this._titleRenderer.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
    },
    setPressedActionEnabled: function (a) {
        this.pressedActionEnabled = a
    },
    setTitleText: function (a) {
        a !== this.getTitleText() && (this._titleRenderer.setString(a), this._ignoreSize ? (a = this.getVirtualRendererSize(), this.setContentSize(a)) : this._titleRenderer._renderCmd._updateTTF())
    },
    getTitleText: function () {
        return this._titleRenderer.getString()
    },
    setTitleColor: function (a) {
        this._titleRenderer.setFontFillColor(a)
    },
    getTitleColor: function () {
        return this._titleRenderer._getFillStyle()
    },
    setTitleFontSize: function (a) {
        this._titleRenderer.setFontSize(a);
        this._fontSize = a
    },
    getTitleFontSize: function () {
        return this._titleRenderer.getFontSize()
    },
    setZoomScale: function (a) {
        this._zoomScale = a
    },
    getZoomScale: function () {
        return this._zoomScale
    },
    getNormalTextureSize: function () {
        return this._normalTextureSize
    },
    setTitleFontName: function (a) {
        this._titleRenderer.setFontName(a);
        this._fontName = a
    },
    getTitleRenderer: function () {
        return this._titleRenderer
    },
    getTitleFontName: function () {
        return this._titleRenderer.getFontName()
    },
    _setTitleFont: function (a) {
        this._titleRenderer.font =
            a
    },
    _getTitleFont: function () {
        return this._titleRenderer.font
    },
    getDescription: function () {
        return "Button"
    },
    _createCloneInstance: function () {
        return new ccui.Button
    },
    _copySpecialProperties: function (a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadTextureNormal(a._normalFileName, a._normalTexType);
        this.loadTexturePressed(a._clickedFileName, a._pressedTexType);
        this.loadTextureDisabled(a._disabledFileName, a._disabledTexType);
        this.setCapInsetsNormalRenderer(a._capInsetsNormal);
        this.setCapInsetsPressedRenderer(a._capInsetsPressed);
        this.setCapInsetsDisabledRenderer(a._capInsetsDisabled);
        this.setTitleText(a.getTitleText());
        this.setTitleFontName(a.getTitleFontName());
        this.setTitleFontSize(a.getTitleFontSize());
        this.setTitleColor(a.getTitleColor());
        this.setPressedActionEnabled(a.pressedActionEnabled);
        this.setZoomScale(a._zoomScale)
    },
    _getNormalSize: function () {
        var a;
        null !== this._titleRenderer && (a = this._titleRenderer.getContentSize());
        var b;
        null !== this._buttonNormalRenderer && (b =
            this._buttonNormalRenderer.getContentSize());
        return cc.size(a.width > b.width ? a.width : b.width, a.height > b.height ? a.height : b.height)
    }
});
_p = ccui.Button.prototype;
cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText);
cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont);
cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize);
cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName);
cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor);
_p = null;
ccui.Button.create = function (a, b, d, e) {
    return new ccui.Button(a, b, d, e)
};
ccui.Button.NORMAL_RENDERER_ZORDER = -2;
ccui.Button.PRESSED_RENDERER_ZORDER = -2;
ccui.Button.DISABLED_RENDERER_ZORDER = -2;
ccui.Button.TITLE_RENDERER_ZORDER = -1;
ccui.Button.ZOOM_ACTION_TIME_STEP = 0.05;
ccui.Button.SYSTEM = 0;
ccui.Button.TTF = 1;
ccui.CheckBox = ccui.Widget.extend({
    _backGroundBoxRenderer: null,
    _backGroundSelectedBoxRenderer: null,
    _frontCrossRenderer: null,
    _backGroundBoxDisabledRenderer: null,
    _frontCrossDisabledRenderer: null,
    _isSelected: !0,
    _checkBoxEventListener: null,
    _checkBoxEventSelector: null,
    _backGroundTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundFileName: "",
    _backGroundSelectedFileName: "",
    _frontCrossFileName: "",
    _backGroundDisabledFileName: "",
    _frontCrossDisabledFileName: "",
    _className: "CheckBox",
    _zoomScale: 0.1,
    _backgroundTextureScaleX: 0.1,
    _backgroundTextureScaleY: 0.1,
    _backGroundBoxRendererAdaptDirty: !0,
    _backGroundSelectedBoxRendererAdaptDirty: !0,
    _frontCrossRendererAdaptDirty: !0,
    _backGroundBoxDisabledRendererAdaptDirty: !0,
    _frontCrossDisabledRendererAdaptDirty: !0,
    ctor: function (a, b, d, e, f, g) {
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        for (var h = 0, n = 0; n < arguments.length; n++) {
            var p = typeof arguments[n];
            "string" === p ? isNaN(arguments[n] - 0) ? h++ : (g = arguments[n], arguments[n] = void 0) : "number" === p && h++
        }
        switch (h) {
            case 2:
                g = d, d = b, b = void 0
        }
        g = void 0 === g ? 0 : g;
        this._isSelected = !0;
        this.setSelected(!1);
        this.loadTextures(a, b, d, e, f, g)
    },
    _initRenderer: function () {
        this._backGroundBoxRenderer = new cc.Sprite;
        this._backGroundSelectedBoxRenderer = new cc.Sprite;
        this._frontCrossRenderer = new cc.Sprite;
        this._backGroundBoxDisabledRenderer = new cc.Sprite;
        this._frontCrossDisabledRenderer =
            new cc.Sprite;
        this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundSelectedBoxRenderer, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER,
            -1)
    },
    loadTextures: function (a, b, d, e, f, g) {
        a && this.loadTextureBackGround(a, g);
        b && this.loadTextureBackGroundSelected(b, g);
        d && this.loadTextureFrontCross(d, g);
        e && this.loadTextureBackGroundDisabled(e, g);
        f && this.loadTextureFrontCrossDisabled(f, g)
    },
    loadTextureBackGround: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundFileName = a;
            this._backGroundTexType = b;
            var d = this._backGroundBoxRenderer;
            d._textureLoaded ? this._backGroundBoxRenderer.setContentSize(this._customSize) : d.addEventListener("load",
                function () {
                    this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize());
                    this.loadTextureBackGround(this._backGroundFileName, this._backGroundTexType)
                }, this);
            switch (this._backGroundTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize());
            this._backGroundBoxRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureBackGroundSelected: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundSelectedFileName = a;
            this._backGroundSelectedTexType = b;
            var d = this._backGroundSelectedBoxRenderer;
            d._textureLoaded || d.addEventListener("load", function () {
                this.loadTextureBackGroundSelected(this._backGroundSelectedFileName, this._backGroundSelectedTexType)
            }, this);
            switch (this._backGroundSelectedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._backGroundSelectedBoxRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureFrontCross: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossFileName = a;
            this._frontCrossTexType = b;
            var d = this._frontCrossRenderer;
            d._textureLoaded || d.addEventListener("load", function () {
                this.loadTextureFrontCross(this._frontCrossFileName, this._frontCrossTexType)
            }, this);
            switch (this._frontCrossTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._frontCrossRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureBackGroundDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundDisabledFileName = a;
            this._backGroundDisabledTexType = b;
            var d = this._backGroundBoxDisabledRenderer;
            d._textureLoaded || d.addEventListener("load", function () {
                this.loadTextureBackGroundDisabled(this._backGroundDisabledFileName, this._backGroundDisabledTexType)
            }, this);
            switch (this._backGroundDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._backGroundBoxDisabledRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureFrontCrossDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossDisabledFileName = a;
            this._frontCrossDisabledTexType = b;
            var d = this._frontCrossDisabledRenderer;
            d._textureLoaded || d.addEventListener("load", function () {
                    this.loadTextureFrontCrossDisabled(this._frontCrossDisabledFileName, this._frontCrossDisabledTexType)
                },
                this);
            switch (this._frontCrossDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._frontCrossDisabledRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    _onPressStateChangedToNormal: function () {
        this._backGroundBoxRenderer.setVisible(!0);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1);
        this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX,
            this._backgroundTextureScaleY);
        this._frontCrossRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY);
        this._isSelected && (this._frontCrossRenderer.setVisible(!0), this._frontCrossRendererAdaptDirty = !0)
    },
    _onPressStateChangedToPressed: function () {
        this._backGroundSelectedFileName ? (this._backGroundBoxRenderer.setVisible(!1), this._backGroundSelectedBoxRenderer.setVisible(!0), this._backGroundBoxDisabledRenderer.setVisible(!1), this._frontCrossDisabledRenderer.setVisible(!1)) : (this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX +
            this._zoomScale, this._backgroundTextureScaleY + this._zoomScale), this._frontCrossRenderer.setScale(this._backgroundTextureScaleX + this._zoomScale, this._backgroundTextureScaleY + this._zoomScale))
    },
    _onPressStateChangedToDisabled: function () {
        this._backGroundDisabledFileName && this._frontCrossDisabledFileName && (this._backGroundBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!0));
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._frontCrossRenderer.setVisible(!1);
        this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX,
            this._backgroundTextureScaleY);
        this._frontCrossRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY);
        this._isSelected && (this._frontCrossDisabledRenderer.setVisible(!0), this._frontCrossDisabledRendererAdaptDirty = !0)
    },
    setZoomScale: function (a) {
        this._zoomScale = a
    },
    getZoomScale: function () {
        return this._zoomScale
    },
    setSelectedState: function (a) {
        this.setSelected(a)
    },
    setSelected: function (a) {
        a !== this._isSelected && (this._isSelected = a, this._frontCrossRenderer.setVisible(this._isSelected))
    },
    getSelectedState: function () {
        return this.isSelected()
    },
    isSelected: function () {
        return this._isSelected
    },
    _selectedEvent: function () {
        this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_SELECTED))
    },
    _unSelectedEvent: function () {
        this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_UNSELECTED) :
            this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_UNSELECTED))
    },
    _releaseUpEvent: function () {
        ccui.Widget.prototype._releaseUpEvent.call(this);
        this._isSelected ? (this.setSelected(!1), this._unSelectedEvent()) : (this.setSelected(!0), this._selectedEvent())
    },
    addEventListenerCheckBox: function (a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function (a, b) {
        this._checkBoxEventSelector = a;
        this._checkBoxEventListener = b
    },
    getVirtualRendererSize: function () {
        return this._backGroundBoxRenderer.getContentSize()
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._frontCrossDisabledRendererAdaptDirty = this._backGroundBoxDisabledRendererAdaptDirty = this._frontCrossRendererAdaptDirty = this._backGroundSelectedBoxRendererAdaptDirty = this._backGroundBoxRendererAdaptDirty = !0
    },
    getVirtualRenderer: function () {
        return this._backGroundBoxRenderer
    },
    _backGroundTextureScaleChangedWithSize: function () {
        var a = this._backGroundBoxRenderer, b = this._contentSize;
        if (this._ignoreSize)a.setScale(1), this._backgroundTextureScaleX = this._backgroundTextureScaleY = 1; else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                this._backgroundTextureScaleX = this._backgroundTextureScaleY = 1;
                return
            }
            var e = b.width / d.width, d = b.height / d.height;
            this._backgroundTextureScaleX = e;
            this._backgroundTextureScaleY = d;
            a.setScaleX(e);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _backGroundSelectedTextureScaleChangedWithSize: function () {
        var a = this._backGroundSelectedBoxRenderer, b = this._contentSize;
        if (this._ignoreSize)a.setScale(1); else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = b.height / d.height;
            a.setScaleX(b.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _frontCrossTextureScaleChangedWithSize: function () {
        var a = this._frontCrossRenderer, b = this._contentSize;
        if (this._ignoreSize)a.setScale(1); else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = b.height / d.height;
            a.setScaleX(b.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _backGroundDisabledTextureScaleChangedWithSize: function () {
        var a =
            this._backGroundBoxDisabledRenderer, b = this._contentSize;
        if (this._ignoreSize)a.setScale(1); else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = b.height / d.height;
            a.setScaleX(b.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _frontCrossDisabledTextureScaleChangedWithSize: function () {
        var a = this._frontCrossDisabledRenderer, b = this._contentSize;
        if (this._ignoreSize)a.setScale(1); else {
            var d = a.getContentSize();
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = b.height / d.height;
            a.setScaleX(b.width / d.width);
            a.setScaleY(e)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    getDescription: function () {
        return "CheckBox"
    },
    _createCloneInstance: function () {
        return new ccui.CheckBox
    },
    _copySpecialProperties: function (a) {
        a instanceof ccui.CheckBox && (this.loadTextureBackGround(a._backGroundFileName, a._backGroundTexType), this.loadTextureBackGroundSelected(a._backGroundSelectedFileName, a._backGroundSelectedTexType), this.loadTextureFrontCross(a._frontCrossFileName, a._frontCrossTexType),
            this.loadTextureBackGroundDisabled(a._backGroundDisabledFileName, a._backGroundDisabledTexType), this.loadTextureFrontCrossDisabled(a._frontCrossDisabledFileName, a._frontCrossDisabledTexType), this.setSelected(a._isSelected), this._checkBoxEventListener = a._checkBoxEventListener, this._checkBoxEventSelector = a._checkBoxEventSelector, this._ccEventCallback = a._ccEventCallback, this._zoomScale = a._zoomScale, this._backgroundTextureScaleX = a._backgroundTextureScaleX, this._backgroundTextureScaleY = a._backgroundTextureScaleY)
    },
    _adaptRenderers: function () {
        this._backGroundBoxRendererAdaptDirty && (this._backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1);
        this._backGroundSelectedBoxRendererAdaptDirty && (this._backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1);
        this._frontCrossRendererAdaptDirty && (this._frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1);
        this._backGroundBoxDisabledRendererAdaptDirty && (this._backGroundDisabledTextureScaleChangedWithSize(),
            this._backGroundBoxDisabledRendererAdaptDirty = !1);
        this._frontCrossDisabledRendererAdaptDirty && (this._frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1)
    }
});
_p = ccui.CheckBox.prototype;
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
_p = null;
ccui.CheckBox.create = function (a, b, d, e, f, g) {
    return new ccui.CheckBox(a, b, d, e, f, g)
};
ccui.CheckBox.EVENT_SELECTED = 0;
ccui.CheckBox.EVENT_UNSELECTED = 1;
ccui.CheckBox.BOX_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1;
ccui.ImageView = ccui.Widget.extend({
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _imageRenderer: null,
    _textureFile: "",
    _imageTexType: ccui.Widget.LOCAL_TEXTURE,
    _imageTextureSize: null,
    _className: "ImageView",
    _imageRendererAdaptDirty: !0,
    ctor: function (a, b) {
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._imageTextureSize = cc.size(this._capInsets.width, this._capInsets.height);
        ccui.Widget.prototype.ctor.call(this);
        a ? this.loadTexture(a, void 0 === b ? 0 : b) : this._imageTexType = ccui.Widget.LOCAL_TEXTURE
    },
    _initRenderer: function () {
        this._imageRenderer =
            new cc.Sprite;
        this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1)
    },
    loadTexture: function (a, b) {
        if (a) {
            var d = this;
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._imageTexType = b;
            var e = d._imageRenderer;
            e._textureLoaded || e.addEventListener("load", function () {
                d.loadTexture(d._textureFile, d._imageTexType)
            });
            switch (d._imageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d._scale9Enabled ? (e.initWithFile(a), e.setCapInsets(d._capInsets)) : e.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d._scale9Enabled ?
                        (e.initWithSpriteFrameName(a), e.setCapInsets(d._capInsets)) : e.initWithSpriteFrameName(a)
            }
            d._imageTextureSize = e.getContentSize();
            this._updateChildrenDisplayedRGBA();
            d._updateContentSizeWithTextureSize(d._imageTextureSize);
            d._imageRendererAdaptDirty = !0;
            d._findLayout()
        }
    },
    setTextureRect: function (a) {
        this._scale9Enabled || this._imageRenderer.setTextureRect(a)
    },
    setScale9Enabled: function (a) {
        this._scale9Enabled !== a && (this._scale9Enabled = a, this.removeProtectedChild(this._imageRenderer), this._imageRenderer = null,
            this._imageRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets), this._imageRendererAdaptDirty = !0)
    },
    isScale9Enabled: function () {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function (a) {
        if (!this._scale9Enabled ||
            this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function (a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._imageRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function () {
        return cc.rect(this._capInsets)
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._imageRendererAdaptDirty = !0
    },
    _adaptRenderers: function () {
        this._imageRendererAdaptDirty && (this._imageTextureScaleChangedWithSize(),
            this._imageRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function () {
        return cc.size(this._imageTextureSize)
    },
    getVirtualRenderer: function () {
        return this._imageRenderer
    },
    _imageTextureScaleChangedWithSize: function () {
        if (this._ignoreSize)this._scale9Enabled || this._imageRenderer.setScale(1); else if (this._scale9Enabled)this._imageRenderer.setPreferredSize(this._contentSize), this._imageRenderer.setScale(1); else {
            var a = this._imageTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._imageRenderer.setScale(1);
                return
            }
            this._imageRenderer.setScaleX(this._contentSize.width /
                a.width);
            this._imageRenderer.setScaleY(this._contentSize.height / a.height)
        }
        this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function () {
        return "ImageView"
    },
    _createCloneInstance: function () {
        return new ccui.ImageView
    },
    _copySpecialProperties: function (a) {
        a instanceof ccui.ImageView && (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._imageTexType), this.setCapInsets(a._capInsets))
    },
    setContentSize: function (a,
                              b) {
        null != b && (a = cc.size(a, b));
        ccui.Widget.prototype.setContentSize.call(this, a);
        if (this._scale9Enabled)this._imageRenderer.setContentSize(a); else {
            var d = this._imageRenderer.getContentSize();
            this._imageRenderer.setScaleX(a.width / d.width);
            this._imageRenderer.setScaleY(a.height / d.height)
        }
    }
});
ccui.ImageView.create = function (a, b) {
    return new ccui.ImageView(a, b)
};
ccui.ImageView.RENDERER_ZORDER = -1;
ccui.LoadingBar = ccui.Widget.extend({
    _direction: null,
    _percent: 100,
    _totalLength: 0,
    _barRenderer: null,
    _renderBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _barRendererTextureSize: null,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _textureFile: "",
    _isTextureLoaded: !1,
    _className: "LoadingBar",
    _barRendererAdaptDirty: !0,
    ctor: function (a, b) {
        this._direction = ccui.LoadingBar.TYPE_LEFT;
        this._barRendererTextureSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== a && this.loadTexture(a);
        void 0 !== b && this.setPercent(b)
    },
    _initRenderer: function () {
        this._barRenderer = new cc.Sprite;
        this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1);
        this._barRenderer.setAnchorPoint(0, 0.5)
    },
    setDirection: function (a) {
        if (this._direction !== a)switch (this._direction = a, this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                this._barRenderer.setAnchorPoint(0, 0.5);
                this._barRenderer.setPosition(0, 0.5 * this._contentSize.height);
                this._scale9Enabled || this._barRenderer.setFlippedX(!1);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                this._barRenderer.setAnchorPoint(1,
                    0.5), this._barRenderer.setPosition(this._totalLength, 0.5 * this._contentSize.height), this._scale9Enabled || this._barRenderer.setFlippedX(!0)
        }
    },
    getDirection: function () {
        return this._direction
    },
    loadTexture: function (a, b) {
        if (a) {
            this._renderBarTexType = b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            var d = this._barRenderer, e = this;
            d._textureLoaded || d.addEventListener("load", function () {
                e.loadTexture(e._textureFile, e._renderBarTexType);
                e._setPercent(e._percent)
            });
            switch (this._renderBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            var f = d.getContentSize();
            this._barRendererTextureSize.width = f.width;
            this._barRendererTextureSize.height = f.height;
            switch (this._direction) {
                case ccui.LoadingBar.TYPE_LEFT:
                    d.setAnchorPoint(0, 0.5);
                    this._scale9Enabled || d.setFlippedX(!1);
                    break;
                case ccui.LoadingBar.TYPE_RIGHT:
                    d.setAnchorPoint(1, 0.5), this._scale9Enabled || d.setFlippedX(!0)
            }
            this._scale9Enabled && d.setCapInsets(this._capInsets);
            this._updateChildrenDisplayedRGBA();
            this._barRendererScaleChangedWithSize();
            this._updateContentSizeWithTextureSize(this._barRendererTextureSize);
            this._barRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    setScale9Enabled: function (a) {
        this._scale9Enabled !== a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer), this._barRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1),
            this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets), this.setPercent(this._percent), this._barRendererAdaptDirty = !0)
    },
    isScale9Enabled: function () {
        return this._scale9Enabled
    },
    setCapInsets: function (a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function () {
        return cc.rect(this._capInsets)
    },
    setPercent: function (a) {
        100 < a && (a = 100);
        0 > a && (a = 0);
        a !==
        this._percent && (this._percent = a, this._setPercent(a))
    },
    _setPercent: function () {
        var a, b, d, e;
        0 >= this._totalLength || (a = this._percent / 100, this._scale9Enabled ? this._setScale9Scale() : (d = this._barRenderer, e = this._barRendererTextureSize, b = d.getTextureRect(), b.width = e.width * a, d.setTextureRect(cc.rect(b.x, b.y, e.width * a, e.height), d._rectRotated)))
    },
    setContentSize: function (a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b);
        this._totalLength = void 0 === b ? a.width : a
    },
    getPercent: function () {
        return this._percent
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function () {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1)
    },
    ignoreContentAdaptWithSize: function (a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function () {
        return cc.size(this._barRendererTextureSize)
    },
    getVirtualRenderer: function () {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function () {
        var a = this._barRenderer, b = this._contentSize;
        if (this._unifySize)this._totalLength = this._contentSize.width, this.setPercent(this._percent); else if (this._ignoreSize)this._scale9Enabled || (this._totalLength = this._barRendererTextureSize.width, a.setScale(1)); else if (this._totalLength = b.width, this._scale9Enabled)this._setScale9Scale(), a.setScale(1); else {
            var d = this._barRendererTextureSize;
            if (0 >= d.width || 0 >= d.height) {
                a.setScale(1);
                return
            }
            var e = b.height / d.height;
            a.setScaleX(b.width /
                d.width);
            a.setScaleY(e)
        }
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                a.setPosition(0, 0.5 * b.height);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                a.setPosition(this._totalLength, 0.5 * b.height)
        }
    },
    _setScale9Scale: function () {
        this._barRenderer.setPreferredSize(cc.size(this._percent / 100 * this._totalLength, this._contentSize.height))
    },
    getDescription: function () {
        return "LoadingBar"
    },
    _createCloneInstance: function () {
        return new ccui.LoadingBar
    },
    _copySpecialProperties: function (a) {
        a instanceof ccui.LoadingBar && (this._prevIgnoreSize =
            a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._renderBarTexType), this.setCapInsets(a._capInsets), this.setPercent(a._percent), this.setDirection(a._direction))
    }
});
_p = ccui.LoadingBar.prototype;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.LoadingBar.create = function (a, b) {
    return new ccui.LoadingBar(a, b)
};
ccui.LoadingBar.TYPE_LEFT = 0;
ccui.LoadingBar.TYPE_RIGHT = 1;
ccui.LoadingBar.RENDERER_ZORDER = -1;
ccui.Slider = ccui.Widget.extend({
    _barRenderer: null,
    _progressBarRenderer: null,
    _barTextureSize: null,
    _progressBarTextureSize: null,
    _slidBallNormalRenderer: null,
    _slidBallPressedRenderer: null,
    _slidBallDisabledRenderer: null,
    _slidBallRenderer: null,
    _barLength: 0,
    _percent: 0,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _textureFile: "",
    _progressBarTextureFile: "",
    _slidBallNormalTextureFile: "",
    _slidBallPressedTextureFile: "",
    _slidBallDisabledTextureFile: "",
    _capInsetsBarRenderer: null,
    _capInsetsProgressBarRenderer: null,
    _sliderEventListener: null,
    _sliderEventSelector: null,
    _barTexType: ccui.Widget.LOCAL_TEXTURE,
    _progressBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballNTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballPTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballDTexType: ccui.Widget.LOCAL_TEXTURE,
    _isTextureLoaded: !1,
    _className: "Slider",
    _barRendererAdaptDirty: !0,
    _progressBarRendererDirty: !0,
    _unifySize: !1,
    _zoomScale: 0.1,
    _sliderBallNormalTextureScaleX: 1,
    _sliderBallNormalTextureScaleY: 1,
    ctor: function (a, b, d) {
        this._barTextureSize = cc.size(0, 0);
        this._progressBarTextureSize =
            cc.size(0, 0);
        this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0);
        this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this);
        d = d || 0;
        this.setTouchEnabled(!0);
        a && this.loadBarTexture(a, d);
        b && this.loadSlidBallTextures(b, d)
    },
    _initRenderer: function () {
        this._barRenderer = new cc.Sprite;
        this._progressBarRenderer = new cc.Sprite;
        this._progressBarRenderer.setAnchorPoint(0, 0.5);
        this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._progressBarRenderer,
            ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1);
        this._slidBallNormalRenderer = new cc.Sprite;
        this._slidBallPressedRenderer = new cc.Sprite;
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer = new cc.Sprite;
        this._slidBallDisabledRenderer.setVisible(!1);
        this._slidBallRenderer = new cc.Node;
        this._slidBallRenderer.addChild(this._slidBallNormalRenderer);
        this._slidBallRenderer.addChild(this._slidBallPressedRenderer);
        this._slidBallRenderer.addChild(this._slidBallDisabledRenderer);
        this._slidBallRenderer.setCascadeColorEnabled(!0);
        this._slidBallRenderer.setCascadeOpacityEnabled(!0);
        this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1)
    },
    loadBarTexture: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._barTexType = b;
            var d = this._barRenderer, e = this;
            d._textureLoaded || d.addEventListener("load", function () {
                e.loadBarTexture(e._textureFile, e._barTexType)
            });
            switch (this._barTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRendererDirty = this._barRendererAdaptDirty = !0;
            this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize());
            this._findLayout();
            this._barTextureSize = this._barRenderer.getContentSize()
        }
    },
    loadProgressBarTexture: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._progressBarTextureFile = a;
            this._progressBarTexType = b;
            var d = this._progressBarRenderer, e = this;
            d._textureLoaded || d.addEventListener("load", function () {
                e.loadProgressBarTexture(e._progressBarTextureFile, e._progressBarTexType)
            });
            switch (this._progressBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
            d = this._progressBarRenderer.getContentSize();
            this._progressBarTextureSize = {width: d.width, height: d.height};
            this._progressBarRendererDirty = !0;
            this._findLayout()
        }
    },
    setScale9Enabled: function (a) {
        this._scale9Enabled !== a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer,
            !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._progressBarRenderer = this._barRenderer = null, this._scale9Enabled ? (this._barRenderer = new ccui.Scale9Sprite, this._progressBarRenderer = new ccui.Scale9Sprite) : (this._barRenderer = new cc.Sprite, this._progressBarRenderer = new cc.Sprite), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER,
            -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsBarRenderer(this._capInsetsBarRenderer), this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer), this._progressBarRendererDirty = this._barRendererAdaptDirty = !0)
    },
    isScale9Enabled: function () {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function (a) {
        if (!this._scale9Enabled ||
            this._scale9Enabled && !a)ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function (a) {
        this.setCapInsetsBarRenderer(a);
        this.setCapInsetProgressBarRenderer(a)
    },
    setCapInsetsBarRenderer: function (a) {
        if (a) {
            var b = this._capInsetsBarRenderer;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsetsBarRenderer: function () {
        return cc.rect(this._capInsetsBarRenderer)
    },
    setCapInsetProgressBarRenderer: function (a) {
        if (a) {
            var b =
                this._capInsetsProgressBarRenderer;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
        }
    },
    getCapInsetsProgressBarRenderer: function () {
        return cc.rect(this._capInsetsProgressBarRenderer)
    },
    loadSlidBallTextures: function (a, b, d, e) {
        this.loadSlidBallTextureNormal(a, e);
        this.loadSlidBallTexturePressed(b, e);
        this.loadSlidBallTextureDisabled(d, e)
    },
    loadSlidBallTextureNormal: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallNormalTextureFile =
                a;
            this._ballNTexType = b;
            var d = this;
            this._slidBallNormalRenderer._textureLoaded || this._slidBallNormalRenderer.addEventListener("load", function () {
                d.loadSlidBallTextureNormal(d._slidBallNormalTextureFile, d._ballNTexType)
            });
            switch (this._ballNTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallNormalRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallNormalRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._findLayout()
        }
    },
    loadSlidBallTexturePressed: function (a,
                                          b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallPressedTextureFile = a;
            this._ballPTexType = b;
            var d = this;
            this._slidBallPressedRenderer._textureLoaded || this._slidBallPressedRenderer.addEventListener("load", function () {
                d.loadSlidBallTexturePressed(d._slidBallPressedTextureFile, d._ballPTexType)
            });
            switch (this._ballPTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallPressedRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallPressedRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._findLayout()
        }
    },
    loadSlidBallTextureDisabled: function (a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallDisabledTextureFile = a;
            this._ballDTexType = b;
            var d = this;
            this._slidBallDisabledRenderer._textureLoaded || this._slidBallDisabledRenderer.addEventListener("load", function () {
                d.loadSlidBallTextureDisabled(d._slidBallDisabledTextureFile, d._ballDTexType)
            });
            switch (this._ballDTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._findLayout()
        }
    },
    setPercent: function (a) {
        100 < a && (a = 100);
        0 > a && (a = 0);
        this._percent = a;
        a = a / 100 * this._barLength;
        this._slidBallRenderer.setPosition(a, this._contentSize.height / 2);
        if (this._scale9Enabled)this._progressBarRenderer.setPreferredSize(cc.size(a, this._contentSize.height)); else {
            var b = this._progressBarRenderer, d = b.getTextureRect();
            b.setTextureRect(cc.rect(d.x, d.y, a / b._scaleX, d.height), b.isTextureRectRotated())
        }
    },
    hitTest: function (a) {
        a = this._slidBallNormalRenderer.convertToNodeSpace(a);
        var b = this._slidBallNormalRenderer.getContentSize(),
            b = cc.rect(0, 0, b.width, b.height);
        return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
    },
    onTouchBegan: function (a, b) {
        var d = ccui.Widget.prototype.onTouchBegan.call(this, a, b);
        if (this._hit) {
            var e = this.convertToNodeSpace(this._touchBeganPosition);
            this.setPercent(this._getPercentWithBallPos(e.x));
            this._percentChangedEvent()
        }
        return d
    },
    onTouchMoved: function (a, b) {
        var d = a.getLocation(), d = this.convertToNodeSpace(d);
        this.setPercent(this._getPercentWithBallPos(d.x));
        this._percentChangedEvent()
    },
    onTouchEnded: function (a,
                            b) {
        ccui.Widget.prototype.onTouchEnded.call(this, a, b)
    },
    onTouchCancelled: function (a, b) {
        ccui.Widget.prototype.onTouchCancelled.call(this, a, b)
    },
    _getPercentWithBallPos: function (a) {
        return a / this._barLength * 100
    },
    addEventListenerSlider: function (a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function (a, b) {
        this._sliderEventSelector = a;
        this._sliderEventListener = b
    },
    _percentChangedEvent: function () {
        this._sliderEventSelector && (this._sliderEventListener ? this._sliderEventSelector.call(this._sliderEventListener,
            this, ccui.Slider.EVENT_PERCENT_CHANGED) : this._sliderEventSelector(this, ccui.Slider.EVENT_PERCENT_CHANGED));
        this._ccEventCallback && this._ccEventCallback(this, ccui.Slider.EVENT_PERCENT_CHANGED)
    },
    getPercent: function () {
        return this._percent
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._progressBarRendererDirty = this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function () {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1);
        this._progressBarRendererDirty && (this._progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1)
    },
    getVirtualRendererSize: function () {
        return this._barRenderer.getContentSize()
    },
    getVirtualRenderer: function () {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function () {
        if (this._unifySize)this._barLength = this._contentSize.width, this._barRenderer.setPreferredSize(this._contentSize); else if (this._ignoreSize)this._barRenderer.setScale(1), this._barLength = this._contentSize.width;
        else if (this._barLength = this._contentSize.width, this._scale9Enabled)this._barRenderer.setPreferredSize(this._contentSize), this._barRenderer.setScale(1); else {
            var a = this._barTextureSize;
            if (0 >= a.width || 0 >= a.height)this._barRenderer.setScale(1); else {
                var b = this._contentSize.height / a.height;
                this._barRenderer.setScaleX(this._contentSize.width / a.width);
                this._barRenderer.setScaleY(b)
            }
        }
        this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _progressBarRendererScaleChangedWithSize: function () {
        if (this._unifySize)this._progressBarRenderer.setPreferredSize(this._contentSize);
        else if (this._ignoreSize) {
            if (!this._scale9Enabled) {
                var a = this._progressBarTextureSize, b = this._contentSize.width / a.width, a = this._contentSize.height / a.height;
                this._progressBarRenderer.setScaleX(b);
                this._progressBarRenderer.setScaleY(a)
            }
        } else if (this._scale9Enabled)this._progressBarRenderer.setPreferredSize(this._contentSize), this._progressBarRenderer.setScale(1); else {
            a = this._progressBarTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._progressBarRenderer.setScale(1);
                return
            }
            b = this._contentSize.width / a.width;
            a = this._contentSize.height / a.height;
            this._progressBarRenderer.setScaleX(b);
            this._progressBarRenderer.setScaleY(a)
        }
        this._progressBarRenderer.setPosition(0, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _onPressStateChangedToNormal: function () {
        this._slidBallNormalRenderer.setVisible(!0);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!1);
        this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX, this._sliderBallNormalTextureScaleY)
    },
    _onPressStateChangedToPressed: function () {
        this._slidBallPressedTextureFile ? (this._slidBallNormalRenderer.setVisible(!1), this._slidBallPressedRenderer.setVisible(!0), this._slidBallDisabledRenderer.setVisible(!1)) : this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX + this._zoomScale, this._sliderBallNormalTextureScaleY + this._zoomScale)
    },
    _onPressStateChangedToDisabled: function () {
        this._slidBallDisabledTextureFile && (this._slidBallNormalRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!0));
        this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX, this._sliderBallNormalTextureScaleY);
        this._slidBallPressedRenderer.setVisible(!1)
    },
    setZoomScale: function (a) {
        this._zoomScale = a
    },
    getZoomScale: function () {
        return this._zoomScale
    },
    getDescription: function () {
        return "Slider"
    },
    _createCloneInstance: function () {
        return new ccui.Slider
    },
    _copySpecialProperties: function (a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadBarTexture(a._textureFile, a._barTexType);
        this.loadProgressBarTexture(a._progressBarTextureFile, a._progressBarTexType);
        this.loadSlidBallTextureNormal(a._slidBallNormalTextureFile, a._ballNTexType);
        this.loadSlidBallTexturePressed(a._slidBallPressedTextureFile, a._ballPTexType);
        this.loadSlidBallTextureDisabled(a._slidBallDisabledTextureFile, a._ballDTexType);
        this.setPercent(a.getPercent());
        this._sliderEventListener = a._sliderEventListener;
        this._sliderEventSelector = a._sliderEventSelector;
        this._zoomScale = a._zoomScale;
        this._ccEventCallback = a._ccEventCallback
    }
});
_p = ccui.Slider.prototype;
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.Slider.create = function (a, b, d) {
    return new ccui.Slider(a, b, d)
};
ccui.Slider.EVENT_PERCENT_CHANGED = 0;
ccui.Slider.BASEBAR_RENDERER_ZORDER = -3;
ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2;
ccui.Slider.BALL_RENDERER_ZORDER = -1;
ccui.Text = ccui.Widget.extend({
    _touchScaleChangeEnabled: !1,
    _normalScaleValueX: 1,
    _normalScaleValueY: 1,
    _fontName: "Arial",
    _fontSize: 16,
    _onSelectedScaleOffset: 0.5,
    _labelRenderer: "",
    _textAreaSize: null,
    _textVerticalAlignment: 0,
    _textHorizontalAlignment: 0,
    _className: "Text",
    _type: null,
    _labelRendererAdaptDirty: !0,
    ctor: function (a, b, d) {
        this._type = ccui.Text.Type.SYSTEM;
        this._textAreaSize = cc.size(0, 0);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== d ? (this.setFontName(b), this.setFontSize(d), this.setString(a)) : this.setFontName(this._fontName)
    },
    _initRenderer: function () {
        this._labelRenderer = new cc.LabelTTF;
        this.addProtectedChild(this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1)
    },
    setText: function (a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function (a) {
        a !== this._labelRenderer.getString() && (this._labelRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0)
    },
    getStringValue: function () {
        cc.log("Please use the getString");
        return this._labelRenderer.getString()
    },
    getString: function () {
        return this._labelRenderer.getString()
    },
    getStringLength: function () {
        return this._labelRenderer.getStringLength()
    },
    setFontSize: function (a) {
        this._labelRenderer.setFontSize(a);
        this._fontSize = a;
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontSize: function () {
        return this._fontSize
    },
    setFontName: function (a) {
        this._fontName = a;
        this._labelRenderer.setFontName(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontName: function () {
        return this._fontName
    },
    _setFont: function (a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._labelRenderer._setFont(a), this._labelScaleChangedWithSize())
    },
    _getFont: function () {
        return this._labelRenderer._getFont()
    },
    getType: function () {
        return this._type
    },
    setTextAreaSize: function (a) {
        this._labelRenderer.setDimensions(a);
        this._ignoreSize || (this._customSize = a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextAreaSize: function () {
        return this._labelRenderer.getDimensions()
    },
    setTextHorizontalAlignment: function (a) {
        this._labelRenderer.setHorizontalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextHorizontalAlignment: function () {
        return this._labelRenderer.getHorizontalAlignment()
    },
    setTextVerticalAlignment: function (a) {
        this._labelRenderer.setVerticalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextVerticalAlignment: function () {
        return this._labelRenderer.getVerticalAlignment()
    },
    setTouchScaleChangeEnabled: function (a) {
        this._touchScaleChangeEnabled = a
    },
    isTouchScaleChangeEnabled: function () {
        return this._touchScaleChangeEnabled
    },
    _onPressStateChangedToNormal: function () {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX), this._labelRenderer.setScaleY(this._normalScaleValueY))
    },
    _onPressStateChangedToPressed: function () {
        this._touchScaleChangeEnabled &&
        (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset))
    },
    _onPressStateChangedToDisabled: function () {
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelRendererAdaptDirty = !0
    },
    _adaptRenderers: function () {
        this._labelRendererAdaptDirty && (this._labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function () {
        return this._labelRenderer.getContentSize()
    },
    getVirtualRenderer: function () {
        return this._labelRenderer
    },
    getAutoRenderSize: function () {
        var a = this._labelRenderer.getContentSize();
        this._ignoreSize || (this._labelRenderer.setDimensions(0, 0), a = this._labelRenderer.getContentSize(), this._labelRenderer.setDimensions(this._contentSize.width, this._contentSize.height));
        return a
    },
    _labelScaleChangedWithSize: function () {
        var a = this._contentSize;
        if (this._ignoreSize)this._labelRenderer.setDimensions(0, 0), this._labelRenderer.setScale(1), this._normalScaleValueX = this._normalScaleValueY =
            1; else {
            this._labelRenderer.setDimensions(cc.size(a.width, a.height));
            var b = this._labelRenderer.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                this._labelRenderer.setScale(1);
                return
            }
            var d = a.width / b.width, b = a.height / b.height;
            this._labelRenderer.setScaleX(d);
            this._labelRenderer.setScaleY(b);
            this._normalScaleValueX = d;
            this._normalScaleValueY = b
        }
        this._labelRenderer.setPosition(a.width / 2, a.height / 2)
    },
    getDescription: function () {
        return "Label"
    },
    enableShadow: function (a, b, d) {
        this._labelRenderer.enableShadow(a, b, d)
    },
    enableOutline: function (a, b) {
        this._labelRenderer.enableStroke(a, b)
    },
    enableGlow: function (a) {
        this._type === ccui.Text.Type.TTF && this._labelRenderer.enableGlow(a)
    },
    disableEffect: function () {
        this._labelRenderer.disableEffect && this._labelRenderer.disableEffect()
    },
    _createCloneInstance: function () {
        return new ccui.Text
    },
    _copySpecialProperties: function (a) {
        a instanceof ccui.Text && (this.setFontName(a._fontName), this.setFontSize(a.getFontSize()), this.setString(a.getString()), this.setTouchScaleChangeEnabled(a.touchScaleEnabled),
            this.setTextAreaSize(a._textAreaSize), this.setTextHorizontalAlignment(a._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(a._labelRenderer.getVerticalAlignment()), this.setContentSize(a.getContentSize()), this.setTextColor(a.getTextColor()))
    },
    _setBoundingWidth: function (a) {
        this._textAreaSize.width = a;
        this._labelRenderer._setBoundingWidth(a);
        this._labelScaleChangedWithSize()
    },
    _setBoundingHeight: function (a) {
        this._textAreaSize.height = a;
        this._labelRenderer._setBoundingHeight(a);
        this._labelScaleChangedWithSize()
    },
    _getBoundingWidth: function () {
        return this._textAreaSize.width
    },
    _getBoundingHeight: function () {
        return this._textAreaSize.height
    },
    _changePosition: function () {
        this._adaptRenderers()
    },
    setColor: function (a) {
        cc.ProtectedNode.prototype.setColor.call(this, a);
        this._labelRenderer.setColor(a)
    },
    setTextColor: function (a) {
        this._labelRenderer.setFontFillColor(a)
    },
    getTextColor: function () {
        return this._labelRenderer._getFillStyle()
    }
});
_p = ccui.Text.prototype;
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "stringLength", _p.getStringLength);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment);
cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment);
_p = null;
ccui.Label = ccui.Text.create = function (a, b, d) {
    return new ccui.Text(a, b, d)
};
ccui.Text.RENDERER_ZORDER = -1;
ccui.Text.Type = {SYSTEM: 0, TTF: 1};
ccui.TextAtlas = ccui.Widget.extend({
    _labelAtlasRenderer: null,
    _stringValue: "",
    _charMapFileName: "",
    _itemWidth: 0,
    _itemHeight: 0,
    _startCharMap: "",
    _className: "TextAtlas",
    _labelAtlasRendererAdaptDirty: null,
    ctor: function (a, b, d, e, f) {
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== f && this.setProperty(a, b, d, e, f)
    },
    _initRenderer: function () {
        this._labelAtlasRenderer = new cc.LabelAtlas;
        this._labelAtlasRenderer.setAnchorPoint(cc.p(0.5, 0.5));
        this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER,
            -1)
    },
    setProperty: function (a, b, d, e, f) {
        this._stringValue = a;
        this._charMapFileName = b;
        this._itemWidth = d;
        this._itemHeight = e;
        this._startCharMap = f;
        this._labelAtlasRenderer.initWithString(a, this._charMapFileName, this._itemWidth, this._itemHeight, this._startCharMap[0]);
        this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
        this._labelAtlasRendererAdaptDirty = !0
    },
    setString: function (a) {
        a !== this._labelAtlasRenderer.getString() && (this._stringValue = a, this._labelAtlasRenderer.setString(a),
            this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0)
    },
    setStringValue: function (a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    getStringValue: function () {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function () {
        return this._labelAtlasRenderer.getString()
    },
    getStringLength: function () {
        return this._labelAtlasRenderer.getStringLength()
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelAtlasRendererAdaptDirty = !0
    },
    _adaptRenderers: function () {
        this._labelAtlasRendererAdaptDirty && (this._labelAtlasScaleChangedWithSize(), this._labelAtlasRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function () {
        return this._labelAtlasRenderer.getContentSize()
    },
    getVirtualRenderer: function () {
        return this._labelAtlasRenderer
    },
    _labelAtlasScaleChangedWithSize: function () {
        var a = this._labelAtlasRenderer;
        if (this._ignoreSize)a.setScale(1); else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / b.width);
            a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function () {
        return "LabelAtlas"
    },
    _copySpecialProperties: function (a) {
        a && this.setProperty(a._stringValue, a._charMapFileName, a._itemWidth, a._itemHeight, a._startCharMap)
    },
    _createCloneInstance: function () {
        return new ccui.TextAtlas
    }
});
_p = ccui.TextAtlas.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextAtlas.create = function (a, b, d, e, f) {
    return new ccui.TextAtlas(a, b, d, e, f)
};
ccui.TextAtlas.RENDERER_ZORDER = -1;
ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({
    _labelBMFontRenderer: null,
    _fntFileHasInit: !1,
    _fntFileName: "",
    _stringValue: "",
    _className: "TextBMFont",
    _labelBMFontRendererAdaptDirty: !0,
    ctor: function (a, b) {
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== b && (this.setFntFile(b), this.setString(a))
    },
    _initRenderer: function () {
        this._labelBMFontRenderer = new cc.LabelBMFont;
        this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1)
    },
    setFntFile: function (a) {
        if (a) {
            this._fntFileName = a;
            this._fntFileHasInit = !0;
            this._labelBMFontRenderer.initWithString(this._stringValue, a);
            this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize());
            this._labelBMFontRendererAdaptDirty = !0;
            var b = this;
            a = b._labelBMFontRenderer;
            a._textureLoaded || a.addEventListener("load", function () {
                b.setFntFile(b._fntFileName)
            })
        }
    },
    setText: function (a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function (a) {
        a !== this._labelBMFontRenderer.getString() && (this._stringValue = a, this._labelBMFontRenderer.setString(a),
        this._fntFileHasInit && (this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0))
    },
    getString: function () {
        return this._stringValue
    },
    getStringLength: function () {
        return this._labelBMFontRenderer.getStringLength()
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelBMFontRendererAdaptDirty = !0
    },
    _adaptRenderers: function () {
        this._labelBMFontRendererAdaptDirty && (this._labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function () {
        return this._labelBMFontRenderer.getContentSize()
    },
    getVirtualRenderer: function () {
        return this._labelBMFontRenderer
    },
    _labelBMFontScaleChangedWithSize: function () {
        var a = this._labelBMFontRenderer;
        if (this._ignoreSize)a.setScale(1); else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / b.width);
            a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function () {
        return "TextBMFont"
    },
    _createCloneInstance: function () {
        return new ccui.TextBMFont
    },
    _copySpecialProperties: function (a) {
        this.setFntFile(a._fntFileName);
        this.setString(a._stringValue)
    }
});
_p = ccui.TextBMFont.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextBMFont.create = function (a, b) {
    return new ccui.TextBMFont(a, b)
};
ccui.TextBMFont.RENDERER_ZORDER = -1;
ccui._TextFieldRenderer = cc.TextFieldTTF.extend({
    _maxLengthEnabled: !1,
    _maxLength: 0,
    _passwordEnabled: !1,
    _passwordStyleText: "",
    _attachWithIME: !1,
    _detachWithIME: !1,
    _insertText: !1,
    _deleteBackward: !1,
    _className: "_TextFieldRenderer",
    ctor: function () {
        cc.TextFieldTTF.prototype.ctor.call(this);
        this._maxLengthEnabled = !1;
        this._maxLength = 0;
        this._passwordEnabled = !1;
        this._passwordStyleText = "*";
        this._deleteBackward = this._insertText = this._detachWithIME = this._attachWithIME = !1
    },
    onEnter: function () {
        cc.TextFieldTTF.prototype.onEnter.call(this);
        cc.TextFieldTTF.prototype.setDelegate.call(this, this)
    },
    onTextFieldAttachWithIME: function (a) {
        this.setAttachWithIME(!0);
        return !1
    },
    onTextFieldInsertText: function (a, b, d) {
        if (1 === d && "\n" === b)return !1;
        this.setInsertText(!0);
        return this._maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= this._maxLength
    },
    onTextFieldDeleteBackward: function (a, b, d) {
        this.setDeleteBackward(!0);
        return !1
    },
    onTextFieldDetachWithIME: function (a) {
        this.setDetachWithIME(!0);
        return !1
    },
    insertText: function (a, b) {
        "\n" !== a &&
        this._maxLengthEnabled && this.getString().length >= this._maxLength ? this._passwordEnabled && this.setPasswordText(this.getString()) : (cc.TextFieldTTF.prototype.insertText.call(this, a, b), this._passwordEnabled && 0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this.setPasswordText(this.getString()))
    },
    deleteBackward: function () {
        cc.TextFieldTTF.prototype.deleteBackward.call(this);
        0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this._passwordEnabled && this.setPasswordText(this._inputText)
    },
    openIME: function () {
        cc.TextFieldTTF.prototype.attachWithIME.call(this)
    },
    closeIME: function () {
        cc.TextFieldTTF.prototype.detachWithIME.call(this)
    },
    setMaxLengthEnabled: function (a) {
        this._maxLengthEnabled = a
    },
    isMaxLengthEnabled: function () {
        return this._maxLengthEnabled
    },
    setMaxLength: function (a) {
        this._maxLength = a
    },
    getMaxLength: function () {
        return this._maxLength
    },
    getCharCount: function () {
        return cc.TextFieldTTF.prototype.getCharCount.call(this)
    },
    setPasswordEnabled: function (a) {
        this._passwordEnabled = a
    },
    isPasswordEnabled: function () {
        return this._passwordEnabled
    },
    setPasswordStyleText: function (a) {
        if (!(1 <
            a.length)) {
            var b = a.charCodeAt(0);
            33 > b || 126 < b || (this._passwordStyleText = a)
        }
    },
    setPasswordText: function (a) {
        var b = "", d = a.length;
        a = d;
        this._maxLengthEnabled && d > this._maxLength && (a = this._maxLength);
        for (d = 0; d < a; ++d)b += this._passwordStyleText;
        cc.LabelTTF.prototype.setString.call(this, b)
    },
    setAttachWithIME: function (a) {
        this._attachWithIME = a
    },
    getAttachWithIME: function () {
        return this._attachWithIME
    },
    setDetachWithIME: function (a) {
        this._detachWithIME = a
    },
    getDetachWithIME: function () {
        return this._detachWithIME
    },
    setInsertText: function (a) {
        this._insertText =
            a
    },
    getInsertText: function () {
        return this._insertText
    },
    setDeleteBackward: function (a) {
        this._deleteBackward = a
    },
    getDeleteBackward: function () {
        return this._deleteBackward
    },
    onDraw: function (a) {
        return !1
    }
});
ccui._TextFieldRenderer.create = function (a, b, d) {
    var e = new ccui._TextFieldRenderer;
    return e && e.initWithString("", b, d) ? (a && e.setPlaceHolder(a), e) : null
};
ccui.TextField = ccui.Widget.extend({
    _textFieldRenderer: null,
    _touchWidth: 0,
    _touchHeight: 0,
    _useTouchArea: !1,
    _textFieldEventListener: null,
    _textFieldEventSelector: null,
    _passwordStyleText: "",
    _textFieldRendererAdaptDirty: !0,
    _fontName: "",
    _fontSize: 12,
    _ccEventCallback: null,
    ctor: function (a, b, d) {
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        b && this.setFontName(b);
        d && this.setFontSize(d);
        a && this.setPlaceHolder(a)
    },
    onEnter: function () {
        ccui.Widget.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    _initRenderer: function () {
        this._textFieldRenderer = ccui._TextFieldRenderer.create("input words here", "Thonburi", 20);
        this.addProtectedChild(this._textFieldRenderer, ccui.TextField.RENDERER_ZORDER, -1)
    },
    setTouchSize: function (a) {
        this._touchWidth = a.width;
        this._touchHeight = a.height
    },
    setTouchAreaEnabled: function (a) {
        this._useTouchArea = a
    },
    hitTest: function (a) {
        if (this._useTouchArea) {
            a = this.convertToNodeSpace(a);
            var b = cc.rect(-this._touchWidth * this._anchorPoint.x, -this._touchHeight * this._anchorPoint.y, this._touchWidth,
                this._touchHeight);
            return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
        }
        return ccui.Widget.prototype.hitTest.call(this, a)
    },
    getTouchSize: function () {
        return cc.size(this._touchWidth, this._touchHeight)
    },
    setText: function (a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function (a) {
        null != a && (a = String(a), this.isMaxLengthEnabled() && (a = a.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRenderer.setPasswordText(a), this._textFieldRenderer.setString(""), this._textFieldRenderer.insertText(a,
            a.length)) : this._textFieldRenderer.setString(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    setPlaceHolder: function (a) {
        this._textFieldRenderer.setPlaceHolder(a);
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getPlaceHolder: function () {
        return this._textFieldRenderer.getPlaceHolder()
    },
    getPlaceHolderColor: function () {
        return this._textFieldRenderer.getPlaceHolderColor()
    },
    setPlaceHolderColor: function (a) {
        this._textFieldRenderer.setColorSpaceHolder(a)
    },
    setTextColor: function (a) {
        this._textFieldRenderer.setTextColor(a)
    },
    setFontSize: function (a) {
        this._textFieldRenderer.setFontSize(a);
        this._fontSize = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontSize: function () {
        return this._fontSize
    },
    setFontName: function (a) {
        this._textFieldRenderer.setFontName(a);
        this._fontName = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontName: function () {
        return this._fontName
    },
    didNotSelectSelf: function () {
        this._textFieldRenderer.detachWithIME()
    },
    getStringValue: function () {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function () {
        return this._textFieldRenderer.getString()
    },
    getStringLength: function () {
        return this._textFieldRenderer.getStringLength()
    },
    onTouchBegan: function (a, b) {
        var d = this, e = ccui.Widget.prototype.onTouchBegan.call(d,
            a, b);
        d._hit ? setTimeout(function () {
            d._textFieldRenderer.attachWithIME()
        }, 0) : setTimeout(function () {
            d._textFieldRenderer.detachWithIME()
        }, 0);
        return e
    },
    setMaxLengthEnabled: function (a) {
        this._textFieldRenderer.setMaxLengthEnabled(a)
    },
    isMaxLengthEnabled: function () {
        return this._textFieldRenderer.isMaxLengthEnabled()
    },
    setMaxLength: function (a) {
        this._textFieldRenderer.setMaxLength(a);
        this.setString(this.getString())
    },
    getMaxLength: function () {
        return this._textFieldRenderer.getMaxLength()
    },
    setPasswordEnabled: function (a) {
        this._textFieldRenderer.setPasswordEnabled(a)
    },
    isPasswordEnabled: function () {
        return this._textFieldRenderer.isPasswordEnabled()
    },
    setPasswordStyleText: function (a) {
        this._textFieldRenderer.setPasswordStyleText(a);
        this._passwordStyleText = a;
        this.setString(this.getString())
    },
    getPasswordStyleText: function () {
        return this._passwordStyleText
    },
    update: function (a) {
        this.getDetachWithIME() && (this._detachWithIMEEvent(), this.setDetachWithIME(!1));
        this.getAttachWithIME() && (this._attachWithIMEEvent(), this.setAttachWithIME(!1));
        this.getInsertText() && (this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()), this._insertTextEvent(), this.setInsertText(!1));
        this.getDeleteBackward() && (this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()), this._deleteBackwardEvent(), this.setDeleteBackward(!1))
    },
    getAttachWithIME: function () {
        return this._textFieldRenderer.getAttachWithIME()
    },
    setAttachWithIME: function (a) {
        this._textFieldRenderer.setAttachWithIME(a)
    },
    getDetachWithIME: function () {
        return this._textFieldRenderer.getDetachWithIME()
    },
    setDetachWithIME: function (a) {
        this._textFieldRenderer.setDetachWithIME(a)
    },
    getInsertText: function () {
        return this._textFieldRenderer.getInsertText()
    },
    setInsertText: function (a) {
        this._textFieldRenderer.setInsertText(a)
    },
    getDeleteBackward: function () {
        return this._textFieldRenderer.getDeleteBackward()
    },
    setDeleteBackward: function (a) {
        this._textFieldRenderer.setDeleteBackward(a)
    },
    _attachWithIMEEvent: function () {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener,
            this, ccui.TextField.EVENT_ATTACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_ATTACH_WITH_IME));
        this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_ATTACH_WITH_IME)
    },
    _detachWithIMEEvent: function () {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DETACH_WITH_IME));
        this._ccEventCallback && this._ccEventCallback(this,
            ccui.TextField.EVENT_DETACH_WITH_IME)
    },
    _insertTextEvent: function () {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT) : this._textFieldEventSelector(this, ccui.TextField.EVENT_INSERT_TEXT));
        this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_INSERT_TEXT)
    },
    _deleteBackwardEvent: function () {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener,
            this, ccui.TextField.EVENT_DELETE_BACKWARD) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DELETE_BACKWARD));
        this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_DELETE_BACKWARD)
    },
    addEventListenerTextField: function (a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function (a, b) {
        this._textFieldEventSelector = a;
        this._textFieldEventListener = b
    },
    _onSizeChanged: function () {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._textFieldRendererAdaptDirty = !0
    },
    _adaptRenderers: function () {
        this._textFieldRendererAdaptDirty &&
        (this._textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1)
    },
    _textfieldRendererScaleChangedWithSize: function () {
        this._ignoreSize || this._textFieldRenderer.setDimensions(this._contentSize);
        this._textFieldRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getAutoRenderSize: function () {
        var a = this._textFieldRenderer.getContentSize();
        this._ignoreSize || (this._textFieldRenderer.setDimensions(0, 0), a = this._textFieldRenderer.getContentSize(), this._textFieldRenderer.setDimensions(this._contentSize.width,
            this._contentSize.height));
        return a
    },
    getVirtualRendererSize: function () {
        return this._textFieldRenderer.getContentSize()
    },
    getVirtualRenderer: function () {
        return this._textFieldRenderer
    },
    getDescription: function () {
        return "TextField"
    },
    attachWithIME: function () {
        this._textFieldRenderer.attachWithIME()
    },
    _createCloneInstance: function () {
        return new ccui.TextField
    },
    _copySpecialProperties: function (a) {
        this.setString(a._textFieldRenderer.getString());
        this.setPlaceHolder(a.getString());
        this.setFontSize(a._textFieldRenderer.getFontSize());
        this.setFontName(a._textFieldRenderer.getFontName());
        this.setMaxLengthEnabled(a.isMaxLengthEnabled());
        this.setMaxLength(a.getMaxLength());
        this.setPasswordEnabled(a.isPasswordEnabled());
        this.setPasswordStyleText(a._passwordStyleText);
        this.setAttachWithIME(a.getAttachWithIME());
        this.setDetachWithIME(a.getDetachWithIME());
        this.setInsertText(a.getInsertText());
        this.setDeleteBackward(a.getDeleteBackward());
        this._ccEventCallback = a._ccEventCallback;
        this._textFieldEventListener = a._textFieldEventListener;
        this._textFieldEventSelector = a._textFieldEventSelector
    },
    setTextAreaSize: function (a) {
        this.setContentSize(a)
    },
    setTextHorizontalAlignment: function (a) {
        this._textFieldRenderer.setHorizontalAlignment(a)
    },
    setTextVerticalAlignment: function (a) {
        this._textFieldRenderer.setVerticalAlignment(a)
    },
    _setFont: function (a) {
        this._textFieldRenderer._setFont(a);
        this._textFieldRendererAdaptDirty = !0
    },
    _getFont: function () {
        return this._textFieldRenderer._getFont()
    },
    _changePosition: function () {
        this._adaptRenderers()
    }
});
ccui.TextField.create = function (a, b, d) {
    return new ccui.TextField(a, b, d)
};
_p = ccui.TextField.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled);
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled);
_p = null;
ccui.TextField.EVENT_ATTACH_WITH_IME = 0;
ccui.TextField.EVENT_DETACH_WITH_IME = 1;
ccui.TextField.EVENT_INSERT_TEXT = 2;
ccui.TextField.EVENT_DELETE_BACKWARD = 3;
ccui.TextField.RENDERER_ZORDER = -1;
ccui.VideoPlayer = ccui.Widget.extend({
    _played: !1, _playing: !1, _stopped: !0, ctor: function (a) {
        ccui.Widget.prototype.ctor.call(this);
        this._EventList = {};
        a && this.setURL(a)
    }, _createRenderCmd: function () {
        return new ccui.VideoPlayer.RenderCmd(this)
    }, setURL: function (a) {
        this._renderCmd.updateURL(a)
    }, getURL: function () {
        return this._renderCmd._url
    }, play: function () {
        var a = this, b = this._renderCmd._video;
        if (b) {
            this._played = !0;
            b.pause();
            if (!1 !== this._stopped || !1 !== this._playing || !0 !== this._played)b.currentTime = 0;
            ccui.VideoPlayer._polyfill.autoplayAfterOperation ?
                setTimeout(function () {
                    b.play();
                    a._playing = !0;
                    a._stopped = !1
                }, 20) : (b.play(), this._playing = !0, this._stopped = !1)
        }
    }, pause: function () {
        var a = this._renderCmd._video;
        a && !0 === this._playing && !1 === this._stopped && (a.pause(), this._playing = !1)
    }, resume: function () {
        !1 === this._stopped && !1 === this._playing && !0 === this._played && this.play()
    }, stop: function () {
        var a = this, b = this._renderCmd._video;
        b && (b.pause(), b.currentTime = 0, this._playing = !1, this._stopped = !0);
        setTimeout(function () {
                a._dispatchEvent(ccui.VideoPlayer.EventType.STOPPED)
            },
            0)
    }, seekTo: function (a) {
        var b = this._renderCmd._video;
        b && (b.currentTime = a, ccui.VideoPlayer._polyfill.autoplayAfterOperation && this.isPlaying() && setTimeout(function () {
            b.play()
        }, 20))
    }, isPlaying: function () {
        ccui.VideoPlayer._polyfill.autoplayAfterOperation && this._playing && setTimeout(function () {
            video.play()
        }, 20);
        return this._playing
    }, setKeepAspectRatioEnabled: function (a) {
        cc.log("On the web is always keep the aspect ratio")
    }, isKeepAspectRatioEnabled: function () {
        return !1
    }, setFullScreenEnabled: function (a) {
        var b =
            this._renderCmd._video;
        b && (a ? cc.screen.requestFullScreen(b) : cc.screen.exitFullScreen(b))
    }, isFullScreenEnabled: function () {
        cc.log("Can't know status")
    }, setEventListener: function (a, b) {
        this._EventList[a] = b
    }, removeEventListener: function (a) {
        this._EventList[a] = null
    }, _dispatchEvent: function (a) {
        (a = this._EventList[a]) && a.call(this, this, this._renderCmd._video.src)
    }, onPlayEvent: function () {
        var a = this._EventList[ccui.VideoPlayer.EventType.PLAYING];
        if (a)for (var b = 0; b < a.length; b++)a[b].call(this, this, this._renderCmd._video.src)
    },
    setContentSize: function (a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b);
        void 0 === b && (b = a.height, a = a.width);
        this._renderCmd.changeSize(a, b)
    }, cleanup: function () {
        this._renderCmd.removeDom();
        this.stopAllActions();
        this.unscheduleAllCallbacks()
    }, onEnter: function () {
        ccui.Widget.prototype.onEnter.call(this);
        var a = ccui.VideoPlayer.elements;
        -1 === a.indexOf(this) && a.push(this)
    }, onExit: function () {
        ccui.Widget.prototype.onExit.call(this);
        var a = ccui.VideoPlayer.elements, b = a.indexOf(this);
        -1 !== b && a.splice(b,
            1)
    }
});
ccui.VideoPlayer.elements = [];
ccui.VideoPlayer.pauseElements = [];
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function () {
    for (var a = ccui.VideoPlayer.elements, b, d = 0; d < a.length; d++)b = a[d], a[d]._playing && (b.pause(), ccui.VideoPlayer.pauseElements.push(b))
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function () {
    for (var a = ccui.VideoPlayer.pauseElements, b = a.pop(); b;)b.play(), b = a.pop()
});
ccui.VideoPlayer.EventType = {PLAYING: "play", PAUSED: "pause", STOPPED: "stop", COMPLETED: "complete"};
(function (a) {
    a._polyfill = {devicePixelRatio: !1, event: "canplay", canPlayType: []};
    var b = document.createElement("video");
    b.canPlayType("video/ogg") && (a._polyfill.canPlayType.push(".ogg"), a._polyfill.canPlayType.push(".ogv"));
    b.canPlayType("video/mp4") && a._polyfill.canPlayType.push(".mp4");
    b.canPlayType("video/webm") && a._polyfill.canPlayType.push(".webm");
    cc.sys.OS_IOS === cc.sys.os && (a._polyfill.devicePixelRatio = !0, a._polyfill.event = "progress");
    cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (a._polyfill.autoplayAfterOperation = !0);
    a = document.createElement("style");
    a.innerHTML = ".cocosVideo:-moz-full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:-webkit-full-screen{transform:matrix(1,0,0,1,0,0) !important;}";
    document.head.appendChild(a)
})(ccui.VideoPlayer);
(function (a) {
    ccui.VideoPlayer.RenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._listener = null;
        this._url = "";
        this.initStyle()
    };
    var b = ccui.VideoPlayer.RenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    b.constructor = ccui.VideoPlayer.RenderCmd;
    b.visit = function () {
        var a = this, b = cc.container, f = cc.eventManager;
        if (this._node._visible)b.appendChild(this._video), null === this._listener && (this._listener = cc.eventManager.addCustomListener(cc.game.EVENT_RESIZE, function () {
            a.resize()
        }));
        else {
            var g = !1;
            (g = "contains" in b ? b.contains(this._video) : b.compareDocumentPosition(this._video) % 16) && b.removeChild(this._video);
            f.removeListener(this._listener);
            this._listener = null
        }
        this.updateStatus()
    };
    b.updateStatus = function () {
        a.devicePixelRatio = cc.view.isRetinaEnabled();
        var b = cc.Node._dirtyFlags, e = this._dirtyFlag;
        e & b.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty);
        e & b.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & b.orderDirty)
    };
    b.resize = function (a) {
        a = a || cc.view;
        var b = this._node, f = cc.eventManager;
        b._parent && b._visible ? this.updateMatrix(this._worldTransform, a._scaleX, a._scaleY) : (f.removeListener(this._listener), this._listener = null)
    };
    b.updateMatrix = function (b, e, f) {
        var g = this._node;
        if (a.devicePixelRatio) {
            var h = window.devicePixelRatio;
            e /= h;
            f /= h
        }
        if (!1 !== this._loaded) {
            var h = g._contentSize.width, n = g._contentSize.height;
            b = "matrix(" + b.a * e + "," + b.b + "," + b.c + "," + b.d * f + "," +
                (b.tx * e - h / 2 + h * g._scaleX / 2 * e) + "," + -(b.ty * f - n / 2 + n * g._scaleY / 2 * f) + ")";
            this._video.style.transform = b;
            this._video.style["-webkit-transform"] = b
        }
    };
    b.updateURL = function (b) {
        var e, f, g, h = this._node;
        if (this._url != b) {
            this._url = b;
            cc.loader.resPath && !/^http/.test(b) && (b = cc.path.join(cc.loader.resPath, b));
            e = !1;
            g = cc.container;
            (e = "contains" in g ? g.contains(this._video) : g.compareDocumentPosition(this._video) % 16) && g.removeChild(this._video);
            f = this._video = document.createElement("video");
            this.bindEvent();
            var n = this, p = function () {
                !0 !=
                n._loaded && (n._loaded = !0, n.changeSize(), n.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), f.removeEventListener(a.event, p), f.currentTime = 0, f.style.visibility = "visible", f.play(), h._played || (f.pause(), f.currentTime = 0))
            };
            f.addEventListener(a.event, p);
            f.preload = "metadata";
            f.style.visibility = "hidden";
            this._loaded = !1;
            h._played = !1;
            h._playing = !1;
            h._stopped = !0;
            this.initStyle();
            this.visit();
            e = document.createElement("source");
            e.src = b;
            f.appendChild(e);
            g = cc.path.extname(b);
            for (var r = 0; r < a.canPlayType.length; r++)g !==
            a.canPlayType[r] && (e = document.createElement("source"), e.src = b.replace(g, a.canPlayType[r]), f.appendChild(e))
        }
    };
    b.bindEvent = function () {
        var a = this, b = this._node, f = this._video;
        f.addEventListener("ended", function () {
            b._renderCmd.updateMatrix(a._worldTransform, cc.view._scaleX, cc.view._scaleY);
            b._playing = !1;
            b._dispatchEvent(ccui.VideoPlayer.EventType.COMPLETED)
        });
        f.addEventListener("play", function () {
            b._dispatchEvent(ccui.VideoPlayer.EventType.PLAYING)
        });
        f.addEventListener("pause", function () {
            b._dispatchEvent(ccui.VideoPlayer.EventType.PAUSED)
        })
    };
    b.initStyle = function () {
        if (this._video) {
            var a = this._video;
            a.style.position = "absolute";
            a.style.bottom = "0px";
            a.style.left = "0px";
            a.className = "cocosVideo"
        }
    };
    b.changeSize = function (a, b) {
        var f = this._node._contentSize;
        a = a || f.width;
        b = b || f.height;
        if (f = this._video)0 !== a && (f.width = a), 0 !== b && (f.height = b)
    };
    b.removeDom = function () {
        var a = this._video;
        if (a) {
            var b = !1;
            (b = "contains" in cc.container ? cc.container.contains(a) : cc.container.compareDocumentPosition(a) % 16) && cc.container.removeChild(a)
        }
    }
})(ccui.VideoPlayer._polyfill);
ccui.RichElement = ccui.Class.extend({
    _type: 0, _tag: 0, _color: null, _opacity: 0, ctor: function (a, b, d) {
        this._type = 0;
        this._tag = a || 0;
        this._color = cc.color(255, 255, 255, 255);
        b && (this._color.r = b.r, this._color.g = b.g, this._color.b = b.b);
        this._opacity = d || 0;
        this._color.a = void 0 === d ? b.a : d
    }
});
ccui.RichElementText = ccui.RichElement.extend({
    _text: "",
    _fontName: "",
    _fontSize: 0,
    _fontDefinition: null,
    ctor: function (a, b, d, e, f, g) {
        var h = b;
        b && b instanceof cc.FontDefinition && (h = b.fillStyle, f = fontDef.fontName, g = fontDef.fontSize, this._fontDefinition = fontDef);
        ccui.RichElement.prototype.ctor.call(this, a, h, d);
        this._type = ccui.RichElement.TEXT;
        this._text = e;
        this._fontName = f;
        this._fontSize = g
    }
});
ccui.RichElementText.create = function (a, b, d, e, f, g) {
    return new ccui.RichElementText(a, b, d, e, f, g)
};
ccui.RichElementImage = ccui.RichElement.extend({
    _filePath: "",
    _textureRect: null,
    _textureType: 0,
    ctor: function (a, b, d, e) {
        ccui.RichElement.prototype.ctor.call(this, a, b, d);
        this._type = ccui.RichElement.IMAGE;
        this._filePath = e || "";
        this._textureRect = cc.rect(0, 0, 0, 0);
        this._textureType = 0
    }
});
ccui.RichElementImage.create = function (a, b, d, e) {
    return new ccui.RichElementImage(a, b, d, e)
};
ccui.RichElementCustomNode = ccui.RichElement.extend({
    _customNode: null, ctor: function (a, b, d, e) {
        ccui.RichElement.prototype.ctor.call(this, a, b, d);
        this._type = ccui.RichElement.CUSTOM;
        this._customNode = e || null
    }
});
ccui.RichElementCustomNode.create = function (a, b, d, e) {
    return new ccui.RichElementCustomNode(a, b, d, e)
};
ccui.RichText = ccui.Widget.extend({
    _formatTextDirty: !1,
    _richElements: null,
    _elementRenders: null,
    _leftSpaceWidth: 0,
    _verticalSpace: 0,
    _elementRenderersContainer: null,
    _lineBreakOnSpace: !1,
    _textHorizontalAlignment: null,
    _textVerticalAlignment: null,
    ctor: function () {
        ccui.Widget.prototype.ctor.call(this);
        this._formatTextDirty = !1;
        this._richElements = [];
        this._elementRenders = [];
        this._verticalSpace = this._leftSpaceWidth = 0;
        this._textHorizontalAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._textVerticalAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP
    },
    _initRenderer: function () {
        this._elementRenderersContainer = new cc.Node;
        this._elementRenderersContainer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._elementRenderersContainer, 0, -1)
    },
    insertElement: function (a, b) {
        this._richElements.splice(b, 0, a);
        this._formatTextDirty = !0
    },
    pushBackElement: function (a) {
        this._richElements.push(a);
        this._formatTextDirty = !0
    },
    removeElement: function (a) {
        cc.isNumber(a) ? this._richElements.splice(a, 1) : cc.arrayRemoveObject(this._richElements, a);
        this._formatTextDirty = !0
    },
    formatText: function () {
        if (this._formatTextDirty) {
            this._elementRenderersContainer.removeAllChildren();
            this._elementRenders.length = 0;
            var a, b, d = this._richElements;
            if (this._ignoreSize)for (this._addNewLine(), a = 0; a < d.length; a++) {
                b = d[a];
                var e = null;
                switch (b._type) {
                    case ccui.RichElement.TEXT:
                        e = b._fontDefinition ? new cc.LabelTTF(b._text, b._fontDefinition) : new cc.LabelTTF(b._text, b._fontName, b._fontSize);
                        break;
                    case ccui.RichElement.IMAGE:
                        e = new cc.Sprite(b._filePath);
                        break;
                    case ccui.RichElement.CUSTOM:
                        e = b._customNode
                }
                e.setColor(b._color);
                e.setOpacity(b._color.a);
                this._pushToContainer(e)
            } else for (this._addNewLine(),
                            a = 0; a < d.length; a++)switch (b = d[a], b._type) {
                case ccui.RichElement.TEXT:
                    b._fontDefinition ? this._handleTextRenderer(b._text, b._fontDefinition, b._fontDefinition.fontSize, b._fontDefinition.fillStyle) : this._handleTextRenderer(b._text, b._fontName, b._fontSize, b._color);
                    break;
                case ccui.RichElement.IMAGE:
                    this._handleImageRenderer(b._filePath, b._color, b._color.a);
                    break;
                case ccui.RichElement.CUSTOM:
                    this._handleCustomRenderer(b._customNode)
            }
            this.formatRenderers();
            this._formatTextDirty = !1
        }
    },
    _handleTextRenderer: function (a,
                                   b, d, e) {
        if ("" !== a)if ("\n" === a)this._addNewLine(); else {
            var f = b instanceof cc.FontDefinition ? new cc.LabelTTF(a, b) : new cc.LabelTTF(a, b, d), g = f.getContentSize().width;
            this._leftSpaceWidth -= g;
            if (0 > this._leftSpaceWidth) {
                var f = a.length * (1 - -this._leftSpaceWidth / g), g = a.substr(0, f), h = a.substr(f, a.length - 1), n = 0 < f;
                this._lineBreakOnSpace && (h = g.lastIndexOf(" "), f = -1 === h ? f : h + 1, h = a.substr(f, a.length - 1), n = 0 < f && " " !== h);
                n && (a = null, b instanceof cc.FontDefinition ? (a = new cc.LabelTTF(g.substr(0, f), b), a.setOpacity(b.fillStyle.a)) :
                    (a = new cc.LabelTTF(g.substr(0, f), b, d), a.setColor(e), a.setOpacity(e.a)), this._pushToContainer(a));
                this._addNewLine();
                this._handleTextRenderer(h, b, d, e)
            } else b instanceof cc.FontDefinition ? f.setOpacity(b.fillStyle.a) : (f.setColor(e), f.setOpacity(e.a)), this._pushToContainer(f)
        }
    },
    _handleImageRenderer: function (a, b, d) {
        a = new cc.Sprite(a);
        this._handleCustomRenderer(a)
    },
    _handleCustomRenderer: function (a) {
        var b = a.getContentSize();
        this._leftSpaceWidth -= b.width;
        0 > this._leftSpaceWidth ? (this._addNewLine(), this._pushToContainer(a),
            this._leftSpaceWidth -= b.width) : this._pushToContainer(a)
    },
    _addNewLine: function () {
        this._leftSpaceWidth = this._customSize.width;
        this._elementRenders.push([])
    },
    formatRenderers: function () {
        var a = 0, b = this._elementRenderersContainer, d = this._elementRenders, e, f, g, h, n, p;
        if (this._ignoreSize) {
            e = 0;
            g = d[0];
            for (f = h = 0; f < g.length; f++)n = g[f], n.setAnchorPoint(cc.p(0, 0)), n.setPosition(h, 0), b.addChild(n, 1, f), p = n.getLineHeight ? n.getLineHeight() : a, n = n.getContentSize(), e += n.width, a = Math.max(Math.min(a, p), n.height), h += n.width;
            if (this._textHorizontalAlignment !== cc.TEXT_ALIGNMENT_LEFT)for (p = 0, this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_RIGHT ? p = this._contentSize.width - h : this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_CENTER && (p = (this._contentSize.width - h) / 2), f = 0; f < g.length; f++)g[f].x += p;
            b.setContentSize(e, a)
        } else {
            var r = [];
            for (e = 0; e < d.length; e++) {
                g = d[e];
                for (f = h = 0; f < g.length; f++)n = g[f], p = n.getLineHeight ? n.getLineHeight() : n.getContentSize().height, h = Math.max(Math.min(n.getContentSize().height, p), h);
                r[e] = h;
                a += r[e]
            }
            var s =
                this._customSize.height;
            for (e = 0; e < d.length; e++) {
                g = d[e];
                h = 0;
                s -= r[e] + this._verticalSpace;
                for (f = 0; f < g.length; f++)n = g[f], n.setAnchorPoint(cc.p(0, 0)), n.setPosition(cc.p(h, s)), b.addChild(n, 1), h += n.getContentSize().width;
                if (this._textHorizontalAlignment !== cc.TEXT_ALIGNMENT_LEFT || this._textVerticalAlignment !== cc.VERTICAL_TEXT_ALIGNMENT_TOP)for (p = 0, this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_RIGHT ? p = this._contentSize.width - h : this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_CENTER && (p = (this._contentSize.width -
                    h) / 2), h = 0, this._textVerticalAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? h = this._customSize.height - a : this._textVerticalAlignment === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (h = (this._customSize.height - a) / 2), f = 0; f < g.length; f++)n = g[f], n.x += p, n.y -= h
            }
            b.setContentSize(this._contentSize)
        }
        a = d.length;
        for (e = 0; e < a; e++)d[e].length = 0;
        this._elementRenders.length = 0;
        this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize);
        this._updateContentSizeWithTextureSize(this._contentSize);
        b.setPosition(0.5 *
            this._contentSize.width, 0.5 * this._contentSize.height)
    },
    _pushToContainer: function (a) {
        0 >= this._elementRenders.length || this._elementRenders[this._elementRenders.length - 1].push(a)
    },
    _adaptRenderers: function () {
        this.formatText()
    },
    setVerticalSpace: function (a) {
        this._verticalSpace = a
    },
    setAnchorPoint: function (a) {
        ccui.Widget.prototype.setAnchorPoint.call(this, a);
        this._elementRenderersContainer.setAnchorPoint(a)
    },
    _setAnchorX: function (a) {
        ccui.Widget.prototype._setAnchorX.call(this, a);
        this._elementRenderersContainer._setAnchorX(a)
    },
    _setAnchorY: function (a) {
        ccui.Widget.prototype._setAnchorY.call(this, a);
        this._elementRenderersContainer._setAnchorY(a)
    },
    getVirtualRendererSize: function () {
        return this._elementRenderersContainer.getContentSize()
    },
    ignoreContentAdaptWithSize: function (a) {
        this._ignoreSize !== a && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a))
    },
    getContentSize: function () {
        this.formatText();
        return cc.Node.prototype.getContentSize.call(this)
    },
    _getWidth: function () {
        this.formatText();
        return cc.Node.prototype._getWidth.call(this)
    },
    _getHeight: function () {
        this.formatText();
        return cc.Node.prototype._getHeight.call(this)
    },
    setContentSize: function (a, b) {
        ccui.Widget.prototype.setContentSize.call(this, void 0 === b ? a.width : a, void 0 === b ? a.height : b);
        this._formatTextDirty = !0
    },
    getDescription: function () {
        return "RichText"
    },
    setCascadeOpacityEnabled: function (a) {
        this._super(a);
        this._elementRenderersContainer.setCascadeOpacityEnabled(a)
    },
    setLineBreakOnSpace: function (a) {
        this._lineBreakOnSpace = a;
        this._formatTextDirty = !0;
        this.formatText()
    },
    setTextHorizontalAlignment: function (a) {
        a !==
        this._textHorizontalAlignment && (this._textHorizontalAlignment = a, this.formatText())
    },
    setTextVerticalAlignment: function (a) {
        a !== this._textVerticalAlignment && (this._textVerticalAlignment = a, this.formatText())
    }
});
ccui.RichText.create = function () {
    return new ccui.RichText
};
ccui.RichElement.TEXT = 0;
ccui.RichElement.IMAGE = 1;
ccui.RichElement.CUSTOM = 2;
ccui.WebView = ccui.Widget.extend({
    ctor: function (a) {
        ccui.Widget.prototype.ctor.call(this);
        this._EventList = {};
        a && this.loadURL(a)
    }, setJavascriptInterfaceScheme: function (a) {
    }, loadData: function (a, b, d, e) {
    }, loadHTMLString: function (a, b) {
    }, loadURL: function (a) {
        this._renderCmd.updateURL(a);
        this._dispatchEvent(ccui.WebView.EventType.LOADING)
    }, stopLoading: function () {
        cc.log("Web does not support loading")
    }, reload: function () {
        var a = this._renderCmd._iframe;
        a && (a = a.contentWindow) && a.location && a.location.reload()
    }, canGoBack: function () {
        cc.log("Web does not support query history");
        return !0
    }, canGoForward: function () {
        cc.log("Web does not support query history");
        return !0
    }, goBack: function () {
        try {
            if (ccui.WebView._polyfill.closeHistory)return cc.log("The current browser does not support the GoBack");
            var a = this._renderCmd._iframe;
            if (a) {
                var b = a.contentWindow;
                if (b && b.location)try {
                    b.history.back.call(b)
                } catch (d) {
                    b.history.back()
                }
            }
        } catch (e) {
            cc.log(e)
        }
    }, goForward: function () {
        try {
            if (ccui.WebView._polyfill.closeHistory)return cc.log("The current browser does not support the GoForward");
            var a =
                this._renderCmd._iframe;
            if (a) {
                var b = a.contentWindow;
                if (b && b.location)try {
                    b.history.forward.call(b)
                } catch (d) {
                    b.history.forward()
                }
            }
        } catch (e) {
            cc.log(e)
        }
    }, evaluateJS: function (a) {
        var b = this._renderCmd._iframe;
        if (b) {
            b = b.contentWindow;
            try {
                b.eval(a), this._dispatchEvent(ccui.WebView.EventType.JS_EVALUATED)
            } catch (d) {
                console.error(d)
            }
        }
    }, setScalesPageToFit: function () {
        cc.log("Web does not support zoom")
    }, setEventListener: function (a, b) {
        this._EventList[a] = b
    }, removeEventListener: function (a) {
        this._EventList[a] = null
    },
    _dispatchEvent: function (a) {
        (a = this._EventList[a]) && a.call(this, this, this._renderCmd._iframe.src)
    }, _createRenderCmd: function () {
        return new ccui.WebView.RenderCmd(this)
    }, setContentSize: function (a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b);
        void 0 === b && (b = a.height, a = a.width);
        this._renderCmd.changeSize(a, b)
    }, cleanup: function () {
        this._renderCmd.removeDom();
        this.stopAllActions();
        this.unscheduleAllCallbacks()
    }
});
ccui.WebView.EventType = {LOADING: "loading", LOADED: "load", ERROR: "error", JS_EVALUATED: "js"};
(function () {
    var a = ccui.WebView._polyfill = {devicePixelRatio: !1, enableDiv: !1};
    cc.sys.os === cc.sys.OS_IOS && (a.enableDiv = !0);
    cc.sys.isMobile ? cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (a.enableBG = !0) : cc.sys.browserType === cc.sys.BROWSER_TYPE_IE && (a.closeHistory = !0)
})();
(function (a) {
    ccui.WebView.RenderCmd = function (b) {
        cc.Node.CanvasRenderCmd.call(this, b);
        this._iframe = this._div = null;
        a.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), this._iframe.style.width = "100%", this._iframe.style.height = "100%", this._div.appendChild(this._iframe)) : this._div = this._iframe = document.createElement("iframe");
        a.enableBG && (this._div.style.background =
            "#FFF");
        this._iframe.addEventListener("load", function () {
            b._dispatchEvent(ccui.WebView.EventType.LOADED)
        });
        this._iframe.addEventListener("error", function () {
            b._dispatchEvent(ccui.WebView.EventType.ERROR)
        });
        this._div.style.background = "#FFF";
        this._div.style.height = "200px";
        this._div.style.width = "300px";
        this._div.style.overflow = "scroll";
        this._listener = null;
        this.initStyle()
    };
    var b = ccui.WebView.RenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    b.constructor = ccui.WebView.RenderCmd;
    b.updateStatus =
        function () {
            a.devicePixelRatio = cc.view.isRetinaEnabled();
            var b = cc.Node._dirtyFlags, e = this._dirtyFlag;
            e & b.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty);
            e & b.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & b.orderDirty)
        };
    b.visit = function () {
        var a = this, b = cc.container, f = cc.eventManager;
        if (this._node._visible)b.appendChild(this._div), null === this._listener &&
        (this._listener = f.addCustomListener(cc.game.EVENT_RESIZE, function () {
            a.resize()
        })); else {
            var g = !1;
            (g = "contains" in b ? b.contains(this._div) : b.compareDocumentPosition(this._div) % 16) && b.removeChild(this._div);
            b = f._listenersMap[cc.game.EVENT_RESIZE].getFixedPriorityListeners();
            f._removeListenerInVector(b, this._listener);
            this._listener = null
        }
        this.updateStatus();
        this.resize(cc.view)
    };
    b.resize = function (a) {
        a = a || cc.view;
        var b = this._node, f = cc.eventManager;
        b._parent && b._visible ? this.updateMatrix(this._worldTransform,
            a._scaleX, a._scaleY) : (a = f._listenersMap[cc.game.EVENT_RESIZE].getFixedPriorityListeners(), f._removeListenerInVector(a, this._listener), this._listener = null)
    };
    b.updateMatrix = function (b, e, f) {
        var g = this._node;
        if (a.devicePixelRatio && 1 !== e && 1 !== e) {
            var h = window.devicePixelRatio;
            e /= h;
            f /= h
        }
        if (!1 !== this._loaded) {
            var h = g._contentSize.width, n = g._contentSize.height;
            b = "matrix(" + b.a * e + "," + b.b + "," + b.c + "," + b.d * f + "," + (b.tx * e - h / 2 + h * g._scaleX / 2 * e) + "," + -(b.ty * f - n / 2 + n * g._scaleY / 2 * f) + ")";
            this._div.style.transform = b;
            this._div.style["-webkit-transform"] =
                b
        }
    };
    b.initStyle = function () {
        if (this._div) {
            var a = this._div;
            a.style.position = "absolute";
            a.style.bottom = "0px";
            a.style.left = "0px"
        }
    };
    b.updateURL = function (a) {
        var b = this._iframe;
        b.src = a;
        var f = this, g = function () {
            f._loaded = !0;
            b.removeEventListener("load", g)
        };
        b.addEventListener("load", g)
    };
    b.changeSize = function (a, b) {
        var f = this._div;
        f && (f.style.width = a + "px", f.style.height = b + "px")
    };
    b.removeDom = function () {
        var a = this._div;
        if (a) {
            var b = !1;
            (b = "contains" in cc.container ? cc.container.contains(a) : cc.container.compareDocumentPosition(a) %
            16) && cc.container.removeChild(a)
        }
    }
})(ccui.WebView._polyfill);
ccui.ScrollViewBar = ccui.ProtectedNode.extend({
    _parentScroll: null,
    _direction: null,
    _upperHalfCircle: null,
    _lowerHalfCircle: null,
    _body: null,
    _opacity: 255,
    _marginFromBoundary: 0,
    _marginForLength: 0,
    _touching: !1,
    _autoHideEnabled: !0,
    autoHideTime: 0,
    _autoHideRemainingTime: 0,
    _className: "ScrollViewBar",
    ctor: function (a, b) {
        cc.ProtectedNode.prototype.ctor.call(this);
        this._direction = b;
        this._parentScroll = a;
        this._marginForLength = this._marginFromBoundary = ccui.ScrollViewBar.DEFAULT_MARGIN;
        this.opacity = 255 * ccui.ScrollViewBar.DEFAULT_SCROLLBAR_OPACITY;
        this.autoHideTime = ccui.ScrollViewBar.DEFAULT_AUTO_HIDE_TIME;
        this._autoHideEnabled = !0;
        ccui.ScrollViewBar.prototype.init.call(this);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0)
    },
    init: function () {
        var a = new Image;
        a.src = ccui.ScrollViewBar.HALF_CIRCLE_IMAGE;
        this._upperHalfCircle = new cc.Sprite(a);
        this._upperHalfCircle.setAnchorPoint(cc.p(0.5, 0));
        this._lowerHalfCircle = new cc.Sprite(a);
        this._lowerHalfCircle.setAnchorPoint(cc.p(0.5, 0));
        this._lowerHalfCircle.setScaleY(-1);
        this.addProtectedChild(this._upperHalfCircle);
        this.addProtectedChild(this._lowerHalfCircle);
        a = new Image;
        a.src = ccui.ScrollViewBar.BODY_IMAGE_1_PIXEL_HEIGHT;
        this._body = new cc.Sprite(a);
        this._body.setAnchorPoint(cc.p(0.5, 0));
        this.addProtectedChild(this._body);
        this.setColor(ccui.ScrollViewBar.DEFAULT_COLOR);
        this.onScrolled(cc.p(0, 0));
        cc.ProtectedNode.prototype.setOpacity.call(this, 0);
        this._autoHideRemainingTime = 0;
        this._direction === ccui.ScrollView.DIR_HORIZONTAL && this.setRotation(90)
    },
    setPositionFromCorner: function (a) {
        this._direction === ccui.ScrollView.DIR_VERTICAL ?
            (this._marginForLength = a.y, this._marginFromBoundary = a.x) : (this._marginForLength = a.x, this._marginFromBoundary = a.y)
    },
    onEnter: function () {
        cc.ProtectedNode.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    getPositionFromCorner: function () {
        return this._direction === ccui.ScrollView.DIR_VERTICAL ? cc.p(this._marginFromBoundary, this._marginForLength) : cc.p(this._marginForLength, this._marginFromBoundary)
    },
    setWidth: function (a) {
        a /= this._body.width;
        this._body.setScaleX(a);
        this._upperHalfCircle.setScale(a);
        this._lowerHalfCircle.setScale(-a)
    },
    getWidth: function () {
        return this._body.getBoundingBox().width
    },
    setAutoHideEnabled: function (a) {
        this._autoHideEnabled = a;
        !this._autoHideEnabled && !this._touching && 0 >= this._autoHideRemainingTime ? cc.ProtectedNode.prototype.setOpacity.call(this, this.opacity) : cc.ProtectedNode.prototype.setOpacity.call(this, 0)
    },
    isAutoHideEnabled: function () {
        return this._autoHideEnabled
    },
    setOpacity: function (a) {
        this._opacity = a
    },
    getOpacity: function () {
        return this._opacity
    },
    _updateLength: function (a) {
        var b = a / this._body.getTextureRect().height;
        this._body.setScaleY(b);
        this._upperHalfCircle.setPositionY(this._body.getPositionY() + a)
    },
    _processAutoHide: function (a) {
        !this._autoHideEnabled || 0 >= this._autoHideRemainingTime || this._touching || (this._autoHideRemainingTime -= a, this._autoHideRemainingTime <= this.autoHideTime && (this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime), cc.ProtectedNode.prototype.setOpacity.call(this, this._autoHideRemainingTime / this.autoHideTime * this._opacity)))
    },
    update: function (a) {
        this._processAutoHide(a)
    },
    onTouchBegan: function () {
        this._autoHideEnabled &&
        (this._touching = !0)
    },
    onTouchEnded: function () {
        this._autoHideEnabled && (this._touching = !1, 0 >= this._autoHideRemainingTime || (this._autoHideRemainingTime = this.autoHideTime))
    },
    onScrolled: function (a) {
        this._autoHideEnabled && (this._autoHideRemainingTime = this.autoHideTime, cc.ProtectedNode.prototype.setOpacity.call(this, this.opacity));
        var b = this._parentScroll.getInnerContainer(), d = 0, e = 0, f = 0, g = 0;
        this._direction === ccui.ScrollView.DIR_VERTICAL ? (d = b.height, e = this._parentScroll.height, f = a.y, g = -b.getPositionY()) : this._direction ===
        ccui.ScrollView.DIR_HORIZONTAL && (d = b.width, e = this._parentScroll.width, f = a.x, g = -b.getPositionX());
        a = this._calculateLength(d, e, f);
        d = this._calculatePosition(d, e, g, f, a);
        this._updateLength(a);
        this.setPosition(d)
    },
    _calculateLength: function (a, b, d) {
        0 !== d && (a += 20 * (0 < d ? d : -d));
        d = b / a;
        return Math.abs(b - 2 * this._marginForLength) * d
    },
    _calculatePosition: function (a, b, d, e, f) {
        a -= b;
        0 !== e && (a += Math.abs(e));
        e = 0;
        0 !== a && (e = Math.max(d / a, 0), e = Math.min(e, 1));
        b = (b - f - 2 * this._marginForLength) * e + this._marginForLength;
        return this._direction ===
        ccui.ScrollView.DIR_VERTICAL ? cc.p(this._parentScroll.width - this._marginFromBoundary, b) : cc.p(b, this._marginFromBoundary)
    }
});
_p = ccui.ScrollViewBar.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "autoHideEnabled", _p.isAutoHideEnabled, _p.setAutoHideEnabled);
ccui.ScrollViewBar.DEFAULT_COLOR = cc.color(52, 65, 87);
ccui.ScrollViewBar.DEFAULT_MARGIN = 20;
ccui.ScrollViewBar.DEFAULT_AUTO_HIDE_TIME = 0.2;
ccui.ScrollViewBar.DEFAULT_SCROLLBAR_OPACITY = 0.4;
ccui.ScrollViewBar.HALF_CIRCLE_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAGCAMAAADAMI+zAAAAJ1BMVEX///////////////////////////////////////////////////9Ruv0SAAAADHRSTlMABgcbbW7Hz9Dz+PmlcJP5AAAAMElEQVR4AUXHwQ2AQAhFwYcLH1H6r1djzDK3ASxUpTBeK/uTCyz7dx54b44m4p5cD1MwAooEJyk3AAAAAElFTkSuQmCC";
ccui.ScrollViewBar.BODY_IMAGE_1_PIXEL_HEIGHT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAABCAMAAADdNb8LAAAAA1BMVEX///+nxBvIAAAACklEQVR4AWNABgAADQABYc2cpAAAAABJRU5ErkJggg\x3d\x3d";
ccui.ScrollView = ccui.Layout.extend({
    _innerContainer: null,
    _direction: null,
    _topBoundary: 0,
    _bottomBoundary: 0,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _touchMoveDisplacements: null,
    _touchMoveTimeDeltas: null,
    _touchMovePreviousTimestamp: 0,
    _touchTotalTimeThreshold: 0.5,
    _autoScrolling: !1,
    _autoScrollTargetDelta: null,
    _autoScrollAttenuate: !0,
    _autoScrollStartPosition: null,
    _autoScrollTotalTime: 0,
    _autoScrollAccumulatedTime: 0,
    _autoScrollCurrentlyOutOfBoundary: !1,
    _autoScrollBraking: !1,
    _autoScrollBrakingStartPosition: null,
    _bePressed: !1,
    _childFocusCancelOffset: 0,
    bounceEnabled: !1,
    _outOfBoundaryAmount: null,
    _outOfBoundaryAmountDirty: !0,
    inertiaScrollEnabled: !1,
    _scrollBarEnabled: !0,
    _verticalScrollBar: null,
    _horizontalScrollBar: null,
    _scrollViewEventListener: null,
    _scrollViewEventSelector: null,
    _className: "ScrollView",
    ctor: function () {
        ccui.Layout.prototype.ctor.call(this);
        this.setClippingEnabled(!0);
        this._innerContainer.setTouchEnabled(!1);
        this._direction = ccui.ScrollView.DIR_NONE;
        this._childFocusCancelOffset = 5;
        this.inertiaScrollEnabled = !0;
        this._outOfBoundaryAmount = cc.p(0, 0);
        this._autoScrollTargetDelta = cc.p(0, 0);
        this._autoScrollStartPosition = cc.p(0, 0);
        this._autoScrollBrakingStartPosition = cc.p(0, 0);
        this._touchMoveDisplacements = [];
        this._touchMoveTimeDeltas = [];
        this._touchMovePreviousTimestamp = 0;
        this._scrollBarEnabled = !0;
        this._initScrollBar();
        this.setTouchEnabled(!0)
    },
    init: function () {
        return ccui.Layout.prototype.init.call(this) ? !0 : !1
    },
    onEnter: function () {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    onExit: function () {
        cc.renderer._removeCache(this.__instanceId);
        ccui.Layout.prototype.onExit.call(this)
    },
    findNextFocusedWidget: function (a, b) {
        return this.getLayoutType() === ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() === ccui.Layout.LINEAR_HORIZONTAL ? this._innerContainer.findNextFocusedWidget(a, b) : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, b)
    },
    _initRenderer: function () {
        ccui.Layout.prototype._initRenderer.call(this);
        this._innerContainer = new ccui.Layout;
        this._innerContainer.setColor(cc.color(255, 255, 255));
        this._innerContainer.setOpacity(255);
        this._innerContainer.setCascadeColorEnabled(!0);
        this._innerContainer.setCascadeOpacityEnabled(!0);
        this.addProtectedChild(this._innerContainer, 1, 1)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new ccui.ScrollView.WebGLRenderCmd(this) : new ccui.ScrollView.CanvasRenderCmd(this)
    },
    _onSizeChanged: function () {
        ccui.Layout.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._topBoundary = a.height;
        this._rightBoundary = a.width;
        var b = this._innerContainer.getContentSize();
        this._innerContainer.setContentSize(cc.size(Math.max(b.width,
            a.width), Math.max(b.height, a.height)));
        this._innerContainer.setPosition(0, a.height - this._innerContainer.getContentSize().height);
        if (this._verticalScrollBar)this._verticalScrollBar.onScrolled(this._getHowMuchOutOfBoundary());
        if (this._horizontalScrollBar)this._horizontalScrollBar.onScrolled(this._getHowMuchOutOfBoundary())
    },
    setInnerContainerSize: function (a) {
        var b = this._innerContainer, d = this._contentSize, e = d.width, f = d.height;
        a.width < d.width ? cc.log("Inner width \x3c\x3d ScrollView width, it will be force sized!") :
            e = a.width;
        a.height < d.height ? cc.log("Inner height \x3c\x3d ScrollView height, it will be force sized!") : f = a.height;
        b.setContentSize(cc.size(e, f));
        a = this._innerContainer.getPosition();
        b = this._innerContainer.getAnchorPoint();
        0 != this._innerContainer.getLeftBoundary() && (a.x = b.x * e);
        this._innerContainer.getTopBoundary() != this._contentSize.height && (a.y = this._contentSize.height - (1 - b.y) * f);
        this.setInnerContainerPosition(a);
        this._updateScrollBar(cc.p(0, 0))
    },
    _setInnerWidth: function (a) {
        var b = this._contentSize.width,
            d = b, e = this._innerContainer, f = e.width;
        a < b ? cc.log("Inner width \x3c\x3d scrollview width, it will be force sized!") : d = a;
        e.width = d;
        switch (this._direction) {
            case ccui.ScrollView.DIR_HORIZONTAL:
            case ccui.ScrollView.DIR_BOTH:
                e.getRightBoundary() <= b && this._scrollChildren(f - e.width, 0)
        }
        a = e.anchorX;
        0 < e.getLeftBoundary() && (e.x = a * d);
        e.getRightBoundary() < b && (e.x = b - (1 - a) * d)
    },
    _setInnerHeight: function (a) {
        var b = this._contentSize.height, d = b, e = this._innerContainer, f = e.height;
        a < b ? cc.log("Inner height \x3c\x3d scrollview height, it will be force sized!") :
            d = a;
        e.height = d;
        switch (this._direction) {
            case ccui.ScrollView.DIR_VERTICAL:
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(0, f - d)
        }
        a = e.anchorY;
        0 < e.getLeftBoundary() && (e.y = a * d);
        e.getRightBoundary() < b && (e.y = b - (1 - a) * d)
    },
    setInnerContainerPosition: function (a) {
        if (a.x !== this._innerContainer.getPositionX() || a.y !== this._innerContainer.getPositionY()) {
            this._innerContainer.setPosition(a);
            this._outOfBoundaryAmountDirty = !0;
            if (this.bounceEnabled)for (a = ccui.ScrollView.MOVEDIR_TOP; a < ccui.ScrollView.MOVEDIR_RIGHT; ++a)this._isOutOfBoundary(a) &&
            this._processScrollEvent(a, !0);
            this._dispatchEvent(ccui.ScrollView.EVENT_CONTAINER_MOVED)
        }
    },
    getInnerContainerPosition: function () {
        return this._innerContainer.getPosition()
    },
    getInnerContainerSize: function () {
        return this._innerContainer.getContentSize()
    },
    _getInnerWidth: function () {
        return this._innerContainer.width
    },
    _getInnerHeight: function () {
        return this._innerContainer.height
    },
    _isInContainer: function (a) {
        if (!this._clippingEnabled)return !0;
        var b = a._position, d = a._contentSize;
        a = a._anchorPoint;
        var e = this._customSize,
            f = this._innerContainer._position, g = 0, h = 0;
        return (g = b.y - a.y * d.height) >= e.height - f.y || g + d.height <= -f.y || (h = b.x - a.x * d.width) >= e.width - f.x || h + d.width <= -f.x ? !1 : !0
    },
    updateChildren: function () {
        var a, b, d, e = this._innerContainer._children;
        b = 0;
        for (d = e.length; b < d; b++)a = e[b], !0 === a._inViewRect && !1 === this._isInContainer(a) ? a._inViewRect = !1 : !1 === a._inViewRect && !0 === this._isInContainer(a) && (a._inViewRect = !0)
    },
    addChild: function (a, b, d) {
        if (!a)return !1;
        !1 === this._isInContainer(a) && (a._inViewRect = !1);
        b = b || a.getLocalZOrder();
        d = d || a.getTag();
        return this._innerContainer.addChild(a, b, d)
    },
    removeAllChildren: function () {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function (a) {
        this._innerContainer.removeAllChildrenWithCleanup(a)
    },
    removeChild: function (a, b) {
        return this._innerContainer.removeChild(a, b)
    },
    getChildren: function () {
        return this._innerContainer.getChildren()
    },
    getChildrenCount: function () {
        return this._innerContainer.getChildrenCount()
    },
    getChildByTag: function (a) {
        return this._innerContainer.getChildByTag(a)
    },
    getChildByName: function (a) {
        return this._innerContainer.getChildByName(a)
    },
    _flattenVectorByDirection: function (a) {
        var b = cc.p(0, 0);
        b.x = this._direction === ccui.ScrollView.DIR_VERTICAL ? 0 : a.x;
        b.y = this._direction === ccui.ScrollView.DIR_HORIZONTAL ? 0 : a.y;
        return b
    },
    _getHowMuchOutOfBoundary: function (a) {
        void 0 === a && (a = cc.p(0, 0));
        if (0 === a.x && 0 === a.y && !this._outOfBoundaryAmountDirty)return this._outOfBoundaryAmount;
        var b = cc.p(0, 0);
        this._innerContainer.getLeftBoundary() + a.x > this._leftBoundary ? b.x = this._leftBoundary -
            (this._innerContainer.getLeftBoundary() + a.x) : this._innerContainer.getRightBoundary() + a.x < this._rightBoundary && (b.x = this._rightBoundary - (this._innerContainer.getRightBoundary() + a.x));
        this._innerContainer.getTopBoundary() + a.y < this._topBoundary ? b.y = this._topBoundary - (this._innerContainer.getTopBoundary() + a.y) : this._innerContainer.getBottomBoundary() + a.y > this._bottomBoundary && (b.y = this._bottomBoundary - (this._innerContainer.getBottomBoundary() + a.y));
        0 === a.x && 0 === a.y && (this._outOfBoundaryAmount = b, this._outOfBoundaryAmountDirty = !1);
        return b
    },
    _isOutOfBoundary: function (a) {
        var b = this._getHowMuchOutOfBoundary();
        if (void 0 !== a)switch (a) {
            case ccui.ScrollView.MOVEDIR_TOP:
                return 0 < b.y;
            case ccui.ScrollView.MOVEDIR_BOTTOM:
                return 0 > b.y;
            case ccui.ScrollView.MOVEDIR_LEFT:
                return 0 > b.x;
            case ccui.ScrollView.MOVEDIR_RIGHT:
                return 0 < b.x
        } else return !this._fltEqualZero(b);
        return !1
    },
    _moveInnerContainer: function (a, b) {
        var d = this._flattenVectorByDirection(a);
        this.setInnerContainerPosition(cc.pAdd(this.getInnerContainerPosition(), d));
        d = this._getHowMuchOutOfBoundary();
        this._updateScrollBar(d);
        this.bounceEnabled && b && this._startBounceBackIfNeeded()
    },
    _updateScrollBar: function (a) {
        if (this._verticalScrollBar)this._verticalScrollBar.onScrolled(a);
        if (this._horizontalScrollBar)this._horizontalScrollBar.onScrolled(a)
    },
    _calculateTouchMoveVelocity: function () {
        for (var a = 0, b = 0; b < this._touchMoveTimeDeltas.length; ++b)a += this._touchMoveTimeDeltas[b];
        if (0 == a || a >= this._touchTotalTimeThreshold)return cc.p(0, 0);
        for (var d = cc.p(0, 0), b = 0; b < this._touchMoveDisplacements.length; ++b)d.x +=
            this._touchMoveDisplacements[b].x, d.y += this._touchMoveDisplacements[b].y;
        return cc.pMult(d, 1 / a)
    },
    setTouchTotalTimeThreshold: function (a) {
        this._touchTotalTimeThreshold = a
    },
    getTouchTotalTimeThreshold: function () {
        return this._touchTotalTimeThreshold
    },
    _startInertiaScroll: function (a) {
        var b = cc.pMult(a, 0.7);
        this._startAttenuatingAutoScroll(b, a)
    },
    _startBounceBackIfNeeded: function () {
        if (!this.bounceEnabled)return !1;
        var a = this._getHowMuchOutOfBoundary();
        if (this._fltEqualZero(a))return !1;
        this._startAutoScroll(a,
            1, !0);
        return !0
    },
    _startAutoScrollToDestination: function (a, b, d) {
        this._startAutoScroll(cc.pSub(a, this._innerContainer.getPosition()), b, d)
    },
    _calculateAutoScrollTimeByInitialSpeed: function (a) {
        return Math.sqrt(Math.sqrt(a / 5))
    },
    _startAttenuatingAutoScroll: function (a, b) {
        var d = this._calculateAutoScrollTimeByInitialSpeed(cc.pLength(b));
        this._startAutoScroll(a, d, !0)
    },
    _startAutoScroll: function (a, b, d) {
        a = this._flattenVectorByDirection(a);
        this._autoScrolling = !0;
        this._autoScrollTargetDelta = a;
        this._autoScrollAttenuate =
            d;
        this._autoScrollStartPosition = this._innerContainer.getPosition();
        this._autoScrollTotalTime = b;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollBraking = !1;
        this._autoScrollBrakingStartPosition = cc.p(0, 0);
        b = this._getHowMuchOutOfBoundary();
        !this._fltEqualZero(b) && (this._autoScrollCurrentlyOutOfBoundary = !0, d = this._getHowMuchOutOfBoundary(a), 0 < b.x * d.x || 0 < b.y * d.y) && (this._autoScrollBraking = !0)
    },
    stopAutoScroll: function () {
        this._autoScrolling = !1;
        this._autoScrollAttenuate = !0;
        this._autoScrollAccumulatedTime =
            this._autoScrollTotalTime = 0
    },
    _isNecessaryAutoScrollBrake: function () {
        if (this._autoScrollBraking)return !0;
        if (this._isOutOfBoundary()) {
            if (!this._autoScrollCurrentlyOutOfBoundary)return this._autoScrollBraking = this._autoScrollCurrentlyOutOfBoundary = !0, this._autoScrollBrakingStartPosition = this.getInnerContainerPosition(), !0
        } else this._autoScrollCurrentlyOutOfBoundary = !1;
        return !1
    },
    _getAutoScrollStopEpsilon: function () {
        return 1E-4
    },
    _fltEqualZero: function (a) {
        return 1E-4 >= Math.abs(a.x) && 1E-4 >= Math.abs(a.y)
    },
    _processAutoScrolling: function (a) {
        var b = this._isNecessaryAutoScrollBrake() ? 0.05 : 1;
        this._autoScrollAccumulatedTime += 1 / b * a;
        var d = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
        this._autoScrollAttenuate && (d -= 1, d = d * d * d * d * d + 1);
        a = cc.pAdd(this._autoScrollStartPosition, cc.pMult(this._autoScrollTargetDelta, d));
        d = Math.abs(d - 1) <= this._getAutoScrollStopEpsilon();
        this.bounceEnabled ? a = cc.pAdd(this._autoScrollBrakingStartPosition, cc.pMult(cc.pSub(a, this._autoScrollBrakingStartPosition), b)) :
            (b = cc.pSub(a, this.getInnerContainerPosition()), b = this._getHowMuchOutOfBoundary(b), this._fltEqualZero(b) || (a.x += b.x, a.y += b.y, d = !0));
        d && (this._autoScrolling = !1, this._dispatchEvent(ccui.ScrollView.EVENT_AUTOSCROLL_ENDED));
        this._moveInnerContainer(cc.pSub(a, this.getInnerContainerPosition()), d)
    },
    _jumpToDestination: function (a, b) {
        void 0 === a.x && (a = cc.p(a, b));
        this._autoScrolling = !1;
        this._moveInnerContainer(cc.pSub(a, this.getInnerContainerPosition()), !0)
    },
    _scrollChildren: function (a) {
        if (this.bounceEnabled) {
            var b =
                this._getHowMuchOutOfBoundary();
            a.x *= 0 == b.x ? 1 : 0.5;
            a.y *= 0 == b.y ? 1 : 0.5
        }
        this.bounceEnabled || (b = this._getHowMuchOutOfBoundary(a), a.x += b.x, a.y += b.y);
        var d = b = !1, e = !1, f = !1;
        0 < a.y ? this._innerContainer.getBottomBoundary() + a.y >= this._bottomBoundary && (f = !0) : 0 > a.y && this._innerContainer.getTopBoundary() + a.y <= this._topBoundary && (e = !0);
        0 > a.x ? this._innerContainer.getRightBoundary() + a.x <= this._rightBoundary && (d = !0) : 0 < a.x && this._innerContainer.getLeftBoundary() + a.x >= this._leftBoundary && (b = !0);
        this._moveInnerContainer(a,
            !1);
        0 == a.x && 0 == a.y || this._processScrollingEvent();
        f && this._processScrollEvent(ccui.ScrollView.MOVEDIR_BOTTOM, !1);
        e && this._processScrollEvent(ccui.ScrollView.MOVEDIR_TOP, !1);
        b && this._processScrollEvent(ccui.ScrollView.MOVEDIR_LEFT, !1);
        d && this._processScrollEvent(ccui.ScrollView.MOVEDIR_RIGHT, !1)
    },
    scrollToBottom: function (a, b) {
        this._startAutoScrollToDestination(cc.p(this._innerContainer.getPositionX(), 0), a, b)
    },
    scrollToTop: function (a, b) {
        this._startAutoScrollToDestination(cc.p(this._innerContainer.getPositionX(),
            this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToLeft: function (a, b) {
        this._startAutoScrollToDestination(cc.p(0, this._innerContainer.getPositionY()), a, b)
    },
    scrollToRight: function (a, b) {
        this._startAutoScrollToDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()), a, b)
    },
    scrollToTopLeft: function (a, b) {
        this._direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollToDestination(cc.p(0,
            this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToTopRight: function (a, b) {
        if (this._direction !== ccui.ScrollView.DIR_BOTH)cc.log("Scroll direction is not both!"); else {
            var d = this._innerContainer.getContentSize();
            this._startAutoScrollToDestination(cc.p(this._contentSize.width - d.width, this._contentSize.height - d.height), a, b)
        }
    },
    scrollToBottomLeft: function (a, b) {
        this._direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollToDestination(cc.p(0,
            0), a, b)
    },
    scrollToBottomRight: function (a, b) {
        this._direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollToDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), a, b)
    },
    scrollToPercentVertical: function (a, b, d) {
        var e = this._contentSize.height - this._innerContainer.getContentSize().height, f = -e;
        this._startAutoScrollToDestination(cc.p(this._innerContainer.getPositionX(), e + a * f / 100), b, d)
    },
    scrollToPercentHorizontal: function (a, b, d) {
        var e =
            this._innerContainer.getContentSize().width - this._contentSize.width;
        this._startAutoScrollToDestination(cc.p(-(a * e / 100), this._innerContainer.getPositionY()), b, d)
    },
    scrollToPercentBothDirection: function (a, b, d) {
        if (this._direction === ccui.ScrollView.DIR_BOTH) {
            var e = this._contentSize.height - this._innerContainer.getContentSize().height, f = -e, g = this._innerContainer.getContentSize().width - this._contentSize.width;
            this._startAutoScrollToDestination(cc.p(-(a.x * g / 100), e + a.y * f / 100), b, d)
        }
    },
    jumpToBottom: function () {
        this._jumpToDestination(this._innerContainer.getPositionX(),
            0)
    },
    jumpToTop: function () {
        this._jumpToDestination(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToLeft: function () {
        this._jumpToDestination(0, this._innerContainer.getPositionY())
    },
    jumpToRight: function () {
        this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY())
    },
    jumpToTopLeft: function () {
        this._direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll _direction is not both!") :
            this._jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToTopRight: function () {
        if (this._direction !== ccui.ScrollView.DIR_BOTH)cc.log("Scroll _direction is not both!"); else {
            var a = this._innerContainer.getContentSize();
            this._jumpToDestination(this._contentSize.width - a.width, this._contentSize.height - a.height)
        }
    },
    jumpToBottomLeft: function () {
        this._direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll _direction is not both!") : this._jumpToDestination(0, 0)
    },
    jumpToBottomRight: function () {
        this._direction !==
        ccui.ScrollView.DIR_BOTH ? cc.log("Scroll _direction is not both!") : this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, 0)
    },
    jumpToPercentVertical: function (a) {
        var b = this._contentSize.height - this._innerContainer.getContentSize().height, d = -b;
        this._jumpToDestination(this._innerContainer.getPositionX(), b + a * d / 100)
    },
    jumpToPercentHorizontal: function (a) {
        var b = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._jumpToDestination(-(a * b / 100), this._innerContainer.getPositionY())
    },
    jumpToPercentBothDirection: function (a) {
        if (this._direction === ccui.ScrollView.DIR_BOTH) {
            var b = this._innerContainer.getContentSize(), d = this._contentSize.height - b.height;
            this._jumpToDestination(-(a.x * (b.width - this._contentSize.width) / 100), d + a.y * -d / 100)
        }
    },
    _gatherTouchMove: function (a) {
        for (; 5 <= this._touchMoveDisplacements.length;)this._touchMoveDisplacements.splice(0, 1), this._touchMoveTimeDeltas.splice(0, 1);
        this._touchMoveDisplacements.push(a);
        a = (new Date).getTime();
        this._touchMoveTimeDeltas.push((a - this._touchMovePreviousTimestamp) /
            1E3);
        this._touchMovePreviousTimestamp = a
    },
    _handlePressLogic: function (a) {
        this._bePressed = !0;
        this._autoScrolling = !1;
        this._touchMovePreviousTimestamp = (new Date).getTime();
        this._touchMoveDisplacements.length = 0;
        this._touchMoveTimeDeltas.length = 0;
        if (this._verticalScrollBar)this._verticalScrollBar.onTouchBegan();
        if (this._horizontalScrollBar)this._horizontalScrollBar.onTouchBegan()
    },
    _handleMoveLogic: function (a) {
        var b = this.convertToNodeSpace(a.getLocation());
        a = this.convertToNodeSpace(a.getPreviousLocation());
        b = cc.pSub(b, a);
        this._scrollChildren(b);
        this._gatherTouchMove(b)
    },
    _handleReleaseLogic: function (a) {
        var b = this.convertToNodeSpace(a.getLocation());
        a = this.convertToNodeSpace(a.getPreviousLocation());
        b = cc.pSub(b, a);
        this._gatherTouchMove(b);
        this._bePressed = !1;
        !this._startBounceBackIfNeeded() && this.inertiaScrollEnabled && (b = this._calculateTouchMoveVelocity(), 0 === b.x && 0 === b.y || this._startInertiaScroll(b));
        if (this._verticalScrollBar)this._verticalScrollBar.onTouchEnded();
        if (this._horizontalScrollBar)this._horizontalScrollBar.onTouchEnded()
    },
    onTouchBegan: function (a, b) {
        var d = ccui.Layout.prototype.onTouchBegan.call(this, a, b);
        this._isInterceptTouch || this._hit && this._handlePressLogic(a);
        return d
    },
    onTouchMoved: function (a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b);
        this._isInterceptTouch || this._handleMoveLogic(a)
    },
    onTouchEnded: function (a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b);
        this._isInterceptTouch || this._handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    onTouchCancelled: function (a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this,
            a, b);
        this._isInterceptTouch || this._handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    update: function (a) {
        this._autoScrolling && this._processAutoScrolling(a)
    },
    interceptTouchEvent: function (a, b, d) {
        if (!this._touchEnabled)ccui.Layout.prototype.interceptTouchEvent.call(this, a, b, d); else if (this._direction !== ccui.ScrollView.DIR_NONE) {
            var e = d.getLocation();
            switch (a) {
                case ccui.Widget.TOUCH_BEGAN:
                    this._isInterceptTouch = !0;
                    this._touchBeganPosition.x = e.x;
                    this._touchBeganPosition.y = e.y;
                    this._handlePressLogic(d);
                    break;
                case ccui.Widget.TOUCH_MOVED:
                    a = cc.pLength(cc.pSub(b.getTouchBeganPosition(), e));
                    this._touchMovePosition.x = e.x;
                    this._touchMovePosition.y = e.y;
                    a > this._childFocusCancelOffset && (b.setHighlighted(!1), this._handleMoveLogic(d));
                    break;
                case ccui.Widget.TOUCH_CANCELED:
                case ccui.Widget.TOUCH_ENDED:
                    this._touchEndPosition.x = e.x, this._touchEndPosition.y = e.y, this._handleReleaseLogic(d), b.isSwallowTouches() && (this._isInterceptTouch = !1)
            }
        }
    },
    _processScrollEvent: function (a, b) {
        var d = 0;
        switch (a) {
            case ccui.ScrollView.MOVEDIR_TOP:
                d =
                    b ? ccui.ScrollView.EVENT_BOUNCE_TOP : ccui.ScrollView.EVENT_SCROLL_TO_TOP;
                break;
            case ccui.ScrollView.MOVEDIR_BOTTOM:
                d = b ? ccui.ScrollView.EVENT_BOUNCE_BOTTOM : ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM;
                break;
            case ccui.ScrollView.MOVEDIR_LEFT:
                d = b ? ccui.ScrollView.EVENT_BOUNCE_LEFT : ccui.ScrollView.EVENT_SCROLL_TO_LEFT;
                break;
            case ccui.ScrollView.MOVEDIR_RIGHT:
                d = b ? ccui.ScrollView.EVENT_BOUNCE_RIGHT : ccui.ScrollView.EVENT_SCROLL_TO_RIGHT
        }
        this._dispatchEvent(d)
    },
    _processScrollingEvent: function () {
        this._dispatchEvent(ccui.ScrollView.EVENT_SCROLLING)
    },
    _dispatchEvent: function (a) {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, a) : this._scrollViewEventSelector(this, a));
        this._ccEventCallback && this._ccEventCallback(this, a)
    },
    addEventListenerScrollView: function (a, b) {
        this._scrollViewEventSelector = a;
        this._scrollViewEventListener = b
    },
    addEventListener: function (a) {
        this._ccEventCallback = a
    },
    setDirection: function (a) {
        this._direction = a;
        this._scrollBarEnabled && (this._removeScrollBar(),
            this._initScrollBar())
    },
    getDirection: function () {
        return this._direction
    },
    setBounceEnabled: function (a) {
        this.bounceEnabled = a
    },
    isBounceEnabled: function () {
        return this.bounceEnabled
    },
    setInertiaScrollEnabled: function (a) {
        this.inertiaScrollEnabled = a
    },
    isInertiaScrollEnabled: function () {
        return this.inertiaScrollEnabled
    },
    setScrollBarEnabled: function (a) {
        this._scrollBarEnabled !== a && (this._scrollBarEnabled && this._removeScrollBar(), (this._scrollBarEnabled = a) && this._initScrollBar())
    },
    isScrollBarEnabled: function () {
        return this._scrollBarEnabled
    },
    setScrollBarPositionFromCorner: function (a) {
        this._direction !== ccui.ScrollView.DIR_HORIZONTAL && this.setScrollBarPositionFromCornerForVertical(a);
        this._direction !== ccui.ScrollView.DIR_VERTICAL && this.setScrollBarPositionFromCornerForHorizontal(a)
    },
    setScrollBarPositionFromCornerForVertical: function (a) {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        cc.assert(this._direction !== ccui.ScrollView.DIR_HORIZONTAL, "Scroll view doesn't have a vertical scroll bar!");
        this._verticalScrollBar.setPositionFromCorner(a)
    },
    getScrollBarPositionFromCornerForVertical: function () {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        cc.assert(this._direction !== ccui.ScrollView.DIR_HORIZONTAL, "Scroll view doesn't have a vertical scroll bar!");
        return this._verticalScrollBar.getPositionFromCorner()
    },
    setScrollBarPositionFromCornerForHorizontal: function (a) {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        cc.assert(this._direction !== ccui.ScrollView.DIR_VERTICAL, "Scroll view doesn't have a horizontal scroll bar!");
        this._horizontalScrollBar.setPositionFromCorner(a)
    },
    getScrollBarPositionFromCornerForHorizontal: function () {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        cc.assert(this._direction !== ccui.ScrollView.DIR_VERTICAL, "Scroll view doesn't have a horizontal scroll bar!");
        return this._horizontalScrollBar.getPositionFromCorner()
    },
    setScrollBarWidth: function (a) {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        this._verticalScrollBar && this._verticalScrollBar.setWidth(a);
        this._horizontalScrollBar &&
        this._horizontalScrollBar.setWidth(a)
    },
    getScrollBarWidth: function () {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        return this._verticalScrollBar ? this._verticalScrollBar.getWidth() : this._horizontalScrollBar ? this._horizontalScrollBar.getWidth() : 0
    },
    setScrollBarColor: function (a) {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        this._verticalScrollBar && this._verticalScrollBar.setColor(a);
        this._horizontalScrollBar && this._horizontalScrollBar.setColor(a)
    },
    getScrollBarColor: function () {
        cc.assert(this._scrollBarEnabled,
            "Scroll bar should be enabled!");
        this._verticalScrollBar && this._verticalScrollBar.getColor();
        this._horizontalScrollBar && this._horizontalScrollBar.getColor();
        return cc.color.WHITE
    },
    setScrollBarOpacity: function (a) {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        this._verticalScrollBar && (this._verticalScrollBar.opacity = a);
        this._horizontalScrollBar && (this._horizontalScrollBar.opacity = a)
    },
    getScrollBarOpacity: function () {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        return this._verticalScrollBar ? this._verticalScrollBar.opacity : this._horizontalScrollBar ? this._horizontalScrollBar.opacity : -1
    },
    setScrollBarAutoHideEnabled: function (a) {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        this._verticalScrollBar && (this._verticalScrollBar.autoHideEnabled = a);
        this._horizontalScrollBar && (this._horizontalScrollBar.autoHideEnabled = a)
    },
    isScrollBarAutoHideEnabled: function () {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        return this._verticalScrollBar ?
            this._verticalScrollBar.autoHideEnabled : this._horizontalScrollBar ? this._horizontalScrollBar.autoHideEnabled : !1
    },
    setScrollBarAutoHideTime: function (a) {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        this._verticalScrollBar && (this._verticalScrollBar.autoHideTime = a);
        this._horizontalScrollBar && (this._horizontalScrollBar.autoHideTime = a)
    },
    getScrollBarAutoHideTime: function () {
        cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!");
        return this._verticalScrollBar ? this._verticalScrollBar.autoHideTime :
            this._horizontalScrollBar ? this._horizontalScrollBar.autoHideTime : 0
    },
    getInnerContainer: function () {
        return this._innerContainer
    },
    setLayoutType: function (a) {
        this._innerContainer.setLayoutType(a)
    },
    getLayoutType: function () {
        return this._innerContainer.getLayoutType()
    },
    _doLayout: function () {
        this._doLayoutDirty && (this._doLayoutDirty = !1)
    },
    getDescription: function () {
        return "ScrollView"
    },
    _createCloneInstance: function () {
        return new ccui.ScrollView
    },
    _copyClonedWidgetChildren: function (a) {
        ccui.Layout.prototype._copyClonedWidgetChildren.call(this,
            a)
    },
    _copySpecialProperties: function (a) {
        a instanceof ccui.ScrollView && (ccui.Layout.prototype._copySpecialProperties.call(this, a), this.setInnerContainerSize(a.getInnerContainerSize()), this.setInnerContainerPosition(a.getInnerContainerPosition()), this.setDirection(a._direction), this._topBoundary = a._topBoundary, this._bottomBoundary = a._bottomBoundary, this._leftBoundary = a._leftBoundary, this._rightBoundary = a._rightBoundary, this._bePressed = a._bePressed, this._childFocusCancelOffset = a._childFocusCancelOffset,
            this._touchMoveDisplacements = a._touchMoveDisplacements, this._touchMoveTimeDeltas = a._touchMoveTimeDeltas, this._touchMovePreviousTimestamp = a._touchMovePreviousTimestamp, this._autoScrolling = a._autoScrolling, this._autoScrollAttenuate = a._autoScrollAttenuate, this._autoScrollStartPosition = a._autoScrollStartPosition, this._autoScrollTargetDelta = a._autoScrollTargetDelta, this._autoScrollTotalTime = a._autoScrollTotalTime, this._autoScrollAccumulatedTime = a._autoScrollAccumulatedTime, this._autoScrollCurrentlyOutOfBoundary =
            a._autoScrollCurrentlyOutOfBoundary, this._autoScrollBraking = a._autoScrollBraking, this._autoScrollBrakingStartPosition = a._autoScrollBrakingStartPosition, this.setBounceEnabled(a.bounceEnabled), this.setInertiaScrollEnabled(a.inertiaScrollEnabled), this._scrollViewEventListener = a._scrollViewEventListener, this._scrollViewEventSelector = a._scrollViewEventSelector, this._ccEventCallback = a._ccEventCallback, this.setScrollBarEnabled(a.isScrollBarEnabled()), this.isScrollBarEnabled() && (this._direction !== ccui.ScrollView.DIR_HORIZONTAL &&
        this.setScrollBarPositionFromCornerForVertical(a.getScrollBarPositionFromCornerForVertical()), this._direction !== ccui.ScrollView.DIR_VERTICAL && this.setScrollBarPositionFromCornerForHorizontal(a.getScrollBarPositionFromCornerForHorizontal()), this.setScrollBarWidth(a.getScrollBarWidth()), this.setScrollBarColor(a.getScrollBarColor()), this.setScrollBarAutoHideEnabled(a.isScrollBarAutoHideEnabled()), this.setScrollBarAutoHideTime(a.getScrollBarAutoHideTime())))
    },
    _initScrollBar: function () {
        this._direction ===
        ccui.ScrollView.DIR_HORIZONTAL || this._verticalScrollBar || (this._verticalScrollBar = new ccui.ScrollViewBar(this, ccui.ScrollView.DIR_VERTICAL), this.addProtectedChild(this._verticalScrollBar, 2));
        this._direction === ccui.ScrollView.DIR_VERTICAL || this._horizontalScrollBar || (this._horizontalScrollBar = new ccui.ScrollViewBar(this, ccui.ScrollView.DIR_HORIZONTAL), this.addProtectedChild(this._horizontalScrollBar, 2))
    },
    _removeScrollBar: function () {
        this._verticalScrollBar && (this.removeProtectedChild(this._verticalScrollBar),
            this._verticalScrollBar = null);
        this._horizontalScrollBar && (this.removeProtectedChild(this._horizontalScrollBar), this._horizontalScrollBar = null)
    },
    getNodeByTag: function (a) {
        return this._innerContainer.getNodeByTag(a)
    },
    getNodes: function () {
        return this._innerContainer.getNodes()
    },
    removeNode: function (a) {
        this._innerContainer.removeNode(a)
    },
    removeNodeByTag: function (a) {
        this._innerContainer.removeNodeByTag(a)
    },
    removeAllNodes: function () {
        this._innerContainer.removeAllNodes()
    },
    addNode: function (a, b, d) {
        this._innerContainer.addNode(a,
            b, d)
    }
});
_p = ccui.ScrollView.prototype;
cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth);
cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight);
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "touchTotalTimeThreshold", _p.getTouchTotalTimeThreshold, _p.setTouchTotalTimeThreshold);
_p = null;
ccui.ScrollView.create = function () {
    return new ccui.ScrollView
};
ccui.ScrollView.DIR_NONE = 0;
ccui.ScrollView.DIR_VERTICAL = 1;
ccui.ScrollView.DIR_HORIZONTAL = 2;
ccui.ScrollView.DIR_BOTH = 3;
ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0;
ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1;
ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2;
ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3;
ccui.ScrollView.EVENT_SCROLLING = 4;
ccui.ScrollView.EVENT_BOUNCE_TOP = 5;
ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6;
ccui.ScrollView.EVENT_BOUNCE_LEFT = 7;
ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8;
ccui.ScrollView.EVENT_CONTAINER_MOVED = 9;
ccui.ScrollView.EVENT_AUTOSCROLL_ENDED = 10;
ccui.ScrollView.MOVEDIR_TOP = 0;
ccui.ScrollView.MOVEDIR_BOTTOM = 1;
ccui.ScrollView.MOVEDIR_LEFT = 2;
ccui.ScrollView.MOVEDIR_RIGHT = 3;
ccui.ListView = ccui.ScrollView.extend({
    _model: null,
    _items: null,
    _gravity: null,
    _itemsMargin: 0,
    _curSelectedIndex: 0,
    _refreshViewDirty: !0,
    _listViewEventListener: null,
    _listViewEventSelector: null,
    _magneticAllowedOutOfBoundary: !0,
    _magneticType: 0,
    _className: "ListView",
    ctor: function () {
        this._items = [];
        ccui.ScrollView.prototype.ctor.call(this);
        this._gravity = ccui.ListView.GRAVITY_CENTER_VERTICAL;
        this.setTouchEnabled(!0);
        this.setDirection(ccui.ScrollView.DIR_VERTICAL)
    },
    setItemModel: function (a) {
        a ? this._model = a : cc.log("Can't set a null to item model!")
    },
    _handleReleaseLogic: function (a) {
        ccui.ScrollView.prototype._handleReleaseLogic.call(this, a);
        this._autoScrolling || this._startMagneticScroll()
    },
    _onItemListChanged: function () {
        this._outOfBoundaryAmountDirty = !0
    },
    _updateInnerContainerSize: function () {
        var a = this._items, b, d;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                b = a.length;
                var e = (b - 1) * this._itemsMargin;
                for (d = 0; d < b; d++)e += a[d].getContentSize().height;
                this.setInnerContainerSize(cc.size(this._contentSize.width, e));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                b =
                    a.length;
                e = (b - 1) * this._itemsMargin;
                for (d = 0; d < b; d++)e += a[d].getContentSize().width;
                this.setInnerContainerSize(cc.size(e, this._contentSize.height))
        }
    },
    _remedyLayoutParameter: function (a) {
        cc.assert(null != a, "ListView Item can't be nil!");
        var b = a.getLayoutParameter(), d = !0;
        b || (b = new ccui.LinearLayoutParameter, d = !1);
        var e = this.getIndex(a);
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._remedyVerticalLayoutParameter(b, e);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._remedyHorizontalLayoutParameter(b,
                    e)
        }
        d || a.setLayoutParameter(b)
    },
    _remedyVerticalLayoutParameter: function (a, b) {
        cc.assert(null != a, "Layout parameter can't be nil!");
        switch (this._gravity) {
            case ccui.ListView.GRAVITY_LEFT:
                a.setGravity(ccui.LinearLayoutParameter.LEFT);
                break;
            case ccui.ListView.GRAVITY_RIGHT:
                a.setGravity(ccui.LinearLayoutParameter.RIGHT);
                break;
            case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                a.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
        }
        0 === b ? a.setMargin(ccui.MarginZero()) : a.setMargin(new ccui.Margin(0, this._itemsMargin,
            0, 0))
    },
    _remedyHorizontalLayoutParameter: function (a, b) {
        cc.assert(null != a, "Layout parameter can't be nil!");
        switch (this._gravity) {
            case ccui.ListView.GRAVITY_TOP:
                a.setGravity(ccui.LinearLayoutParameter.TOP);
                break;
            case ccui.ListView.GRAVITY_BOTTOM:
                a.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                break;
            case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                a.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
        }
        0 === b ? a.setMargin(ccui.MarginZero()) : a.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0))
    },
    pushBackDefaultItem: function () {
        if (null !=
            this._model) {
            var a = this._model.clone();
            this._remedyLayoutParameter(a);
            this.addChild(a);
            this._refreshViewDirty = !0
        }
    },
    insertDefaultItem: function (a) {
        if (null != this._model) {
            var b = this._model.clone();
            this._items.splice(a, 0, b);
            ccui.ScrollView.prototype.addChild.call(this, b);
            this._remedyLayoutParameter(b);
            this._refreshViewDirty = !0
        }
    },
    pushBackCustomItem: function (a) {
        this._remedyLayoutParameter(a);
        this.addChild(a);
        this._refreshViewDirty = !0
    },
    addChild: function (a, b, d) {
        a && (b = b || a.getLocalZOrder(), d = d || a.getName(),
            ccui.ScrollView.prototype.addChild.call(this, a, b, d), a instanceof ccui.Widget && (this._items.push(a), this._onItemListChanged()))
    },
    removeChild: function (a, b) {
        if (a) {
            var d = this._items.indexOf(a);
            -1 < d && this._items.splice(d, 1);
            this._onItemListChanged();
            ccui.ScrollView.prototype.removeChild.call(this, a, b)
        }
    },
    removeAllChildren: function () {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function (a) {
        ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._items = [];
        this._onItemListChanged()
    },
    insertCustomItem: function (a, b) {
        this._items.splice(b, 0, a);
        this._onItemListChanged();
        ccui.ScrollView.prototype.addChild.call(this, a);
        this._remedyLayoutParameter(a);
        this._refreshViewDirty = !0
    },
    removeItem: function (a) {
        a = this.getItem(a);
        null != a && (this.removeChild(a, !0), this._refreshViewDirty = !0)
    },
    removeLastItem: function () {
        this.removeItem(this._items.length - 1)
    },
    removeAllItems: function () {
        this.removeAllChildren()
    },
    getItem: function (a) {
        return 0 > a || a >= this._items.length ? null : this._items[a]
    },
    getItems: function () {
        return this._items
    },
    getIndex: function (a) {
        return null == a ? -1 : this._items.indexOf(a)
    },
    setGravity: function (a) {
        this._gravity !== a && (this._gravity = a, this._refreshViewDirty = !0)
    },
    setMagneticType: function (a) {
        this._magneticType = a;
        this._onItemListChanged();
        this._startMagneticScroll()
    },
    getMagneticType: function () {
        return this._magneticType
    },
    setMagneticAllowedOutOfBoundary: function (a) {
        this._magneticAllowedOutOfBoundary = a
    },
    getMagneticAllowedOutOfBoundary: function () {
        return this._magneticAllowedOutOfBoundary
    },
    setItemsMargin: function (a) {
        this._itemsMargin !==
        a && (this._itemsMargin = a, this._refreshViewDirty = !0)
    },
    getItemsMargin: function () {
        return this._itemsMargin
    },
    setDirection: function (a) {
        switch (a) {
            case ccui.ScrollView.DIR_VERTICAL:
                this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
                break;
            case ccui.ScrollView.DIR_BOTH:
                return;
            default:
                return
        }
        ccui.ScrollView.prototype.setDirection.call(this, a)
    },
    _getHowMuchOutOfBoundary: function (a) {
        void 0 === a && (a = cc.p(0, 0));
        if (this._magneticAllowedOutOfBoundary &&
            0 !== this._items.length) {
            if (this._magneticType === ccui.ListView.MAGNETIC_NONE || this._magneticType === ccui.ListView.MAGNETIC_BOTH_END)return ccui.ScrollView.prototype._getHowMuchOutOfBoundary.call(this, a);
            if (0 === a.x && 0 === a.y && !this._outOfBoundaryAmountDirty)return this._outOfBoundaryAmount
        } else return ccui.ScrollView.prototype._getHowMuchOutOfBoundary.call(this, a);
        var b = this._leftBoundary, d = this._rightBoundary, e = this._topBoundary, f = this._bottomBoundary, g = this._items.length - 1, h = this.getContentSize(), n =
            cc.p(0, 0), p = cc.p(0, 0);
        switch (this._magneticType) {
            case ccui.ListView.MAGNETIC_CENTER:
                n.x = (h.width - this._items[0].width) / 2;
                n.y = (h.height - this._items[0].height) / 2;
                p.x = (h.width - this._items[g].width) / 2;
                p.y = (h.height - this._items[g].height) / 2;
                break;
            case ccui.ListView.MAGNETIC_LEFT:
            case ccui.ListView.MAGNETIC_TOP:
                p.x = h.width - this._items[g].width;
                p.y = h.height - this._items[g].height;
                break;
            case ccui.ListView.MAGNETIC_RIGHT:
            case ccui.ListView.MAGNETIC_BOTTOM:
                n.x = h.width - this._items[0].width, n.y = h.height - this._items[0].height
        }
        b +=
            n.x;
        d -= p.x;
        e -= n.y;
        f += p.y;
        g = cc.p(0, 0);
        this._innerContainer.getLeftBoundary() + a.x > b ? g.x = b - (this._innerContainer.getLeftBoundary() + a.x) : this._innerContainer.getRightBoundary() + a.x < d && (g.x = d - (this._innerContainer.getRightBoundary() + a.x));
        this._innerContainer.getTopBoundary() + a.y < e ? g.y = e - (this._innerContainer.getTopBoundary() + a.y) : this._innerContainer.getBottomBoundary() + a.y > f && (g.y = f - (this._innerContainer.getBottomBoundary() + a.y));
        0 === a.x && 0 === a.y && (this._outOfBoundaryAmount = g, this._outOfBoundaryAmountDirty = !1);
        return g
    },
    _calculateItemPositionWithAnchor: function (a, b) {
        var d = cc.p(a.getLeftBoundary(), a.getBottomBoundary()), e = a.getContentSize();
        return cc.p(d.x + e.width * b.x, d.y + e.height * b.y)
    },
    _findClosestItem: function (a, b, d, e, f, g, h) {
        cc.assert(0 <= e && g < b.length && e <= g, "");
        if (e === g)return b[e];
        if (1 === g - e)return f <= h ? b[e] : b[g];
        var n = Math.floor((e + g) / 2), p = this._calculateItemPositionWithAnchor(b[n], d), p = cc.pLength(cc.pSub(a, p));
        return f <= h ? this._findClosestItem(a, b, d, e, f, n, p) : this._findClosestItem(a, b, d, n, p, g, h)
    },
    getClosestItemToPosition: function (a, b) {
        if (0 === this._items.length)return null;
        var d = this._calculateItemPositionWithAnchor(this._items[0], b), d = cc.pLength(cc.pSub(a, d)), e = this._items.length - 1, f = this._calculateItemPositionWithAnchor(this._items[e], b), f = cc.pLength(cc.pSub(a, f));
        return this._findClosestItem(a, this._items, b, 0, d, e, f)
    },
    getClosestItemToPositionInCurrentView: function (a, b) {
        var d = this.getContentSize(), e = cc.pMult(this._innerContainer.getPosition(), -1);
        e.x += d.width * a.x;
        e.y += d.height * a.y;
        return this.getClosestItemToPosition(e,
            b)
    },
    getCenterItemInCurrentView: function () {
        return this.getClosestItemToPositionInCurrentView(cc.p(0.5, 0.5), cc.p(0.5, 0.5))
    },
    getLeftmostItemInCurrentView: function () {
        return this._direction === ccui.ScrollView.DIR_HORIZONTAL ? this.getClosestItemToPositionInCurrentView(cc.p(0, 0.5), cc.p(0.5, 0.5)) : null
    },
    getRightmostItemInCurrentView: function () {
        return this._direction === ccui.ScrollView.DIR_HORIZONTAL ? this.getClosestItemToPositionInCurrentView(cc.p(1, 0.5), cc.p(0.5, 0.5)) : null
    },
    getTopmostItemInCurrentView: function () {
        return this._direction ===
        ccui.ScrollView.DIR_VERTICAL ? this.getClosestItemToPositionInCurrentView(cc.p(0.5, 1), cc.p(0.5, 0.5)) : null
    },
    getBottommostItemInCurrentView: function () {
        return this._direction === ccui.ScrollView.DIR_VERTICAL ? this.getClosestItemToPositionInCurrentView(cc.p(0.5, 0), cc.p(0.5, 0.5)) : null
    },
    _calculateItemDestination: function (a, b, d) {
        var e = this.getContentSize(), f = cc.p(0, 0);
        f.x += e.width * a.x;
        f.y += e.height * a.y;
        a = this._calculateItemPositionWithAnchor(b, d);
        return cc.pMult(cc.pSub(a, f), -1)
    },
    jumpToBottom: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToBottom.call(this)
    },
    jumpToTop: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToTop.call(this)
    },
    jumpToLeft: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToLeft.call(this)
    },
    jumpToRight: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToRight.call(this)
    },
    jumpToTopLeft: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToTopLeft.call(this)
    },
    jumpToTopRight: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToTopRight.call(this)
    },
    jumpToBottomLeft: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToBottomLeft.call(this)
    },
    jumpToBottomRight: function () {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToBottomRight.call(this)
    },
    jumpToPercentVertical: function (a) {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToPercentVertical.call(this, a)
    },
    jumpToPercentHorizontal: function (a) {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToPercentHorizontal.call(this, a)
    },
    jumpToPercentBothDirection: function (a) {
        this.doLayout();
        ccui.ScrollView.prototype.jumpToPercentBothDirection.call(this,
            a)
    },
    jumpToItem: function (a, b, d) {
        if (a = this.getItem(a))this.doLayout(), b = this._calculateItemDestination(b, a, d), this.bounceEnabled || (d = cc.pSub(b, this._innerContainer.getPosition()), d = this._getHowMuchOutOfBoundary(d), b.x += d.x, b.y += d.y), this._jumpToDestination(b)
    },
    scrollToItem: function (a, b, d, e) {
        void 0 === e && (e = 1);
        if (a = this.getItem(a))b = this._calculateItemDestination(b, a, d), this._startAutoScrollToDestination(b, e, !0)
    },
    requestRefreshView: function () {
        this._refreshViewDirty = !0
    },
    refreshView: function () {
        this.forceDoLayout()
    },
    doLayout: function () {
        this._doLayout()
    },
    requestDoLayout: function () {
        this._refreshViewDirty = !0
    },
    _doLayout: function () {
        if (this._refreshViewDirty) {
            for (var a = this._items, b = 0; b < a.length; b++) {
                var d = a[b];
                d.setLocalZOrder(b);
                this._remedyLayoutParameter(d)
            }
            this._updateInnerContainerSize();
            this._innerContainer.forceDoLayout();
            this._refreshViewDirty = !1
        }
    },
    addEventListenerListView: function (a, b) {
        this._listViewEventListener = b;
        this._listViewEventSelector = a
    },
    _selectedItemEvent: function (a) {
        a = a === ccui.Widget.TOUCH_BEGAN ?
            ccui.ListView.ON_SELECTED_ITEM_START : ccui.ListView.ON_SELECTED_ITEM_END;
        this._listViewEventSelector && (this._listViewEventListener ? this._listViewEventSelector.call(this._listViewEventListener, this, a) : this._listViewEventSelector(this, a));
        this._ccEventCallback && this._ccEventCallback(this, a)
    },
    interceptTouchEvent: function (a, b, d) {
        ccui.ScrollView.prototype.interceptTouchEvent.call(this, a, b, d);
        if (this._touchEnabled && a !== ccui.Widget.TOUCH_MOVED) {
            for (d = b; d;) {
                if (d && d.getParent() === this._innerContainer) {
                    this._curSelectedIndex =
                        this.getIndex(d);
                    break
                }
                d = d.getParent()
            }
            b.isHighlighted() && this._selectedItemEvent(a)
        }
    },
    getCurSelectedIndex: function () {
        return this._curSelectedIndex
    },
    _onSizeChanged: function () {
        ccui.ScrollView.prototype._onSizeChanged.call(this);
        this._refreshViewDirty = !0
    },
    getDescription: function () {
        return "ListView"
    },
    _createCloneInstance: function () {
        return new ccui.ListView
    },
    _copyClonedWidgetChildren: function (a) {
        a = a.getItems();
        for (var b = 0; b < a.length; b++)this.pushBackCustomItem(a[b].clone())
    },
    _copySpecialProperties: function (a) {
        a instanceof ccui.ListView && (ccui.ScrollView.prototype._copySpecialProperties.call(this, a), this.setItemModel(a._model), this.setItemsMargin(a._itemsMargin), this.setGravity(a._gravity), this._listViewEventListener = a._listViewEventListener, this._listViewEventSelector = a._listViewEventSelector)
    },
    _startAttenuatingAutoScroll: function (a, b) {
        var d = a;
        if (0 !== this._items.length && this._magneticType !== ccui.ListView.MAGNETIC_NONE) {
            var d = this._flattenVectorByDirection(d), e = this._getHowMuchOutOfBoundary(d);
            if (0 === e.x && 0 === e.y) {
                e =
                    this._magneticType;
                e === ccui.ListView.MAGNETIC_BOTH_END && (this._direction === ccui.ScrollView.DIR_HORIZONTAL ? e = 0 < d.x ? ccui.ListView.MAGNETIC_LEFT : ccui.ListView.MAGNETIC_RIGHT : this._direction === ccui.ScrollView.DIR_VERTICAL && (e = 0 < d.y ? ccui.ListView.MAGNETIC_BOTTOM : ccui.ListView.MAGNETIC_TOP));
                var f = this._getAnchorPointByMagneticType(e), e = cc.pMult(this._innerContainer.getPosition(), -1);
                e.x += this.width * f.x;
                e.y += this.height * f.y;
                d = this.getClosestItemToPosition(cc.pSub(e, d), f);
                d = this._calculateItemPositionWithAnchor(d,
                    f);
                d = cc.pSub(e, d)
            }
        }
        ccui.ScrollView.prototype._startAttenuatingAutoScroll.call(this, d, b)
    },
    _getAnchorPointByMagneticType: function (a) {
        switch (a) {
            case ccui.ListView.MAGNETIC_BOTH_END:
                return cc.p(0, 1);
            case ccui.ListView.MAGNETIC_CENTER:
                return cc.p(0.5, 0.5);
            case ccui.ListView.MAGNETIC_LEFT:
                return cc.p(0, 0.5);
            case ccui.ListView.MAGNETIC_RIGHT:
                return cc.p(1, 0.5);
            case ccui.ListView.MAGNETIC_TOP:
                return cc.p(0.5, 1);
            case ccui.ListView.MAGNETIC_BOTTOM:
                return cc.p(0.5, 0)
        }
        return cc.p(0, 0)
    },
    _startMagneticScroll: function () {
        if (0 !==
            this._items.length && this._magneticType !== ccui.ListView.MAGNETIC_NONE) {
            var a = this._getAnchorPointByMagneticType(this._magneticType), b = cc.pMult(this._innerContainer.getPosition(), -1);
            b.x += this.width * a.x;
            b.y += this.height * a.y;
            b = this.getClosestItemToPosition(b, a);
            this.scrollToItem(this.getIndex(b), a, a)
        }
    }
});
ccui.ListView.create = function () {
    return new ccui.ListView
};
ccui.ListView.EVENT_SELECTED_ITEM = 0;
ccui.ListView.ON_SELECTED_ITEM_START = 0;
ccui.ListView.ON_SELECTED_ITEM_END = 1;
ccui.ListView.GRAVITY_LEFT = 0;
ccui.ListView.GRAVITY_RIGHT = 1;
ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2;
ccui.ListView.GRAVITY_TOP = 3;
ccui.ListView.GRAVITY_BOTTOM = 4;
ccui.ListView.GRAVITY_CENTER_VERTICAL = 5;
ccui.ListView.MAGNETIC_NONE = 0;
ccui.ListView.MAGNETIC_CENTER = 1;
ccui.ListView.MAGNETIC_BOTH_END = 2;
ccui.ListView.MAGNETIC_LEFT = 3;
ccui.ListView.MAGNETIC_RIGHT = 4;
ccui.ListView.MAGNETIC_TOP = 5;
ccui.ListView.MAGNETIC_BOTTOM = 6;
ccui.PageView = ccui.ListView.extend({
    _curPageIdx: 0,
    _childFocusCancelOffset: 0,
    _pageViewEventListener: null,
    _pageViewEventSelector: null,
    _className: "PageView",
    _indicator: null,
    _indicatorPositionAsAnchorPoint: null,
    ctor: function () {
        ccui.ListView.prototype.ctor.call(this);
        this._childFocusCancelOffset = 5;
        this._indicatorPositionAsAnchorPoint = cc.p(0.5, 0.1);
        this._pageViewEventSelector = this._pageViewEventListener = null;
        this.setDirection(ccui.ScrollView.DIR_HORIZONTAL);
        this.setMagneticType(ccui.ListView.MAGNETIC_CENTER);
        this.setScrollBarEnabled(!1)
    },
    addWidgetToPage: function (a, b, d) {
        this.insertCustomItem(a, b)
    },
    addPage: function (a) {
        this.pushBackCustomItem(a)
    },
    insertPage: function (a, b) {
        this.insertCustomItem(a, b)
    },
    removePage: function (a) {
        this.removeItem(this.getIndex(a))
    },
    removePageAtIndex: function (a) {
        this.removeItem(a)
    },
    removeAllPages: function () {
        this.removeAllItems()
    },
    scrollToItem: function (a) {
        ccui.ListView.prototype.scrollToItem.call(this, a, cc.p(0.5, 0.5), cc.p(0.5, 0.5))
    },
    scrollToPage: function (a) {
        this.scrollToItem(a)
    },
    _doLayout: function () {
        if (this._refreshViewDirty) {
            ccui.ListView.prototype._doLayout.call(this);
            if (this._indicator) {
                var a = this.getIndex(this.getCenterItemInCurrentView());
                this._indicator.indicate(a)
            }
            this._refreshViewDirty = !1
        }
    },
    setDirection: function (a) {
        ccui.ListView.prototype.setDirection.call(this, a);
        a === ccui.ScrollView.DIR_HORIZONTAL ? this._indicatorPositionAsAnchorPoint = cc.p(0.5, 0.1) : a === ccui.ScrollView.DIR_VERTICAL && (this._indicatorPositionAsAnchorPoint = cc.p(0.1, 0.5));
        this._indicator && (this._indicator.setDirection(a), this._refreshIndicatorPosition())
    },
    setCustomScrollThreshold: function (a) {
    },
    getCustomScrollThreshold: function () {
        return 0
    },
    setUsingCustomScrollThreshold: function (a) {
    },
    isUsingCustomScrollThreshold: function () {
        return !1
    },
    _moveInnerContainer: function (a, b) {
        ccui.ListView.prototype._moveInnerContainer.call(this, a, b);
        this._curPageIdx = this.getIndex(this.getCenterItemInCurrentView());
        this._indicator && this._indicator.indicate(this._curPageIdx)
    },
    _onItemListChanged: function () {
        ccui.ListView.prototype._onItemListChanged.call(this);
        this._indicator && this._indicator.reset(this._items.length)
    },
    _onSizeChanged: function () {
        ccui.ListView.prototype._onSizeChanged.call(this);
        this._refreshIndicatorPosition()
    },
    _remedyLayoutParameter: function (a) {
        a.setContentSize(this.getContentSize());
        ccui.ListView.prototype._remedyLayoutParameter.call(this, a)
    },
    _refreshIndicatorPosition: function () {
        if (this._indicator) {
            var a = this.getContentSize();
            this._indicator.setPosition(cc.p(a.width * this._indicatorPositionAsAnchorPoint.x, a.height * this._indicatorPositionAsAnchorPoint.y))
        }
    },
    _handleReleaseLogic: function (a) {
        ccui.ScrollView.prototype._handleReleaseLogic.call(this,
            a);
        if (!(0 >= this._items.length))if (a = this._flattenVectorByDirection(this._calculateTouchMoveVelocity()), 500 > cc.pLength(a))this._startMagneticScroll(); else {
            var b = this.getItem(this._curPageIdx), b = this._calculateItemDestination(cc.p(0.5, 0.5), b, cc.p(0.5, 0.5)), b = cc.pSub(b, this.getInnerContainerPosition()), b = this._flattenVectorByDirection(b);
            0 < a.x * b.x || 0 < a.y * b.y ? this._startMagneticScroll() : (0 > a.x || 0 < a.y ? ++this._curPageIdx : --this._curPageIdx, this._curPageIdx = Math.min(this._curPageIdx, this._items.length),
                this._curPageIdx = Math.max(this._curPageIdx, 0), this.scrollToItem(this._curPageIdx))
        }
    },
    _getAutoScrollStopEpsilon: function () {
        return 0.001
    },
    _pageTurningEvent: function () {
        this._pageViewEventSelector && (this._pageViewEventListener ? this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING) : this._pageViewEventSelector(this, ccui.PageView.EVENT_TURNING));
        this._ccEventCallback && this._ccEventCallback(this, ccui.PageView.EVENT_TURNING)
    },
    addEventListenerPageView: function (a, b) {
        this._pageViewEventSelector =
            a;
        this._pageViewEventListener = b
    },
    addEventListener: function (a) {
        this._ccEventCallback = function (b, d) {
            d == ccui.ScrollView.EVENT_AUTOSCROLL_ENDED && a(this, d)
        }
    },
    setCurrentPageIndex: function (a) {
        this.jumpToItem(a, cc.p(0.5, 0.5), cc.p(0.5, 0.5))
    },
    setCurPageIndex: function (a) {
        this.setCurrentPageIndex(a)
    },
    getCurrentPageIndex: function () {
        return this._curPageIdx
    },
    getCurPageIndex: function () {
        var a = this.getCenterItemInCurrentView();
        return this.getIndex(a)
    },
    getPages: function () {
        return this.getItems()
    },
    getPage: function (a) {
        return this.getItem(a)
    },
    getDescription: function () {
        return "PageView"
    },
    _createCloneInstance: function () {
        return new ccui.PageView
    },
    _copyClonedWidgetChildren: function (a) {
        a = a.getPages();
        for (var b = 0; b < a.length; b++)this.addPage(a[b].clone())
    },
    _copySpecialProperties: function (a) {
        ccui.ListView.prototype._copySpecialProperties.call(this, a);
        this._ccEventCallback = a._ccEventCallback;
        this._pageViewEventListener = a._pageViewEventListener;
        this._pageViewEventSelector = a._pageViewEventSelector;
        this._customScrollThreshold = a._customScrollThreshold
    },
    setIndicatorEnabled: function (a) {
        a != (null !== this._indicator) && (a ? (this._indicator = new ccui.PageViewIndicator, this._indicator.setDirection(this.getDirection()), this.addProtectedChild(this._indicator, 1E4), this.setIndicatorSelectedIndexColor(cc.color(100, 100, 255)), this._refreshIndicatorPosition()) : (this.removeProtectedChild(this._indicator), this._indicator = null))
    },
    getIndicatorEnabled: function () {
        return null !== this._indicator
    },
    setIndicatorPositionAsAnchorPoint: function (a) {
        this._indicatorPositionAsAnchorPoint =
            a;
        this._refreshIndicatorPosition()
    },
    getIndicatorPositionAsAnchorPoint: function () {
        return this._indicatorPositionAsAnchorPoint
    },
    setIndicatorPosition: function (a) {
        if (this._indicator) {
            var b = this.getContentSize();
            this._indicatorPositionAsAnchorPoint.x = a.x / b.width;
            this._indicatorPositionAsAnchorPoint.y = a.y / b.height;
            this._indicator.setPosition(a)
        }
    },
    getIndicatorPosition: function () {
        cc.assert(null !== this._indicator, "");
        return this._indicator.getPosition()
    },
    setIndicatorSpaceBetweenIndexNodes: function (a) {
        this._indicator &&
        this._indicator.setSpaceBetweenIndexNodes(a)
    },
    getIndicatorSpaceBetweenIndexNodes: function () {
        cc.assert(null !== this._indicator, "");
        return this._indicator.getSpaceBetweenIndexNodes()
    },
    setIndicatorSelectedIndexColor: function (a) {
        this._indicator && this._indicator.setSelectedIndexColor(a)
    },
    getIndicatorSelectedIndexColor: function () {
        cc.assert(null !== this._indicator, "");
        return this._indicator.getSelectedIndexColor()
    }
});
ccui.PageView.create = function () {
    return new ccui.PageView
};
ccui.PageView.EVENT_TURNING = 0;
ccui.PageView.TOUCH_DIR_LEFT = 0;
ccui.PageView.TOUCH_DIR_RIGHT = 1;
ccui.PageView.DIRECTION_LEFT = 0;
ccui.PageView.DIRECTION_RIGHT = 1;
ccui.PageViewIndicator = ccui.ProtectedNode.extend({
    _direction: null,
    _indexNodes: null,
    _currentIndexNode: null,
    _spaceBetweenIndexNodes: 0,
    _className: "PageViewIndicator",
    ctor: function () {
        cc.ProtectedNode.prototype.ctor.call(this);
        this._direction = ccui.ScrollView.DIR_HORIZONTAL;
        this._indexNodes = [];
        this._spaceBetweenIndexNodes = ccui.PageViewIndicator.SPACE_BETWEEN_INDEX_NODES_DEFAULT;
        var a = new Image;
        a.src = ccui.PageViewIndicator.CIRCLE_IMAGE;
        this._currentIndexNode = new cc.Sprite(a);
        this._currentIndexNode.setVisible(!1);
        this.addProtectedChild(this._currentIndexNode, 1)
    },
    setDirection: function (a) {
        this._direction = a;
        this._rearrange()
    },
    reset: function (a) {
        for (; this._indexNodes.length < a;)this._increaseNumberOfPages();
        for (; this._indexNodes.length > a;)this._decreaseNumberOfPages();
        this._rearrange();
        this._currentIndexNode.setVisible(0 < this._indexNodes.length)
    },
    indicate: function (a) {
        0 > a || a >= this._indexNodes.length || this._currentIndexNode.setPosition(this._indexNodes[a].getPosition())
    },
    _rearrange: function () {
        if (0 !== this._indexNodes.length)for (var a =
            this._direction === ccui.ScrollView.DIR_HORIZONTAL, b = this._indexNodes[0].getContentSize(), d = a ? b.width : b.height, e = this._indexNodes.length, e = -((d * e + this._spaceBetweenIndexNodes * (e - 1)) / 2) + d / 2, f = 0; f < this._indexNodes.length; ++f) {
            var g;
            g = a ? cc.p(e, b.height / 2) : cc.p(b.width / 2, -e);
            this._indexNodes[f].setPosition(g);
            e += d + this._spaceBetweenIndexNodes
        }
    },
    setSpaceBetweenIndexNodes: function (a) {
        this._spaceBetweenIndexNodes !== a && (this._spaceBetweenIndexNodes = a, this._rearrange())
    },
    getSpaceBetweenIndexNodes: function () {
        return this._spaceBetweenIndexNodes
    },
    setSelectedIndexColor: function (a) {
        this._currentIndexNode.setColor(a)
    },
    getSelectedIndexColor: function () {
        return this._currentIndexNode.getColor()
    },
    _increaseNumberOfPages: function () {
        var a = new Image;
        a.src = ccui.PageViewIndicator.CIRCLE_IMAGE;
        a = new cc.Sprite(a);
        this.addProtectedChild(a);
        this._indexNodes.push(a)
    },
    _decreaseNumberOfPages: function () {
        0 !== this._indexNodes.length && (this.removeProtectedChild(this._indexNodes[0]), this._indexNodes.splice(0, 1))
    },
    clear: function () {
        for (var a = 0; a < this._indexNodes.length; ++a)this.removeProtectedChild(this._indexNodes[a]);
        this._indexNodes.length = 0;
        this._currentIndexNode.setVisible(!1)
    }
});
_p = ccui.PageViewIndicator.prototype;
cc.defineGetterSetter(_p, "spaceBetweenIndexNodes", _p.getSpaceBetweenIndexNodes, _p.setSpaceBetweenIndexNodes);
ccui.PageViewIndicator.SPACE_BETWEEN_INDEX_NODES_DEFAULT = 23;
ccui.PageViewIndicator.CIRCLE_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAA8ElEQVRIx62VyRGCQBBF+6gWRCEmYDIQkhiBCgHhSclC8YqWzOV5oVzKAYZp3r1/9fpbxAIBMTsKrjx5cqVgR0wgLhCRUWOjJiPqD56xoaGPhpRZV/iSEy6crHmw5oIrF9b/lVeMofrJgjlnxlIy/wik+JB+mme8BExbBhm+5CJC2LE2LtSEQoyGWDioBA5CoRIohJtK4CYDxzNEM4GAugR1E9VjVC+SZpXvhCJCrjomESLvc17pDGX7bWmlh6UtpjPVCWy9zaJ0TD7qfm3pwERMz2trRVZk3K3BD/L34AY+dEDCniMVBkPFkT2J/b2/AIV+dRpFLOYoAAAAAElFTkSuQmCC";
(function () {
    if (ccui.ProtectedNode.CanvasRenderCmd) {
        ccui.ScrollView.CanvasRenderCmd = function (a) {
            ccui.Layout.CanvasRenderCmd.call(this, a);
            this._needDraw = !0;
            this._dirty = !1
        };
        var a = ccui.ScrollView.CanvasRenderCmd.prototype = Object.create(ccui.Layout.CanvasRenderCmd.prototype);
        a.constructor = ccui.ScrollView.CanvasRenderCmd;
        a.visit = function (a) {
            var d = this._node;
            d._visible && (d = d.__instanceId, cc.renderer.pushRenderCommand(this), cc.renderer._turnToCacheMode(d), ccui.Layout.CanvasRenderCmd.prototype.visit.call(this,
                a), this._dirtyFlag = 0, cc.renderer._turnToNormalMode())
        };
        a.rendering = function (a) {
            var d = cc.renderer._cacheToCanvasCmds[this._node.__instanceId], e, f = cc.view.getScaleX(), g = cc.view.getScaleY(), h = a || cc._renderContext;
            h.computeRealOffsetY();
            a = 0;
            for (e = d.length; a < e; a++) {
                var n = d[a]._node;
                n instanceof ccui.ScrollView || n && n._parent && !1 === n._parent._inViewRect || d[a].rendering(h, f, g)
            }
        }
    }
})();
(function () {
    if (ccui.ProtectedNode.WebGLRenderCmd) {
        ccui.ScrollView.WebGLRenderCmd = function (a) {
            ccui.Layout.WebGLRenderCmd.call(this, a);
            this._needDraw = !0;
            this._dirty = !1
        };
        var a = ccui.ScrollView.WebGLRenderCmd.prototype = Object.create(ccui.Layout.WebGLRenderCmd.prototype);
        a.constructor = ccui.ScrollView.WebGLRenderCmd;
        a.visit = function (a) {
            var d = this._node;
            if (d._visible) {
                var e = this._node.__instanceId;
                cc.renderer.pushRenderCommand(this);
                cc.renderer._turnToCacheMode(e);
                ccui.Layout.WebGLRenderCmd.prototype.visit.call(this,
                    a);
                d.updateChildren();
                this._dirtyFlag = 0;
                cc.renderer._turnToNormalMode()
            }
        };
        a.rendering = function (a) {
            var d = cc.renderer._cacheToBufferCmds[this._node.__instanceId], e, f, g = a || cc._renderContext;
            if (d)for (a = 0, e = d.length; a < e; a++)f = d[a]._node, f instanceof ccui.ScrollView || f && f._parent && !1 === f._parent._inViewRect || d[a].rendering(g)
        }
    }
})();
cc.Component = cc.Class.extend({
    _owner: null, _name: "", _enabled: !0, ctor: function () {
        this._owner = null;
        this._name = "";
        this._enabled = !0
    }, init: function () {
        return !0
    }, onEnter: function () {
    }, onExit: function () {
    }, update: function (a) {
    }, serialize: function (a) {
    }, isEnabled: function () {
        return this._enabled
    }, setEnabled: function (a) {
        this._enabled = a
    }, getName: function () {
        return this._name
    }, setName: function (a) {
        this._name = a
    }, setOwner: function (a) {
        this._owner = a
    }, getOwner: function () {
        return this._owner
    }
});
cc.Component.create = function () {
    return new cc.Component
};
cc.ComponentContainer = cc.Class.extend({
    _components: null, _owner: null, ctor: function (a) {
        this._components = null;
        this._owner = a
    }, getComponent: function (a) {
        if (!a)throw Error("cc.ComponentContainer.getComponent(): name should be non-null");
        a = a.trim();
        this._components || (this._components = {});
        return this._components[a]
    }, add: function (a) {
        if (!a)throw Error("cc.ComponentContainer.add(): component should be non-null");
        if (a.getOwner())return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"),
            !1;
        null == this._components && (this._components = {}, this._owner.scheduleUpdate());
        if (this._components[a.getName()])return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        a.setOwner(this._owner);
        this._components[a.getName()] = a;
        a.onEnter();
        return !0
    }, remove: function (a) {
        if (!a)throw Error("cc.ComponentContainer.remove(): name should be non-null");
        if (!this._components)return !1;
        if (a instanceof cc.Component)return this._removeByComponent(a);
        a = a.trim();
        return this._removeByComponent(this._components[a])
    },
    _removeByComponent: function (a) {
        if (!a)return !1;
        a.onExit();
        a.setOwner(null);
        delete this._components[a.getName()];
        return !0
    }, removeAll: function () {
        if (this._components) {
            var a = this._components, b;
            for (b in a) {
                var d = a[b];
                d.onExit();
                d.setOwner(null);
                delete a[b]
            }
            this._owner.unscheduleUpdate();
            this._components = null
        }
    }, _alloc: function () {
        this._components = {}
    }, visit: function (a) {
        if (this._components) {
            var b = this._components, d;
            for (d in b)b[d].update(a)
        }
    }, isEmpty: function () {
        return this._components ? 0 === this._components.length :
            !0
    }
});
ccui.LayoutComponent_ReferencePoint = {BOTTOM_LEFT: 0, TOP_LEFT: 1, BOTTOM_RIGHT: 2, TOP_RIGHT: 3};
ccui.LayoutComponent_PositionType = {
    Position: 0,
    RelativePosition: 1,
    PreRelativePosition: 2,
    PreRelativePositionEnable: 3
};
ccui.LayoutComponent_SizeType = {Size: 0, PreSize: 1, PreSizeEnable: 2};
ccui.LayoutComponent = cc.Component.extend({
    _horizontalEdge: 0,
    _verticalEdge: 0,
    _leftMargin: 0,
    _rightMargin: 0,
    _bottomMargin: 0,
    _topMargin: 0,
    _usingPositionPercentX: !1,
    _positionPercentX: 0,
    _usingPositionPercentY: !1,
    _positionPercentY: 0,
    _usingStretchWidth: !1,
    _usingStretchHeight: !1,
    _percentWidth: 0,
    _usingPercentWidth: !1,
    _percentHeight: 0,
    _usingPercentHeight: !1,
    _actived: !0,
    _isPercentOnly: !1,
    ctor: function () {
        this._name = ccui.LayoutComponent.NAME
    },
    init: function () {
        return cc.Component.prototype.init.call(this) ? !0 : !1
    },
    getPercentContentSize: function () {
        return cc.p(this._percentWidth, this._percentHeight)
    },
    setPercentContentSize: function (a) {
        this.setPercentWidth(a.x);
        this.setPercentHeight(a.y)
    },
    setUsingPercentContentSize: function (a) {
        this._usingPercentWidth = this._usingPercentHeight = a
    },
    SetActiveEnable: function (a) {
        this._actived = a
    },
    getUsingPercentContentSize: function () {
        return this._usingPercentWidth && this._usingPercentHeight
    },
    getAnchorPosition: function () {
        return this._owner.getAnchorPoint()
    },
    setAnchorPosition: function (a,
                                 b) {
        var d = this._owner.getBoundingBox();
        this._owner.setAnchorPoint(a, b);
        var e = this._owner.getBoundingBox(), f = d.x - e.x, d = d.y - e.y, e = this._owner.getPosition();
        e.x += f;
        e.y += d;
        this.setPosition(e)
    },
    getPosition: function () {
        return this._owner.getPosition()
    },
    setPosition: function (a, b) {
        var d = this._getOwnerParent(), e;
        null != d ? (void 0 === b ? (e = a.x, b = a.y) : e = a, d = d.getContentSize(), 0 !== d.width ? this._positionPercentX = e / d.width : (this._positionPercentX = 0, this._usingPositionPercentX && (e = 0)), 0 !== d.height ? this._positionPercentY =
            b / d.height : (this._positionPercentY = 0, this._usingPositionPercentY && (b = 0)), this._owner.setPosition(e, b), this._refreshHorizontalMargin(), this._refreshVerticalMargin()) : this._owner.setPosition(a, b)
    },
    isPositionPercentXEnabled: function () {
        return this._usingPositionPercentX
    },
    setPositionPercentXEnabled: function (a) {
        if (this._usingPositionPercentX = a)this._horizontalEdge = ccui.LayoutComponent.horizontalEdge.NONE
    },
    getPositionPercentX: function () {
        return this._positionPercentX
    },
    setPositionPercentX: function (a) {
        this._positionPercentX =
            a;
        a = this._getOwnerParent();
        null !== a && (this._owner.setPositionX(a.width * this._positionPercentX), this._refreshHorizontalMargin())
    },
    isPositionPercentYEnabled: function () {
        return this._usingPositionPercentY
    },
    setPositionPercentYEnabled: function (a) {
        if (this._usingPositionPercentY = a)this._verticalEdge = ccui.LayoutComponent.verticalEdge.NONE
    },
    getPositionPercentY: function () {
        return this._positionPercentY
    },
    setPositionPercentY: function (a) {
        this._positionPercentY = a;
        a = this._getOwnerParent();
        null !== a && (this._owner.setPositionY(a.height *
            this._positionPercentY), this._refreshVerticalMargin())
    },
    getHorizontalEdge: function () {
        return this._horizontalEdge
    },
    setHorizontalEdge: function (a) {
        this._horizontalEdge = a;
        this._horizontalEdge !== ccui.LayoutComponent.horizontalEdge.NONE && (this._usingPositionPercentX = !1);
        var b = this._getOwnerParent();
        null !== b && (a = this._owner.getPosition(), b = b.getContentSize(), 0 !== b.width ? this._positionPercentX = a.x / b.width : (this._positionPercentX = 0, a.x = 0, this._usingPositionPercentX && this._owner.setPosition(a)), this._refreshHorizontalMargin())
    },
    getVerticalEdge: function () {
        return this._verticalEdge
    },
    setVerticalEdge: function (a) {
        this._verticalEdge = a;
        this._verticalEdge !== ccui.LayoutComponent.verticalEdge.NONE && (this._usingPositionPercentY = !1);
        var b = this._getOwnerParent();
        null !== b && (a = this._owner.getPosition(), b = b.getContentSize(), 0 !== b.height ? this._positionPercentY = a.y / b.height : (this._positionPercentY = 0, a.y = 0, this._usingPositionPercentY && this._owner.setPosition(a)), this._refreshVerticalMargin())
    },
    getLeftMargin: function () {
        return this._leftMargin
    },
    setLeftMargin: function (a) {
        this._leftMargin = a
    },
    getRightMargin: function () {
        return this._rightMargin
    },
    setRightMargin: function (a) {
        this._rightMargin = a
    },
    getTopMargin: function () {
        return this._topMargin
    },
    setTopMargin: function (a) {
        this._topMargin = a
    },
    getBottomMargin: function () {
        return this._bottomMargin
    },
    setBottomMargin: function (a) {
        this._bottomMargin = a
    },
    getSize: function () {
        return this.getOwner().getContentSize()
    },
    setSize: function (a) {
        var b = this._getOwnerParent();
        null !== b ? (b = b.getContentSize(), 0 !== b.width ? this._percentWidth =
            a.width / b.width : (this._percentWidth = 0, this._usingPercentWidth && (a.width = 0)), 0 !== b.height ? this._percentHeight = a.height / b.height : (this._percentHeight = 0, this._usingPercentHeight && (a.height = 0)), this._owner.setContentSize(a), this._refreshHorizontalMargin(), this._refreshVerticalMargin()) : this._owner.setContentSize(a)
    },
    isPercentWidthEnabled: function () {
        return this._usingPercentWidth
    },
    setPercentWidthEnabled: function (a) {
        if (this._usingPercentWidth = a)this._usingStretchWidth = !1
    },
    getSizeWidth: function () {
        return this._owner.width
    },
    setSizeWidth: function (a) {
        var b = this._owner.getContentSize();
        b.width = a;
        a = this._getOwnerParent();
        null !== a ? (a = a.getContentSize(), 0 !== a.width ? this._percentWidth = b.width / a.width : (this._percentWidth = 0, this._usingPercentWidth && (b.width = 0)), this._owner.setContentSize(b), this._refreshHorizontalMargin()) : this._owner.setContentSize(b)
    },
    getPercentWidth: function () {
        return this._percentWidth
    },
    setPercentWidth: function (a) {
        this._percentWidth = a;
        a = this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getContentSize();
            b.width = a.width * this._percentWidth;
            this._owner.setContentSize(b);
            this._refreshHorizontalMargin()
        }
    },
    isPercentHeightEnabled: function () {
        return this._usingPercentHeight
    },
    setPercentHeightEnabled: function (a) {
        if (this._usingPercentHeight = a)this._usingStretchHeight = !1
    },
    getSizeHeight: function () {
        return this._owner.height
    },
    setSizeHeight: function (a) {
        var b = this._owner.getContentSize();
        b.height = a;
        a = this._getOwnerParent();
        null !== a ? (a = a.getContentSize(), 0 !== a.height ? this._percentHeight = b.height / a.height : (this._percentHeight =
            0, this._usingPercentHeight && (b.height = 0)), this._owner.setContentSize(b), this._refreshVerticalMargin()) : this._owner.setContentSize(b)
    },
    getPercentHeight: function () {
        return this._percentHeight
    },
    setPercentHeight: function (a) {
        this._percentHeight = a;
        a = this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getContentSize();
            b.height = a.height * this._percentHeight;
            this._owner.setContentSize(b);
            this._refreshVerticalMargin()
        }
    },
    isStretchWidthEnabled: function () {
        return this._usingStretchWidth
    },
    setStretchWidthEnabled: function (a) {
        if (this._usingStretchWidth =
                a)this._usingPercentWidth = !1
    },
    isStretchHeightEnabled: function () {
        return this._usingStretchHeight
    },
    setStretchHeightEnabled: function (a) {
        if (this._usingStretchHeight = a)this._usingPercentHeight = !1
    },
    setPercentOnlyEnabled: function (a) {
        this._isPercentOnly = a
    },
    setActiveEnabled: function (a) {
        this._actived = a
    },
    refreshLayout: function () {
        if (this._actived) {
            var a = this._getOwnerParent();
            if (null !== a) {
                var a = a.getContentSize(), b = this._owner, d = b.getAnchorPoint(), e = b.getContentSize(), f = b.getPosition();
                switch (this._horizontalEdge) {
                    case ccui.LayoutComponent.horizontalEdge.NONE:
                        this._usingStretchWidth && !this._isPercentOnly ? (e.width = a.width * this._percentWidth, f.x = this._leftMargin + d.x * e.width) : (this._usingPositionPercentX && (f.x = a.width * this._positionPercentX), this._usingPercentWidth && (e.width = a.width * this._percentWidth));
                        break;
                    case ccui.LayoutComponent.horizontalEdge.LEFT:
                        if (this._isPercentOnly)break;
                        if (this._usingPercentWidth || this._usingStretchWidth)e.width = a.width * this._percentWidth;
                        f.x = this._leftMargin + d.x * e.width;
                        break;
                    case ccui.LayoutComponent.horizontalEdge.RIGHT:
                        if (this._isPercentOnly)break;
                        if (this._usingPercentWidth || this._usingStretchWidth)e.width = a.width * this._percentWidth;
                        f.x = a.width - (this._rightMargin + (1 - d.x) * e.width);
                        break;
                    case ccui.LayoutComponent.horizontalEdge.CENTER:
                        if (this._isPercentOnly)break;
                        this._usingStretchWidth ? (e.width = a.width - this._leftMargin - this._rightMargin, 0 > e.width && (e.width = 0), f.x = this._leftMargin + d.x * e.width) : (this._usingPercentWidth && (e.width = a.width * this._percentWidth), f.x = a.width * this._positionPercentX)
                }
                switch (this._verticalEdge) {
                    case ccui.LayoutComponent.verticalEdge.NONE:
                        this._usingStretchHeight && !this._isPercentOnly ? (e.height = a.height * this._percentHeight, f.y = this._bottomMargin + d.y * e.height) : (this._usingPositionPercentY && (f.y = a.height * this._positionPercentY), this._usingPercentHeight && (e.height = a.height * this._percentHeight));
                        break;
                    case ccui.LayoutComponent.verticalEdge.BOTTOM:
                        if (this._isPercentOnly)break;
                        if (this._usingPercentHeight || this._usingStretchHeight)e.height = a.height * this._percentHeight;
                        f.y = this._bottomMargin + d.y * e.height;
                        break;
                    case ccui.LayoutComponent.verticalEdge.TOP:
                        if (this._isPercentOnly)break;
                        if (this._usingPercentHeight || this._usingStretchHeight)e.height = a.height * this._percentHeight;
                        f.y = a.height - (this._topMargin + (1 - d.y) * e.height);
                        break;
                    case ccui.LayoutComponent.verticalEdge.CENTER:
                        if (this._isPercentOnly)break;
                        this._usingStretchHeight ? (e.height = a.height - this._topMargin - this._bottomMargin, 0 > e.height && (e.height = 0), f.y = this._bottomMargin + d.y * e.height) : (this._usingPercentHeight && (e.height = a.height * this._percentHeight), f.y = a.height * this._positionPercentY)
                }
                b.setPosition(f);
                b.setContentSize(e);
                if (b instanceof ccui.PageView)for (b.forceDoLayout(), a = b.getPages(), b = 0; b < a.length; b++)ccui.helper.doLayout(a[b]); else ccui.helper.doLayout(b)
            }
        }
    },
    _getOwnerParent: function () {
        return this._owner ? this._owner.getParent() : null
    },
    _refreshHorizontalMargin: function () {
        var a = this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getPosition(), d = this._owner.getAnchorPoint(), e = this._owner.getContentSize(), a = a.getContentSize();
            this._leftMargin = b.x - d.x * e.width;
            this._rightMargin = a.width - (b.x + (1 - d.x) * e.width)
        }
    },
    _refreshVerticalMargin: function () {
        var a =
            this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getPosition(), d = this._owner.getAnchorPoint(), e = this._owner.getContentSize(), a = a.getContentSize();
            this._bottomMargin = b.y - d.y * e.height;
            this._topMargin = a.height - (b.y + (1 - d.y) * e.height)
        }
    }
});
ccui.LayoutComponent.horizontalEdge = {NONE: 0, LEFT: 1, RIGHT: 2, CENTER: 3};
ccui.LayoutComponent.verticalEdge = {NONE: 0, BOTTOM: 1, TOP: 2, CENTER: 3};
ccui.LayoutComponent.NAME = "__ui_layout";
ccui.LayoutComponent.bindLayoutComponent = function (a) {
    var b = a.getComponent(ccui.LayoutComponent.NAME);
    return void 0 !== b ? b : (b = new ccui.LayoutComponent) && b.init() ? (a.addComponent(b), b) : null
};
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class;
ccs.Class.extend = ccs.Class.extend || cc.Class.extend;
ccs.Node = ccs.Node || cc.Node;
ccs.Node.extend = ccs.Node.extend || cc.Node.extend;
ccs.Sprite = ccs.Sprite || cc.Sprite;
ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend;
ccs.Component = ccs.Component || cc.Component;
ccs.Component.extend = ccs.Component.extend || cc.Component.extend;
ccs.cocostudioVersion = "v1.3.0.0";
ccs.VERSION_COMBINED = 0.3;
ccs.VERSION_CHANGE_ROTATION_RANGE = 1;
ccs.VERSION_COLOR_READING = 1.1;
ccs.MAX_VERTEXZ_VALUE = 5E6;
ccs.ARMATURE_MAX_CHILD = 50;
ccs.ARMATURE_MAX_ZORDER = 100;
ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER;
ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = !1;
ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = !1;
ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = !1;
ccs.armatureVersion = function () {
    return "v1.1.0.0"
};
ccs.CONST_VERSION = "version";
ccs.CONST_VERSION_2_0 = 2;
ccs.CONST_VERSION_COMBINED = 0.3;
ccs.CONST_ARMATURES = "armatures";
ccs.CONST_ARMATURE = "armature";
ccs.CONST_BONE = "b";
ccs.CONST_DISPLAY = "d";
ccs.CONST_ANIMATIONS = "animations";
ccs.CONST_ANIMATION = "animation";
ccs.CONST_MOVEMENT = "mov";
ccs.CONST_FRAME = "f";
ccs.CONST_TEXTURE_ATLAS = "TextureAtlas";
ccs.CONST_SUB_TEXTURE = "SubTexture";
ccs.CONST_SKELETON = "skeleton";
ccs.CONST_A_NAME = "name";
ccs.CONST_A_DURATION = "dr";
ccs.CONST_A_FRAME_INDEX = "fi";
ccs.CONST_A_DURATION_TO = "to";
ccs.CONST_A_DURATION_TWEEN = "drTW";
ccs.CONST_A_LOOP = "lp";
ccs.CONST_A_MOVEMENT_SCALE = "sc";
ccs.CONST_A_MOVEMENT_DELAY = "dl";
ccs.CONST_A_DISPLAY_INDEX = "dI";
ccs.CONST_A_PLIST = "plist";
ccs.CONST_A_PARENT = "parent";
ccs.CONST_A_SKEW_X = "kX";
ccs.CONST_A_SKEW_Y = "kY";
ccs.CONST_A_SCALE_X = "cX";
ccs.CONST_A_SCALE_Y = "cY";
ccs.CONST_A_Z = "z";
ccs.CONST_A_EVENT = "evt";
ccs.CONST_A_SOUND = "sd";
ccs.CONST_A_SOUND_EFFECT = "sdE";
ccs.CONST_A_TWEEN_EASING = "twE";
ccs.CONST_A_EASING_PARAM = "twEP";
ccs.CONST_A_TWEEN_ROTATE = "twR";
ccs.CONST_A_IS_ARMATURE = "isArmature";
ccs.CONST_A_DISPLAY_TYPE = "displayType";
ccs.CONST_A_MOVEMENT = "mov";
ccs.CONST_A_X = "x";
ccs.CONST_A_Y = "y";
ccs.CONST_A_COCOS2DX_X = "cocos2d_x";
ccs.CONST_A_COCOS2DX_Y = "cocos2d_y";
ccs.CONST_A_WIDTH = "width";
ccs.CONST_A_HEIGHT = "height";
ccs.CONST_A_PIVOT_X = "pX";
ccs.CONST_A_PIVOT_Y = "pY";
ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX";
ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY";
ccs.CONST_A_BLEND_TYPE = "bd";
ccs.CONST_A_BLEND_SRC = "bd_src";
ccs.CONST_A_BLEND_DST = "bd_dst";
ccs.CONST_A_ALPHA = "a";
ccs.CONST_A_RED = "r";
ccs.CONST_A_GREEN = "g";
ccs.CONST_A_BLUE = "b";
ccs.CONST_A_ALPHA_OFFSET = "aM";
ccs.CONST_A_RED_OFFSET = "rM";
ccs.CONST_A_GREEN_OFFSET = "gM";
ccs.CONST_A_BLUE_OFFSET = "bM";
ccs.CONST_A_COLOR_TRANSFORM = "colorTransform";
ccs.CONST_A_TWEEN_FRAME = "tweenFrame";
ccs.CONST_CONTOUR = "con";
ccs.CONST_CONTOUR_VERTEX = "con_vt";
ccs.CONST_FL_NAN = "NaN";
ccs.CONST_FRAME_DATA = "frame_data";
ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data";
ccs.CONST_MOVEMENT_DATA = "mov_data";
ccs.CONST_ANIMATION_DATA = "animation_data";
ccs.CONST_DISPLAY_DATA = "display_data";
ccs.CONST_SKIN_DATA = "skin_data";
ccs.CONST_BONE_DATA = "bone_data";
ccs.CONST_ARMATURE_DATA = "armature_data";
ccs.CONST_CONTOUR_DATA = "contour_data";
ccs.CONST_TEXTURE_DATA = "texture_data";
ccs.CONST_VERTEX_POINT = "vertex";
ccs.CONST_COLOR_INFO = "color";
ccs.CONST_CONFIG_FILE_PATH = "config_file_path";
ccs.CONST_CONTENT_SCALE = "content_scale";
ccs.DataInfo = function () {
    this.asyncStruct = null;
    this.configFileQueue = [];
    this.contentScale = 1;
    this.baseFilePath = this.filename = "";
    this.cocoStudioVersion = this.flashToolVersion = 0
};
ccs.dataReaderHelper = {
    ConfigType: {DragonBone_XML: 0, CocoStudio_JSON: 1, CocoStudio_Binary: 2},
    _configFileList: [],
    _flashToolVersion: ccs.CONST_VERSION_2_0,
    _positionReadScale: 1,
    _asyncRefCount: 0,
    _asyncRefTotalCount: 0,
    _dataQueue: null,
    setPositionReadScale: function (a) {
        this._positionReadScale = a
    },
    getPositionReadScale: function () {
        return this._positionReadScale
    },
    addDataFromFile: function (a) {
        if (-1 === this._configFileList.indexOf(a)) {
            this._configFileList.push(a);
            var b = this._initBaseFilePath(a), d = cc.path.extname(a).toLowerCase(),
                e = new ccs.DataInfo;
            e.filename = a;
            e.basefilePath = b;
            ".xml" === d ? ccs.dataReaderHelper.addDataFromXML(a, e) : ".json" === d || ".exportjson" === d ? ccs.dataReaderHelper.addDataFromJson(a, e) : ".csb" === d && ccs.dataReaderHelper.addDataFromBinaryCache(a, e)
        }
    },
    addDataFromFileAsync: function (a, b, d, e, f) {
        if (-1 !== this._configFileList.indexOf(d))f && e && (0 === this._asyncRefTotalCount && 0 === this._asyncRefCount ? this._asyncCallBack(e, f, 1) : this._asyncCallBack(e, f, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount));
        else {
            this._asyncRefTotalCount++;
            this._asyncRefCount++;
            var g = this;
            cc.director.getScheduler().schedule(function () {
                g.addDataFromFile(d);
                g._asyncRefCount--;
                g._asyncCallBack(e, f, (g._asyncRefTotalCount - g._asyncRefCount) / g._asyncRefTotalCount)
            }, this, 0.1, !1, 0, !1, "armatrueDataHelper")
        }
    },
    removeConfigFile: function (a) {
        for (var b = this._configFileList, d = b.length, e = b[d], f = 0; f < d; f++)b[f] === a && (e = f);
        e !== b[d] && cc.arrayRemoveObject(b, a)
    },
    addDataFromCache: function (a, b) {
        if (a) {
            b.flashToolVersion = parseFloat(a.getAttribute(ccs.CONST_VERSION));
            var d = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ARMATURES + " \x3e  " + ccs.CONST_ARMATURE + ""), e = ccs.armatureDataManager, f;
            for (f = 0; f < d.length; f++) {
                var g = this.decodeArmature(d[f], b);
                e.addArmatureData(g.name, g, b.filename)
            }
            d = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ANIMATIONS + " \x3e  " + ccs.CONST_ANIMATION + "");
            for (f = 0; f < d.length; f++)g = this.decodeAnimation(d[f], b), e.addAnimationData(g.name, g, b.filename);
            d = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_TEXTURE_ATLAS +
                " \x3e  " + ccs.CONST_SUB_TEXTURE + "");
            for (f = 0; f < d.length; f++)g = this.decodeTexture(d[f], b), e.addTextureData(g.name, g, b.filename)
        } else cc.log("XML error  or  XML is empty.")
    },
    decodeArmature: function (a, b) {
        var d = new ccs.ArmatureData;
        d.init();
        d.name = a.getAttribute(ccs.CONST_A_NAME);
        for (var e = a.querySelectorAll(ccs.CONST_ARMATURE + " \x3e " + ccs.CONST_BONE), f = 0; f < e.length; f++) {
            var g = e[f], h = g.getAttribute(ccs.CONST_A_PARENT), n = null;
            if (h)for (var p = 0; p < e.length && (n = e[p], h != e[p].getAttribute(ccs.CONST_A_NAME)); p++);
            g = this.decodeBone(g, n, b);
            d.addBoneData(g)
        }
        return d
    },
    decodeArmatureFromJSON: function (a, b) {
        var d = new ccs.ArmatureData;
        d.init();
        var e = a[ccs.CONST_A_NAME];
        e && (d.name = e);
        b.cocoStudioVersion = d.dataVersion = a[ccs.CONST_VERSION] || 0.1;
        for (var e = a[ccs.CONST_BONE_DATA], f = 0; f < e.length; f++) {
            var g = this.decodeBoneFromJson(e[f], b);
            d.addBoneData(g)
        }
        return d
    },
    decodeBone: function (a, b, d) {
        b = new ccs.BoneData;
        b.init();
        b.name = a.getAttribute(ccs.CONST_A_NAME);
        b.parentName = a.getAttribute(ccs.CONST_A_PARENT) || "";
        b.zOrder = parseInt(a.getAttribute(ccs.CONST_A_Z)) ||
            0;
        a = a.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_DISPLAY);
        for (var e = 0; e < a.length; e++) {
            var f = this.decodeBoneDisplay(a[e], d);
            b.addDisplayData(f)
        }
        return b
    },
    decodeBoneFromJson: function (a, b) {
        var d = new ccs.BoneData;
        d.init();
        this.decodeNodeFromJson(d, a, b);
        d.name = a[ccs.CONST_A_NAME] || "";
        d.parentName = a[ccs.CONST_A_PARENT] || "";
        for (var e = a[ccs.CONST_DISPLAY_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeBoneDisplayFromJson(e[f], b);
            d.addDisplayData(g)
        }
        return d
    },
    decodeBoneDisplay: function (a, b) {
        var d = null;
        1 === (parseFloat(a.getAttribute(ccs.CONST_A_IS_ARMATURE)) || 0) ? (d = new ccs.ArmatureDisplayData, d.displayType = ccs.DISPLAY_TYPE_ARMATURE) : (d = new ccs.SpriteDisplayData, d.displayType = ccs.DISPLAY_TYPE_SPRITE);
        var e = a.getAttribute(ccs.CONST_A_NAME) || "";
        e && (d.displayName = e);
        return d
    },
    decodeBoneDisplayFromJson: function (a, b) {
        var d = a[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE, e = null;
        switch (d) {
            case ccs.DISPLAY_TYPE_SPRITE:
                var e = new ccs.SpriteDisplayData, f = a[ccs.CONST_A_NAME];
                null != f && (e.displayName = f);
                if (f = (a[ccs.CONST_SKIN_DATA] || [])[0]) {
                    var g = e.skinData;
                    g.x = f[ccs.CONST_A_X] * this._positionReadScale;
                    g.y = f[ccs.CONST_A_Y] * this._positionReadScale;
                    g.scaleX = null == f[ccs.CONST_A_SCALE_X] ? 1 : f[ccs.CONST_A_SCALE_X];
                    g.scaleY = null == f[ccs.CONST_A_SCALE_Y] ? 1 : f[ccs.CONST_A_SCALE_Y];
                    g.skewX = null == f[ccs.CONST_A_SKEW_X] ? 1 : f[ccs.CONST_A_SKEW_X];
                    g.skewY = null == f[ccs.CONST_A_SKEW_Y] ? 1 : f[ccs.CONST_A_SKEW_Y];
                    g.x *= b.contentScale;
                    g.y *= b.contentScale
                }
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                e = new ccs.ArmatureDisplayData;
                f = a[ccs.CONST_A_NAME];
                null != f && (e.displayName = a[ccs.CONST_A_NAME]);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                e = new ccs.ParticleDisplayData;
                f = a[ccs.CONST_A_PLIST];
                null != f && (e.displayName = b.asyncStruct ? b.asyncStruct.basefilePath + f : b.basefilePath + f);
                break;
            default:
                e = new ccs.SpriteDisplayData
        }
        e.displayType = d;
        return e
    },
    decodeAnimation: function (a, b) {
        var d = new ccs.AnimationData, e = a.getAttribute(ccs.CONST_A_NAME), f = ccs.armatureDataManager.getArmatureData(e);
        d.name = e;
        for (var e = a.querySelectorAll(ccs.CONST_ANIMATION + " \x3e " + ccs.CONST_MOVEMENT),
                 g = null, h = 0; h < e.length; h++)g = e[h], g = this.decodeMovement(g, f, b), d.addMovement(g);
        return d
    },
    decodeAnimationFromJson: function (a, b) {
        var d = new ccs.AnimationData;
        a[ccs.CONST_A_NAME] && (d.name = a[ccs.CONST_A_NAME]);
        for (var e = a[ccs.CONST_MOVEMENT_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeMovementFromJson(e[f], b);
            d.addMovement(g)
        }
        return d
    },
    decodeMovement: function (a, b, d) {
        var e = new ccs.MovementData;
        e.name = a.getAttribute(ccs.CONST_A_NAME);
        var f;
        f = 0;
        f = a.getAttribute(ccs.CONST_A_DURATION);
        e.duration = null == f ?
            0 : parseFloat(f);
        f = a.getAttribute(ccs.CONST_A_DURATION_TO);
        e.durationTo = null == f ? 0 : parseFloat(f);
        f = a.getAttribute(ccs.CONST_A_DURATION_TWEEN);
        e.durationTween = null == f ? 0 : parseFloat(f);
        f = a.getAttribute(ccs.CONST_A_LOOP);
        e.loop = f ? Boolean(parseFloat(f)) : !0;
        if (f = a.getAttribute(ccs.CONST_A_TWEEN_EASING))f != ccs.CONST_FL_NAN ? (f = null == f ? 0 : parseFloat(f), e.tweenEasing = 2 === f ? ccs.TweenType.SINE_EASEINOUT : f) : e.tweenEasing = ccs.TweenType.LINEAR;
        a = a.querySelectorAll(ccs.CONST_MOVEMENT + " \x3e " + ccs.CONST_BONE);
        var g =
            null;
        for (f = 0; f < a.length; f++) {
            var g = a[f], h = g.getAttribute(ccs.CONST_A_NAME);
            if (!e.getMovementBoneData(h)) {
                var h = b.getBoneData(h), n = h.parentName, p = null;
                if ("" !== n)for (var r = 0; r < a.length && (p = a[r], n !== p.getAttribute(ccs.CONST_A_NAME)); r++);
                g = this.decodeMovementBone(g, p, h, d);
                e.addMovementBoneData(g)
            }
        }
        return e
    },
    decodeMovementFromJson: function (a, b) {
        var d = new ccs.MovementData;
        d.loop = null == a[ccs.CONST_A_LOOP] ? !1 : a[ccs.CONST_A_LOOP];
        d.durationTween = a[ccs.CONST_A_DURATION_TWEEN] || 0;
        d.durationTo = a[ccs.CONST_A_DURATION_TO] ||
            0;
        d.duration = a[ccs.CONST_A_DURATION] || 0;
        d.scale = null == a[ccs.CONST_A_DURATION] ? 1 : null == a[ccs.CONST_A_MOVEMENT_SCALE] ? 1 : a[ccs.CONST_A_MOVEMENT_SCALE];
        d.tweenEasing = null == a[ccs.CONST_A_TWEEN_EASING] ? ccs.TweenType.LINEAR : a[ccs.CONST_A_TWEEN_EASING];
        var e = a[ccs.CONST_A_NAME];
        e && (d.name = e);
        for (var e = a[ccs.CONST_MOVEMENT_BONE_DATA] || [], f = 0; f < e.length; f++) {
            var g = this.decodeMovementBoneFromJson(e[f], b);
            d.addMovementBoneData(g)
        }
        return d
    },
    decodeMovementBone: function (a, b, d, e) {
        var f = new ccs.MovementBoneData;
        f.init();
        var g;
        a && (g = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0, f.scale = g, g = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0, 0 < g && (g -= 1), f.delay = g);
        var h = 0, n = g = 0, p = null, r = [];
        if (null != b) {
            for (var s = b.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME), h = 0; h < s.length; h++)r.push(s[h]);
            h = r.length
        }
        f.name = a.getAttribute(ccs.CONST_A_NAME);
        a = a.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME);
        for (var t = s = 0, v = 0; v < a.length; v++) {
            var u = a[v];
            if (b)for (; s < h && (p ? t < g || t >= g + n : 1);)p = r[s],
                g += n, n = parseFloat(p.getAttribute(ccs.CONST_A_DURATION)), s++;
            u = this.decodeFrame(u, p, d, e);
            f.addFrameData(u);
            u.frameID = t;
            t += u.duration;
            f.duration = t
        }
        b = f.frameList;
        d = Math.PI;
        for (h = b.length - 1; 0 <= h; h--)if (0 < h) {
            e = b[h].skewX - b[h - 1].skewX;
            g = b[h].skewY - b[h - 1].skewY;
            if (e < -d || e > d)b[h - 1].skewX = 0 > e ? b[h - 1].skewX - 2 * d : b[h - 1].skewX + 2 * d;
            if (g < -d || g > d)b[h - 1].skewY = 0 > g ? b[h - 1].skewY - 2 * d : b[h - 1].skewY + 2 * d
        }
        b = new ccs.FrameData;
        b.copy(f.frameList[f.frameList.length - 1]);
        b.frameID = f.duration;
        f.addFrameData(b);
        return f
    },
    decodeMovementBoneFromJson: function (a,
                                          b) {
        var d = new ccs.MovementBoneData;
        d.init();
        d.delay = a[ccs.CONST_A_MOVEMENT_DELAY] || 0;
        var e = a[ccs.CONST_A_NAME];
        e && (d.name = e);
        for (var f = (a[ccs.CONST_FRAME_DATA] || []).length, e = 0; e < f; e++) {
            var g = this.decodeFrameFromJson(a[ccs.CONST_FRAME_DATA][e], b);
            d.addFrameData(g);
            b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && (g.frameID = d.duration, d.duration += g.duration)
        }
        if (b.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE)for (f = d.frameList, g = Math.PI, e = f.length - 1; 0 <= e; e--)if (0 < e) {
            var h = f[e].skewX - f[e - 1].skewX,
                n = f[e].skewY - f[e - 1].skewY;
            if (h < -g || h > g)f[e - 1].skewX = 0 > h ? f[e - 1].skewX - 2 * g : f[e - 1].skewX + 2 * g;
            if (n < -g || n > g)f[e - 1].skewY = 0 > n ? f[e - 1].skewY - 2 * g : f[e - 1].skewY + 2 * g
        }
        b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && 0 < d.frameList.length && (g = new ccs.FrameData, g.copy(d.frameList[d.frameList.length - 1]), d.addFrameData(g), g.frameID = d.duration);
        return d
    },
    decodeFrame: function (a, b, d, e) {
        var f = 0, f = f = f = f = f = f = f = f = f = f = f = 0;
        d = new ccs.FrameData;
        d.strMovement = a.getAttribute(ccs.CONST_A_MOVEMENT) || "";
        d.movement = d.strMovement;
        d.strEvent =
            a.getAttribute(ccs.CONST_A_EVENT) || "";
        d.event = d.strEvent;
        d.strSound = a.getAttribute(ccs.CONST_A_SOUND) || "";
        d.sound = d.strSound;
        d.strSoundEffect = a.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "";
        d.soundEffect = d.strSoundEffect;
        f = a.getAttribute(ccs.CONST_A_TWEEN_FRAME);
        d.isTween = !(void 0 != f && "false" === f);
        if (e.flashToolVersion >= ccs.CONST_VERSION_2_0) {
            if (f = a.getAttribute(ccs.CONST_A_COCOS2DX_X))d.x = parseFloat(f), d.x *= this._positionReadScale;
            f = a.getAttribute(ccs.CONST_A_COCOS2DX_Y)
        } else {
            if (f = a.getAttribute(ccs.CONST_A_X))d.x =
                parseFloat(f), d.x *= this._positionReadScale;
            f = a.getAttribute(ccs.CONST_A_Y)
        }
        f && (d.y = -parseFloat(f), d.y *= this._positionReadScale);
        f = a.getAttribute(ccs.CONST_A_SCALE_X);
        null != f && (d.scaleX = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_SCALE_Y);
        null != f && (d.scaleY = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_SKEW_X);
        null != f && (d.skewX = cc.degreesToRadians(parseFloat(f)));
        f = a.getAttribute(ccs.CONST_A_SKEW_Y);
        null != f && (d.skewY = cc.degreesToRadians(-parseFloat(f)));
        f = a.getAttribute(ccs.CONST_A_DURATION);
        null != f &&
        (d.duration = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_DISPLAY_INDEX);
        null != f && (d.displayIndex = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_Z);
        null != f && (d.zOrder = parseInt(f));
        f = a.getAttribute(ccs.CONST_A_TWEEN_ROTATE);
        null != f && (d.tweenRotate = parseFloat(f));
        f = a.getAttribute(ccs.CONST_A_BLEND_TYPE);
        if (null != f) {
            var g = d.blendFunc;
            switch (f) {
                case ccs.BLEND_TYPE_NORMAL:
                    g.src = cc.BLEND_SRC;
                    g.dst = cc.BLEND_DST;
                    break;
                case ccs.BLEND_TYPE_ADD:
                    g.src = cc.SRC_ALPHA;
                    g.dst = cc.ONE;
                    break;
                case ccs.BLEND_TYPE_MULTIPLY:
                    g.src =
                        cc.DST_COLOR;
                    g.dst = cc.ONE_MINUS_SRC_ALPHA;
                    break;
                case ccs.BLEND_TYPE_SCREEN:
                    g.src = cc.ONE;
                    g.dst = cc.ONE_MINUS_DST_COLOR;
                    break;
                default:
                    d.blendFunc.src = cc.BLEND_SRC, d.blendFunc.dst = cc.BLEND_DST
            }
        }
        var h = a.querySelectorAll(ccs.CONST_FRAME + " \x3e " + ccs.CONST_A_COLOR_TRANSFORM);
        if (h && 0 < h.length) {
            var h = h[0], n, p, r, s, t, f = parseFloat(h.getAttribute(ccs.CONST_A_ALPHA)) || 0, g = parseFloat(h.getAttribute(ccs.CONST_A_RED)) || 0;
            n = parseFloat(h.getAttribute(ccs.CONST_A_GREEN)) || 0;
            p = parseFloat(h.getAttribute(ccs.CONST_A_BLUE)) ||
                0;
            r = parseFloat(h.getAttribute(ccs.CONST_A_ALPHA_OFFSET)) || 0;
            s = parseFloat(h.getAttribute(ccs.CONST_A_RED_OFFSET)) || 0;
            t = parseFloat(h.getAttribute(ccs.CONST_A_GREEN_OFFSET)) || 0;
            h = parseFloat(h.getAttribute(ccs.CONST_A_BLUE_OFFSET)) || 0;
            d.a = 2.55 * r + f;
            d.r = 2.55 * s + g;
            d.g = 2.55 * t + n;
            d.b = 2.55 * h + p;
            d.isUseColorInfo = !0
        }
        f = a.getAttribute(ccs.CONST_A_TWEEN_EASING);
        null != f && (f != ccs.CONST_FL_NAN ? (f = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) && (d.tweenEasing = 2 === f ? ccs.TweenType.SINE_EASEINOUT : f) : d.tweenEasing = ccs.TweenType.LINEAR);
        b && (a = new ccs.BaseData, e.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (a.x = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_X)), a.y = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_Y))) : (a.x = parseFloat(b.getAttribute(ccs.CONST_A_X)), a.y = parseFloat(b.getAttribute(ccs.CONST_A_Y))), a.skewX = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_X)), a.skewY = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_Y)), a.y = -a.y, a.skewX = cc.degreesToRadians(a.skewX), a.skewY = cc.degreesToRadians(-a.skewY), ccs.TransformHelp.transformFromParent(d,
            a));
        return d
    },
    decodeFrameFromJson: function (a, b) {
        var d = new ccs.FrameData;
        this.decodeNodeFromJson(d, a, b);
        d.tweenEasing = a[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.LINEAR;
        d.displayIndex = a[ccs.CONST_A_DISPLAY_INDEX];
        var e = null == a[ccs.CONST_A_BLEND_DST] ? cc.BLEND_DST : a[ccs.CONST_A_BLEND_DST];
        d.blendFunc.src = null == a[ccs.CONST_A_BLEND_SRC] ? cc.BLEND_SRC : a[ccs.CONST_A_BLEND_SRC];
        d.blendFunc.dst = e;
        d.isTween = null == a[ccs.CONST_A_TWEEN_FRAME] ? !0 : a[ccs.CONST_A_TWEEN_FRAME];
        e = a[ccs.CONST_A_EVENT];
        null != e && (d.strEvent =
            e, d.event = e);
        b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED ? d.duration = null == a[ccs.CONST_A_DURATION] ? 1 : a[ccs.CONST_A_DURATION] : d.frameID = a[ccs.CONST_A_FRAME_INDEX];
        for (var e = a[ccs.CONST_A_EASING_PARAM] || [], f = 0; f < e.length; f++)d.easingParams[f] = e[f];
        return d
    },
    decodeTexture: function (a, b) {
        var d = new ccs.TextureData;
        d.init();
        a.getAttribute(ccs.CONST_A_NAME) && (d.name = a.getAttribute(ccs.CONST_A_NAME));
        var e, f;
        b.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (e = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) ||
            0, f = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0) : (e = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_X)) || 0, f = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_Y)) || 0);
        var g = parseFloat(a.getAttribute(ccs.CONST_A_WIDTH)) || 0, h = parseFloat(a.getAttribute(ccs.CONST_A_HEIGHT)) || 0;
        d.pivotX = e / g;
        d.pivotY = (h - f) / h;
        e = a.querySelectorAll(ccs.CONST_SUB_TEXTURE + " \x3e " + ccs.CONST_CONTOUR);
        for (f = 0; f < e.length; f++)d.addContourData(this.decodeContour(e[f], b));
        return d
    },
    decodeTextureFromJson: function (a) {
        var b = new ccs.TextureData;
        b.init();
        var d = a[ccs.CONST_A_NAME];
        null != d && (b.name = d);
        b.width = a[ccs.CONST_A_WIDTH] || 0;
        b.height = a[ccs.CONST_A_HEIGHT] || 0;
        b.pivotX = a[ccs.CONST_A_PIVOT_X] || 0;
        b.pivotY = a[ccs.CONST_A_PIVOT_Y] || 0;
        a = a[ccs.CONST_CONTOUR_DATA] || [];
        for (d = 0; d < a.length; d++)b.contourDataList.push(this.decodeContourFromJson(a[d]));
        return b
    },
    decodeContour: function (a, b) {
        var d = new ccs.ContourData;
        d.init();
        for (var e = a.querySelectorAll(ccs.CONST_CONTOUR + " \x3e " + ccs.CONST_CONTOUR_VERTEX), f, g = 0; g < e.length; g++) {
            f = e[g];
            var h = cc.p(0, 0);
            h.x = parseFloat(f.getAttribute(ccs.CONST_A_X)) || 0;
            h.y = parseFloat(f.getAttribute(ccs.CONST_A_Y)) || 0;
            h.y = -h.y;
            d.vertexList.push(h)
        }
        return d
    },
    decodeContourFromJson: function (a) {
        var b = new ccs.ContourData;
        b.init();
        a = a[ccs.CONST_VERTEX_POINT] || [];
        for (var d = a.length, e = 0; e < d; e++) {
            var f = a[e], g = cc.p(0, 0);
            g.x = f[ccs.CONST_A_X] || 0;
            g.y = f[ccs.CONST_A_Y] || 0;
            b.vertexList.push(g)
        }
        return b
    },
    addDataFromJsonCache: function (a, b) {
        b.contentScale = null == a[ccs.CONST_CONTENT_SCALE] ? 1 : a[ccs.CONST_CONTENT_SCALE];
        var d = a[ccs.CONST_ARMATURE_DATA] ||
            [], e, f;
        for (e = 0; e < d.length; e++)f = this.decodeArmatureFromJSON(d[e], b), ccs.armatureDataManager.addArmatureData(f.name, f, b.filename);
        d = a[ccs.CONST_ANIMATION_DATA] || [];
        for (e = 0; e < d.length; e++)f = this.decodeAnimationFromJson(d[e], b), ccs.armatureDataManager.addAnimationData(f.name, f, b.filename);
        d = a[ccs.CONST_TEXTURE_DATA] || [];
        for (e = 0; e < d.length; e++)f = this.decodeTextureFromJson(d[e], b), ccs.armatureDataManager.addTextureData(f.name, f, b.filename);
        if (null == b.asyncStruct ? ccs.armatureDataManager.isAutoLoadSpriteFile() :
                b.asyncStruct.autoLoadSpriteFile) {
            var d = a[ccs.CONST_CONFIG_FILE_PATH] || [], g;
            for (e = 0; e < d.length; e++)f = d[e], g = f.lastIndexOf("."), f = f.substring(0, g), g = b.basefilePath + f + ".plist", f = b.basefilePath + f + ".png", ccs.armatureDataManager.addSpriteFrameFromFile(g, f, b.filename)
        }
    },
    decodeNodeFromJson: function (a, b, d) {
        a.x = b[ccs.CONST_A_X] * this._positionReadScale;
        a.y = b[ccs.CONST_A_Y] * this._positionReadScale;
        a.x *= d.contentScale;
        a.y *= d.contentScale;
        a.zOrder = b[ccs.CONST_A_Z];
        a.skewX = b[ccs.CONST_A_SKEW_X] || 0;
        a.skewY = b[ccs.CONST_A_SKEW_Y] ||
            0;
        a.scaleX = null == b[ccs.CONST_A_SCALE_X] ? 1 : b[ccs.CONST_A_SCALE_X];
        a.scaleY = null == b[ccs.CONST_A_SCALE_Y] ? 1 : b[ccs.CONST_A_SCALE_Y];
        if (b = d.cocoStudioVersion < ccs.VERSION_COLOR_READING ? b[0] : b[ccs.CONST_COLOR_INFO] || null)a.a = null == b[ccs.CONST_A_ALPHA] ? 255 : b[ccs.CONST_A_ALPHA], a.r = null == b[ccs.CONST_A_RED] ? 255 : b[ccs.CONST_A_RED], a.g = null == b[ccs.CONST_A_GREEN] ? 255 : b[ccs.CONST_A_GREEN], a.b = null == b[ccs.CONST_A_BLUE] ? 255 : b[ccs.CONST_A_BLUE], a.isUseColorInfo = !0
    },
    clear: function () {
        this._configFileList = [];
        this._asyncRefTotalCount =
            this._asyncRefCount = 0
    },
    _asyncCallBack: function (a, b, d) {
        a && cc.isFunction(a) && a.call(b, d);
        if (b && a && "string" === typeof a)b[a](d)
    },
    _initBaseFilePath: function (a) {
        var b = a.lastIndexOf("/");
        return a = -1 < b ? a.substr(0, b + 1) : ""
    },
    addDataFromXML: function (a, b) {
        var d = cc.loader.getRes(a);
        if (!d)throw Error("Please load the resource first : " + a);
        (d = cc.saxParser.parse(d).documentElement) && this.addDataFromCache(d, b)
    },
    addDataFromJson: function (a, b) {
        var d = cc.loader.getRes(a);
        this.addDataFromJsonCache(d, b)
    }
};
ccs.spriteFrameCacheHelper = {
    _textureAtlasDic: {}, _imagePaths: [], addSpriteFrameFromFile: function (a, b) {
        cc.spriteFrameCache.addSpriteFrames(a, b)
    }, getTextureAtlasWithTexture: function (a) {
        return null
    }, clear: function () {
        this._textureAtlasDic = {};
        this._imagePaths = []
    }
};
ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({});
ccs.TransformHelp.helpMatrix1 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpMatrix2 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpPoint1 = cc.p(0, 0);
ccs.TransformHelp.helpPoint2 = cc.p(0, 0);
ccs.TransformHelp.helpParentNode = {};
ccs.TransformHelp.transformFromParent = function (a, b) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(b, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParent = function (a, b) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(b, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformFromParentWithoutScale = function (a, b) {
    for (var d in b)this.helpParentNode[d] = b[d];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParentWithoutScale = function (a, b) {
    for (var d in b)this.helpParentNode[d] = b[d];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.nodeToMatrix = function (a, b) {
    if (a.skewX === -a.skewY) {
        var d = Math.sin(a.skewX), e = Math.cos(a.skewX);
        b.a = a.scaleX * e;
        b.b = a.scaleX * -d;
        b.c = a.scaleY * d;
        b.d = a.scaleY * e
    } else b.a = a.scaleX * Math.cos(a.skewY), b.b = a.scaleX * Math.sin(a.skewY), b.c = a.scaleY * Math.sin(a.skewX), b.d = a.scaleY * Math.cos(a.skewX);
    b.tx = a.x;
    b.ty = a.y
};
ccs.TransformHelp.matrixToNode = function (a, b) {
    this.helpPoint1.x = 0;
    this.helpPoint1.y = 1;
    this.helpPoint1 = cc.pointApplyAffineTransform(this.helpPoint1, a);
    this.helpPoint1.x -= a.tx;
    this.helpPoint1.y -= a.ty;
    this.helpPoint2.x = 1;
    this.helpPoint2.y = 0;
    this.helpPoint2 = cc.pointApplyAffineTransform(this.helpPoint2, a);
    this.helpPoint2.x -= a.tx;
    this.helpPoint2.y -= a.ty;
    b.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964);
    b.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x);
    b.scaleX = Math.sqrt(a.a * a.a +
        a.b * a.b);
    b.scaleY = Math.sqrt(a.c * a.c + a.d * a.d);
    b.x = a.tx;
    b.y = a.ty
};
ccs.TransformHelp.nodeConcat = function (a, b) {
    a.x += b.x;
    a.y += b.y;
    a.skewX += b.skewX;
    a.skewY += b.skewY;
    a.scaleX += b.scaleX;
    a.scaleY += b.scaleY
};
ccs.TransformHelp.nodeSub = function (a, b) {
    a.x -= b.x;
    a.y -= b.y;
    a.skewX -= b.skewX;
    a.skewY -= b.skewY;
    a.scaleX -= b.scaleX;
    a.scaleY -= b.scaleY
};
ccs.TweenType = {
    CUSTOM_EASING: -1,
    LINEAR: 0,
    SINE_EASEIN: 1,
    SINE_EASEOUT: 2,
    SINE_EASEINOUT: 3,
    QUAD_EASEIN: 4,
    QUAD_EASEOUT: 5,
    QUAD_EASEINOUT: 6,
    CUBIC_EASEIN: 7,
    CUBIC_EASEOUT: 8,
    CUBIC_EASEINOUT: 9,
    QUART_EASEIN: 10,
    QUART_EASEOUT: 11,
    QUART_EASEINOUT: 12,
    QUINT_EASEIN: 13,
    QUINT_EASEOUT: 14,
    QUINT_EASEINOUT: 15,
    EXPO_EASEIN: 16,
    EXPO_EASEOUT: 17,
    EXPO_EASEINOUT: 18,
    CIRC_EASEIN: 19,
    CIRC_EASEOUT: 20,
    CIRC_EASEINOUT: 21,
    ELASTIC_EASEIN: 22,
    ELASTIC_EASEOUT: 23,
    ELASTIC_EASEINOUT: 24,
    BACK_EASEIN: 25,
    BACK_EASEOUT: 26,
    BACK_EASEINOUT: 27,
    BOUNCE_EASEIN: 28,
    BOUNCE_EASEOUT: 29,
    BOUNCE_EASEINOUT: 30,
    TWEEN_EASING_MAX: 1E4
};
ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({});
ccs.DOUBLE_PI = ccs.M_PI_X_2 = 2 * Math.PI;
ccs.HALF_PI = ccs.M_PI_2 = Math.PI / 2;
ccs.M_PI = Math.PI;
ccs.TweenFunction.tweenTo = function (a, b, d) {
    var e = 0;
    switch (b) {
        case ccs.TweenType.CUSTOM_EASING:
            e = this.customEase(a, d);
            break;
        case ccs.TweenType.LINEAR:
            e = this.linear(a);
            break;
        case ccs.TweenType.SINE_EASEIN:
            e = this.sineEaseIn(a);
            break;
        case ccs.TweenType.SINE_EASEOUT:
            e = this.sineEaseOut(a);
            break;
        case ccs.TweenType.SINE_EASEINOUT:
            e = this.sineEaseInOut(a);
            break;
        case ccs.TweenType.QUAD_EASEIN:
            e = this.quadEaseIn(a);
            break;
        case ccs.TweenType.QUAD_EASEOUT:
            e = this.quadEaseOut(a);
            break;
        case ccs.TweenType.QUAD_EASEINOUT:
            e =
                this.quadEaseInOut(a);
            break;
        case ccs.TweenType.CUBIC_EASEIN:
            e = this.cubicEaseIn(a);
            break;
        case ccs.TweenType.CUBIC_EASEOUT:
            e = this.cubicEaseOut(a);
            break;
        case ccs.TweenType.CUBIC_EASEINOUT:
            e = this.cubicEaseInOut(a);
            break;
        case ccs.TweenType.QUART_EASEIN:
            e = this.quartEaseIn(a);
            break;
        case ccs.TweenType.QUART_EASEOUT:
            e = this.quartEaseOut(a);
            break;
        case ccs.TweenType.QUART_EASEINOUT:
            e = this.quartEaseInOut(a);
            break;
        case ccs.TweenType.QUINT_EASEIN:
            e = this.quintEaseIn(a);
            break;
        case ccs.TweenType.QUINT_EASEOUT:
            e = this.quintEaseOut(a);
            break;
        case ccs.TweenType.QUINT_EASEINOUT:
            e = this.quintEaseInOut(a);
            break;
        case ccs.TweenType.EXPO_EASEIN:
            e = this.expoEaseIn(a);
            break;
        case ccs.TweenType.EXPO_EASEOUT:
            e = this.expoEaseOut(a);
            break;
        case ccs.TweenType.EXPO_EASEINOUT:
            e = this.expoEaseInOut(a);
            break;
        case ccs.TweenType.CIRC_EASEIN:
            e = this.circEaseIn(a);
            break;
        case ccs.TweenType.CIRC_EASEOUT:
            e = this.circEaseOut(a);
            break;
        case ccs.TweenType.CIRC_EASEINOUT:
            e = this.circEaseInOut(a);
            break;
        case ccs.TweenType.ELASTIC_EASEIN:
            b = 0.3;
            null != d && 0 < d.length && (b = d[0]);
            e = this.elasticEaseIn(a, b);
            break;
        case ccs.TweenType.ELASTIC_EASEOUT:
            b = 0.3;
            null != d && 0 < d.length && (b = d[0]);
            e = this.elasticEaseOut(a, b);
            break;
        case ccs.TweenType.ELASTIC_EASEINOUT:
            b = 0.3;
            null != d && 0 < d.length && (b = d[0]);
            e = this.elasticEaseInOut(a, b);
            break;
        case ccs.TweenType.BACK_EASEIN:
            e = this.backEaseIn(a);
            break;
        case ccs.TweenType.BACK_EASEOUT:
            e = this.backEaseOut(a);
            break;
        case ccs.TweenType.BACK_EASEINOUT:
            e = this.backEaseInOut(a);
            break;
        case ccs.TweenType.BOUNCE_EASEIN:
            e = this.bounceEaseIn(a);
            break;
        case ccs.TweenType.BOUNCE_EASEOUT:
            e =
                this.bounceEaseOut(a);
            break;
        case ccs.TweenType.BOUNCE_EASEINOUT:
            e = this.bounceEaseInOut(a);
            break;
        default:
            e = this.sineEaseInOut(a)
    }
    return e
};
ccs.TweenFunction.linear = function (a) {
    return a
};
ccs.TweenFunction.sineEaseIn = function (a) {
    return -1 * Math.cos(a * ccs.HALF_PI) + 1
};
ccs.TweenFunction.sineEaseOut = function (a) {
    return Math.sin(a * ccs.HALF_PI)
};
ccs.TweenFunction.sineEaseInOut = function (a) {
    return -0.5 * (Math.cos(ccs.M_PI * a) - 1)
};
ccs.TweenFunction.quadEaseIn = function (a) {
    return a * a
};
ccs.TweenFunction.quadEaseOut = function (a) {
    return -1 * a * (a - 2)
};
ccs.TweenFunction.quadEaseInOut = function (a) {
    a *= 2;
    if (1 > a)return 0.5 * a * a;
    --a;
    return -0.5 * (a * (a - 2) - 1)
};
ccs.TweenFunction.cubicEaseIn = function (a) {
    return a * a * a
};
ccs.TweenFunction.cubicEaseOut = function (a) {
    a -= 1;
    return a * a * a + 1
};
ccs.TweenFunction.cubicEaseInOut = function (a) {
    a *= 2;
    if (1 > a)return 0.5 * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a + 2)
};
ccs.TweenFunction.quartEaseIn = function (a) {
    return a * a * a * a
};
ccs.TweenFunction.quartEaseOut = function (a) {
    a -= 1;
    return -(a * a * a * a - 1)
};
ccs.TweenFunction.quartEaseInOut = function (a) {
    a *= 2;
    if (1 > a)return 0.5 * a * a * a * a;
    a -= 2;
    return -0.5 * (a * a * a * a - 2)
};
ccs.TweenFunction.quintEaseIn = function (a) {
    return a * a * a * a * a
};
ccs.TweenFunction.quintEaseOut = function (a) {
    a -= 1;
    return a * a * a * a * a + 1
};
ccs.TweenFunction.quintEaseInOut = function (a) {
    a *= 2;
    if (1 > a)return 0.5 * a * a * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a * a * a + 2)
};
ccs.TweenFunction.expoEaseIn = function (a) {
    return 0 === a ? 0 : Math.pow(2, 10 * (a - 1)) - 0.001
};
ccs.TweenFunction.expoEaseOut = function (a) {
    return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1
};
ccs.TweenFunction.expoEaseInOut = function (a) {
    a /= 0.5;
    return a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)
};
ccs.TweenFunction.circEaseIn = function (a) {
    return -1 * (Math.sqrt(1 - a * a) - 1)
};
ccs.TweenFunction.circEaseOut = function (a) {
    a -= 1;
    return Math.sqrt(1 - a * a)
};
ccs.TweenFunction.circEaseInOut = function (a) {
    a *= 2;
    if (1 > a)return -0.5 * (Math.sqrt(1 - a * a) - 1);
    a -= 2;
    return 0.5 * (Math.sqrt(1 - a * a) + 1)
};
ccs.TweenFunction.elasticEaseIn = function (a, b) {
    var d = 0.3;
    0 < b.length && (d = b[0]);
    var e = 0;
    0 === a || 1 === a ? e = a : (e = d / 4, a -= 1, e = -Math.pow(2, 10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d));
    return e
};
ccs.TweenFunction.elasticEaseOut = function (a, b) {
    var d = 0.3;
    0 < b.length && (d = b[0]);
    var e = 0;
    0 === a || 1 === a ? e = a : (e = d / 4, e = Math.pow(2, -10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d) + 1);
    return e
};
ccs.TweenFunction.elasticEaseInOut = function (a, b) {
    var d = 0.3;
    0 < b.length && (d = b[0]);
    var e = 0;
    0 === a || 1 === a ? e = a : (d || (d = 0.3 * 1.5), e = d / 4, a = 2 * a - 1, e = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d) : Math.pow(2, -10 * a) * Math.sin((a - e) * ccs.DOUBLE_PI / d) * 0.5 + 1);
    return e
};
ccs.TweenFunction.backEaseIn = function (a) {
    return a * a * (2.70158 * a - 1.70158)
};
ccs.TweenFunction.backEaseOut = function (a) {
    a -= 1;
    return a * a * (2.70158 * a + 1.70158) + 1
};
ccs.TweenFunction.backEaseInOut = function (a) {
    a *= 2;
    if (1 > a)return a * a * (3.5949095 * a - 2.5949095) / 2;
    a -= 2;
    return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
};
ccs.bounceTime = function (a) {
    if (a < 1 / 2.75)return 7.5625 * a * a;
    if (a < 2 / 2.75)return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75)return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
ccs.TweenFunction.bounceEaseIn = function (a) {
    return 1 - ccs.bounceTime(1 - a)
};
ccs.TweenFunction.bounceEaseOut = function (a) {
    return ccs.bounceTime(a)
};
ccs.TweenFunction.bounceEaseInOut = function (a) {
    var b = 0;
    return b = 0.5 > a ? 0.5 * (1 - ccs.bounceTime(1 - 2 * a)) : 0.5 * ccs.bounceTime(2 * a - 1) + 0.5
};
ccs.TweenFunction.customEase = function (a, b) {
    if (0 < b.length) {
        var d = 1 - a;
        return b[1] * d * d * d + 3 * b[3] * a * d * d + 3 * b[5] * a * a * d + b[7] * a * a * a
    }
    return a
};
ccs.TweenFunction.easeIn = function (a, b) {
    return Math.pow(a, b)
};
ccs.TweenFunction.easeOut = function (a, b) {
    return Math.pow(a, 1 / b)
};
ccs.TweenFunction.easeInOut = function (a, b) {
    a *= 2;
    return 1 > a ? 0.5 * Math.pow(a, b) : 1 - 0.5 * Math.pow(2 - a, b)
};
ccs.TweenFunction.quadraticIn = function (a) {
    return Math.pow(a, 2)
};
ccs.TweenFunction.quadraticOut = function (a) {
    return -a * (a - 2)
};
ccs.TweenFunction.bezieratFunction = function (a, b, d, e, f) {
    return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * b + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
};
var ENABLE_PHYSICS_DETECT = !1;
ccs.fmodf = function (a, b) {
    for (; a > b;)a -= b;
    return a
};
var CC_SAFE_RELEASE = function (a) {
    a && a.release && a.release()
};
ccs.isSpriteContainPoint = function (a, b, d) {
    b = a.convertToNodeSpace(b);
    d && (d.x = b.x, d.y = b.y);
    a = a.getContentSize();
    return cc.rectContainsPoint(cc.rect(0, 0, a.width, a.height), b)
};
ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint;
ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint;
ccs.extBezierTo = function (a, b, d, e, f) {
    var g = cc.p(0, 0);
    e && !f && (g.x = Math.pow(1 - a, 2) * b.x + 2 * a * (1 - a) * d.x + Math.pow(a, 2) * e.x, g.y = Math.pow(1 - a, 2) * b.y + 2 * a * (1 - a) * d.y + Math.pow(a, 2) * e.y);
    f && (g.x = b.x * Math.pow(1 - a, 3) + 3 * a * d.x * Math.pow(1 - a, 2) + 3 * e.x * Math.pow(a, 2) * (1 - a) + f.x * Math.pow(a, 3), g.y = b.y * Math.pow(1 - a, 3) + 3 * a * d.y * Math.pow(1 - a, 2) + 3 * e.y * Math.pow(a, 2) * (1 - a) + f.y * Math.pow(a, 3));
    return g
};
ccs.extCircleTo = function (a, b, d, e, f) {
    var g = cc.p(0, 0);
    g.x = b.x + d * Math.cos(e + f * a);
    g.y = b.y + d * Math.sin(e + f * a);
    return g
};
ccs.RelativeData = function () {
    this.plistFiles = [];
    this.armatures = [];
    this.animations = [];
    this.textures = []
};
ccs.armatureDataManager = {
    _animationDatas: {},
    _armatureDatas: {},
    _textureDatas: {},
    _autoLoadSpriteFile: !1,
    _relativeDatas: {},
    s_sharedArmatureDataManager: null,
    removeArmatureFileInfo: function (a) {
        var b = this.getRelativeData(a);
        if (b) {
            var d, e;
            for (d = 0; d < b.armatures.length; d++)e = b.armatures[d], this.removeArmatureData(e);
            for (d = 0; d < b.animations.length; d++)e = b.animations[d], this.removeAnimationData(e);
            for (d = 0; d < b.textures.length; d++)e = b.textures[d], this.removeTextureData(e);
            for (d = 0; d < b.plistFiles.length; d++)e = b.plistFiles[d],
                cc.spriteFrameCache.removeSpriteFramesFromFile(e);
            delete this._relativeDatas[a];
            ccs.dataReaderHelper.removeConfigFile(a)
        }
    },
    addArmatureData: function (a, b, d) {
        (d = this.getRelativeData(d)) && d.armatures.push(a);
        this._armatureDatas[a] = b
    },
    getArmatureData: function (a) {
        var b = null;
        this._armatureDatas && (b = this._armatureDatas[a]);
        return b
    },
    removeArmatureData: function (a) {
        this._armatureDatas[a] && delete this._armatureDatas[a]
    },
    addAnimationData: function (a, b, d) {
        (d = this.getRelativeData(d)) && d.animations.push(a);
        this._animationDatas[a] =
            b
    },
    getAnimationData: function (a) {
        var b = null;
        this._animationDatas[a] && (b = this._animationDatas[a]);
        return b
    },
    removeAnimationData: function (a) {
        this._animationDatas[a] && delete this._animationDatas[a]
    },
    addTextureData: function (a, b, d) {
        (d = this.getRelativeData(d)) && d.textures.push(a);
        this._textureDatas[a] = b
    },
    getTextureData: function (a) {
        var b = null;
        this._textureDatas && (b = this._textureDatas[a]);
        return b
    },
    removeTextureData: function (a) {
        this._textureDatas[a] && delete this._textureDatas[a]
    },
    addArmatureFileInfo: function () {
        var a,
            b, d;
        switch (arguments.length) {
            case 1:
                d = arguments[0];
                this.addRelativeData(d);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFile(d);
                break;
            case 3:
                a = arguments[0], b = arguments[1], d = arguments[2], this.addRelativeData(d), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFile(d), this.addSpriteFrameFromFile(b, a)
        }
    },
    addArmatureFileInfoAsync: function () {
        var a, b, d, e, f;
        switch (arguments.length) {
            case 3:
                d = arguments[0];
                e = arguments[2];
                f = arguments[1];
                this.addRelativeData(d);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFileAsync("", "", d, f, e);
                break;
            case 5:
                a = arguments[0], b = arguments[1], d = arguments[2], e = arguments[4], f = arguments[3], this.addRelativeData(d), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFileAsync(a, b, d, f, e), this.addSpriteFrameFromFile(b, a)
        }
    },
    addSpriteFrameFromFile: function (a, b, d) {
        (d = this.getRelativeData(d)) && d.plistFiles.push(a);
        ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(a, b)
    },
    isAutoLoadSpriteFile: function () {
        return this._autoLoadSpriteFile
    },
    getArmatureDatas: function () {
        return this._armatureDatas
    },
    getAnimationDatas: function () {
        return this._animationDatas
    },
    getTextureDatas: function () {
        return this._textureDatas
    },
    addRelativeData: function (a) {
        this._relativeDatas[a] || (this._relativeDatas[a] = new ccs.RelativeData)
    },
    getRelativeData: function (a) {
        return this._relativeDatas[a]
    },
    clear: function () {
        this._animationDatas = {};
        this._armatureDatas = {};
        this._textureDatas = {};
        ccs.spriteFrameCacheHelper.clear();
        ccs.dataReaderHelper.clear()
    }
};
ccs.BLEND_TYPE_NORMAL = 0;
ccs.BLEND_TYPE_LAYER = 1;
ccs.BLEND_TYPE_DARKEN = 2;
ccs.BLEND_TYPE_MULTIPLY = 3;
ccs.BLEND_TYPE_LIGHTEN = 4;
ccs.BLEND_TYPE_SCREEN = 5;
ccs.BLEND_TYPE_OVERLAY = 6;
ccs.BLEND_TYPE_HIGHLIGHT = 7;
ccs.BLEND_TYPE_ADD = 8;
ccs.BLEND_TYPE_SUBTRACT = 9;
ccs.BLEND_TYPE_DIFFERENCE = 10;
ccs.BLEND_TYPE_INVERT = 11;
ccs.BLEND_TYPE_ALPHA = 12;
ccs.BLEND_TYPE_ERASE = 13;
ccs.DISPLAY_TYPE_SPRITE = 0;
ccs.DISPLAY_TYPE_ARMATURE = 1;
ccs.DISPLAY_TYPE_PARTICLE = 2;
ccs.DISPLAY_TYPE_MAX = 3;
ccs.BaseData = ccs.Class.extend({
    x: 0,
    y: 0,
    zOrder: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1,
    tweenRotate: 0,
    isUseColorInfo: !1,
    r: 255,
    g: 255,
    b: 255,
    a: 255,
    ctor: function () {
        this.skewY = this.skewX = this.zOrder = this.y = this.x = 0;
        this.scaleY = this.scaleX = 1;
        this.tweenRotate = 0;
        this.isUseColorInfo = !1;
        this.a = this.b = this.g = this.r = 255
    },
    copy: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.zOrder = a.zOrder;
        this.scaleX = a.scaleX;
        this.scaleY = a.scaleY;
        this.skewX = a.skewX;
        this.skewY = a.skewY;
        this.tweenRotate = a.tweenRotate;
        this.isUseColorInfo = a.isUseColorInfo;
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    setColor: function (a) {
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    getColor: function () {
        return cc.color(this.r, this.g, this.b, this.a)
    },
    subtract: function (a, b, d) {
        this.x = b.x - a.x;
        this.y = b.y - a.y;
        this.scaleX = b.scaleX - a.scaleX;
        this.scaleY = b.scaleY - a.scaleY;
        this.skewX = b.skewX - a.skewX;
        this.skewY = b.skewY - a.skewY;
        this.isUseColorInfo || a.isUseColorInfo || b.isUseColorInfo ? (this.a = b.a - a.a, this.r = b.r - a.r, this.g = b.g - a.g, this.b = b.b - a.b, this.isUseColorInfo = !0) : (this.a = this.r =
            this.g = this.b = 0, this.isUseColorInfo = !1);
        d && (this.skewX > ccs.M_PI && (this.skewX -= ccs.DOUBLE_PI), this.skewX < -ccs.M_PI && (this.skewX += ccs.DOUBLE_PI), this.skewY > ccs.M_PI && (this.skewY -= ccs.DOUBLE_PI), this.skewY < -ccs.M_PI && (this.skewY += ccs.DOUBLE_PI));
        b.tweenRotate && (this.skewX += b.tweenRotate * ccs.PI * 2, this.skewY -= b.tweenRotate * ccs.PI * 2)
    }
});
ccs.DisplayData = ccs.Class.extend({
    displayType: ccs.DISPLAY_TYPE_MAX, displayName: "", ctor: function () {
        this.displayType = ccs.DISPLAY_TYPE_MAX
    }, changeDisplayToTexture: function (a) {
        var b = a.lastIndexOf(".");
        -1 !== b && (a = a.substring(0, b));
        return a
    }, copy: function (a) {
        this.displayName = a.displayName;
        this.displayType = a.displayType
    }
});
ccs.SpriteDisplayData = ccs.DisplayData.extend({
    skinData: null, ctor: function () {
        this.skinData = new ccs.BaseData;
        this.displayType = ccs.DISPLAY_TYPE_SPRITE
    }, copy: function (a) {
        ccs.DisplayData.prototype.copy.call(this, a);
        this.skinData = a.skinData
    }
});
ccs.ArmatureDisplayData = ccs.DisplayData.extend({
    ctor: function () {
        this.displayName = "";
        this.displayType = ccs.DISPLAY_TYPE_ARMATURE
    }
});
ccs.ParticleDisplayData = ccs.DisplayData.extend({
    ctor: function () {
        this.displayType = ccs.DISPLAY_TYPE_PARTICLE
    }
});
ccs.BoneData = ccs.BaseData.extend({
    displayDataList: null,
    name: "",
    parentName: "",
    boneDataTransform: null,
    ctor: function () {
        this.displayDataList = [];
        this.parentName = this.name = "";
        this.boneDataTransform = null
    },
    init: function () {
        this.displayDataList.length = 0;
        return !0
    },
    addDisplayData: function (a) {
        this.displayDataList.push(a)
    },
    getDisplayData: function (a) {
        return this.displayDataList[a]
    }
});
ccs.ArmatureData = ccs.Class.extend({
    boneDataDic: null, name: "", dataVersion: 0.1, ctor: function () {
        this.boneDataDic = {};
        this.name = "";
        this.dataVersion = 0.1
    }, init: function () {
        return !0
    }, addBoneData: function (a) {
        this.boneDataDic[a.name] = a
    }, getBoneDataDic: function () {
        return this.boneDataDic
    }, getBoneData: function (a) {
        return this.boneDataDic[a]
    }
});
ccs.FrameData = ccs.BaseData.extend({
    duration: 0,
    tweenEasing: 0,
    easingParamNumber: 0,
    easingParams: null,
    displayIndex: -1,
    movement: "",
    event: "",
    sound: "",
    soundEffect: "",
    blendFunc: null,
    frameID: 0,
    isTween: !0,
    ctor: function () {
        ccs.BaseData.prototype.ctor.call(this);
        this.duration = 1;
        this.tweenEasing = ccs.TweenType.LINEAR;
        this.easingParamNumber = 0;
        this.easingParams = [];
        this.displayIndex = 0;
        this.soundEffect = this.sound = this.event = this.movement = "";
        this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.frameID = 0;
        this.isTween = !0
    },
    copy: function (a) {
        ccs.BaseData.prototype.copy.call(this, a);
        this.duration = a.duration;
        this.displayIndex = a.displayIndex;
        this.tweenEasing = a.tweenEasing;
        this.easingParamNumber = a.easingParamNumber;
        if (0 !== this.easingParamNumber)for (var b = this.easingParams.length = 0; b < this.easingParamNumber; b++)this.easingParams[b] = a.easingParams[b];
        this.blendFunc = a.blendFunc;
        this.isTween = a.isTween
    }
});
ccs.MovementBoneData = ccs.Class.extend({
    delay: 0, scale: 1, duration: 0, frameList: null, name: "", ctor: function () {
        this.delay = 0;
        this.scale = 1;
        this.duration = 0;
        this.frameList = [];
        this.name = ""
    }, init: function () {
        return !0
    }, addFrameData: function (a) {
        this.frameList.push(a)
    }, getFrameData: function (a) {
        return this.frameList[a]
    }
});
ccs.MovementData = function () {
    this.name = "";
    this.duration = 0;
    this.scale = 1;
    this.durationTween = this.durationTo = 0;
    this.loop = !0;
    this.tweenEasing = ccs.TweenType.LINEAR;
    this.movBoneDataDic = {}
};
ccs.MovementData.prototype.addMovementBoneData = function (a) {
    this.movBoneDataDic[a.name] = a
};
ccs.MovementData.prototype.getMovementBoneData = function (a) {
    return this.movBoneDataDic[a]
};
ccs.AnimationData = function () {
    this.movementDataDic = {};
    this.movementNames = [];
    this.name = ""
};
ccs.AnimationData.prototype.addMovement = function (a) {
    this.movementDataDic[a.name] = a;
    this.movementNames.push(a.name)
};
ccs.AnimationData.prototype.getMovement = function (a) {
    return this.movementDataDic[a]
};
ccs.AnimationData.prototype.getMovementCount = function () {
    return Object.keys(this.movementDataDic).length
};
ccs.ContourVertex2 = function (a, b) {
    this.x = a || 0;
    this.y = b || 0
};
ccs.ContourData = function () {
    this.vertexList = []
};
ccs.ContourData.prototype.init = function () {
    this.vertexList.length = 0;
    return !0
};
ccs.ContourData.prototype.addVertex = function (a) {
    this.vertexList.push(a)
};
ccs.TextureData = function () {
    this.width = this.height = 0;
    this.pivotY = this.pivotX = 0.5;
    this.name = "";
    this.contourDataList = []
};
ccs.TextureData.prototype.init = function () {
    this.contourDataList.length = 0
};
ccs.TextureData.prototype.addContourData = function (a) {
    this.contourDataList.push(a)
};
ccs.TextureData.prototype.getContourData = function (a) {
    return this.contourDataList[a]
};
ccs.DecorativeDisplay = ccs.Class.extend({
    _display: null, _colliderDetector: null, _displayData: null, ctor: function () {
        this._displayData = this._colliderDetector = this._display = null
    }, init: function () {
        return !0
    }, setDisplay: function (a) {
        a._parent && (a._parent.removeChild(a), delete a._parent);
        this._display = a
    }, getDisplay: function () {
        return this._display
    }, setColliderDetector: function (a) {
        this._colliderDetector = a
    }, getColliderDetector: function () {
        return this._colliderDetector
    }, setDisplayData: function (a) {
        this._displayData =
            a
    }, getDisplayData: function () {
        return this._displayData
    }, release: function () {
        this._colliderDetector = this._displayData = this._display = null
    }
});
ccs.DecorativeDisplay.create = function () {
    return new ccs.DecorativeDisplay
};
ccs.displayFactory = {
    addDisplay: function (a, b, d) {
        switch (d.displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.addSpriteDisplay(a, b, d);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.addParticleDisplay(a, b, d);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.addArmatureDisplay(a, b, d)
        }
    }, createDisplay: function (a, b) {
        switch (b.getDisplayData().displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.createSpriteDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.createParticleDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.createArmatureDisplay(a,
                    b)
        }
    }, _helpTransform: {a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0}, updateDisplay: function (a, b, d) {
        var e = a.getDisplayRenderNode();
        if (e) {
            switch (a.getDisplayRenderNodeType()) {
                case ccs.DISPLAY_TYPE_SPRITE:
                    d && e.updateArmatureTransform();
                    break;
                case ccs.DISPLAY_TYPE_PARTICLE:
                    this.updateParticleDisplay(a, e, b);
                    break;
                case ccs.DISPLAY_TYPE_ARMATURE:
                    this.updateArmatureDisplay(a, e, b);
                    break;
                default:
                    b = a.getNodeToArmatureTransform(), e.setAdditionalTransform(b)
            }
            if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) &&
                d && (e = a.getDisplayManager().getCurrentDecorativeDisplay(), d = e.getColliderDetector())) {
                b = e.getDisplay();
                var f = b.getNodeToParentTransform(), e = this._helpTransform;
                e.a = f.a;
                e.b = f.b;
                e.c = f.c;
                e.d = f.d;
                e.tx = f.tx;
                e.ty = f.ty;
                b = cc.pointApplyAffineTransform(b.getAnchorPointInPoints(), e);
                e.tx = b.x;
                e.ty = b.y;
                a = cc.affineTransformConcat(e, a.getArmature().getNodeToParentTransform());
                d.updateTransform(a)
            }
        }
    }, addSpriteDisplay: function (a, b, d) {
        var e = new ccs.SpriteDisplayData;
        e.copy(d);
        b.setDisplayData(e);
        this.createSpriteDisplay(a,
            b)
    }, createSpriteDisplay: function (a, b) {
        var d = null, e = b.getDisplayData(), d = e.displayName, f = d.lastIndexOf(".");
        -1 !== f && (d = d.substring(0, f));
        d = "" === d ? new ccs.Skin : new ccs.Skin("#" + d + ".png");
        b.setDisplay(d);
        d.setBone(a);
        this.initSpriteDisplay(a, b, e.displayName, d);
        (f = a.getArmature()) && (f.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? d.setSkinData(e.skinData) : d.setSkinData(a.boneData))
    }, initSpriteDisplay: function (a, b, d, e) {
        var f = d.lastIndexOf(".");
        -1 !== f && (d = d.substring(0, f));
        (d = ccs.armatureDataManager.getTextureData(d)) &&
        e.setAnchorPoint(cc.p(d.pivotX, d.pivotY));
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && d && 0 < d.contourDataList.length && (a = new ccs.ColliderDetector(a), a.addContourDataList(d.contourDataList), b.setColliderDetector(a))
    }, addArmatureDisplay: function (a, b, d) {
        var e = new ccs.ArmatureDisplayData;
        e.copy(d);
        b.setDisplayData(e);
        this.createArmatureDisplay(a, b)
    }, createArmatureDisplay: function (a, b) {
        var d = b.getDisplayData(), d = new ccs.Armature(d.displayName, a);
        b.setDisplay(d)
    }, updateArmatureDisplay: function (a,
                                        b, d) {
        b && (b.sortAllChildren(), b.update(d))
    }, addParticleDisplay: function (a, b, d) {
        var e = new ccs.ParticleDisplayData;
        e.copy(d);
        b.setDisplayData(e);
        this.createParticleDisplay(a, b)
    }, createParticleDisplay: function (a, b) {
        var d = b.getDisplayData(), d = new cc.ParticleSystem(d.displayName);
        d.removeFromParent();
        d.cleanup();
        a.getArmature() && d.setParent(a.getArmature());
        b.setDisplay(d)
    }, updateParticleDisplay: function (a, b, d) {
        var e = new ccs.BaseData;
        ccs.TransformHelp.matrixToNode(a.nodeToArmatureTransform(), e);
        b.setPosition(e.x,
            e.y);
        b.setScaleX(e.scaleX);
        b.setScaleY(e.scaleY);
        b.update(d)
    }
};
ccs.DisplayManager = ccs.Class.extend({
    _decoDisplayList: null,
    _currentDecoDisplay: null,
    _displayRenderNode: null,
    _displayIndex: null,
    _forceChangeDisplay: !1,
    _bone: null,
    _visible: !0,
    _displayType: null,
    ctor: function (a) {
        this._decoDisplayList = [];
        this._displayIndex = this._displayRenderNode = this._currentDecoDisplay = null;
        this._forceChangeDisplay = !1;
        this._bone = null;
        this._visible = !0;
        this._displayType = ccs.DISPLAY_TYPE_MAX;
        a && ccs.DisplayManager.prototype.init.call(this, a)
    },
    init: function (a) {
        this._bone = a;
        this.initDisplayList(a.getBoneData());
        return !0
    },
    addDisplay: function (a, b) {
        var d, e = this._decoDisplayList;
        0 <= b && b < e.length ? d = e[b] : (d = new ccs.DecorativeDisplay, e.push(d));
        if (a instanceof ccs.DisplayData)ccs.displayFactory.addDisplay(this._bone, d, a); else {
            var f = null;
            if (a instanceof ccs.Skin) {
                a.setBone(this._bone);
                f = new ccs.SpriteDisplayData;
                ccs.displayFactory.initSpriteDisplay(this._bone, d, a.getDisplayName(), a);
                var g = d.getDisplayData();
                if (g instanceof ccs.SpriteDisplayData)a.setSkinData(g.skinData), f.skinData = g.skinData; else {
                    for (var g = !1, h =
                        e.length - 2; 0 <= h; h--) {
                        var n = e[h].getDisplayData();
                        if (n instanceof ccs.SpriteDisplayData) {
                            g = !0;
                            a.setSkinData(n.skinData);
                            f.skinData = n.skinData;
                            break
                        }
                    }
                    g || a.setSkinData(new ccs.BaseData)
                }
            } else a instanceof cc.ParticleSystem ? (f = new ccs.ParticleDisplayData, a.removeFromParent(), a.cleanup(), (e = this._bone.getArmature()) && a.setParent(e)) : a instanceof ccs.Armature ? (f = new ccs.ArmatureDisplayData, f.displayName = a.getName(), a.setParentBone(this._bone)) : f = new ccs.DisplayData;
            d.setDisplay(a);
            d.setDisplayData(f)
        }
        b ===
        this._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(b, !1))
    },
    _addDisplayOther: function (a, b) {
        var d = null;
        if (b instanceof ccs.Skin) {
            b.setBone(this._bone);
            d = new ccs.SpriteDisplayData;
            d.displayName = b.getDisplayName();
            ccs.displayFactory.initSpriteDisplay(this._bone, a, b.getDisplayName(), b);
            var e = a.getDisplayData();
            if (e instanceof ccs.SpriteDisplayData)b.setSkinData(e.skinData); else {
                for (var e = !1, f = this._decoDisplayList.length - 2; 0 <= f; f--) {
                    var g = this._decoDisplayList[f].getDisplayData();
                    if (g) {
                        e = !0;
                        b.setSkinData(g.skinData);
                        d.skinData = g.skinData;
                        break
                    }
                }
                e || b.setSkinData(new ccs.BaseData);
                b.setSkinData(new ccs.BaseData)
            }
        } else b instanceof cc.ParticleSystem ? (d = new ccs.ParticleDisplayData, d.displayName = b._plistFile) : b instanceof ccs.Armature ? (d = new ccs.ArmatureDisplayData, d.displayName = b.getName(), b.setParentBone(this._bone)) : d = new ccs.DisplayData;
        a.setDisplay(b);
        a.setDisplayData(d)
    },
    removeDisplay: function (a) {
        this._decoDisplayList.splice(a, 1);
        a === this._displayIndex && (this.setCurrentDecorativeDisplay(null),
            this._displayIndex = -1)
    },
    getDecorativeDisplayList: function () {
        return this._decoDisplayList
    },
    changeDisplayWithIndex: function (a, b) {
        a >= this._decoDisplayList.length ? cc.log("the index value is out of range") : (this._forceChangeDisplay = b, this._displayIndex !== a && (this._displayIndex = a, 0 > a ? this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this.setCurrentDecorativeDisplay(null)) : this.setCurrentDecorativeDisplay(this._decoDisplayList[a])))
    },
    changeDisplayWithName: function (a, b) {
        for (var d = this._decoDisplayList,
                 e = 0; e < d.length; e++)if (d[e].getDisplayData().displayName === a) {
            this.changeDisplayWithIndex(e, b);
            break
        }
    },
    setCurrentDecorativeDisplay: function (a) {
        var b = this._currentDecoDisplay;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!1);
        b = this._currentDecoDisplay = a;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!0);
        a = b ? b.getDisplay() :
            null;
        var b = this._displayRenderNode, d = this._bone;
        b && (b instanceof ccs.Armature && d.setChildArmature(null), b.removeFromParent(!0));
        (this._displayRenderNode = a) ? (a instanceof ccs.Armature ? (this._bone.setChildArmature(a), a.setParentBone(this._bone)) : a instanceof cc.ParticleSystem && (a instanceof ccs.Armature ? (d.setChildArmature(a), a.setParentBone(d)) : a instanceof cc.ParticleSystem && a.resetSystem()), a.setColor(d.getDisplayedColor()), a.setOpacity(d.getDisplayedOpacity()), this._displayRenderNode.setVisible(this._visible),
            this._displayType = this._currentDecoDisplay.getDisplayData().displayType) : this._displayType = ccs.DISPLAY_TYPE_MAX;
        cc.renderer.childrenOrderDirty = !0
    },
    getDisplayRenderNode: function () {
        return this._displayRenderNode
    },
    getDisplayRenderNodeType: function () {
        return this._displayType
    },
    getCurrentDisplayIndex: function () {
        return this._displayIndex
    },
    getCurrentDecorativeDisplay: function () {
        return this._currentDecoDisplay
    },
    getDecorativeDisplayByIndex: function (a) {
        return this._decoDisplayList[a]
    },
    initDisplayList: function (a) {
        this._decoDisplayList.length =
            0;
        if (a) {
            a = a.displayDataList;
            for (var b = this._decoDisplayList, d = this._bone, e = 0; e < a.length; e++) {
                var f = a[e], g = new ccs.DecorativeDisplay;
                g.setDisplayData(f);
                ccs.displayFactory.createDisplay(d, g);
                b.push(g)
            }
        }
    },
    containPoint: function (a, b) {
        if (!this._visible || 0 > this._displayIndex)return !1;
        void 0 !== b && (a = cc.p(a, b));
        if (this._currentDecoDisplay.getDisplayData().displayType === ccs.DISPLAY_TYPE_SPRITE) {
            var d = this._currentDecoDisplay.getDisplay(), d = d.getChildByTag(0);
            return ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(d, a)
        }
        return !1
    },
    setVisible: function (a) {
        this._displayRenderNode && (this._visible = a, this._displayRenderNode.setVisible(a))
    },
    isVisible: function () {
        return this._visible
    },
    getContentSize: function () {
        return this._displayRenderNode ? this._displayRenderNode.getContentSize() : cc.size(0, 0)
    },
    getBoundingBox: function () {
        return this._displayRenderNode ? this._displayRenderNode.getBoundingBox() : cc.rect(0, 0, 0, 0)
    },
    getAnchorPoint: function () {
        return this._displayRenderNode ? this._displayRenderNode.getAnchorPoint() : cc.p(0, 0)
    },
    getAnchorPointInPoints: function () {
        return this._displayRenderNode ?
            this._displayRenderNode.getAnchorPointInPoints() : cc.p(0, 0)
    },
    getForceChangeDisplay: function () {
        return this._forceChangeDisplay
    },
    release: function () {
        this._decoDisplayList = null;
        this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this._displayRenderNode = null)
    }
});
ccs.DisplayManager.create = function (a) {
    return new ccs.DisplayManager(a)
};
ccs.Skin = ccs.Sprite.extend({
    _skinData: null,
    bone: null,
    _skinTransform: null,
    _displayName: "",
    _armature: null,
    _className: "Skin",
    ctor: function (a, b) {
        cc.Sprite.prototype.ctor.call(this);
        this.bone = this._skinData = null;
        this._displayName = "";
        this._skinTransform = cc.affineTransformIdentity();
        this._armature = null;
        null == a || "" === a ? ccs.Skin.prototype.init.call(this) : "#" === a[0] ? ccs.Skin.prototype.initWithSpriteFrameName.call(this, a.substr(1)) : ccs.Skin.prototype.initWithFile.call(this, a, b)
    },
    initWithSpriteFrameName: function (a) {
        if ("" ===
            a)return !1;
        var b = cc.spriteFrameCache.getSpriteFrame(a), d = !0;
        b ? this.initWithSpriteFrame(b) : (cc.log("Can't find CCSpriteFrame with %s. Please check your .plist file", a), d = !1);
        this._displayName = a;
        return d
    },
    initWithFile: function (a, b) {
        var d = b ? cc.Sprite.prototype.initWithFile.call(this, a, b) : cc.Sprite.prototype.initWithFile.call(this, a);
        this._displayName = a;
        return d
    },
    setSkinData: function (a) {
        this._skinData = a;
        this.setScaleX(a.scaleX);
        this.setScaleY(a.scaleY);
        this.setRotationX(cc.radiansToDegrees(a.skewX));
        this.setRotationY(cc.radiansToDegrees(-a.skewY));
        this.setPosition(a.x, a.y);
        a = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform();
        var b = this._skinTransform;
        b.a = a.a;
        b.b = a.b;
        b.c = a.c;
        b.d = a.d;
        b.tx = a.tx;
        b.ty = a.ty;
        this.updateArmatureTransform()
    },
    getSkinData: function () {
        return this._skinData
    },
    updateArmatureTransform: function () {
        this._renderCmd.updateArmatureTransform()
    },
    getNodeToWorldTransform: function () {
        return this._renderCmd.getNodeToWorldTransform()
    },
    getNodeToWorldTransformAR: function () {
        return this._renderCmd.getNodeToWorldTransformAR()
    },
    setBone: function (a) {
        this.bone = a;
        if (a = this.bone.getArmature())this._armature = a
    },
    getBone: function () {
        return this.bone
    },
    getDisplayName: function () {
        return this._displayName
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Skin.CanvasRenderCmd(this) : new ccs.Skin.WebGLRenderCmd(this)
    }
});
_p = ccs.Skin.prototype;
cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData);
cc.defineGetterSetter(_p, "displayName", _p.getDisplayName);
_p = null;
ccs.Skin.create = function (a, b) {
    return new ccs.Skin(a, b)
};
ccs.Skin.createWithSpriteFrameName = function (a) {
    return new ccs.Skin("#" + a)
};
(function () {
    ccs.Skin.RenderCmd = {
        updateArmatureTransform: function () {
            var a = this._node;
            this._transform = cc.affineTransformConcat(a._skinTransform, a.bone.getNodeToArmatureTransform());
            this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty
        }, getNodeToWorldTransform: function () {
            return cc.affineTransformConcat(this._transform, this._node.bone.getArmature().getNodeToWorldTransform())
        }, getNodeToWorldTransformAR: function () {
            var a = this._transform, d = this._node;
            this._anchorPointInPoints = cc.pointApplyAffineTransform(this._anchorPointInPoints,
                a);
            a.tx = this._anchorPointInPoints.x;
            a.ty = this._anchorPointInPoints.y;
            return cc.affineTransformConcat(a, d.bone.getArmature().getNodeToWorldTransform())
        }
    };
    ccs.Skin.CanvasRenderCmd = function (a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = ccs.Skin.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(ccs.Skin.RenderCmd, a);
    a.constructor = ccs.Skin.CanvasRenderCmd
})();
(function () {
    ccs.Skin.WebGLRenderCmd = function (a) {
        cc.Sprite.WebGLRenderCmd.call(this, a)
    };
    var a = ccs.Skin.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    cc.inject(ccs.Skin.RenderCmd, a);
    a.constructor = ccs.Skin.WebGLRenderCmd;
    a.vertexBytesPerUnit = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    a.bytesPerUnit = a.vertexBytesPerUnit;
    a.indicesPerUnit = 6;
    a.verticesPerUnit = 4;
    a._supportBatch = !0;
    a.batchShader = null;
    a.updateTransform = function () {
        var a = this._node, d = this._quad, e = this._vertices;
        if (this._buffer) {
            var f =
                this.getNodeToParentTransform(), g = this._float32View, h, n, p = 0, r = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT / 16, s = this.getParentRenderCmd();
            h = s ? s._stackMatrix : cc.current_stack.top;
            n = this._transform4x4;
            var t = this._stackMatrix, s = n.mat;
            s[0] = f.a;
            s[4] = f.c;
            s[12] = f.tx;
            s[1] = f.b;
            s[5] = f.d;
            s[13] = f.ty;
            cc.kmMat4Multiply(t, h, n);
            s[14] = a._vertexZ;
            s = t.mat;
            for (f = 0; 4 > f; ++f)h = e[f].x, n = e[f].y, z = e[f].z, g[p] = h * s[0] + n * s[4] + s[12], g[p + 1] = h * s[1] + n * s[5] + s[13], g[p + 2] = s[14], p += r;
            a.textureAtlas && a.textureAtlas.updateQuad(d, a.textureAtlas.getTotalQuads());
            cc._renderContext.bindBuffer(gl.ARRAY_BUFFER, this._buffer.vertexBuffer);
            cc._renderContext.bufferSubData(gl.ARRAY_BUFFER, this._bufferOffset, this._float32View);
            cc._renderContext.bindBuffer(gl.ARRAY_BUFFER, null)
        }
    }
})();
ccs.ANIMATION_TYPE_SINGLE_FRAME = -4;
ccs.ANIMATION_TYPE_NO_LOOP = -3;
ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2;
ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1;
ccs.ANIMATION_TYPE_LOOP_FRONT = 0;
ccs.ANIMATION_TYPE_LOOP_BACK = 1;
ccs.ANIMATION_TYPE_MAX = 2;
ccs.ProcessBase = ccs.Class.extend({
    _processScale: 1,
    _isComplete: !0,
    _isPause: !0,
    _isPlaying: !1,
    _currentPercent: 0,
    _rawDuration: 0,
    _loopType: 0,
    _tweenEasing: 0,
    animationInternal: null,
    _currentFrame: 0,
    _durationTween: 0,
    _nextFrameIndex: 0,
    _curFrameIndex: null,
    _isLoopBack: !1,
    ctor: function () {
        this._processScale = 1;
        this._isPause = this._isComplete = !0;
        this._isPlaying = !1;
        this._rawDuration = this._durationTween = this._currentPercent = this._currentFrame = 0;
        this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK;
        this._tweenEasing = ccs.TweenType.LINEAR;
        this.animationInternal = 1 / 60;
        this._durationTween = this._curFrameIndex = 0;
        this._isLoopBack = !1
    },
    pause: function () {
        this._isPause = !0;
        this._isPlaying = !1
    },
    resume: function () {
        this._isPause = !1;
        this._isPlaying = !0
    },
    stop: function () {
        this._isComplete = !0;
        this._isPlaying = !1
    },
    play: function (a, b, d, e) {
        this._isPause = this._isComplete = !1;
        this._isPlaying = !0;
        this._currentFrame = 0;
        this._nextFrameIndex = a;
        this._tweenEasing = e
    },
    update: function (a) {
        if (!(this._isComplete || this._isPause || 0 >= this._rawDuration || 1 < a)) {
            var b = void 0 === this._nextFrameIndex ?
                0 : this._nextFrameIndex, d = this._currentFrame;
            0 >= b ? (this._currentPercent = 1, d = 0) : (d += a / this.animationInternal * this._processScale, this._currentPercent = d / b, d = ccs.fmodf(d, b));
            this._currentFrame = d;
            this.updateHandler()
        }
    },
    gotoFrame: function (a) {
        var b = this._loopType;
        b === ccs.ANIMATION_TYPE_NO_LOOP ? b = ccs.ANIMATION_TYPE_MAX : b === ccs.ANIMATION_TYPE_TO_LOOP_FRONT && (b = ccs.ANIMATION_TYPE_LOOP_FRONT);
        this._loopType = b;
        this._curFrameIndex = a;
        this._nextFrameIndex = this._durationTween
    },
    getCurrentFrameIndex: function () {
        return this._curFrameIndex =
            (this._rawDuration - 1) * this._currentPercent
    },
    updateHandler: function () {
    },
    isPause: function () {
        return this._isPause
    },
    isComplete: function () {
        return this._isComplete
    },
    getCurrentPercent: function () {
        return this._currentPercent
    },
    getRawDuration: function () {
        return this._rawDuration
    },
    getLoop: function () {
        return this._loopType
    },
    getTweenEasing: function () {
        return this._tweenEasing
    },
    getAnimationInternal: function () {
        return this.animationInternal
    },
    setAnimationInternal: function (a) {
        this.animationInternal = a
    },
    getProcessScale: function () {
        return this._processScale
    },
    setProcessScale: function (a) {
        this._processScale = a
    },
    isPlaying: function () {
        return this._isPlaying
    }
});
_p = ccs.ProcessBase.prototype;
cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex);
cc.defineGetterSetter(_p, "paused", _p.isPause);
cc.defineGetterSetter(_p, "completed", _p.isComplete);
cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent);
cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration);
cc.defineGetterSetter(_p, "loop", _p.getLoop);
cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing);
cc.defineGetterSetter(_p, "playing", _p.isPlaying);
_p = null;
ccs.MovementEventType = {start: 0, complete: 1, loopComplete: 2};
ccs.AnimationEvent = ccs.Class.extend({
    _arguments: null,
    _callFunc: null,
    _selectorTarget: null,
    ctor: function (a, b, d) {
        this._data = d;
        this._callFunc = a;
        this._selectorTarget = b
    },
    call: function () {
        this._callFunc && this._callFunc.apply(this._selectorTarget, this._arguments)
    },
    setArguments: function (a) {
        this._arguments = a
    }
});
ccs.MovementEvent = function () {
    this.armature = null;
    this.movementType = ccs.MovementEventType.start;
    this.movementID = ""
};
ccs.FrameEvent = function () {
    this.bone = null;
    this.frameEventName = "";
    this.currentFrameIndex = this.originFrameIndex = 0
};
ccs.ArmatureAnimation = ccs.ProcessBase.extend({
    _animationData: null,
    _movementData: null,
    _armature: null,
    _movementID: "",
    _toIndex: 0,
    _tweenList: null,
    _speedScale: 1,
    _ignoreFrameEvent: !1,
    _frameEventQueue: null,
    _movementEventQueue: null,
    _movementList: null,
    _onMovementList: !1,
    _movementListLoop: !1,
    _movementIndex: 0,
    _movementListDurationTo: -1,
    _movementEventCallFunc: null,
    _frameEventCallFunc: null,
    _movementEventTarget: null,
    _frameEventTarget: null,
    _movementEventListener: null,
    _frameEventListener: null,
    ctor: function (a) {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._tweenList = [];
        this._movementList = [];
        this._frameEventQueue = [];
        this._movementEventQueue = [];
        this._armature = null;
        a && ccs.ArmatureAnimation.prototype.init.call(this, a)
    },
    init: function (a) {
        this._armature = a;
        this._tweenList.length = 0;
        return !0
    },
    pause: function () {
        for (var a = this._tweenList, b = 0; b < a.length; b++)a[b].pause();
        ccs.ProcessBase.prototype.pause.call(this)
    },
    resume: function () {
        for (var a = this._tweenList, b = 0; b < a.length; b++)a[b].resume();
        ccs.ProcessBase.prototype.resume.call(this)
    },
    stop: function () {
        for (var a =
            this._tweenList, b = 0; b < a.length; b++)a[b].stop();
        a.length = 0;
        ccs.ProcessBase.prototype.stop.call(this)
    },
    setAnimationScale: function (a) {
        this.setSpeedScale(a)
    },
    getAnimationScale: function () {
        return this.getSpeedScale()
    },
    setSpeedScale: function (a) {
        if (a !== this._speedScale) {
            this._speedScale = a;
            this._processScale = this._movementData ? this._speedScale * this._movementData.scale : this._speedScale;
            a = this._armature.getBoneDic();
            for (var b in a) {
                var d = a[b];
                d.getTween().setProcessScale(this._processScale);
                d.getChildArmature() &&
                d.getChildArmature().getAnimation().setSpeedScale(this._processScale)
            }
        }
    },
    getSpeedScale: function () {
        return this._speedScale
    },
    play: function (a, b, d) {
        cc.assert(this._animationData, "this.animationData can not be null");
        this._movementData = this._animationData.getMovement(a);
        cc.assert(this._movementData, "this._movementData can not be null");
        b = void 0 === b ? -1 : b;
        d = void 0 === d ? -1 : d;
        this._rawDuration = this._movementData.duration;
        this._movementID = a;
        this._processScale = this._speedScale * this._movementData.scale;
        b = -1 ===
        b ? this._movementData.durationTo : b;
        a = 0 === this._movementData.durationTween ? this._rawDuration : this._movementData.durationTween;
        var e = this._movementData.tweenEasing;
        d = 0 > d ? this._movementData.loop : d;
        this._onMovementList = !1;
        ccs.ProcessBase.prototype.play.call(this, b, a, d, e);
        0 === this._rawDuration ? this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME : (this._loopType = d ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._durationTween = a);
        this._tweenList.length = 0;
        var f, g = this._armature.getBoneDic(), h;
        for (h in g) {
            var n =
                g[h];
            f = this._movementData.movBoneDataDic[n.getName()];
            var p = n.getTween();
            f && 0 < f.frameList.length ? (this._tweenList.push(p), f.duration = this._movementData.duration, p.play(f, b, a, d, e), p.setProcessScale(this._processScale), n.getChildArmature() && n.getChildArmature().getAnimation().setSpeedScale(this._processScale)) : n.isIgnoreMovementBoneData() || (n.getDisplayManager().changeDisplayWithIndex(-1, !1), p.stop())
        }
        this._armature.update(0)
    },
    playByIndex: function (a, b, d, e, f) {
        cc.log("playByIndex is deprecated. Use playWithIndex instead.");
        this.playWithIndex(a, b, e)
    },
    playWithIndex: function (a, b, d) {
        var e = this._animationData.movementNames;
        cc.assert(-1 < a && a < e.length);
        this.play(e[a], b, d)
    },
    playWithNames: function (a, b, d) {
        this._movementListLoop = void 0 === d ? !0 : d;
        this._movementListDurationTo = void 0 === b ? -1 : b;
        this._onMovementList = !0;
        this._movementIndex = 0;
        a instanceof Array ? this._movementList = a : this._movementList.length = 0;
        this.updateMovementList()
    },
    playWithIndexes: function (a, b, d) {
        this._movementList.length = 0;
        this._movementListLoop = void 0 === d ? !0 : d;
        this._movementListDurationTo =
            void 0 === b ? -1 : b;
        this._onMovementList = !0;
        this._movementIndex = 0;
        b = this._animationData.movementNames;
        for (d = 0; d < a.length; d++)this._movementList.push(b[a[d]]);
        this.updateMovementList()
    },
    gotoAndPlay: function (a) {
        if (!this._movementData || 0 > a || a >= this._movementData.duration)cc.log("Please ensure you have played a movement, and the frameIndex is in the range."); else {
            var b = this._ignoreFrameEvent;
            this._isPlaying = this._ignoreFrameEvent = !0;
            this._isComplete = this._isPause = !1;
            ccs.ProcessBase.prototype.gotoFrame.call(this,
                a);
            this._currentPercent = this._curFrameIndex / (this._movementData.duration - 1);
            this._currentFrame = this._nextFrameIndex * this._currentPercent;
            for (var d = this._tweenList, e = 0; e < d.length; e++)d[e].gotoAndPlay(a);
            this._armature.update(0);
            this._ignoreFrameEvent = b
        }
    },
    gotoAndPause: function (a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    getMovementCount: function () {
        return this._animationData.getMovementCount()
    },
    update: function (a) {
        ccs.ProcessBase.prototype.update.call(this, a);
        for (var b = this._tweenList, d = 0; d < b.length; d++)b[d].update(a);
        for (b = this._frameEventQueue; 0 < b.length;)a = b.shift(), this._ignoreFrameEvent = !0, this._frameEventCallFunc && this._frameEventCallFunc.call(this._frameEventTarget, a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._frameEventListener && this._frameEventListener(a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._ignoreFrameEvent = !1;
        for (b = this._movementEventQueue; 0 < b.length;)a = b.shift(), this._movementEventCallFunc && this._movementEventCallFunc.call(this._movementEventTarget,
            a.armature, a.movementType, a.movementID), this._movementEventListener && this._movementEventListener(a.armature, a.movementType, a.movementID)
    },
    updateHandler: function () {
        var a = this._currentPercent;
        if (1 <= a) {
            switch (this._loopType) {
                case ccs.ANIMATION_TYPE_NO_LOOP:
                    this._loopType = ccs.ANIMATION_TYPE_MAX;
                    this._currentFrame = (a - 1) * this._nextFrameIndex;
                    a = this._currentFrame / this._durationTween;
                    if (1 > a) {
                        this._nextFrameIndex = this._durationTween;
                        this.movementEvent(this._armature, ccs.MovementEventType.start, this._movementID);
                        break
                    }
                    break;
                case ccs.ANIMATION_TYPE_MAX:
                case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                    a = 1;
                    this._isComplete = !0;
                    this._isPlaying = !1;
                    this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID);
                    this.updateMovementList();
                    break;
                case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                    this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT;
                    a = ccs.fmodf(a, 1);
                    this._currentFrame = 0 === this._nextFrameIndex ? 0 : ccs.fmodf(this._currentFrame, this._nextFrameIndex);
                    this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                    this.movementEvent(this,
                        ccs.MovementEventType.start, this._movementID);
                    break;
                default:
                    this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._toIndex = 0, this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID)
            }
            this._currentPercent = a
        }
    },
    getCurrentMovementID: function () {
        return this._isComplete ? "" : this._movementID
    },
    setMovementEventCallFunc: function (a, b) {
        1 === arguments.length ? this._movementEventListener = a : 2 === arguments.length && (this._movementEventTarget = b, this._movementEventCallFunc =
            a)
    },
    setFrameEventCallFunc: function (a, b) {
        1 === arguments.length ? this._frameEventListener = a : 2 === arguments.length && (this._frameEventTarget = b, this._frameEventCallFunc = a)
    },
    setUserObject: function (a) {
        this._userObject = a
    },
    frameEvent: function (a, b, d, e) {
        if (this._frameEventTarget && this._frameEventCallFunc || this._frameEventListener) {
            var f = new ccs.FrameEvent;
            f.bone = a;
            f.frameEventName = b;
            f.originFrameIndex = d;
            f.currentFrameIndex = e;
            this._frameEventQueue.push(f)
        }
    },
    movementEvent: function (a, b, d) {
        if (this._movementEventTarget &&
            this._movementEventCallFunc || this._movementEventListener) {
            var e = new ccs.MovementEvent;
            e.armature = a;
            e.movementType = b;
            e.movementID = d;
            this._movementEventQueue.push(e)
        }
    },
    updateMovementList: function () {
        if (this._onMovementList) {
            var a, b = this._movementList;
            this._movementListLoop ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++, this._movementIndex >= b.length && (this._movementIndex = 0)) : this._movementIndex < b.length ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++) :
                this._onMovementList = !1;
            this._onMovementList = !0
        }
    },
    setAnimationData: function (a) {
        this._animationData !== a && (this._animationData = a)
    },
    getAnimationData: function () {
        return this._animationData
    },
    getUserObject: function () {
        return this._userObject
    },
    isIgnoreFrameEvent: function () {
        return this._ignoreFrameEvent
    }
});
_p = ccs.ArmatureAnimation.prototype;
cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale);
cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale);
_p = null;
ccs.ArmatureAnimation.create = function (a) {
    return new ccs.ArmatureAnimation(a)
};
ccs.Tween = ccs.ProcessBase.extend({
    _tweenData: null,
    _to: null,
    _from: null,
    _between: null,
    _movementBoneData: null,
    _bone: null,
    _frameTweenEasing: 0,
    _betweenDuration: 0,
    _totalDuration: 0,
    _toIndex: 0,
    _fromIndex: 0,
    _animation: null,
    _passLastFrame: !1,
    ctor: function (a) {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._frameTweenEasing = ccs.TweenType.LINEAR;
        ccs.Tween.prototype.init.call(this, a)
    },
    init: function (a) {
        this._from = new ccs.FrameData;
        this._between = new ccs.FrameData;
        this._bone = a;
        this._tweenData = this._bone.getTweenData();
        this._tweenData.displayIndex = -1;
        this._animation = null !== this._bone && null !== this._bone.getArmature() ? this._bone.getArmature().getAnimation() : null;
        return !0
    },
    play: function (a, b, d, e, f) {
        ccs.ProcessBase.prototype.play.call(this, b, d, e, f);
        this._loopType = e ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP;
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        f = a !== this._movementBoneData;
        this.setMovementBoneData(a);
        this._rawDuration = this._movementBoneData.duration;
        a = this._movementBoneData.getFrameData(0);
        this._tweenData.displayIndex = a.displayIndex;
        this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData()), this._tweenData.scaleX += 1, this._tweenData.scaleY += 1);
        0 === this._rawDuration ? (this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME, 0 === b ? this.setBetween(a, a) : this.setBetween(this._tweenData, a), this._frameTweenEasing = ccs.TweenType.LINEAR) : 1 < this._movementBoneData.frameList.length && (this._durationTween = d * this._movementBoneData.scale,
            e && 0 !== this._movementBoneData.delay ? this.setBetween(this._tweenData, this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)) : f && 0 !== b ? this.setBetween(this._tweenData, a) : this.setBetween(a, a));
        this.tweenNodeTo(0)
    },
    gotoAndPlay: function (a) {
        ccs.ProcessBase.prototype.gotoFrame.call(this, a);
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        this._isPlaying = !0;
        this._isComplete = this._isPause = !1;
        this._currentPercent = this._curFrameIndex / (this._rawDuration -
            1);
        this._currentFrame = this._nextFrameIndex * this._currentPercent
    },
    gotoAndPause: function (a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    updateHandler: function () {
        var a = null == this._currentPercent ? 1 : this._currentPercent, b = this._loopType;
        if (1 <= a)switch (b) {
            case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            case ccs.ANIMATION_TYPE_NO_LOOP:
                b = ccs.ANIMATION_TYPE_MAX;
                a = 0 >= this._durationTween ? 1 : (a - 1) * this._nextFrameIndex / this._durationTween;
                1 <= a ? (a = 1, this._isComplete = !0, this._isPlaying = !1) : (this._nextFrameIndex = this._durationTween, this._currentFrame = a * this._nextFrameIndex, this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0);
                break;
            case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                b = ccs.ANIMATION_TYPE_LOOP_FRONT;
                this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                0 !== this._movementBoneData.delay ? (this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex, a = this._currentFrame / this._nextFrameIndex) : this._currentFrame = a = 0;
                this._fromIndex = this._toIndex =
                    this._betweenDuration = this._totalDuration = 0;
                break;
            case ccs.ANIMATION_TYPE_MAX:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            default:
                this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex)
        }
        1 > a && b < ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = Math.sin(a * cc.PI / 2));
        this._currentPercent = a;
        this._loopType = b;
        b > ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = this.updateFrameData(a));
        this._frameTweenEasing !== ccs.TweenType.TWEEN_EASING_MAX && this.tweenNodeTo(a)
    },
    setBetween: function (a, b, d) {
        void 0 === d && (d = !0);
        0 > a.displayIndex &&
        0 <= b.displayIndex ? (this._from.copy(b), this._between.subtract(b, b, d)) : 0 > b.displayIndex && 0 <= a.displayIndex ? (this._from.copy(a), this._between.subtract(b, b, d)) : (this._from.copy(a), this._between.subtract(a, b, d));
        a.isTween || (this._tweenData.copy(a), this._tweenData.isTween = !0);
        this.arriveKeyFrame(a)
    },
    arriveKeyFrame: function (a) {
        if (a) {
            var b = this._bone, d = b.getDisplayManager(), e = a.displayIndex;
            d.getForceChangeDisplay() || d.changeDisplayWithIndex(e, !1);
            this._tweenData.zOrder = a.zOrder;
            b.updateZOrder();
            this._bone.setBlendFunc(a.blendFunc);
            (b = b.getChildArmature()) && "" !== a.movement && b.getAnimation().play(a.movement)
        }
    },
    tweenNodeTo: function (a, b) {
        b || (b = this._tweenData);
        var d = this._from, e = this._between;
        d.isTween || (a = 0);
        b.x = d.x + a * e.x;
        b.y = d.y + a * e.y;
        b.scaleX = d.scaleX + a * e.scaleX;
        b.scaleY = d.scaleY + a * e.scaleY;
        b.skewX = d.skewX + a * e.skewX;
        b.skewY = d.skewY + a * e.skewY;
        this._bone.setTransformDirty(!0);
        b && e.isUseColorInfo && this.tweenColorTo(a, b);
        return b
    },
    tweenColorTo: function (a, b) {
        var d = this._from, e = this._between;
        b.a = d.a + a * e.a;
        b.r = d.r + a * e.r;
        b.g = d.g + a *
            e.g;
        b.b = d.b + a * e.b;
        this._bone.updateColor()
    },
    updateFrameData: function (a) {
        1 < a && 0 !== this._movementBoneData.delay && (a = ccs.fmodf(a, 1));
        a *= this._rawDuration - 1;
        var b, d, e = this._totalDuration, f = this._betweenDuration, g = this._toIndex;
        if (a < e || a >= e + f) {
            var f = this._movementBoneData.frameList, h = f.length;
            if (a < f[0].frameID)return b = d = f[0], this.setBetween(b, d), this._currentPercent;
            if (a >= f[h - 1].frameID) {
                if (this._passLastFrame)return b = d = f[h - 1], this.setBetween(b, d), this._currentPercent;
                this._passLastFrame = !0
            } else this._passLastFrame = !1;
            do if (this._fromIndex = g, b = f[this._fromIndex], e = b.frameID, g = this._fromIndex + 1, g >= h && (g = 0), d = f[g], b.strEvent && !this._animation.isIgnoreFrameEvent() && this._animation.frameEvent(this._bone, b.strEvent, b.frameID, a), a === b.frameID || this._passLastFrame && this._fromIndex === h - 1)break; while (a < b.frameID || a >= d.frameID);
            f = d.frameID - b.frameID;
            this._frameTweenEasing = b.tweenEasing;
            this.setBetween(b, d, !1);
            this._totalDuration = e;
            this._betweenDuration = f;
            this._toIndex = g
        }
        a = 0 === f ? 0 : (a - this._totalDuration) / this._betweenDuration;
        b = this._frameTweenEasing !== ccs.TweenType.LINEAR ? this._frameTweenEasing : this._tweenEasing;
        b === ccs.TweenType.TWEEN_EASING_MAX || b === ccs.TweenType.LINEAR || this._passLastFrame || (a = ccs.TweenFunction.tweenTo(a, b, this._from.easingParams));
        return a
    },
    setAnimation: function (a) {
        this._animation = a
    },
    getAnimation: function () {
        return this._animation
    },
    setMovementBoneData: function (a) {
        this._movementBoneData = a
    }
});
_p = ccs.Tween.prototype;
cc.defineGetterSetter(_p, "animation", _p.getAnimation, _p.setAnimation);
_p = null;
ccs.Tween.create = function (a) {
    return new ccs.Tween(a)
};
ccs.PT_RATIO = 32;
ccs.ColliderFilter = ccs.Class.extend({
    _collisionType: 0,
    _group: 0,
    _categoryBits: 0,
    _groupIndex: 0,
    _maskBits: 0,
    ctor: function (a, b) {
        this._collisionType = a || 0;
        this._group = b || 0
    },
    updateShape: function (a) {
        if (a instanceof cp.Shape)a.collision_type = this._collisionType, a.group = this._group; else if (a instanceof Box2D.b2FilterData) {
            var b = new Box2D.b2FilterData;
            b.categoryBits = this._categoryBits;
            b.groupIndex = this._groupIndex;
            b.maskBits = this._maskBits;
            a.SetFilterData(b)
        }
    }
});
ccs.ColliderBody = ccs.Class.extend({
    shape: null, coutourData: null, colliderFilter: null, _calculatedVertexList: null, ctor: function (a) {
        this.shape = null;
        this.coutourData = a;
        this.colliderFilter = new ccs.ColliderFilter;
        ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX && (this._calculatedVertexList = [])
    }, getContourData: function () {
        return this.coutourData
    }, setColliderFilter: function (a) {
        this.colliderFilter = a
    }, getCalculatedVertexList: function () {
        return this._calculatedVertexList
    }, setB2Fixture: function (a) {
        this._fixture = a
    }, getB2Fixture: function () {
        return this._fixture
    },
    setShape: function (a) {
        this.shape = a
    }, getShape: function () {
        return this.shape
    }, setContourData: function (a) {
        this.coutourData = a
    }, getColliderFilter: function () {
        return this.colliderFilter
    }
});
ccs.ColliderDetector = ccs.Class.extend({
    _colliderBodyList: null,
    _bone: null,
    _body: null,
    _active: !1,
    _filter: null,
    helpPoint: cc.p(0, 0),
    ctor: function (a) {
        this._colliderBodyList = [];
        this._body = this._bone = null;
        this._active = !1;
        this._filter = null;
        ccs.ColliderDetector.prototype.init.call(this, a)
    },
    init: function (a) {
        this._colliderBodyList.length = 0;
        a && (this._bone = a);
        this._filter = new ccs.ColliderFilter;
        return !0
    },
    addContourData: function (a) {
        var b = new ccs.ColliderBody(a);
        this._colliderBodyList.push(b);
        if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
            b =
                b.getCalculatedVertexList();
            a = a.vertexList;
            for (var d = 0; d < a.length; d++) {
                var e = new ccs.ContourVertex2(0, 0);
                b.push(e)
            }
        }
    },
    addContourDataList: function (a) {
        for (var b = 0; b < a.length; b++)this.addContourData(a[b])
    },
    removeContourData: function (a) {
        var b = [], d, e = this._colliderBodyList;
        for (d = 0; d < e.length; d++) {
            var f = e[d];
            f && f.getContourData() === a && b.push(f)
        }
        for (d = 0; d < b.length; d++)cc.arrayRemoveObject(e, b[d])
    },
    removeAll: function () {
        this._colliderBodyList.length = 0
    },
    setActive: function (a) {
        if (this._active !== a) {
            this._active =
                a;
            a = this._body;
            var b;
            if (a)if (b = null, this._active)for (var d = 0; d < this._colliderBodyList.length; d++)b = this._colliderBodyList[d], b = b.getShape(), a.space.addShape(b); else for (d = 0; d < this._colliderBodyList.length; d++)b = this._colliderBodyList[d], b = b.getShape(), a.space.removeShape(b)
        }
    },
    getActive: function () {
        return this._active
    },
    getColliderBodyList: function () {
        return this._colliderBodyList
    },
    setColliderFilter: function (a) {
        this._filter = a;
        for (var b = this._colliderBodyList, d = 0; d < b.length; d++) {
            var e = b[d];
            e.setColliderFilter(a);
            e.getShape() && e.getColliderFilter().updateShape(e.getShape())
        }
    },
    getColliderFilter: function () {
        return this._filter
    },
    updateTransform: function (a) {
        if (this._active)for (var b = null, d = this._body, e = this.helpPoint, f = 0; f < this._colliderBodyList.length; f++) {
            var b = this._colliderBodyList[f], g = b.getContourData(), h = null;
            d && (h = b.getShape());
            for (var g = g.vertexList, n = b.getCalculatedVertexList(), b = 0; b < g.length; b++) {
                e.x = g[b].x;
                e.y = g[b].y;
                e = cc.pointApplyAffineTransform(e, a);
                if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
                    var p =
                        cc.p(0, 0);
                    p.x = e.x;
                    p.y = e.y;
                    n[b] = p
                }
                h && (h.verts[2 * b] = e.x, h.verts[2 * b + 1] = e.y)
            }
            if (h)for (b = 0; b < g.length; b++)n = cp.v.normalize(cp.v.perp(cp.v.sub(h.verts[(b + 1) % h.verts.length], h.verts[b]))), h.planes && (h.planes[b].n = n, h.planes[b].d = cp.v.dot(n, h.verts[b]))
        }
    },
    setBody: function (a) {
        this._body = a;
        for (var b = this._colliderBodyList, d = 0; d < b.length; d++) {
            a = b[d];
            for (var e = [], f = a.getContourData().vertexList, g = 0; g < f.length; g++) {
                var h = f[g];
                e.push(h.x);
                e.push(h.y)
            }
            e = new cp.PolyShape(this._body, e, cp.vzero);
            e.sensor = !0;
            e.data =
                this._bone;
            this._active && this._body.space.addShape(e);
            a.setShape(e);
            a.getColliderFilter().updateShape(e)
        }
    },
    getBody: function () {
        return this._body
    }
});
_p = ccs.ColliderDetector.prototype;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p = null;
ccs.ColliderDetector.create = function (a) {
    return new ccs.ColliderDetector(a)
};
ccs.Armature = ccs.Node.extend({
    animation: null,
    armatureData: null,
    batchNode: null,
    _textureAtlas: null,
    _parentBone: null,
    _boneDic: null,
    _topBoneList: null,
    _armatureIndexDic: null,
    _offsetPoint: null,
    version: 0,
    _armatureTransformDirty: !0,
    _body: null,
    _blendFunc: null,
    _className: "Armature",
    ctor: function (a, b) {
        cc.Node.prototype.ctor.call(this);
        this._name = "";
        this._topBoneList = [];
        this._armatureIndexDic = {};
        this._offsetPoint = cc.p(0, 0);
        this._armatureTransformDirty = !0;
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        a &&
        ccs.Armature.prototype.init.call(this, a, b)
    },
    init: function (a, b) {
        cc.Node.prototype.init.call(this);
        b && (this._parentBone = b);
        this.removeAllChildren();
        this.animation = new ccs.ArmatureAnimation;
        this.animation.init(this);
        this._boneDic = {};
        this._topBoneList.length = 0;
        var d = ccs.armatureDataManager, e;
        if ("" !== a) {
            e = d.getAnimationData(a);
            cc.assert(e, "AnimationData not exist!");
            this.animation.setAnimationData(e);
            d = d.getArmatureData(a);
            cc.assert(d, "ArmatureData not exist!");
            this.armatureData = d;
            var d = d.getBoneDataDic(),
                f;
            for (f in d) {
                var d = this.createBone(String(f)), g = e.getMovement(e.movementNames[0]);
                g && (g = g.getMovementBoneData(d.getName())) && !(0 >= g.frameList.length) && (g = g.getFrameData(0)) && (d.getTweenData().copy(g), d.changeDisplayWithIndex(g.displayIndex, !1))
            }
            this.update(0);
            this.updateOffsetPoint()
        } else a = "new_armature", this.armatureData = new ccs.ArmatureData, this.armatureData.name = a, e = new ccs.AnimationData, e.name = a, d.addArmatureData(a, this.armatureData), d.addAnimationData(a, e), this.animation.setAnimationData(e);
        this._renderCmd.initShaderCache();
        this.setCascadeOpacityEnabled(!0);
        this.setCascadeColorEnabled(!0);
        return !0
    },
    addChild: function (a, b, d) {
        a instanceof ccui.Widget ? cc.log("Armature doesn't support to add Widget as its child, it will be fix soon.") : cc.Node.prototype.addChild.call(this, a, b, d)
    },
    createBone: function (a) {
        var b = this.getBone(a);
        if (b)return b;
        var b = this.armatureData.getBoneData(a), d = b.parentName, e = null;
        d ? (this.createBone(d), e = new ccs.Bone(a), this.addBone(e, d)) : (e = new ccs.Bone(a), this.addBone(e,
            ""));
        e.setBoneData(b);
        e.getDisplayManager().changeDisplayWithIndex(-1, !1);
        return e
    },
    addBone: function (a, b) {
        cc.assert(a, "Argument must be non-nil");
        var d = this._boneDic;
        a.getName() && cc.assert(!d[a.getName()], "bone already added. It can't be added again");
        if (b) {
            var e = d[b];
            e ? e.addChildBone(a) : this._topBoneList.push(a)
        } else this._topBoneList.push(a);
        a.setArmature(this);
        d[a.getName()] = a;
        this.addChild(a)
    },
    removeBone: function (a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        a.setArmature(null);
        a.removeFromParent(b);
        cc.arrayRemoveObject(this._topBoneList, a);
        delete this._boneDic[a.getName()];
        this.removeChild(a, !0)
    },
    getBone: function (a) {
        return this._boneDic[a]
    },
    changeBoneParent: function (a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        var d = a.getParentBone();
        d && (cc.arrayRemoveObject(d.getChildren(), a), a.setParentBone(null));
        b && ((d = this._boneDic[b]) ? (d.addChildBone(a), cc.arrayRemoveObject(this._topBoneList, a)) : this._topBoneList.push(a))
    },
    getBoneDic: function () {
        return this._boneDic
    },
    updateOffsetPoint: function () {
        var a = this.getBoundingBox();
        this.setContentSize(a);
        var b = this._offsetPoint;
        b.x = -a.x;
        b.y = -a.y;
        0 !== a.width && 0 !== a.height && this.setAnchorPoint(b.x / a.width, b.y / a.height)
    },
    getOffsetPoints: function () {
        return {x: this._offsetPoint.x, y: this._offsetPoint.y}
    },
    setAnimation: function (a) {
        this.animation = a
    },
    getAnimation: function () {
        return this.animation
    },
    getArmatureTransformDirty: function () {
        return this._armatureTransformDirty
    },
    update: function (a) {
        this.animation.update(a);
        for (var b = this._topBoneList,
                 d = 0; d < b.length; d++)b[d].update(a);
        this._armatureTransformDirty = !1
    },
    onEnter: function () {
        cc.Node.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    onExit: function () {
        cc.Node.prototype.onExit.call(this);
        this.unscheduleUpdate()
    },
    getBoundingBox: function () {
        for (var a, b, d, e = 0, f = !0, g = cc.rect(0, 0, 0, 0), h = this._children, n = h.length, p = 0; p < n; p++)if (a = h[p])if (e = a.getDisplayManager().getBoundingBox(), 0 !== e.x || 0 !== e.y || 0 !== e.width || 0 !== e.height)f ? (a = e.x, b = e.y, d = e.x + e.width, e = e.y + e.height, f = !1) : (a = e.x < g.x ? e.x : g.x, b =
            e.y < g.y ? e.y : g.y, d = e.x + e.width > g.x + g.width ? e.x + e.width : g.x + g.width, e = e.y + e.height > g.y + g.height ? e.y + e.height : g.y + g.height), g.x = a, g.y = b, g.width = d - a, g.height = e - b;
        return cc.rectApplyAffineTransform(g, this.getNodeToParentTransform())
    },
    getBoneAtPoint: function (a, b) {
        for (var d = this._children, e = d.length - 1; 0 <= e; e--) {
            var f = d[e];
            if (f instanceof ccs.Bone && f.getDisplayManager().containPoint(a, b))return f
        }
        return null
    },
    setParentBone: function (a) {
        this._parentBone = a;
        a = this._boneDic;
        for (var b in a)a[b].setArmature(this)
    },
    getParentBone: function () {
        return this._parentBone
    },
    drawContour: function () {
        cc._drawingUtil.setDrawColor(255, 255, 255, 255);
        cc._drawingUtil.setLineWidth(1);
        var a = this._boneDic, b;
        for (b in a) {
            var d = a[b].getColliderDetector();
            if (d)for (var d = d.getColliderBodyList(), e = 0; e < d.length; e++) {
                var f = d[e].getCalculatedVertexList();
                cc._drawingUtil.drawPoly(f, f.length, !0)
            }
        }
    },
    setBody: function (a) {
        if (this._body !== a) {
            this._body = a;
            this._body.data = this;
            var b, d;
            a = this._children;
            for (var e = 0; e < a.length; e++)if (b = a[e], b instanceof ccs.Bone) {
                b = b.getDisplayManager().getDecorativeDisplayList();
                for (var f = 0; f < b.length; f++)d = b[f], (d = d.getColliderDetector()) && d.setBody(this._body)
            }
        }
    },
    getShapeList: function () {
        return this._body ? this._body.shapeList : null
    },
    getBody: function () {
        return this._body
    },
    setBlendFunc: function (a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getBlendFunc: function () {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    setColliderFilter: function (a) {
        var b =
            this._boneDic, d;
        for (d in b)b[d].setColliderFilter(a)
    },
    getArmatureData: function () {
        return this.armatureData
    },
    setArmatureData: function (a) {
        this.armatureData = a
    },
    getBatchNode: function () {
        return this.batchNode
    },
    setBatchNode: function (a) {
        this.batchNode = a
    },
    getVersion: function () {
        return this.version
    },
    setVersion: function (a) {
        this.version = a
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Armature.CanvasRenderCmd(this) : new ccs.Armature.WebGLRenderCmd(this)
    }
});
_p = ccs.Armature.prototype;
cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter);
_p = null;
ccs.Armature.create = function (a, b) {
    return new ccs.Armature(a, b)
};
(function () {
    ccs.Armature.RenderCmd = {
        _updateAnchorPointInPoint: function () {
            var a = this._node, b = a._contentSize, d = a._anchorPoint, a = a._offsetPoint;
            this._anchorPointInPoints.x = b.width * d.x - a.x;
            this._anchorPointInPoints.y = b.height * d.y - a.y;
            this._realAnchorPointInPoints.x = b.width * d.x;
            this._realAnchorPointInPoints.y = b.height * d.y;
            this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
        }, getAnchorPointInPoints: function () {
            return cc.p(this._realAnchorPointInPoints)
        }
    }
})();
(function () {
    ccs.Armature.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._realAnchorPointInPoints = new cc.Point(0, 0);
        this._startRenderCmd = new cc.CustomRenderCmd(this, this._startCmdCallback);
        this._RestoreRenderCmd = new cc.CustomRenderCmd(this, this._RestoreCmdCallback)
    };
    var a = ccs.Armature.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.inject(ccs.Armature.RenderCmd, a);
    a.constructor = ccs.Armature.CanvasRenderCmd;
    a._startCmdCallback = function (a,
                                    d, e) {
        var f = this._node._parent;
        this.transform(f ? f._renderCmd : null);
        a = a || cc._renderContext;
        a.save();
        a._switchToArmatureMode(!0, this._worldTransform, d, e)
    };
    a.transform = function (a, d) {
        ccs.Node.CanvasRenderCmd.prototype.transform.call(this, a, d);
        for (var e = this._node._children, f = 0, g = e.length; f < g; f++) {
            var h = e[f];
            if (h && h.getDisplayRenderNode) {
                var n = h.getDisplayRenderNode();
                if (n && n._renderCmd) {
                    n = n._renderCmd;
                    n.transform(null);
                    var p = h._renderCmd._displayedColor, h = h._renderCmd._displayedOpacity, r = cc.Node._dirtyFlags,
                        s = n._dirtyFlag, t = s & r.opacityDirty;
                    s & r.colorDirty && n._updateDisplayColor(p);
                    t && n._updateDisplayOpacity(h)
                }
            }
        }
    };
    a._RestoreCmdCallback = function (a) {
        this._cacheDirty = !1;
        a._switchToArmatureMode(!1);
        a.restore()
    };
    a.initShaderCache = function () {
    };
    a.setShaderProgram = function () {
    };
    a.updateChildPosition = function (a, d) {
        cc.renderer.pushRenderCommand(d._renderCmd)
    };
    a.rendering = function (a, d, e) {
        for (var f = this._node._children, g = cc.BlendFunc.ALPHA_PREMULTIPLIED, h = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, n = 0, p = f.length; n < p; n++) {
            var r =
                f[n];
            if (r && r.getDisplayRenderNode) {
                var s = r.getDisplayRenderNode();
                if (null !== s)switch (r.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        s instanceof ccs.Skin && this.updateChildPosition(a, s, r, g, h);
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        s._renderCmd.rendering(a, d, e);
                        break;
                    default:
                        s.visit(this)
                }
            } else r instanceof cc.Node && this._visitNormalChild(r)
        }
    };
    a._visitNormalChild = function (a) {
        if (null != a) {
            var d = a._renderCmd;
            if (a._visible) {
                d._curLevel = this._curLevel + 1;
                var e = a._children, f;
                d._syncStatus(this);
                d.transform(null);
                var g = e.length;
                if (0 < g) {
                    a.sortAllChildren();
                    for (a = 0; a < g; a++)if (f = e[a], 0 > f._localZOrder)f._renderCmd.visit(d); else break;
                    for (cc.renderer.pushRenderCommand(d); a < g; a++)e[a]._renderCmd.visit(d)
                } else cc.renderer.pushRenderCommand(d);
                this._dirtyFlag = 0
            }
        }
    };
    a.visit = function (a) {
        var d = this._node;
        d._visible && (this.updateStatus(a), d.sortAllChildren(), cc.renderer.pushRenderCommand(this._startRenderCmd), this.rendering(), cc.renderer.pushRenderCommand(this._RestoreRenderCmd), this._cacheDirty = !1)
    }
})();
(function () {
    ccs.Armature.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._realAnchorPointInPoints = new cc.Point(0, 0)
    };
    var a = ccs.Armature.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.inject(ccs.Armature.RenderCmd, a);
    a.constructor = ccs.Armature.WebGLRenderCmd;
    a.rendering = function (a, d) {
        var e = this._node;
        d || (cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix(), cc.kmGLLoadMatrix(this._stackMatrix));
        for (var f = e._children, g = cc.BlendFunc.ALPHA_PREMULTIPLIED,
                 h = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, n = 0, p = f.length; n < p; n++) {
            var r = f[n];
            if (r && r.getDisplayRenderNode) {
                var s = r.getDisplayRenderNode();
                if (null !== s)switch (r.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        if (s instanceof ccs.Skin) {
                            s.setShaderProgram(this._shaderProgram);
                            this._updateColorAndOpacity(s._renderCmd, r);
                            s.updateTransform();
                            var t = r.getBlendFunc();
                            t.src !== g.src || t.dst !== g.dst ? s.setBlendFunc(r.getBlendFunc()) : e._blendFunc.src !== g.src || e._blendFunc.dst !== g.dst || s.getTexture().hasPremultipliedAlpha() ?
                                s.setBlendFunc(e._blendFunc) : s.setBlendFunc(h);
                            s._renderCmd.rendering(a)
                        }
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        s.setShaderProgram(this._shaderProgram);
                        s._renderCmd.rendering(a, !0);
                        break;
                    default:
                        s._renderCmd.transform(), s._renderCmd.rendering(a)
                }
            } else r instanceof cc.Node && (r.setShaderProgram(this._shaderProgram), r._renderCmd.transform(), r._renderCmd.rendering && r._renderCmd.rendering(a))
        }
        d || cc.kmGLPopMatrix()
    };
    a.initShaderCache = function () {
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR)
    };
    a.setShaderProgram = function (a) {
        this._shaderProgram = a
    };
    a._updateColorAndOpacity = function (a, d) {
        var e = d._renderCmd._displayedColor, f = d._renderCmd._displayedOpacity, g = cc.Node._dirtyFlags, h = a._dirtyFlag, n = h & g.colorDirty, g = h & g.opacityDirty;
        n && a._updateDisplayColor(e);
        g && a._updateDisplayOpacity(f);
        (n || g) && a._updateColor()
    };
    a.updateChildPosition = function (a, d, e, f, g) {
        var h = this._node;
        d.updateTransform();
        var n = e.getBlendFunc();
        n.src !== f.src || n.dst !== f.dst ? d.setBlendFunc(e.getBlendFunc()) : h._blendFunc.src !==
        f.src || node_blendFunc.dst !== f.dst || d.getTexture().hasPremultipliedAlpha() ? d.setBlendFunc(h._blendFunc) : d.setBlendFunc(g);
        d.rendering(a)
    };
    a.updateStatus = function () {
        var a = cc.Node._dirtyFlags, d = this._dirtyFlag, e = d & a.colorDirty, f = d & a.opacityDirty;
        e && this._updateDisplayColor();
        f && this._updateDisplayOpacity();
        (e || f) && this._updateColor();
        d & a.orderDirty && (this._dirtyFlag ^= this._dirtyFlag & a.orderDirty);
        this.transform(this.getParentRenderCmd(), !0)
    };
    a.visit = function (a) {
        var d = this._node;
        if (d._visible) {
            var e =
                cc.current_stack;
            e.stack.push(e.top);
            this.updateStatus(a);
            e.top = this._stackMatrix;
            d.sortAllChildren();
            a = cc.renderer;
            var f = d._children, g, h, n = f.length;
            for (h = 0; h < n; h++)if (g = f[h], 0 > g._localZOrder)isNaN(g._customZ) && (g._vertexZ = a.assignedZ, a.assignedZ += a.assignedZStep); else break;
            isNaN(d._customZ) && (d._vertexZ = a.assignedZ, a.assignedZ += a.assignedZStep);
            for (a.pushRenderCommand(this); h < n; h++)g = f[h], isNaN(g._customZ) && (g._vertexZ = a.assignedZ, a.assignedZ += a.assignedZStep);
            this._dirtyFlag = 0;
            e.top = e.stack.pop()
        }
    }
})();
ccs.Bone = ccs.Node.extend({
    _boneData: null,
    _armature: null,
    _childArmature: null,
    _displayManager: null,
    ignoreMovementBoneData: !1,
    _tween: null,
    _tweenData: null,
    _parentBone: null,
    _boneTransformDirty: !1,
    _worldTransform: null,
    _blendFunc: null,
    blendDirty: !1,
    _worldInfo: null,
    _armatureParentBone: null,
    _dataVersion: 0,
    _className: "Bone",
    ctor: function (a) {
        cc.Node.prototype.ctor.call(this);
        this._displayManager = this._tween = this._boneData = this._childArmature = this._armature = this._parentBone = this._tweenData = null;
        this.ignoreMovementBoneData = !1;
        this._worldTransform = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
        this._boneTransformDirty = !0;
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.blendDirty = !1;
        this._armatureParentBone = this._worldInfo = null;
        this._dataVersion = 0;
        ccs.Bone.prototype.init.call(this, a)
    },
    init: function (a) {
        a && (this._name = a);
        this._tweenData = new ccs.FrameData;
        this._tween = new ccs.Tween(this);
        this._displayManager = new ccs.DisplayManager(this);
        this._worldInfo = new ccs.BaseData;
        this._boneData = new ccs.BaseData;
        return !0
    },
    setBoneData: function (a) {
        cc.assert(a,
            "_boneData must not be null");
        this._boneData !== a && (this._boneData = a);
        this.setName(this._boneData.name);
        this._localZOrder = this._boneData.zOrder;
        this._displayManager.initDisplayList(a)
    },
    getBoneData: function () {
        return this._boneData
    },
    setArmature: function (a) {
        (this._armature = a) ? (this._tween.setAnimation(this._armature.getAnimation()), this._dataVersion = this._armature.getArmatureData().dataVersion, this._armatureParentBone = this._armature.getParentBone()) : this._armatureParentBone = null
    },
    getArmature: function () {
        return this._armature
    },
    update: function (a) {
        this._parentBone && (this._boneTransformDirty = this._boneTransformDirty || this._parentBone.isTransformDirty());
        this._armatureParentBone && !this._boneTransformDirty && (this._boneTransformDirty = this._armatureParentBone.isTransformDirty());
        if (this._boneTransformDirty) {
            var b = this._tweenData;
            this._dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeConcat(b, this._boneData), b.scaleX -= 1, b.scaleY -= 1);
            var d = this._worldInfo;
            d.copy(b);
            d.x = b.x + this._position.x;
            d.y = b.y + this._position.y;
            d.scaleX = b.scaleX * this._scaleX;
            d.scaleY = b.scaleY * this._scaleY;
            d.skewX = b.skewX + this._skewX + cc.degreesToRadians(this._rotationX);
            d.skewY = b.skewY + this._skewY - cc.degreesToRadians(this._rotationY);
            this._parentBone ? this._applyParentTransform(this._parentBone) : this._armatureParentBone && this._applyParentTransform(this._armatureParentBone);
            ccs.TransformHelp.nodeToMatrix(d, this._worldTransform);
            this._armatureParentBone && (this._worldTransform = cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToParentTransform()))
        }
        ccs.displayFactory.updateDisplay(this,
            a, this._boneTransformDirty || this._armature.getArmatureTransformDirty());
        for (b = 0; b < this._children.length; b++)this._children[b].update(a);
        this._boneTransformDirty = !1
    },
    _applyParentTransform: function (a) {
        var b = this._worldInfo, d = a._worldTransform;
        a = a._worldInfo;
        var e = b.x, f = b.y;
        b.x = e * d.a + f * d.c + a.x;
        b.y = e * d.b + f * d.d + a.y;
        b.scaleX *= a.scaleX;
        b.scaleY *= a.scaleY;
        b.skewX += a.skewX;
        b.skewY += a.skewY
    },
    setBlendFunc: function (a, b) {
        var d = this._blendFunc, e, f;
        void 0 === b ? (e = a.src, f = a.dst) : (e = a, f = b);
        if (d.src !== e || d.dst !== f)d.src =
            e, d.dst = f, this.blendDirty = !0
    },
    updateColor: function () {
        var a = this._displayManager.getDisplayRenderNode();
        if (null !== a) {
            var b = this._renderCmd;
            a.setColor(cc.color(b._displayedColor.r * this._tweenData.r / 255, b._displayedColor.g * this._tweenData.g / 255, b._displayedColor.b * this._tweenData.b / 255));
            a.setOpacity(b._displayedOpacity * this._tweenData.a / 255)
        }
    },
    updateZOrder: function () {
        this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? this.setLocalZOrder(this._tweenData.zOrder + this._boneData.zOrder) :
            this.setLocalZOrder(this._tweenData.zOrder)
    },
    addChildBone: function (a) {
        cc.assert(a, "Argument must be non-nil");
        cc.assert(!a.parentBone, "child already added. It can't be added again");
        0 > this._children.indexOf(a) && (this._children.push(a), a.setParentBone(this))
    },
    removeChildBone: function (a, b) {
        if (0 < this._children.length && -1 !== this._children.getIndex(a)) {
            if (b)for (var d = a._children, e = 0; e < d.length; e++)a.removeChildBone(d[e], b);
            a.setParentBone(null);
            a.getDisplayManager().setCurrentDecorativeDisplay(null);
            cc.arrayRemoveObject(this._children,
                a)
        }
    },
    removeFromParent: function (a) {
        this._parentBone && this._parentBone.removeChildBone(this, a)
    },
    setParentBone: function (a) {
        this._parentBone = a
    },
    getParentBone: function () {
        return this._parentBone
    },
    setChildArmature: function (a) {
        this._childArmature !== a && (null == a && this._childArmature && this._childArmature.setParentBone(null), this._childArmature = a)
    },
    getChildArmature: function () {
        return this._childArmature
    },
    getTween: function () {
        return this._tween
    },
    setLocalZOrder: function (a) {
        this._localZOrder !== a && cc.Node.prototype.setLocalZOrder.call(this,
            a)
    },
    getNodeToArmatureTransform: function () {
        return this._worldTransform
    },
    getNodeToWorldTransform: function () {
        return cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToWorldTransform())
    },
    getDisplayRenderNode: function () {
        return this._displayManager.getDisplayRenderNode()
    },
    getDisplayRenderNodeType: function () {
        return this._displayManager.getDisplayRenderNodeType()
    },
    addDisplay: function (a, b) {
        return this._displayManager.addDisplay(a, b || 0)
    },
    removeDisplay: function (a) {
        this._displayManager.removeDisplay(a)
    },
    changeDisplayByIndex: function (a, b) {
        cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead.");
        this.changeDisplayWithIndex(a, b)
    },
    changeDisplayByName: function (a, b) {
        cc.log("changeDisplayByName is deprecated. Use changeDisplayWithName instead.");
        this.changeDisplayWithName(a, b)
    },
    changeDisplayWithIndex: function (a, b) {
        this._displayManager.changeDisplayWithIndex(a, b)
    },
    changeDisplayWithName: function (a, b) {
        this._displayManager.changeDisplayWithName(a, b)
    },
    getColliderDetector: function () {
        var a =
            this._displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a : null
    },
    setColliderFilter: function (a) {
        for (var b = this._displayManager.getDecorativeDisplayList(), d = 0; d < b.length; d++) {
            var e = b[d].getColliderDetector();
            e && e.setColliderFilter(a)
        }
    },
    getColliderFilter: function () {
        var a = this.displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a.getColliderFilter() : null
    },
    setTransformDirty: function (a) {
        this._boneTransformDirty = a
    },
    isTransformDirty: function () {
        return this._boneTransformDirty
    },
    getDisplayManager: function () {
        return this._displayManager
    },
    setIgnoreMovementBoneData: function (a) {
        this._ignoreMovementBoneData = a
    },
    isIgnoreMovementBoneData: function () {
        return this._ignoreMovementBoneData
    },
    getBlendFunc: function () {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    setBlendDirty: function (a) {
        this._blendDirty = a
    },
    isBlendDirty: function () {
        return this._blendDirty
    },
    getTweenData: function () {
        return this._tweenData
    },
    getWorldInfo: function () {
        return this._worldInfo
    },
    getChildrenBone: function () {
        return this._children
    },
    nodeToArmatureTransform: function () {
        return this.getNodeToArmatureTransform()
    },
    nodeToWorldTransform: function () {
        return this.getNodeToWorldTransform()
    },
    getColliderBodyList: function () {
        var a = this.getColliderDetector();
        return a ? a.getColliderBodyList() : null
    },
    getIgnoreMovementBoneData: function () {
        return this.isIgnoreMovementBoneData()
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Bone.CanvasRenderCmd(this) : new ccs.Bone.WebGLRenderCmd(this)
    }
});
_p = ccs.Bone.prototype;
cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData);
cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature);
cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature);
cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone);
cc.defineGetterSetter(_p, "tween", _p.getTween);
cc.defineGetterSetter(_p, "tweenData", _p.getTweenData);
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p = null;
ccs.Bone.create = function (a) {
    return new ccs.Bone(a)
};
ccs.Bone.RenderCmd = {
    _updateColor: function () {
        var a = this._node, b = a._displayManager.getDisplayRenderNode();
        if (null !== b) {
            var d = b._renderCmd;
            b.setColor(cc.color(a._tweenData.r, a._tweenData.g, a._tweenData.g));
            b.setOpacity(a._tweenData.a);
            d._syncDisplayColor(this._displayedColor);
            d._syncDisplayOpacity(this._displayedOpacity);
            d._updateColor()
        }
    }
};
(function () {
    ccs.Bone.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = ccs.Bone.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.inject(ccs.Bone.RenderCmd, a);
    a.constructor = ccs.Bone.CanvasRenderCmd
})();
(function () {
    if (cc.Node.WebGLRenderCmd) {
        ccs.Bone.WebGLRenderCmd = function (a) {
            cc.Node.WebGLRenderCmd.call(this, a);
            this._needDraw = !1
        };
        var a = ccs.Bone.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        cc.inject(ccs.Bone.RenderCmd, a);
        a.constructor = ccs.Bone.WebGLRenderCmd
    }
})();
ccs.FRAME_TYPE_MOVE = 0;
ccs.FRAME_TYPE_SCALE = 1;
ccs.FRAME_TYPE_ROTATE = 2;
ccs.FRAME_TYPE_TINT = 3;
ccs.FRAME_TYPE_FADE = 4;
ccs.FRAME_TYPE_MAX = 5;
ccs.FrameEaseType = {
    CUSTOM: -1,
    LINEAR: 0,
    SINE_EASEIN: 1,
    SINE_EASEOUT: 2,
    SINE_EASEINOUT: 3,
    QUAD_EASEIN: 4,
    QUAD_EASEOUT: 5,
    QUAD_EASEINOUT: 6,
    CUBIC_EASEIN: 7,
    CUBIC_EASEOUT: 8,
    CUBIC_EASEINOUT: 9,
    QUART_EASEIN: 10,
    QUART_EASEOUT: 11,
    QUART_EASEINOUT: 12,
    QUINT_EASEIN: 13,
    QUINT_EASEOUT: 14,
    QUINT_EASEINOUT: 15,
    EXPO_EASEIN: 16,
    EXPO_EASEOUT: 17,
    EXPO_EASEINOUT: 18,
    CIRC_EASEIN: 19,
    CIRC_EASEOUT: 20,
    CIRC_EASEINOUT: 21,
    ELASTIC_EASEIN: 22,
    ELASTIC_EASEOUT: 23,
    ELASTIC_EASEINOUT: 24,
    BACK_EASEIN: 25,
    BACK_EASEOUT: 26,
    BACK_EASEINOUT: 27,
    BOUNCE_EASEIN: 28,
    BOUNCE_EASEOUT: 29,
    BOUNCE_EASEINOUT: 30,
    TWEEN_EASING_MAX: 1E3
};
ccs.ActionFrame = ccs.Class.extend({
    frameType: 0, easingType: 0, frameIndex: 0, _Parameter: null, time: 0, ctor: function () {
        this.frameType = 0;
        this.easingType = ccs.FrameEaseType.LINEAR;
        this.time = this.frameIndex = 0
    }, getAction: function (a, b) {
        cc.log("Need a definition of \x3cgetAction\x3e for ActionFrame");
        return null
    }, _getEasingAction: function (a) {
        if (null === a)return console.error("Action cannot be null!"), null;
        var b;
        switch (this.easingType) {
            case ccs.FrameEaseType.LINEAR:
                b = a;
                break;
            case ccs.FrameEaseType.SINE_EASEIN:
                b = a.easing(cc.easeSineIn());
                break;
            case ccs.FrameEaseType.SINE_EASEOUT:
                b = a.easing(cc.easeSineOut());
                break;
            case ccs.FrameEaseType.SINE_EASEINOUT:
                b = a.easing(cc.easeSineInOut());
                break;
            case ccs.FrameEaseType.QUAD_EASEIN:
                b = a.easing(cc.easeQuadraticActionIn());
                break;
            case ccs.FrameEaseType.QUAD_EASEOUT:
                b = a.easing(cc.easeQuadraticActionOut());
                break;
            case ccs.FrameEaseType.QUAD_EASEINOUT:
                b = a.easing(cc.easeQuadraticActionInOut());
                break;
            case ccs.FrameEaseType.CUBIC_EASEIN:
                b = a.easing(cc.easeCubicActionIn());
                break;
            case ccs.FrameEaseType.CUBIC_EASEOUT:
                b =
                    a.easing(cc.easeCubicActionOut());
                break;
            case ccs.FrameEaseType.CUBIC_EASEINOUT:
                b = a.easing(cc.easeCubicActionInOut());
                break;
            case ccs.FrameEaseType.QUART_EASEIN:
                b = a.easing(cc.easeQuarticActionIn());
                break;
            case ccs.FrameEaseType.QUART_EASEOUT:
                b = a.easing(cc.easeQuarticActionOut());
                break;
            case ccs.FrameEaseType.QUART_EASEINOUT:
                b = a.easing(cc.easeQuarticActionInOut());
                break;
            case ccs.FrameEaseType.QUINT_EASEIN:
                b = a.easing(cc.easeQuinticActionIn());
                break;
            case ccs.FrameEaseType.QUINT_EASEOUT:
                b = a.easing(cc.easeQuinticActionOut());
                break;
            case ccs.FrameEaseType.QUINT_EASEINOUT:
                b = a.easing(cc.easeQuinticActionInOut());
                break;
            case ccs.FrameEaseType.EXPO_EASEIN:
                b = a.easing(cc.easeExponentialIn());
                break;
            case ccs.FrameEaseType.EXPO_EASEOUT:
                b = a.easing(cc.easeExponentialOut());
                break;
            case ccs.FrameEaseType.EXPO_EASEINOUT:
                b = a.easing(cc.easeExponentialInOut());
                break;
            case ccs.FrameEaseType.CIRC_EASEIN:
                b = a.easing(cc.easeCircleActionIn());
                break;
            case ccs.FrameEaseType.CIRC_EASEOUT:
                b = a.easing(cc.easeCircleActionOut());
                break;
            case ccs.FrameEaseType.CIRC_EASEINOUT:
                b =
                    a.easing(cc.easeCircleActionInOut());
                break;
            case ccs.FrameEaseType.ELASTIC_EASEIN:
                b = a.easing(cc.easeElasticIn());
                break;
            case ccs.FrameEaseType.ELASTIC_EASEOUT:
                b = a.easing(cc.easeElasticOut());
                break;
            case ccs.FrameEaseType.ELASTIC_EASEINOUT:
                b = a.easing(cc.easeElasticInOut());
                break;
            case ccs.FrameEaseType.BACK_EASEIN:
                b = a.easing(cc.easeBackIn());
                break;
            case ccs.FrameEaseType.BACK_EASEOUT:
                b = a.easing(cc.easeBackOut());
                break;
            case ccs.FrameEaseType.BACK_EASEINOUT:
                b = a.easing(cc.easeBackInOut());
                break;
            case ccs.FrameEaseType.BOUNCE_EASEIN:
                b =
                    a.easing(cc.easeBounceIn());
                break;
            case ccs.FrameEaseType.BOUNCE_EASEOUT:
                b = a.easing(cc.easeBounceOut());
                break;
            case ccs.FrameEaseType.BOUNCE_EASEINOUT:
                b = a.easing(cc.easeBounceInOut())
        }
        return b
    }, setEasingParameter: function (a) {
        this._Parameter = [];
        for (var b = 0; b < a.length; b++)this._Parameter.push(a[b])
    }, setEasingType: function (a) {
        this.easingType = a
    }
});
ccs.ActionMoveFrame = ccs.ActionFrame.extend({
    _position: null, ctor: function () {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this.frameType = ccs.FRAME_TYPE_MOVE
    }, setPosition: function (a, b) {
        void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b)
    }, getPosition: function () {
        return this._position
    }, getAction: function (a) {
        return this._getEasingAction(cc.moveTo(a, this._position))
    }
});
ccs.ActionScaleFrame = ccs.ActionFrame.extend({
    _scaleX: 1, _scaleY: 1, ctor: function () {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._scaleY = this._scaleX = 1;
        this.frameType = ccs.FRAME_TYPE_SCALE
    }, setScaleX: function (a) {
        this._scaleX = a
    }, getScaleX: function () {
        return this._scaleX
    }, setScaleY: function (a) {
        this._scaleY = a
    }, getScaleY: function () {
        return this._scaleY
    }, getAction: function (a) {
        return this._getEasingAction(cc.scaleTo(a, this._scaleX, this._scaleY))
    }
});
ccs.ActionRotationFrame = ccs.ActionFrame.extend({
    _rotation: 0, ctor: function () {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._rotation = 0;
        this.frameType = ccs.FRAME_TYPE_ROTATE
    }, setRotation: function (a) {
        this._rotation = a
    }, getRotation: function () {
        return this._rotation
    }, getAction: function (a, b) {
        return void 0 === b ? this._getEasingAction(cc.rotateTo(a, this._rotation)) : b instanceof cc.ActionRotationFrame ? this._getEasingAction(cc.rotateBy(a, this._rotation - b._rotation)) : this.getAction(a)
    }
});
ccs.ActionFadeFrame = ccs.ActionFrame.extend({
    _opacity: 255, ctor: function () {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._opacity = 255;
        this.frameType = ccs.FRAME_TYPE_FADE
    }, setOpacity: function (a) {
        this._opacity = a
    }, getOpacity: function () {
        return this._opacity
    }, getAction: function (a) {
        return this._getEasingAction(cc.fadeTo(a, this._opacity))
    }
});
ccs.ActionTintFrame = ccs.ActionFrame.extend({
    _color: null, ctor: function () {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._color = cc.color(255, 255, 255, 255);
        this.frameType = ccs.FRAME_TYPE_TINT
    }, setColor: function (a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b
    }, getColor: function () {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    }, getAction: function (a) {
        return this._getEasingAction(cc.tintTo(a, this._color.r, this._color.g, this._color.b))
    }
});
ccs.actionManager = {
    _actionDic: {}, initWithDictionary: function (a, b, d) {
        var e = a.lastIndexOf("/");
        a = a.substr(e + 1, a.length);
        b = b.actionlist;
        for (var e = [], f = 0; f < b.length; f++) {
            var g = new ccs.ActionObject;
            g.initWithDictionary(b[f], d);
            e.push(g)
        }
        this._actionDic[a] = e
    }, getActionByName: function (a, b) {
        var d = a.lastIndexOf("/"), d = a.substr(d + 1, a.length), d = this._actionDic[d];
        if (!d)return null;
        for (var e = 0; e < d.length; e++) {
            var f = d[e];
            if (b === f.getName())return f
        }
        return null
    }, playActionByName: function (a, b, d) {
        (a = this.getActionByName(a,
            b)) && a.play(d)
    }, stopActionByName: function (a, b) {
        var d = this.getActionByName(a, b);
        d && d.stop()
    }, releaseActions: function () {
        this._actionDic = {}
    }, clear: function () {
        this._actionDic = {}
    }
};
ccs.ActionNode = ccs.Class.extend({
    _currentFrameIndex: 0,
    _destFrameIndex: 0,
    _unitTime: 0,
    _actionTag: 0,
    _object: null,
    _actionSpawn: null,
    _action: null,
    _frameArray: null,
    _frameArrayNum: 0,
    ctor: function () {
        this._destFrameIndex = this._currentFrameIndex = 0;
        this._unitTime = 0.1;
        this._actionTag = 0;
        this._action = this._actionSpawn = this._object = null;
        this._frameArray = [];
        this._frameArrayNum = ccs.FRAME_TYPE_MAX;
        for (var a = 0; a < this._frameArrayNum; a++)this._frameArray.push([])
    },
    initWithDictionary: function (a, b) {
        this.setActionTag(a.ActionTag);
        for (var d = a.actionframelist, e = ccui.helper.seekActionWidgetByActionTag(b, a.ActionTag), f = e instanceof ccui.Widget && !(e instanceof ccui.Layout), g = 0; g < d.length; g++) {
            var h = d[g], n = h.frameid, p = h.tweenType;
            null == p && (p = 0);
            for (var r = h.tweenParameter, s = [], t = 0; t < r; t++)s.push(h.tweenParameter[t]);
            if (void 0 !== h.positionx) {
                var t = h.positionx, v = h.positiony;
                f && e.parent && (r = e.parent.getAnchorPointInPoints(), t += r.x, v += r.y);
                r = new ccs.ActionMoveFrame;
                r.frameIndex = n;
                r.setEasingType(p);
                r.setEasingParameter(s);
                r.setPosition(t,
                    v);
                t = this._frameArray[ccs.FRAME_TYPE_MOVE];
                t.push(r)
            }
            void 0 !== h.scalex && (t = h.scalex, v = h.scaley, r = new ccs.ActionScaleFrame, r.frameIndex = n, r.setEasingType(p), r.setEasingParameter(s), r.setScaleX(t), r.setScaleY(v), t = this._frameArray[ccs.FRAME_TYPE_SCALE], t.push(r));
            void 0 !== h.rotation && (t = h.rotation, r = new ccs.ActionRotationFrame, r.frameIndex = n, r.setEasingType(p), r.setEasingParameter(s), r.setRotation(t), t = this._frameArray[ccs.FRAME_TYPE_ROTATE], t.push(r));
            void 0 !== h.opacity && (t = h.opacity, r = new ccs.ActionFadeFrame,
                r.frameIndex = n, r.setEasingType(p), r.setEasingParameter(s), r.setOpacity(t), t = this._frameArray[ccs.FRAME_TYPE_FADE], t.push(r));
            void 0 !== h.colorr && (t = h.colorr, v = h.colorg, h = h.colorb, r = new ccs.ActionTintFrame, r.frameIndex = n, r.setEasingType(p), r.setEasingParameter(s), r.setColor(cc.color(t, v, h)), t = this._frameArray[ccs.FRAME_TYPE_TINT], t.push(r))
        }
        this._initActionNodeFromRoot(b)
    },
    _initActionNodeFromRoot: function (a) {
        a instanceof ccui.Widget && (a = ccui.helper.seekActionWidgetByActionTag(a, this.getActionTag())) &&
        this.setObject(a)
    },
    setUnitTime: function (a) {
        this._unitTime = a;
        this._refreshActionProperty()
    },
    getUnitTime: function () {
        return this._unitTime
    },
    setActionTag: function (a) {
        this._actionTag = a
    },
    getActionTag: function () {
        return this._actionTag
    },
    setObject: function (a) {
        this._object = a
    },
    getObject: function () {
        return this._object
    },
    getActionNode: function () {
        return this._object instanceof cc.Node ? this._object : null
    },
    insertFrame: function (a, b) {
        null != b && this._frameArray[b.frameType].splice(a, 0, b)
    },
    addFrame: function (a) {
        a && this._frameArray[a.frameType].push(a)
    },
    deleteFrame: function (a) {
        null != a && cc.arrayRemoveObject(this._frameArray[a.frameType], a)
    },
    clearAllFrame: function () {
        for (var a = 0; a < this._frameArrayNum; a++)this._frameArray[a].length = 0
    },
    _refreshActionProperty: function () {
        if (null === this._object)return null;
        for (var a = [], b = 0; b < this._frameArrayNum; b++) {
            var d = this._frameArray[b];
            if (!(0 >= d.length)) {
                for (var e = [], f = 0; f < d.length; f++) {
                    var g = d[f], h = null;
                    0 !== f ? (h = (g.frameIndex - d[f - 1].frameIndex) * this.getUnitTime(), h = g.getAction(h)) : h = g.getAction(0);
                    h && e.push(h)
                }
                e &&
                (d = cc.sequence(e), null !== d && a.push(d))
            }
        }
        this._action = null;
        return this._actionSpawn = cc.spawn(a)
    },
    playAction: function (a) {
        null !== this._object && null !== this._actionSpawn && (this._action = a ? cc.sequence(this._actionSpawn, a) : cc.sequence(this._actionSpawn), this._runAction())
    },
    _runAction: function () {
        var a = this.getActionNode();
        null !== a && null !== this._action && a.runAction(this._action)
    },
    stopAction: function () {
        var a = this.getActionNode();
        null !== a && null !== this._action && (this._action.isDone() || a.stopAction(this._action))
    },
    getFirstFrameIndex: function () {
        for (var a = 99999, b = !1, d = this._frameArray, e = 0, f = this._frameArrayNum; e < f; e++) {
            var g = d[e];
            0 >= g.length || (b = !0, g = g[0].frameIndex, a = a > g ? g : a)
        }
        b || (a = 0);
        return a
    },
    getLastFrameIndex: function () {
        for (var a = -1, b = !1, d = this._frameArray, e = 0, f = this._frameArrayNum; e < f; e++) {
            var g = d[e];
            0 >= g.length || (b = !0, g = g[g.length - 1].frameIndex, a = a < g ? g : a)
        }
        b || (a = 0);
        return a
    },
    updateActionToTimeLine: function (a) {
        for (var b = !1, d = this.getUnitTime(), e = 0; e < this._frameArrayNum; e++) {
            var f = this._frameArray[e];
            if (null !==
                f)for (var g = 0; g < f.length; g++) {
                var h = f[g];
                if (h.frameIndex * d === a) {
                    this._easingToFrame(1, 1, h);
                    b = !0;
                    break
                } else if (h.frameIndex * d > a) {
                    0 === g ? (this._easingToFrame(1, 1, h), b = !1) : (b = f[g - 1], f = (h.frameIndex - b.frameIndex) * d, g = a - b.frameIndex * d, this._easingToFrame(f, 1, b), this._easingToFrame(f, g / f, h), b = !0);
                    break
                }
            }
        }
        return b
    },
    _easingToFrame: function (a, b, d) {
        a = d.getAction(a);
        d = this.getActionNode();
        null != a && null != d && (a.startWithTarget(d), a.update(b))
    },
    isActionDoneOnce: function () {
        return null === this._action ? !0 : this._action.isDone()
    }
});
ccs.ActionObject = ccs.Class.extend({
    _actionNodeList: null,
    _name: "",
    _loop: !1,
    _pause: !1,
    _playing: !1,
    _unitTime: 0,
    _currentTime: 0,
    _scheduler: null,
    _callback: null,
    _fTotalTime: 0,
    ctor: function () {
        this._actionNodeList = [];
        this._name = "";
        this._playing = this._pause = this._loop = !1;
        this._unitTime = 0.1;
        this._fTotalTime = this._currentTime = 0;
        this._scheduler = cc.director.getScheduler()
    },
    setName: function (a) {
        this._name = a
    },
    getName: function () {
        return this._name
    },
    setLoop: function (a) {
        this._loop = a
    },
    getLoop: function () {
        return this._loop
    },
    setUnitTime: function (a) {
        this._unitTime = a;
        a = this._actionNodeList.length;
        for (var b = 0; b < a; b++)this._actionNodeList[b].setUnitTime(this._unitTime)
    },
    getUnitTime: function () {
        return this._unitTime
    },
    getCurrentTime: function () {
        return this._currentTime
    },
    setCurrentTime: function (a) {
        this._currentTime = a
    },
    getTotalTime: function () {
        return this._fTotalTime
    },
    isPlaying: function () {
        return this._playing
    },
    initWithDictionary: function (a, b) {
        this.setName(a.name);
        this.setLoop(a.loop);
        this.setUnitTime(a.unittime);
        for (var d = a.actionnodelist,
                 e = 0, f = 0; f < d.length; f++) {
            var g = new ccs.ActionNode;
            g.initWithDictionary(d[f], b);
            g.setUnitTime(this.getUnitTime());
            this._actionNodeList.push(g);
            g = g.getLastFrameIndex() - g.getFirstFrameIndex();
            g > e && (e = g)
        }
        this._fTotalTime = e * this._unitTime
    },
    addActionNode: function (a) {
        a && (this._actionNodeList.push(a), a.setUnitTime(this._unitTime))
    },
    removeActionNode: function (a) {
        null != a && cc.arrayRemoveObject(this._actionNodeList, a)
    },
    play: function (a) {
        this.stop();
        this.updateToFrameByTime(0);
        for (var b = this._actionNodeList, d = b.length,
                 e = 0; e < d; e++)b[e].playAction(a);
        this._loop && this._scheduler.schedule(this.simulationActionUpdate, this, 0, cc.REPEAT_FOREVER, 0, !1, this.__instanceId + "");
        void 0 !== a && (this._callback = a)
    },
    pause: function () {
        this._pause = !0;
        this._playing = !1
    },
    stop: function () {
        for (var a = this._actionNodeList, b = 0; b < a.length; b++)a[b].stopAction();
        this._scheduler.unschedule(this.simulationActionUpdate, this);
        this._playing = this._pause = !1
    },
    updateToFrameByTime: function (a) {
        this._currentTime = a;
        for (var b = 0; b < this._actionNodeList.length; b++)this._actionNodeList[b].updateActionToTimeLine(a)
    },
    simulationActionUpdate: function (a) {
        a = !0;
        for (var b = this._actionNodeList, d = 0, e = b.length; d < e; d++)if (!b[d].isActionDoneOnce()) {
            a = !1;
            break
        }
        a && (null !== this._callback && this._callback.execute(), this._loop ? this.play() : (this._playing = !1, this._scheduler.unschedule(this.simulationActionUpdate, this)))
    }
});
ccs.ComAttribute = ccs.Component.extend({
    _jsonDict: null, _filePath: "", ctor: function () {
        cc.Component.prototype.ctor.call(this);
        this._jsonDict = {};
        this._filePath = "";
        this._name = "CCComAttribute";
        ccs.ComAttribute.prototype.init.call(this)
    }, init: function () {
        this._jsonDict = {};
        return !0
    }, setInt: function (a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    }, setDouble: function (a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    }, setFloat: function (a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setBool: function (a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    }, setString: function (a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    }, setObject: function (a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    }, getInt: function (a) {
        return parseInt(this._jsonDict[a] || 0)
    }, getDouble: function (a) {
        return parseFloat(this._jsonDict[a] || 0)
    }, getFloat: function (a) {
        return parseFloat(this._jsonDict[a] || 0)
    }, getBool: function (a) {
        return Boolean(this._jsonDict[a] || !1)
    }, getString: function (a) {
        return this._jsonDict[a] ||
            ""
    }, getObject: function (a) {
        return this._jsonDict[a]
    }, parse: function (a) {
        this._jsonDict = cc.loader.getRes(a)
    }
});
ccs.ComAttribute.create = function () {
    return new ccs.ComAttribute
};
ccs.ComAudio = ccs.Component.extend({
    _filePath: "", _loop: !1, ctor: function () {
        cc.Component.prototype.ctor.call(this);
        this._name = "Audio";
        ccs.ComAudio.prototype.init.call(this)
    }, init: function () {
        return !0
    }, onExit: function () {
        this.stopBackgroundMusic(!0);
        this.stopAllEffects()
    }, end: function () {
        cc.audioEngine.end()
    }, preloadBackgroundMusic: function (a) {
        cc.loader.load(a)
    }, playBackgroundMusic: function (a, b) {
        a ? cc.audioEngine.playMusic(a, b) : cc.audioEngine.playMusic(this._filePath, this._loop)
    }, stopBackgroundMusic: function (a) {
        cc.audioEngine.stopMusic(a)
    },
    pauseBackgroundMusic: function () {
        cc.audioEngine.pauseMusic()
    }, resumeBackgroundMusic: function () {
        cc.audioEngine.resumeMusic()
    }, rewindBackgroundMusic: function () {
        cc.audioEngine.rewindMusic()
    }, willPlayBackgroundMusic: function () {
        return cc.audioEngine.willPlayMusic()
    }, isBackgroundMusicPlaying: function () {
        return cc.audioEngine.isMusicPlaying()
    }, getBackgroundMusicVolume: function () {
        return cc.audioEngine.getMusicVolume()
    }, setBackgroundMusicVolume: function (a) {
        cc.audioEngine.setMusicVolume(a)
    }, getEffectsVolume: function () {
        return cc.audioEngine.getEffectsVolume()
    },
    setEffectsVolume: function (a) {
        cc.audioEngine.setEffectsVolume(a)
    }, playEffect: function (a, b) {
        return a ? cc.audioEngine.playEffect(a, b) : cc.audioEngine.playEffect(this._filePath, this._loop)
    }, pauseEffect: function (a) {
        cc.audioEngine.pauseEffect(a)
    }, pauseAllEffects: function () {
        cc.audioEngine.pauseAllEffects()
    }, resumeEffect: function (a) {
        cc.audioEngine.resumeEffect(a)
    }, resumeAllEffects: function () {
        cc.audioEngine.resumeAllEffects()
    }, stopEffect: function (a) {
        cc.audioEngine.stopEffect(a)
    }, stopAllEffects: function () {
        cc.audioEngine.stopAllEffects()
    },
    preloadEffect: function (a) {
        cc.loader.getRes(a);
        this.setFile(a);
        this.setLoop(!1)
    }, unloadEffect: function (a) {
        cc.audioEngine.unloadEffect(a)
    }, setFile: function (a) {
        this._filePath = a
    }, setLoop: function (a) {
        this._loop = a
    }, getFile: function () {
        return this._filePath
    }, isLoop: function () {
        return this._loop
    }
});
ccs.ComAudio.create = function () {
    return new ccs.ComAudio
};
ccs.ComController = ccs.Component.extend({
    ctor: function () {
        cc.Component.prototype.ctor.call(this);
        this._name = "ComController";
        ccs.ComController.prototype.init.call(this)
    }, onEnter: function () {
        null !== this._owner && this._owner.scheduleUpdate()
    }, isEnabled: function () {
        return this._enabled
    }, setEnabled: function (a) {
        this._enabled = a
    }
});
ccs.ComController.create = function () {
    return new ccs.ComController
};
ccs.ComRender = ccs.Component.extend({
    _render: null, ctor: function (a, b) {
        cc.Component.prototype.ctor.call(this);
        this._render = a;
        this._name = b;
        this.isRenderer = !0;
        ccs.ComRender.prototype.init.call(this)
    }, onEnter: function () {
        this._owner && this._owner.addChild(this._render)
    }, onExit: function () {
        this._owner && (this._owner.removeChild(this._render, !0), this._render = null)
    }, getNode: function () {
        return this._render
    }, setNode: function (a) {
        this._render = a
    }
});
ccs.ComRender.create = function (a, b) {
    return new ccs.ComRender(a, b)
};
ccs.objectFactory = {
    _typeMap: {}, createObject: function (a) {
        var b = null;
        (a = this._typeMap[a]) && (b = cc.isFunction(a._fun) ? new a._fun : a._fun);
        return b
    }, registerType: function (a) {
        this._typeMap[a._className] = a
    }, createGUI: function (a) {
        var b = null;
        "Panel" === a ? a = "Layout" : "TextArea" === a ? a = "Label" : "TextButton" === a && (a = "Button");
        (a = this._typeMap[a]) && a._fun && (b = a._fun);
        return b
    }, removeAll: function () {
        this._typeMap = {}
    }
};
ccs.TInfo = ccs.Class.extend({
    _className: "", _fun: null, ctor: function (a, b) {
        b ? (this._className = a, this._fun = b) : (this._className = a._className, this._fun = a._fun);
        ccs.objectFactory.registerType(this)
    }
});
ccs.sendEvent = function (a) {
    a = ccs.triggerManager.get(a);
    if (null != a)for (var b = 0; b < a.length; b++) {
        var d = a[b];
        null != d && d.detect() && d.done()
    }
};
ccs.registerTriggerClass = function (a, b) {
    new ccs.TInfo(a, b)
};
ccs.triggerManager = {
    _eventTriggers: {}, _triggerObjs: {}, _movementDispatches: [], parse: function (a) {
        for (var b = 0; b < a.length; ++b) {
            var d = a[b], e = new ccs.TriggerObj;
            e.serialize(d);
            for (var d = e.getEvents(), f = 0; f < d.length; f++)this.add(d[f], e);
            this._triggerObjs[e.getId()] = e
        }
    }, get: function (a) {
        return this._eventTriggers[a]
    }, getTriggerObj: function (a) {
        return this._triggerObjs[a]
    }, add: function (a, b) {
        var d = this._eventTriggers[a];
        d || (d = []);
        -1 === d.indexOf(b) && (d.push(b), this._eventTriggers[a] = d)
    }, removeAll: function () {
        for (var a in this._eventTriggers)for (var b =
            this._eventTriggers[a], d = 0; d < b.length; d++)b[d].removeAll();
        this._eventTriggers = {}
    }, remove: function (a, b) {
        if (b)return this._removeObj(a, b);
        var d = !1, e = this._eventTriggers[a];
        if (e) {
            for (d = 0; d < e.length; d++) {
                var f = e[d];
                f && f.removeAll()
            }
            delete this._eventTriggers[a];
            d = !0
        }
        return d
    }, _removeObj: function (a, b) {
        var d = !1;
        do {
            var e = this._eventTriggers[a];
            if (e) {
                for (d = 0; d < e.length; d++) {
                    var f = e[d];
                    if (f && f == b) {
                        f.removeAll();
                        e.splice(d, 1);
                        break
                    }
                }
                d = !0
            }
        } while (0);
        return d
    }, removeTriggerObj: function (a) {
        a = this.getTriggerObj(a);
        if (!a)return !1;
        for (var b = a.getEvents(), d = 0; d < b.length; d++)this.remove(b[d], a);
        return !0
    }, isEmpty: function () {
        return !this._eventTriggers || 0 >= this._eventTriggers.length
    }, addArmatureMovementCallBack: function (a, b, d) {
        if (null != a && null != d && null != b) {
            for (var e, f = !1, g = 0; g < this._movementDispatches.length; g++)(e = this._movementDispatches[g]) && e[0] === a && (e.addAnimationEventCallBack(b, d), f = !0);
            f || (e = new ccs.ArmatureMovementDispatcher, a.getAnimation().setMovementEventCallFunc(e.animationEvent, e), e.addAnimationEventCallBack(b,
                d), this._movementDispatches.push([a, e]))
        }
    }, removeArmatureMovementCallBack: function (a, b, d) {
        if (null != a && null != b && null != d)for (var e, f = 0; f < this._movementDispatches.length; f++)(e = this._movementDispatches[f]) && e[0] === a && e.removeAnimationEventCallBack(d, b)
    }, removeArmatureAllMovementCallBack: function (a) {
        if (null != a)for (var b, d = 0; d < this._movementDispatches.length; d++)if ((b = this._movementDispatches[d]) && b[0] === a) {
            this._movementDispatches.splice(d, 1);
            break
        }
    }, removeAllArmatureMovementCallBack: function () {
        this._movementDispatches.length =
            0
    }, version: function () {
        return "1.2.0.0"
    }
};
ccs.ArmatureMovementDispatcher = ccs.Class.extend({
    _mapEventAnimation: null, ctor: function () {
        this._mapEventAnimation = []
    }, animationEvent: function (a, b, d) {
        for (var e, f, g = 0; g < this._mapEventAnimation.length; g++)e = this._mapEventAnimation[g], f = e[0], (e = e[1]) && e.call(f, a, b, d)
    }, addAnimationEventCallBack: function (a, b) {
        this._mapEventAnimation.push([b, a])
    }, removeAnimationEventCallBack: function (a, b) {
        for (var d, e = 0; e < this._mapEventAnimation.length; e++)d = this._mapEventAnimation[e], d[0] === b && this._mapEventAnimation.splice(e,
            1)
    }
});
ccs.BaseTriggerCondition = ccs.Class.extend({
    ctor: function () {
    }, init: function () {
        return !0
    }, detect: function () {
        return !0
    }, serialize: function (a) {
    }, removeAll: function () {
    }
});
ccs.BaseTriggerAction = ccs.Class.extend({
    ctor: function () {
    }, init: function () {
        return !0
    }, done: function () {
    }, serialize: function (a) {
    }, removeAll: function () {
    }
});
ccs.TriggerObj = ccs.Class.extend({
    _cons: null, _acts: null, _id: 0, _enable: !0, _vInt: null, ctor: function () {
        this._id = 0;
        this._enable = !0;
        ccs.TriggerObj.prototype.init.call(this)
    }, init: function () {
        this._cons = [];
        this._acts = [];
        this._vInt = [];
        return !0
    }, detect: function () {
        if (!this._enable || 0 === this._cons.length)return !0;
        for (var a = !0, b = null, d = 0; d < this._cons.length; d++)(b = this._cons[d]) && b.detect && (a = a && b.detect());
        return a
    }, done: function () {
        if (this._enable && 0 !== this._acts.length)for (var a, b = 0; b < this._acts.length; b++)(a =
            this._acts[b]) && a.done && a.done()
    }, removeAll: function () {
        for (var a = null, b = 0; b < this._cons.length; b++)(a = this._cons[b]) && a.removeAll();
        this._cons = [];
        for (b = 0; b < this._acts.length; b++)(a = this._acts[b]) && a.removeAll();
        this._acts = []
    }, serialize: function (a) {
        this._id = a.id || 0;
        for (var b = a.conditions || [], d = 0; d < b.length; d++) {
            var e = b[d], f = e.classname, g = ccs.objectFactory.createObject(f);
            g ? (g.serialize(e), g.init(), this._cons.push(g)) : cc.log("class named classname(" + f + ") can not implement!")
        }
        b = a.actions || [];
        for (d = 0; d <
        b.length; d++)e = b[d], f = e.classname, (g = ccs.objectFactory.createObject(f)) ? (g.serialize(e), g.init(), this._acts.push(g)) : cc.log("class named classname(" + f + ") can not implement!");
        a = a.events || [];
        for (d = 0; d < a.length; d++)e = a[d], e = e.id, 0 > e || this._vInt.push(e)
    }, getId: function () {
        return this._id
    }, setEnable: function (a) {
        this._enable = a
    }, getEvents: function () {
        return this._vInt
    }
});
ccs.TriggerObj.create = function () {
    return new ccs.TriggerObj
};
ccs.ActionTimelineData = ccs.Class.extend({
    _actionTag: 0, ctor: function (a) {
        this._init(a)
    }, _init: function (a) {
        this._actionTag = a;
        return !0
    }, setActionTag: function (a) {
        this._actionTag = a
    }, getActionTag: function () {
        return this._actionTag
    }
});
ccs.AnimationInfo = function (a, b, d) {
    this.name = a;
    this.startIndex = b;
    this.endIndex = d
};
ccs.ComExtensionData = ccs.Component.extend({
    _customProperty: null,
    _timelineData: null,
    _name: "ComExtensionData",
    ctor: function () {
        this._customProperty = "";
        this._timelineData = new ccs.ActionTimelineData(0);
        return !0
    },
    setActionTag: function (a) {
        this._timelineData.setActionTag(a)
    },
    getActionTag: function () {
        return this._timelineData.getActionTag()
    },
    setCustomProperty: function (a) {
        this._customProperty = a
    },
    getCustomProperty: function () {
        return this._customProperty
    }
});
ccs.ComExtensionData.create = function () {
    return new ccs.ComExtensionData
};
ccs.ActionTimelineData.create = function (a) {
    return new ccs.ActionTimelineData(a)
};
ccs.ActionTimeline = cc.Action.extend({
    _timelineMap: null,
    _timelineList: null,
    _duration: 0,
    _time: null,
    _timeSpeed: 1,
    _frameInternal: 1 / 60,
    _playing: !1,
    _currentFrame: 0,
    _startFrame: 0,
    _endFrame: 0,
    _loop: null,
    _frameEventListener: null,
    _animationInfos: null,
    _lastFrameListener: null,
    ctor: function () {
        cc.Action.prototype.ctor.call(this);
        this._timelineMap = {};
        this._timelineList = [];
        this._animationInfos = {};
        this.init()
    },
    _gotoFrame: function (a) {
        for (var b = this._timelineList.length, d = 0; d < b; d++)this._timelineList[d]._gotoFrame(a)
    },
    _stepToFrame: function (a) {
        for (var b = this._timelineList.length, d = 0; d < b; d++)this._timelineList[d]._stepToFrame(a)
    },
    _emitFrameEvent: function (a) {
        this._frameEventListener && this._frameEventListener(a)
    },
    init: function () {
        return !0
    },
    gotoFrameAndPlay: function (a, b, d, e) {
        var f = 0, g = arguments.length, h = [], n;
        for (f; f < g; f++)"boolean" === typeof arguments[f] ? n = arguments[f] : h.push(arguments[f]);
        a = h[0];
        b = void 0 !== h[1] ? h[1] : this._duration;
        d = h[2] || a;
        this._startFrame = a;
        this._endFrame = b;
        this._currentFrame = d;
        this._loop = null != n ?
            n : !0;
        this._time = this._currentFrame * this._frameInternal;
        this.resume();
        this._gotoFrame(this._currentFrame)
    },
    gotoFrameAndPause: function (a) {
        this._startFrame = this._currentFrame = a;
        this._time = this._currentFrame * this._frameInternal;
        this.pause();
        this._gotoFrame(this._currentFrame)
    },
    pause: function () {
        this._playing = !1
    },
    resume: function () {
        this._playing = !0
    },
    isPlaying: function () {
        return this._playing
    },
    setTimeSpeed: function (a) {
        this._timeSpeed = a
    },
    getTimeSpeed: function () {
        return this._timeSpeed
    },
    setDuration: function (a) {
        this._duration =
            a
    },
    getDuration: function () {
        return this._duration
    },
    getStartFrame: function () {
        return this._startFrame
    },
    getEndFrame: function () {
        return this._endFrame
    },
    setCurrentFrame: function (a) {
        a >= this._startFrame && a <= this._endFrame ? (this._currentFrame = a, this._time = this._currentFrame * this._frameInternal) : cc.log("frame index is not between start frame and end frame")
    },
    getCurrentFrame: function () {
        return this._currentFrame
    },
    addTimeline: function (a) {
        var b = a.getActionTag();
        this._timelineMap[b] || (this._timelineMap[b] = []);
        -1 ===
        this._timelineMap[b].indexOf(a) && (this._timelineList.push(a), this._timelineMap[b].push(a), a.setActionTimeline(this))
    },
    removeTimeline: function (a) {
        var b = a.getActionTag();
        this._timelineMap[b] && this._timelineMap[b].some(function (b) {
            if (b === a)return !0
        }) && (cc.arrayRemoveObject(this._timelineMap[b], a), cc.arrayRemoveObject(this._timelineList, a), a.setActionTimeline(null))
    },
    getTimelines: function () {
        return this._timelineList
    },
    setFrameEventCallFunc: function (a) {
        this._frameEventListener = a
    },
    clearFrameEventCallFunc: function () {
        this._frameEventListener =
            null
    },
    clone: function () {
        var a = new ccs.ActionTimeline;
        a.setDuration(this._duration);
        a.setTimeSpeed(this._timeSpeed);
        for (var b in this._timelineMap) {
            var d = this._timelineMap[b], e;
            for (e in d) {
                var f = d[e].clone();
                a.addTimeline(f)
            }
        }
        return a
    },
    reverse: function () {
        return null
    },
    step: function (a) {
        this._playing && 0 !== this._timelineMap.length && 0 !== this._duration && (this._time += a * this._timeSpeed, a = this._time - this._endFrame * this._frameInternal, a < this._frameInternal ? (this._currentFrame = Math.floor(this._time / this._frameInternal),
            this._stepToFrame(this._currentFrame), 0 <= a && this._lastFrameListener && this._lastFrameListener()) : (this._playing = this._loop) ? this.gotoFrameAndPlay(this._startFrame, this._endFrame, this._loop) : (this._time = this._endFrame * this._frameInternal, this._currentFrame != this._endFrame && (this._currentFrame = this._endFrame, this._stepToFrame(this._currentFrame), this._lastFrameListener && this._lastFrameListener())))
    },
    _foreachNodeDescendant: function (a, b) {
        b(a);
        for (var d = a.getChildren(), e = 0; e < d.length; e++)this._foreachNodeDescendant(d[e],
            b)
    },
    startWithTarget: function (a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        var b = this;
        this._foreachNodeDescendant(a, function (a) {
            var e = a.getComponent("ComExtensionData");
            if (e && (e = e.getActionTag(), b._timelineMap[e]))for (var e = b._timelineMap[e], f = 0; f < e.length; f++)e[f].setNode(a)
        })
    },
    isDone: function () {
        return !1
    },
    play: function (a, b) {
        var d = this._animationInfos[a];
        if (!d)return cc.log("Can't find animation info for %s", a);
        this.gotoFrameAndPlay(d.startIndex, d.endIndex, b)
    },
    addAnimationInfo: function (a) {
        this._animationInfos[a.name] =
            a
    },
    removeAnimationInfo: function (a) {
        delete this._animationInfos[a]
    },
    isAnimationInfoExists: function (a) {
        return this._animationInfos[a]
    },
    getAnimationInfo: function (a) {
        return this._animationInfos[a]
    },
    setLastFrameCallFunc: function (a) {
        this._lastFrameListener = a
    },
    clearLastFrameCallFunc: function () {
        this._lastFrameListener = null
    }
});
ccs.ActionTimeline.create = function () {
    return new ccs.ActionTimeline
};
ccs.Frame = ccs.Class.extend({
    _frameIndex: null,
    _tween: null,
    _timeline: null,
    _node: null,
    _tweenType: null,
    _easingParam: null,
    _enterWhenPassed: null,
    ctor: function () {
        this._frameIndex = 0;
        this._tween = !0;
        this._node = this._timeline = null;
        this._enterWhenPassed = !1;
        this._easingParam = []
    },
    _emitEvent: function () {
        this._timeline && this._timeline.getActionTimeline()._emitFrameEvent(this)
    },
    _cloneProperty: function (a) {
        this._frameIndex = a.getFrameIndex();
        this._tween = a.isTween();
        this._tweenType = a.getTweenType();
        this.setEasingParams(a.getEasingParams())
    },
    setFrameIndex: function (a) {
        this._frameIndex = a
    },
    getFrameIndex: function () {
        return this._frameIndex
    },
    setTimeline: function (a) {
        this._timeline = a
    },
    getTimeline: function (a) {
        return this._timeline
    },
    setNode: function (a) {
        this._node = a
    },
    getNode: function () {
        return this._node
    },
    setTween: function (a) {
        this._tween = a
    },
    isTween: function () {
        return this._tween
    },
    onEnter: function (a) {
    },
    apply: function (a) {
        this._tween && (this._tweenType !== ccs.FrameEaseType.TWEEN_EASING_MAX && this._tweenType !== ccs.FrameEaseType.LINEAR && (a = this.tweenPercent(a)),
            this._onApply(a))
    },
    _onApply: function (a) {
    },
    clone: function () {
    },
    tweenPercent: function (a) {
        var b = ccs.Frame.tweenToMap[this._tweenType];
        return b ? b(a, this._easingParam) : a
    },
    setEasingParams: function (a) {
        if (a)for (var b = this._easingParam.length = 0; b < a.length; b++)this._easingParam[b] = a[b]
    },
    getEasingParams: function () {
        return this._easingParam
    },
    setTweenType: function (a) {
        this._tweenType = a
    },
    getTweenType: function () {
        return this._tweenType
    },
    isEnterWhenPassed: function () {
        return this._enterWhenPassed
    }
});
ccs.Frame.tweenToMap = {
    "-1": function (a, b) {
        if (b) {
            var d = 1 - a;
            return b[1] * d * d * d + 3 * b[3] * a * d * d + 3 * b[5] * a * a * d + b[7] * a * a * a
        }
        return a
    },
    1: cc._easeSineInObj.easing,
    2: cc._easeSineOutObj.easing,
    3: cc._easeSineInOutObj.easing,
    4: cc._easeQuadraticActionIn.easing,
    5: cc._easeQuadraticActionOut.easing,
    6: cc._easeQuadraticActionInOut.easing,
    7: cc._easeCubicActionIn.easing,
    8: cc._easeCubicActionOut.easing,
    9: cc._easeCubicActionInOut.easing,
    10: cc._easeCubicActionIn.easing,
    11: cc._easeCubicActionOut.easing,
    12: cc._easeCubicActionInOut.easing,
    13: cc._easeQuinticActionIn.easing,
    14: cc._easeQuinticActionOut.easing,
    15: cc._easeQuinticActionInOut.easing,
    16: cc._easeExponentialInObj.easing,
    17: cc._easeExponentialOutObj.easing,
    18: cc._easeExponentialInOutObj.easing,
    19: cc._easeCircleActionIn.easing,
    20: cc._easeCircleActionOut.easing,
    21: cc._easeCircleActionInOut.easing,
    22: function (a, b) {
        var d = 0.3;
        null != b && (d = b[0]);
        return cc.easeElasticIn(d).easing(a)
    },
    23: function (a, b) {
        var d = 0.3;
        null != b && (d = b[0]);
        return cc.easeElasticOut(d).easing(a)
    },
    24: function (a, b) {
        var d =
            0.3;
        null != b && (d = b[0]);
        return cc.easeElasticInOut(d).easing(a)
    },
    25: cc._easeBackInObj.easing,
    26: cc._easeBackOutObj.easing,
    27: cc._easeBackInOutObj.easing,
    28: cc._easeBounceInObj.easing,
    29: cc._easeBounceOutObj.easing,
    30: cc._easeBounceInOutObj.easing
};
ccs.VisibleFrame = ccs.Frame.extend({
    _visible: !0, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._visible = !0
    }, onEnter: function (a) {
        this._node && this._node.setVisible(this._visible)
    }, clone: function () {
        var a = new ccs.VisibleFrame;
        a.setVisible(this._visible);
        a._cloneProperty(this);
        return a
    }, setVisible: function (a) {
        this._visible = a
    }, isVisible: function () {
        return this._visible
    }
});
ccs.VisibleFrame.create = function () {
    return new ccs.VisibleFrame
};
ccs.TextureFrame = ccs.Frame.extend({
    _sprite: null, _textureName: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._textureName = ""
    }, setNode: function (a) {
        ccs.Frame.prototype.setNode.call(this, a);
        this._sprite = a
    }, onEnter: function (a) {
        if (this._sprite) {
            a = this._sprite.getBlendFunc();
            var b = cc.spriteFrameCache._spriteFrames[this._textureName];
            null != b ? this._sprite.setSpriteFrame(b) : this._sprite.setTexture(this._textureName);
            this._sprite.getBlendFunc() !== a && this._sprite.setBlendFunc(a)
        }
    }, clone: function () {
        var a =
            new ccs.TextureFrame;
        a.setTextureName(this._textureName);
        a._cloneProperty(this);
        return a
    }, setTextureName: function (a) {
        this._textureName = a
    }, getTextureName: function () {
        return this._textureName
    }
});
ccs.TextureFrame.create = function () {
    return new ccs.TextureFrame
};
ccs.RotationFrame = ccs.Frame.extend({
    _rotation: null, _betwennRotation: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._rotation = 0
    }, onEnter: function (a) {
        this._node && (this._node.setRotation(this._rotation), this._tween && (this._betwennRotation = a._rotation - this._rotation))
    }, _onApply: function (a) {
        0 !== this._betwennRotation && this._node.setRotation(this._rotation + a * this._betwennRotation)
    }, clone: function () {
        var a = new ccs.RotationFrame;
        a.setRotation(this._rotation);
        a._cloneProperty(this);
        return a
    },
    setRotation: function (a) {
        this._rotation = a
    }, getRotation: function () {
        return this._rotation
    }
});
ccs.RotationFrame.create = function () {
    return new ccs.RotationFrame
};
ccs.SkewFrame = ccs.Frame.extend({
    _skewX: null, _skewY: null, _betweenSkewX: null, _betweenSkewY: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._skewY = this._skewX = 0
    }, onEnter: function (a) {
        this._node && (this._node.setSkewX(this._skewX), this._node.setSkewY(this._skewY), this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY))
    }, _onApply: function (a) {
        if (0 !== this._betweenSkewX || 0 !== this._betweenSkewY) {
            var b = this._skewY + a * this._betweenSkewY;
            this._node.setSkewX(this._skewX +
                a * this._betweenSkewX);
            this._node.setSkewY(b)
        }
    }, clone: function () {
        var a = new ccs.SkewFrame;
        a.setSkewX(this._skewX);
        a.setSkewY(this._skewY);
        a._cloneProperty(this);
        return a
    }, setSkewX: function (a) {
        this._skewX = a
    }, getSkewX: function () {
        return this._skewX
    }, setSkewY: function (a) {
        this._skewY = a
    }, getSkewY: function () {
        return this._skewY
    }
});
ccs.SkewFrame.create = function () {
    return new ccs.SkewFrame
};
ccs.RotationSkewFrame = ccs.SkewFrame.extend({
    onEnter: function (a) {
        this._node && (this._node.setRotationX(this._skewX), this._node.setRotationY(this._skewY), this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY))
    }, _onApply: function (a) {
        if (this._node && (0 !== this._betweenSkewX || 0 !== this._betweenSkewY)) {
            var b = this._skewY + a * this._betweenSkewY;
            this._node.setRotationX(this._skewX + a * this._betweenSkewX);
            this._node.setRotationY(b)
        }
    }, clone: function () {
        var a = new ccs.RotationSkewFrame;
        a.setSkewX(this._skewX);
        a.setSkewY(this._skewY);
        a._cloneProperty(this);
        return a
    }
});
ccs.RotationSkewFrame.create = function () {
    return new ccs.RotationSkewFrame
};
ccs.PositionFrame = ccs.Frame.extend({
    _position: null, _betweenX: null, _betweenY: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._position = cc.p(0, 0)
    }, onEnter: function (a) {
        this._node && (this._node.setPosition(this._position), this._tween && (this._betweenX = a._position.x - this._position.x, this._betweenY = a._position.y - this._position.y))
    }, _onApply: function (a) {
        if (this._node && (0 !== this._betweenX || 0 !== this._betweenY)) {
            var b = cc.p(0, 0);
            b.x = this._position.x + this._betweenX * a;
            b.y = this._position.y + this._betweenY *
                a;
            this._node.setPosition(b)
        }
    }, clone: function () {
        var a = new ccs.PositionFrame;
        a.setPosition(this._position);
        a._cloneProperty(this);
        return a
    }, setPosition: function (a) {
        this._position = a
    }, getPosition: function () {
        return this._position
    }, setX: function (a) {
        this._position.x = a
    }, getX: function () {
        return this._position.x
    }, setY: function (a) {
        this._position.y = a
    }, getY: function () {
        return this._position.y
    }
});
ccs.PositionFrame.create = function () {
    return new ccs.PositionFrame
};
ccs.ScaleFrame = ccs.Frame.extend({
    _scaleX: null, _scaleY: null, _betweenScaleX: null, _betweenScaleY: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._scaleY = this._scaleX = 1
    }, onEnter: function (a) {
        this._node && (this._node.setScaleX(this._scaleX), this._node.setScaleY(this._scaleY), this._tween && (this._betweenScaleX = a._scaleX - this._scaleX, this._betweenScaleY = a._scaleY - this._scaleY))
    }, _onApply: function (a) {
        if (this._node && (0 !== this._betweenScaleX || 0 !== this._betweenScaleY)) {
            var b = this._scaleY + this._betweenScaleY *
                a;
            this._node.setScaleX(this._scaleX + this._betweenScaleX * a);
            this._node.setScaleY(b)
        }
    }, clone: function () {
        var a = new ccs.ScaleFrame;
        a.setScaleX(this._scaleX);
        a.setScaleY(this._scaleY);
        a._cloneProperty(this);
        return a
    }, setScale: function (a) {
        this._scaleY = this._scaleX = a
    }, setScaleX: function (a) {
        this._scaleX = a
    }, getScaleX: function () {
        return this._scaleX
    }, setScaleY: function (a) {
        this._scaleY = a
    }, getScaleY: function () {
        return this._scaleY
    }
});
ccs.ScaleFrame.create = function () {
    return new ccs.ScaleFrame
};
ccs.AnchorPointFrame = ccs.Frame.extend({
    _anchorPoint: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._anchorPoint = cc.p(0, 0)
    }, onEnter: function (a) {
        this._node && this._node.setAnchorPoint(this._anchorPoint)
    }, clone: function () {
        var a = new ccs.AnchorPointFrame;
        a.setAnchorPoint(this._anchorPoint);
        a._cloneProperty(this);
        return a
    }, setAnchorPoint: function (a) {
        this._anchorPoint = a
    }, getAnchorPoint: function () {
        return this._anchorPoint
    }
});
ccs.AnchorPointFrame.create = function () {
    return new ccs.AnchorPointFrame
};
ccs.InnerActionType = {LoopAction: 0, NoLoopAction: 1, SingleFrame: 2};
ccs.InnerActionFrame = ccs.Frame.extend({
    _innerActionType: null,
    _startFrameIndex: null,
    _endFrameIndex: 0,
    _singleFrameIndex: 0,
    _enterWithName: null,
    _animationName: "",
    ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._enterWithName = !1;
        this._innerActionType = ccs.InnerActionType.LoopAction;
        this._startFrameIndex = 0
    },
    onEnter: function (a) {
        if (this._node && (a = this._node.getActionByTag(this._node.getTag())))if (ccs.InnerActionType.SingleFrame === this._innerActionType)a.gotoFrameAndPause(this._singleFrameIndex); else {
            var b =
                this._startFrameIndex, d = this._endFrameIndex;
            this._enterWithName && ("-- ALL --" === this._animationName ? (b = 0, d = a.getDuration()) : a.isAnimationInfoExists(this._animationName) ? (d = a.getAnimationInfo(this._animationName), b = d.startIndex, d = d.endIndex) : cc.log("Animation %s not exists!", this._animationName));
            var e = this._timeline.getActionTimeline().getDuration() - this._frameIndex - d + b;
            0 > e && (d += e);
            ccs.InnerActionType.NoLoopAction === this._innerActionType ? a.gotoFrameAndPlay(b, d, !1) : ccs.InnerActionType.LoopAction ===
            this._innerActionType && a.gotoFrameAndPlay(b, d, !0)
        }
    },
    setAnimationName: function (a) {
        this._animationName = a
    },
    setSingleFrameIndex: function (a) {
        this._singleFrameIndex = a
    },
    getSingleFrameIndex: function () {
        return this._startFrameIndex
    },
    setEnterWithName: function (a) {
        this._enterWithName = a
    },
    getEnterWithName: function () {
        return this._enterWithName
    },
    clone: function () {
        var a = new ccs.InnerActionFrame;
        a.setInnerActionType(this._innerActionType);
        a.setStartFrameIndex(this._startFrameIndex);
        a.setEnterWithName(this._enterWithName);
        a.setAnimationName(this._animationName);
        a.setSingleFrameIndex(this._singleFrameIndex);
        a._cloneProperty(this);
        return a
    },
    setInnerActionType: function (a) {
        this._innerActionType = a
    },
    getInnerActionType: function () {
        return this._innerActionType
    },
    setStartFrameIndex: function (a) {
        this._startFrameIndex = a
    },
    getStartFrameIndex: function () {
        return this._startFrameIndex
    }
});
ccs.InnerActionFrame.create = function () {
    return new ccs.InnerActionFrame
};
ccs.ColorFrame = ccs.Frame.extend({
    _alpha: null,
    _color: null,
    _betweenAlpha: null,
    _betweenRed: null,
    _betweenGreen: null,
    _betweenBlue: null,
    ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._color = cc.color(255, 255, 255)
    },
    onEnter: function (a) {
        this._node && (this._node.setColor(this._color), this._tween && (a = a._color, this._betweenRed = a.r - this._color.r, this._betweenGreen = a.g - this._color.g, this._betweenBlue = a.b - this._color.b))
    },
    _onApply: function (a) {
        if (this._node && this._tween && (0 !== this._betweenAlpha || 0 !== this._betweenRed ||
            0 !== this._betweenGreen || 0 !== this._betweenBlue)) {
            var b = cc.color(255, 255, 255);
            b.r = this._color.r + this._betweenRed * a;
            b.g = this._color.g + this._betweenGreen * a;
            b.b = this._color.b + this._betweenBlue * a;
            this._node.setColor(b);
            null !== this._alpha && this._node.setOpacity(this._alpha + this._betweenAlpha * a)
        }
    },
    clone: function () {
        var a = new ccs.ColorFrame;
        a.setColor(this._color);
        a._cloneProperty(this);
        return a
    },
    setColor: function (a) {
        this._color = a
    },
    getColor: function () {
        return this._color
    }
});
ccs.ColorFrame.create = function () {
    return new ccs.ColorFrame
};
ccs.AlphaFrame = ccs.Frame.extend({
    _alpha: null, _betweenAlpha: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._alpha = 255
    }, onEnter: function (a) {
        this._node && (this._node.setOpacity(this._alpha), this._tween && (this._betweenAlpha = a._alpha - this._alpha))
    }, _onApply: function (a) {
        this._node && this._node.setOpacity(this._alpha + this._betweenAlpha * a)
    }, setAlpha: function (a) {
        this._alpha = a
    }, getAlpha: function () {
        return this._alpha
    }, clone: function () {
        var a = new ccs.AlphaFrame;
        a.setAlpha(this._alpha);
        a._cloneProperty(this);
        return a
    }
});
ccs.EventFrame = ccs.Frame.extend({
    _event: null, ctor: function () {
        ccs.Frame.prototype.ctor.call(this);
        this._event = "";
        this._enterWhenPassed = !0
    }, onEnter: function (a) {
        this._emitEvent()
    }, clone: function () {
        var a = new ccs.EventFrame;
        a.setEvent(this._event);
        a._cloneProperty(this);
        return a
    }, setEvent: function (a) {
        this._event = a
    }, getEvent: function () {
        return this._event
    }
});
ccs.EventFrame.create = function () {
    return new ccs.EventFrame
};
ccs.ZOrderFrame = ccs.Frame.extend({
    _zorder: 0, onEnter: function (a) {
        this._node && this._node.setLocalZOrder(this._zorder)
    }, clone: function () {
        var a = new ccs.ZOrderFrame;
        a.setZOrder(this._zorder);
        a._cloneProperty(this);
        return a
    }, setZOrder: function (a) {
        this._zorder = a
    }, getZOrder: function () {
        return this._zorder
    }
});
ccs.ZOrderFrame.create = function () {
    return new ccs.ZOrderFrame
};
ccs.BlendFuncFrame = ccs.Frame.extend({
    ctor: function () {
        this._super();
        this._blendFunc = null
    }, onEnter: function (a, b) {
        this._node && this._blendFunc && this._node.setBlendFunc(this._blendFunc)
    }, clone: function () {
        var a = new ccs.BlendFuncFrame;
        a.setBlendFunc(this._blendFunc);
        a._cloneProperty(this);
        return a
    }, setBlendFunc: function (a) {
        a && a.src && a.dst && (this._blendFunc = a)
    }, getBlendFunc: function () {
        return this._blendFunc
    }
});
ccs.BlendFuncFrame.create = function () {
    return new ccs.BlendFuncFrame
};
ccs.Timeline = ccs.Class.extend({
    _frames: null,
    _currentKeyFrame: null,
    _currentKeyFrameIndex: null,
    _fromIndex: null,
    _toIndex: null,
    _betweenDuration: null,
    _actionTag: null,
    _ActionTimeline: null,
    _node: null,
    ctor: function () {
        this._frames = [];
        this._currentKeyFrame = null;
        this._actionTag = this._betweenDuration = this._toIndex = this._fromIndex = this._currentKeyFrameIndex = 0;
        this._node = this._ActionTimeline = null
    },
    _gotoFrame: function (a) {
        0 !== this._frames.length && (this._binarySearchKeyFrame(a), this._apply(a))
    },
    _stepToFrame: function (a) {
        0 !==
        this._frames.length && (this._updateCurrentKeyFrame(a), this._apply(a))
    },
    getFrames: function () {
        return this._frames
    },
    addFrame: function (a) {
        this._frames.push(a);
        a.setTimeline(this)
    },
    insertFrame: function (a, b) {
        this._frames.splice(b, 0, a);
        a.setTimeline(this)
    },
    removeFrame: function (a) {
        cc.arrayRemoveObject(this._frames, a);
        a.setTimeline(null)
    },
    setActionTag: function (a) {
        this._actionTag = a
    },
    getActionTag: function () {
        return this._actionTag
    },
    setNode: function (a) {
        for (var b = 0; b < this._frames.length; b++)this._frames[b].setNode(a)
    },
    getNode: function () {
        return this._node
    },
    setActionTimeline: function (a) {
        this._ActionTimeline = a
    },
    getActionTimeline: function () {
        return this._ActionTimeline
    },
    clone: function () {
        var a = new ccs.Timeline;
        a._actionTag = this._actionTag;
        for (var b = 0; b < this._frames.length; b++) {
            var d = this._frames[b].clone();
            a.addFrame(d)
        }
        return a
    },
    _apply: function (a) {
        this._currentKeyFrame && this._currentKeyFrame.apply(0 >= this._betweenDuration ? 0 : (a - this._currentKeyFrameIndex) / this._betweenDuration)
    },
    _binarySearchKeyFrame: function (a) {
        var b =
            null, d = null, e = this._frames.length, f = !1;
        do if (a < this._frames[0].getFrameIndex())this._currentKeyFrameIndex >= this._frames[0].getFrameIndex() && (f = !0), this._toIndex = this._fromIndex = 0, b = d = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex(); else if (a >= this._frames[e - 1].getFrameIndex())this._fromIndex = e - 1, this._toIndex = 0, b = d = this._frames[e - 1], this._currentKeyFrameIndex = this._frames[e - 1].getFrameIndex(), this._betweenDuration = 0; else {
            for (var g = -1, b = 0, d = e - 1, h = 0; b <=
            d;) {
                h = Math.ceil((b + d) / 2);
                if (a >= this._frames[h].getFrameIndex() && a < this._frames[h + 1].getFrameIndex()) {
                    g = h;
                    break
                }
                this._frames[h].getFrameIndex() > a ? d = h - 1 : b = h + 1
            }
            this._fromIndex = g;
            this._toIndex = 1 < e ? g + 1 | 0 : g | 0;
            b = this._frames[g];
            d = this._frames[g + 1];
            0 === g && this._currentKeyFrameIndex < b.getFrameIndex() && (f = !0);
            this._currentKeyFrameIndex = b.getFrameIndex();
            this._betweenDuration = d.getFrameIndex() - b.getFrameIndex()
        } while (0);
        if (f || this._currentKeyFrame != b)this._currentKeyFrame = b, this._currentKeyFrame.onEnter(d)
    },
    _updateCurrentKeyFrame: function (a) {
        if (a < this._currentKeyFrameIndex || a >= this._currentKeyFrameIndex + this._betweenDuration) {
            var b = null, d = null;
            do {
                var e = this._frames.length;
                if (a < this._frames[0].getFrameIndex())b = d = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex(); else {
                    if (a >= this._frames[e - 1].getFrameIndex() && (a = this._frames[e - 1].getFrameIndex(), this._currentKeyFrameIndex >= a))return;
                    do {
                        this._fromIndex = this._toIndex;
                        b = this._frames[this._fromIndex];
                        this._currentKeyFrameIndex =
                            b.getFrameIndex();
                        this._toIndex = this._fromIndex + 1;
                        this._toIndex >= e && (this._toIndex = 0);
                        d = this._frames[this._toIndex];
                        if (a === b.getFrameIndex())break;
                        if (a > b.getFrameIndex() && a < d.getFrameIndex())break;
                        if (b.isEnterWhenPassed())b.onEnter(d)
                    } while (1);
                    this._betweenDuration = d.getFrameIndex() - b.getFrameIndex()
                }
            } while (0);
            this._currentKeyFrame = b;
            this._currentKeyFrame.onEnter(d)
        }
    }
});
ccs.Timeline.create = function () {
    return new ccs.Timeline
};
ccs.SkinNode = function () {
    var a = cc.Node.extend({});
    a.create = function () {
    };
    return a
}();
ccs.BoneNode = function () {
    var a = cc.Node, b = ccs.SkinNode, d = cc.BlendFunc, e = {p: cc.p, size: cc.size, rect: cc.rect}, f = {
        log: cc.log,
        assert: cc.assert
    }, g = a.extend({
        _customCommand: null,
        _blendFunc: null,
        _rackColor: null,
        _rackLength: null,
        _rackWidth: null,
        _childBones: null,
        _boneSkins: null,
        _rootSkeleton: null,
        _squareVertices: null,
        _squareColors: null,
        _noMVPVertices: null,
        ctor: function (b) {
            a.prototype.ctor.call(this);
            null === this._squareVertices && (this._squareVertices = [{x: 0, y: 0}, {x: 0, y: 0}, {x: 0, y: 0}, {
                x: 0,
                y: 0
            }]);
            this._rackColor =
                cc.color.WHITE;
            this._blendFunc = d.ALPHA_NON_PREMULTIPLIED;
            this._childBones = [];
            this._boneSkins = [];
            this._rackLength = void 0 === b ? 50 : b;
            this._rackWidth = 20;
            this._updateVertices()
        },
        addSkin: function (b, d, e) {
            var g = this._boneSkins;
            f.assert(null != b, "Argument must be non-nil");
            if (e)for (e = 0; e < g.length; e++)g[e].setVisible(!1);
            a.prototype.addChild.call(this, b);
            this._boneSkins.push(b);
            b.setVisible(d)
        },
        getChildBones: function () {
            return this._childBones
        },
        getSkins: function () {
            return this._boneSkins
        },
        displaySkin: function (a,
                               b) {
            var d = this._boneSkins, e, f;
            if ("string" === typeof a)for (f = 0; f < d.length; f++)e = d[f], a == e.getName() ? e.setVisible(!0) : b && e.setVisible(!1); else for (f = 0; f < d.length; f++)e = d[f], e == a ? e.setVisible(!0) : b && e.setVisible(!1)
        },
        getVisibleSkins: function () {
            for (var a = [], b = this._boneSkins, d, e = 0; e < b.length; e++)d = b[e], d.isVisible() && a.push(d);
            return a
        },
        getRootSkeletonNode: function () {
            return this._rootSkeleton
        },
        getAllSubBones: function () {
            for (var a = [], b = [], d = this._childBones, e = 0; e < d.length; e++)b.push(d[e]);
            for (; 0 < b.length;)for (d =
                                          b.pop(), a.push(d), d = d.getChildBones(), e = 0; e < d; e++)b.push(d[e]);
            return a
        },
        getAllSubSkins: function () {
            for (var a = this.getAllSubBones(), b = [], d = 0; d < a.length; d++)for (var e = a[d].getSkins(), f = 0; f < e.length; f++)b.push(e[d]);
            return b
        },
        addChild: function (b, d, e) {
            a.prototype.addChild.call(this, b, d, e);
            this._addToChildrenListHelper(b)
        },
        removeChild: function (b, d) {
            -1 !== this._children.indexOf(b) && (a.prototype.removeChild.call(this, b, d), this._removeFromChildrenListHelper(b))
        },
        setBlendFunc: function (a) {
            var b = this._blendFunc;
            if (a && b.src !== a.src && b.dst !== a.dst) {
                this._blendFunc = a;
                for (var b = this._boneSkins, d, e = 0; e < b.length; e++)d = b[e], d.setBlendFunc(a)
            }
        },
        getBlendFunc: function () {
            return this._blendFunc
        },
        setDebugDrawLength: function (a) {
            this._rackLength = a;
            this._updateVertices()
        },
        getDebugDrawLength: function () {
            return this._rackLength
        },
        setDebugDrawWidth: function (a) {
            this._rackWidth = a;
            this._updateVertices()
        },
        getDebugDrawWidth: function () {
            return this._rackWidth
        },
        setDebugDrawEnabled: function (a) {
            var b = this._renderCmd;
            b._debug !== a && (b._debug =
                a, cc.renderer.childrenOrderDirty = !0, this._visible && null != this._rootSkeleton && (this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0))
        },
        isDebugDrawEnabled: function () {
            return this._renderCmd._debug
        },
        setDebugDrawColor: function (a) {
            this._rackColor = a
        },
        getDebugDrawColor: function () {
            return this._rackColor
        },
        getVisibleSkinsRect: function () {
            var a, b, d, f = 0;
            a = b = d = f;
            var g = !0, h = e.rect(0, 0, 0, 0);
            this._renderCmd._debug && null != this._rootSkeleton && this._rootSkeleton._renderCmd._debug && (d = this._rackWidth,
                f = this._rackLength, g = !1);
            for (var n = this._boneSkins, w, y = 0; y < n.length; y++) {
                w = n[y];
                var A = w.getBoundingBox();
                !w.isVisible() || 0 === A.x && 0 === A.y && 0 === A.width && 0 === A.height || (g ? (a = cc.rectGetMinX(A), b = cc.rectGetMinY(A), d = cc.rectGetMaxX(A), f = cc.rectGetMaxY(A), g = !1) : (a = Math.min(cc.rectGetMinX(A), a), b = Math.min(cc.rectGetMinY(A), b), d = Math.max(cc.rectGetMaxX(A), d), f = Math.max(cc.rectGetMaxY(A), f)), h.setRect(a, b, d - a, f - b))
            }
            return h
        },
        getBoundingBox: function () {
            var a = this.getVisibleSkinsRect();
            return cc.rectApplyAffineTransform(a,
                this.getNodeToParentAffineTransform())
        },
        batchBoneDrawToSkeleton: function (a) {
        },
        setLocalZOrder: function (b) {
            a.prototype.setLocalZOrder.call(this, b);
            null != this._rootSkeleton && (this._rootSkeleton._subBonesOrderDirty = !0)
        },
        setName: function (b) {
            var d = this._rootSkeleton, e = this.getName();
            a.prototype.setName.call(this, b);
            if (null != d) {
                var e = d._subBonesMap[e], f = d._subBonesMap[b];
                e && !f && (delete d._subBonesMap[e], d._subBonesMap[b] = e)
            }
        },
        setContentSize: function (b) {
            a.prototype.setContentSize.call(this, b);
            this._updateVertices()
        },
        setAnchorPoint: function (b) {
            a.prototype.setAnchorPoint.call(this, b);
            this._updateVertices()
        },
        setVisible: function (b) {
            this._visible != b && (a.prototype.setVisible.call(this, b), null != this._rootSkeleton && (this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0))
        },
        _addToChildrenListHelper: function (a) {
            a instanceof g ? this._addToBoneList(a) : this._addToSkinList(a)
        },
        _removeFromChildrenListHelper: function (a) {
            a instanceof g ? this._removeFromBoneList(a) : a instanceof b && this._removeFromSkinList(skin)
        },
        _removeFromBoneList: function (a) {
            if (null != this._rootSkeleton && a instanceof ccs.SkeletonNode && a._rootSkeleton === this._rootSkeleton) {
                a._rootSkeleton = null;
                var b = a.getAllSubBones();
                b.push(a);
                for (var d, e = 0; e < b.length; e++)d = b[e], d._rootSkeleton = null, delete this._rootSkeleton._subBonesMap[d.getName()], this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0
            } else this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0;
            cc.arrayRemoveObject(this._childBones, a)
        },
        _setRootSkeleton: function (a) {
            this._rootSkeleton =
                a;
            a = this.getAllSubBones();
            for (var b = 0; b < a.length; b++)this._addToBoneList(a[b])
        },
        _addToBoneList: function (a) {
            -1 === this._childBones.indexOf(a) && this._childBones.push(a);
            if (null != this._rootSkeleton && !(a instanceof b || a._rootSkeleton)) {
                var d = a.getAllSubBones();
                d.push(a);
                for (var e = 0; e < d.length; e++) {
                    a = d[e];
                    a._setRootSkeleton(this._rootSkeleton);
                    var f = a.getName();
                    this._rootSkeleton._subBonesMap[f] ? cc.log("already has a bone named %s in skeleton %s", f, this._rootSkeleton.getName()) : this._rootSkeleton._subBonesMap[a.getName()] =
                        a;
                    this._rootSkeleton._subBonesDirty = !0;
                    this._rootSkeleton._subBonesOrderDirty = !0
                }
            }
        },
        _visitSkins: function () {
            var a = this._renderCmd;
            if (this._visible) {
                var b = a.getParentRenderCmd();
                b && (a._curLevel = b._curLevel + 1);
                var d = this._boneSkins, e;
                a._syncStatus(b);
                var f = d.length;
                if (0 < f) {
                    this.sortAllChildren();
                    for (b = 0; b < f; b++)if (e = d[b], 0 > e._localZOrder)e._renderCmd.visit(a); else break;
                    for (; b < f; b++)d[b]._renderCmd.visit(a)
                }
                a._dirtyFlag = 0
            }
        },
        _addToSkinList: function (a) {
            this._boneSkins.push(a);
            if (a.getBlendFunc) {
                var b =
                    a.getBlendFunc();
                this._blendFunc.src !== b.src && this._blendFunc.dst !== b.dst && a.setBlendFunc(this._blendFunc)
            }
        },
        _removeFromSkinList: function (a) {
            cc.arrayRemoveObject(this._boneSkins, a)
        },
        sortAllChildren: function () {
            this._sortArray(this._childBones);
            this._sortArray(this._boneSkins);
            a.prototype.sortAllChildren.call(this)
        },
        _sortArray: function (a) {
            if (a) {
                var b = a.length, d, e, f;
                for (d = 1; d < b; d++) {
                    f = a[d];
                    for (e = d - 1; 0 <= e;) {
                        if (f._localZOrder < a[e]._localZOrder)a[e + 1] = a[e]; else if (f._localZOrder === a[e]._localZOrder && f.arrivalOrder <
                            a[e].arrivalOrder)a[e + 1] = a[e]; else break;
                        e--
                    }
                    a[e + 1] = f
                }
            }
        },
        _updateVertices: function () {
            var a = this._squareVertices, b = this._renderCmd._anchorPointInPoints;
            if (this._rackLength != a[2].x - b.x || a[3].y != this._rackWidth / 2 - b.y) {
                a[1].x = a[1].y = a[3].y = 0;
                a[0].x = a[2].x = 0.1 * this._rackLength;
                a[2].y = 0.5 * this._rackWidth;
                a[0].y = -a[2].y;
                a[3].x = this._rackLength;
                for (var d = 0; d < a.length; d++)a[d].x += b.x, a[d].y += b.y;
                this._renderCmd.updateDebugPoint(a)
            }
        },
        _createRenderCmd: function () {
            return cc._renderType === cc.game.RENDER_TYPE_CANVAS ?
                new h(this) : new n(this)
        }
    });
    g.create = function (a, b) {
        return new ccui.BoneNode(a, b)
    };
    var h = function () {
        var b = function (b) {
            a.CanvasRenderCmd.call(this, b);
            this._debug = !1;
            this._color = cc.color.WHITE;
            this._drawNode = new cc.DrawNode
        }, d = b.prototype = Object.create(a.CanvasRenderCmd.prototype);
        d.constructor = b;
        d.visit = function (a) {
            var b = this._node;
            b._visit && b._visit(a)
        };
        d.updateDebugPoint = function (a) {
            this._drawNode.clear();
            this._drawNode.drawPoly(a, this._color, 0, this._color)
        };
        d.transform = function (b, d) {
            var e = this._node._rootSkeleton;
            a.CanvasRenderCmd.prototype.transform.call(this, b, d);
            e && e._renderCmd._debug && this._drawNode._renderCmd.transform(this)
        };
        return b
    }(), n = function () {
        var b = function (b) {
            a.WebGLRenderCmd.call(this, b);
            this._debug = !1;
            this._color = cc.color.WHITE;
            this._drawNode = new cc.DrawNode
        }, d = b.prototype = Object.create(a.WebGLRenderCmd.prototype);
        d.constructor = b;
        d.visit = function (a) {
            var b = this._node;
            b._visit && b._visit(a)
        };
        d.updateDebugPoint = function (a) {
            this._drawNode.clear();
            this._drawNode.drawPoly(a, this._color, 0, this._color)
        };
        d.transform = function (b, d) {
            var e = this._node._rootSkeleton;
            a.WebGLRenderCmd.prototype.transform.call(this, b, d);
            e && e._renderCmd._debug && this._drawNode._renderCmd.transform(this)
        };
        return b
    }();
    return g
}();
ccs.SkeletonNode = function () {
    var a = ccs.BoneNode, b = a.extend({
        _subBonesMap: null,
        _squareVertices: null,
        _squareColors: null,
        _noMVPVertices: null,
        _skinGroupMap: null,
        _sortedAllBonesDirty: !1,
        _sortedAllBones: null,
        _batchedBoneVetices: null,
        _batchedBoneColors: null,
        _batchedVeticesCount: null,
        _batchBoneCommand: null,
        _subOrderedAllBones: null,
        ctor: function () {
            this._squareVertices = [{x: 0, y: 0}, {x: 0, y: 0}, {x: 0, y: 0}, {x: 0, y: 0}, {x: 0, y: 0}, {
                x: 0,
                y: 0
            }, {x: 0, y: 0}, {x: 0, y: 0}];
            this._rootSkeleton = this;
            a.prototype.ctor.call(this);
            this._subBonesMap =
            {};
            this._subOrderedAllBones = [];
            this._skinGroupMap = {};
            this._rackLength = this._rackWidth = 20;
            this._updateVertices()
        },
        getBoneNode: function (a) {
            return (a = this._subBonesMap[a]) ? a : null
        },
        getAllSubBonesMap: function () {
            return this._subBonesMap
        },
        changeSkins: function (a) {
            if ("object" === typeof a) {
                var b, f;
                for (f in a) {
                    b = a[f];
                    var g = this.getBoneNode(f);
                    null !== g && g.displaySkin(b, !0)
                }
            } else(a = this._suitMap[a]) && this.changeSkins(a, !0)
        },
        addSkinGroup: function (a, b) {
            this._skinGroupMap[a] = b
        },
        getBoundingBox: function () {
            var a, b, f,
                g = 0;
            a = b = f = g;
            var h = this.getVisibleSkinsRect(), n = !0;
            if (0 !== h.x || 0 !== h.y || 0 !== h.width || 0 !== h.height)a = cc.rectGetMinX(h), b = cc.rectGetMinY(h), f = cc.rectGetMaxX(h), g = cc.rectGetMaxY(h), n = !1;
            for (var p = this.getAllSubBones(), r, s = 0; s < p.length; s++)if (r = p[s], r = cc.rectApplyAffineTransform(r.getVisibleSkinsRect(), r.getNodeToParentTransform(r.getRootSkeletonNode())), 0 !== r.x || 0 !== r.y || 0 !== r.width || 0 !== r.height)n ? (a = cc.rectGetMinX(r), b = cc.rectGetMinY(r), f = cc.rectGetMaxX(r), g = cc.rectGetMaxY(r), n = !1) : (a = Math.min(cc.rectGetMinX(r),
                a), b = Math.min(cc.rectGetMinY(r), b), f = Math.max(cc.rectGetMaxX(r), f), g = Math.max(cc.rectGetMaxY(r), g));
            h.x = a;
            h.y = b;
            h.width = f - a;
            h.height = g - b;
            return cc.rectApplyAffineTransform(h, this.getNodeToParentTransform())
        },
        _visit: function (a) {
            if (this._visible) {
                var b = this._renderCmd;
                a = a || b.getParentRenderCmd();
                b._syncStatus(a);
                var f;
                if (0 !== this._children.length)for (a = 0; a < this._children.length; a++)f = this._children[a], f._renderCmd.visit(b);
                this._checkSubBonesDirty();
                f = this._subOrderedAllBones;
                var g;
                for (a = 0; a < f.length; a++)g =
                    f[a], g._visitSkins();
                if (b._debug)for (a = 0; a < f.length; a++)b = f[a]._renderCmd, cc.renderer.pushRenderCommand(b._drawNode._renderCmd);
                this._dirtyFlag = 0
            }
        },
        _checkSubBonesDirty: function () {
            this._subBonesDirty && (this._updateOrderedAllbones(), this._subBonesDirty = !1);
            this._subBonesOrderDirty && (this._sortOrderedAllBones(), this._subBonesOrderDirty = !1)
        },
        _updateOrderedAllbones: function () {
            this._subOrderedAllBones.length = 0;
            for (var a = [], b = this._childBones, f, g = 0; g < b.length; g++)f = b[g], f.isVisible() && a.push(f);
            for (; 0 < a.length;)for (g =
                                          a.pop(), b = g._renderCmd, b._syncStatus(b.getParentRenderCmd()), this._subOrderedAllBones.push(g), b = g.getChildBones(), g = 0; g < b.length; g++)f = b[g], f.isVisible() && a.push(f)
        },
        _sortOrderedAllBones: function () {
            this._sortArray(this._subOrderedAllBones)
        },
        _updateVertices: function () {
            var a = this._squareVertices, b = this._renderCmd._anchorPointInPoints;
            if (this._rackLength != a[6].x - b.x || this._rackWidth != a[3].y - b.y) {
                var f = 0.5 * this._rackLength, g = 0.5 * this._rackWidth, h = 0.25 * f, n = 0.25 * g;
                a[5].y = a[2].y = a[1].y = a[6].y = a[0].x = a[4].x =
                    a[7].x = a[3].x = 0;
                a[5].x = -f;
                a[0].y = -g;
                a[6].x = f;
                a[3].y = g;
                a[1].x = h;
                a[7].y = n;
                a[2].x = -h;
                a[4].y = -n;
                for (f = 0; f < a.length; f++)a[f].x += b.x, a[f].y += b.y
            }
        },
        _updateAllDrawBones: function () {
            this._subDrawBones = {};
            for (var a in this._subBonesMap) {
                var b = this._subBonesMap[a];
                b.isVisible() && b.isDebugDrawEnabled() && this._subDrawBones.push(b)
            }
            this._sortArray(this._sortedAllBones);
            this._subDrawBones = !1
        }
    });
    b.create = function () {
        return new b
    };
    return b
}();
ccs._load = function () {
    var a = function (a, e, n) {
        var p = cc.loader.getRes(a);
        if (!p)return cc.log("%s does not exist", a);
        var r = a.match(d), r = (r && r[1] ? r[1] : null).toLocaleLowerCase();
        if ("json" !== r && "exportjson" !== r)return cc.log("%s load error, must be json file", a);
        var s;
        e ? s = b[e] : p.widgetTree ? s = b.ccui : p.nodeTree ? s = b.timeline : p.Content && p.Content.Content ? s = b.timeline : p.gameobjects && (s = b.scene);
        if (!s)return cc.log("Can't find the parser : %s", a), new cc.Node;
        e = p.version || p.Version;
        if (!e && p.armature_data)return cc.warn("%s is armature. please use:",
            a), cc.warn("    ccs.armatureDataManager.addArmatureFileInfoAsync(%s);", a), cc.warn("    var armature \x3d new ccs.Armature('name');"), new cc.Node;
        s = f(s, e);
        return s ? s.parse(a, p, n) || null : (cc.log("Can't find the parser : %s", a), new cc.Node)
    }, b = {ccui: {}, timeline: {}, action: {}, scene: {}};
    a.registerParser = function (a, d, e) {
        if (!a || !d || !e)return cc.log("register parser error");
        b[a] || (b[a] = {});
        b[a][d] = e
    };
    a.getParser = function (a, d) {
        return a && d ? b[a] ? b[a][d] : void 0 : a ? b[a] : b
    };
    var d = /\.([^\.]+)$/, e = /([^\.](\.\*)?)*$/,
        f = function (a, b) {
            return a[b] ? a[b] : "*" === b ? null : f(a, b.replace(e, "*"))
        };
    return a
}();
ccs._parser = cc.Class.extend({
    ctor: function () {
        this.parsers = {}
    }, _dirnameReg: /\S*\//, _dirname: function (a) {
        return (a = a.match(this._dirnameReg)) && a[0] ? a[0] : ""
    }, getClass: function (a) {
        return a.classname
    }, getNodeJson: function (a) {
        return a.widgetTree
    }, parse: function (a, b, d) {
        d = d || this._dirname(a);
        this.pretreatment(b, d);
        var e = this.parseNode(this.getNodeJson(b), d, a);
        e && this.deferred(b, d, e, a);
        return e
    }, pretreatment: function (a, b, d) {
    }, deferred: function (a, b, d, e) {
    }, parseNode: function (a, b) {
        var d = this.parsers[this.getClass(a)],
            e = null;
        d ? e = d.call(this, a, b) : cc.log("Can't find the parser : %s", this.getClass(a));
        return e
    }, registerParser: function (a, b) {
        this.parsers[a] = b
    }
});
ccs.actionCustoms = {};
ccs.load = function (a, b) {
    var d = {node: null, action: null};
    d.node = ccs._load(a, null, b);
    d.action = ccs._load(a, "action", b);
    d.action && -1 === d.action.tag && d.node && (d.action.tag = d.node.tag);
    ccs.actionCustoms[a] = d.action;
    return d
};
ccs.load.validate = {};
ccs.loadWithVisibleSize = function (a, b) {
    var d = ccs.load(a, b), e = cc.director.getVisibleSize();
    d.node && e && (d.node.setContentSize(e.width, e.height), ccui.helper.doLayout(d.node));
    return d
};
ccs.actionTimelineCache = {
    createAction: function (a) {
        return ccs._load(a, "action")
    }
};
ccs.csLoader = {
    createNode: function (a) {
        return ccs._load(a)
    }
};
cc.loader.register(["json"], {
    load: function (a, b, d, e) {
        cc.loader.loadJson(a, function (a, d) {
            var h = cc.path;
            if (d && d.Content && d.Content.Content.UsedResources) {
                for (var n = d.Content.Content.UsedResources, p = h.dirname(b), r = [], s, t = 0; t < n.length; t++)s = h.join(p, n[t]), s = h._normalize(s), ccs.load.validate[s] || (ccs.load.validate[s] = !0, r.push(s));
                cc.loader.load(r, function () {
                    e(a, d)
                })
            } else e(a, d)
        })
    }
});
(function (a, b) {
    var d = new (b.extend({
        getNodeJson: function (a) {
            return a
        }, parseNode: function (a, b) {
            var d = this.parsers[this.getClass(a)], e = null;
            d ? e = d.call(this, a, b) : cc.log("Can't find the parser : %s", this.getClass(a));
            return e
        }, deferred: function (a, b, d, e) {
            ccs.triggerManager.parse(a.Triggers || []);
            ccs.sceneReader && (ccs.sceneReader._node = d)
        }, setPropertyFromJsonDict: function (a, b) {
            var d = cc.isUndefined(b.x) ? 0 : b.x, e = cc.isUndefined(b.y) ? 0 : b.y;
            a.setPosition(d, e);
            d = Boolean(cc.isUndefined(b.visible) ? 1 : b.visible);
            a.setVisible(d);
            d = cc.isUndefined(b.objecttag) ? -1 : b.objecttag;
            a.setTag(d);
            d = cc.isUndefined(b.zorder) ? 0 : b.zorder;
            a.setLocalZOrder(d);
            d = cc.isUndefined(b.scalex) ? 1 : b.scalex;
            e = cc.isUndefined(b.scaley) ? 1 : b.scaley;
            a.setScaleX(d);
            a.setScaleY(e);
            d = cc.isUndefined(b.rotation) ? 0 : b.rotation;
            a.setRotation(d);
            a.setName(b.name || "")
        }
    }));
    d.parseChild = function (a, b, d) {
        for (var e = 0; e < b.length; e++) {
            var f, g = b[e];
            g && (f = this.parseNode(g, d));
            f && a.addChild(f)
        }
    };
    var e = {
        CCSprite: function (a, b, d) {
            var e = new cc.Sprite;
            g(b.fileData,
                d, function (a, b) {
                    if (0 === b)e.setTexture(a); else if (1 === b) {
                        var d = cc.spriteFrameCache.getSpriteFrame(a);
                        e.setSpriteFrame(d)
                    }
                });
            b = new ccs.ComRender(e, "CCSprite");
            a.addComponent(b);
            return b
        }, CCTMXTiledMap: function (a, b, d) {
            var e = null;
            g(b.fileData, d, function (a, b) {
                0 === b && (e = new cc.TMXTiledMap(a))
            });
            b = new ccs.ComRender(e, "CCTMXTiledMap");
            a.addComponent(b);
            return b
        }, CCParticleSystemQuad: function (a, b, d) {
            var e = null;
            g(b.fileData, d, function (a, b) {
                0 === b ? e = new cc.ParticleSystem(a) : cc.log("unknown resourcetype on CCParticleSystemQuad!");
                e.setPosition(0, 0)
            });
            b = new ccs.ComRender(e, "CCParticleSystemQuad");
            a.addComponent(b);
            return b
        }, CCArmature: function (a, b, d) {
            var e = null;
            g(b.fileData, d, function (a, b) {
                if (0 === b) {
                    var d = cc.loader.getRes(a);
                    d || cc.log("Please load the resource [%s] first!", a);
                    d = d.armature_data[0].name;
                    ccs.armatureDataManager.addArmatureFileInfo(a);
                    e = new ccs.Armature(d)
                }
            });
            if (e)return d = new ccs.ComRender(e, "CCArmature"), a.addComponent(d), (a = b.selectedactionname) && e.getAnimation() && e.getAnimation().play(a), d
        }, CCComAudio: function (a,
                                 b, d) {
            var e = null;
            g(b.fileData, d, function (d, f) {
                if (0 === f) {
                    e = new ccs.ComAudio;
                    e.preloadEffect(d);
                    var g = b.name;
                    g && e.setName(g);
                    a.addComponent(e)
                }
            })
        }, CCComAttribute: function (a, b, d) {
            var e = null;
            g(b.fileData, d, function (b, d) {
                0 === d ? (e = new ccs.ComAttribute, "" !== b && e.parse(b), a.addComponent(e)) : cc.log("unknown resourcetype on CCComAttribute!")
            });
            return e
        }, CCBackgroundAudio: function (a, b, d) {
            var e = null;
            g(b.fileData, d, function (d, f) {
                if (0 === f) {
                    e = new ccs.ComAudio;
                    e.preloadBackgroundMusic(d);
                    e.setFile(d);
                    var g = Boolean(b.loop ||
                        0);
                    e.setLoop(g);
                    var p = b.name;
                    p && e.setName(p);
                    a.addComponent(e);
                    e.playBackgroundMusic(d, g)
                }
            })
        }, GUIComponent: function (a, b, d) {
            var e = null;
            g(b.fileData, d, function (a, b) {
                e = ccs._load(a, "ccui")
            });
            b = new ccs.ComRender(e, "GUIComponent");
            a.addComponent(b);
            return b
        }, CCScene: function () {
        }
    }, f = {}, g = function (a, b, d) {
        if (null != a) {
            var e = a.path, g = a.resourceType;
            a = a.plist;
            e && (a && (cc.loader.getRes(b + a) ? (f[b + a] = !0, cc.spriteFrameCache.addSpriteFrames(b + a)) : f[b + a] || cc.log("%s need to be preloaded", b + a)), 0 !== g ? d(e, g) : d(b + e, g))
        }
    };
    d.parseComponents = function (a, b, d) {
        a && b && b.forEach(function (b) {
            var f = e[b.classname], g = null;
            f ? g = f(a, b, d) : cc.log("Can't find the component parser : %s", b.classname);
            b = b.name;
            g && b && g.setName(b)
        })
    };
    d.registerParser("CCNode", function (a, b) {
        var d = new cc.Node;
        this.setPropertyFromJsonDict(d, a);
        this.parseChild.call(this, d, a.gameobjects, b);
        this.parseComponents(d, a.components, b);
        var e = a.CanvasSize;
        e && d.setContentSize(cc.size(e._width, e._height));
        return d
    });
    a.registerParser("scene", "*", d)
})(ccs._load, ccs._parser);
(function (a, b) {
    var d = new (b.extend({
        addSpriteFrame: function (a, b) {
            if (a)for (var d = 0; d < a.length; d++)cc.spriteFrameCache.addSpriteFrames(b + a[d])
        }, pretreatment: function (a, b) {
            this.addSpriteFrame(a.textures, b)
        }, deferred: function (a, b, d, e) {
            d && (ccs.actionManager.initWithDictionary(e, a.animation, d), d.setContentSize(cc.size(a.designWidth, a.designHeight)))
        }
    }));
    d.generalAttributes = function (a, b) {
        var d = b.ignoreSize;
        null != d && a.ignoreContentAdaptWithSize(d);
        b.sizeType && a.setSizeType(b.sizeType);
        b.positionType && a.setPositionType(b.positionType);
        a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY));
        a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY));
        var e = d = 0;
        b.adaptScreen ? (e = cc.director.getWinSize(), d = e.width, e = e.height) : (d = b.width, e = b.height);
        a.setContentSize(d, e);
        a.setTag(b.tag);
        a.setActionTag(b.actiontag);
        a.setTouchEnabled(b.touchAble);
        d = b.name;
        a.setName(d ? d : "default");
        a.setPosition(b.x, b.y);
        a.setScaleX(null != b.scaleX ? b.scaleX : 1);
        a.setScaleY(null != b.scaleY ? b.scaleY : 1);
        a.setRotation(b.rotation || 0);
        d = b.visible || !1;
        null != d &&
        a.setVisible(d);
        a.setLocalZOrder(b.ZOrder);
        if (null != b.layoutParameter) {
            d = b.layoutParameter;
            e = null;
            switch (d.type) {
                case 1:
                    e = new ccui.LinearLayoutParameter;
                    e.setGravity(d.gravity);
                    break;
                case 2:
                    var f = e = new ccui.RelativeLayoutParameter;
                    f.setRelativeName(d.relativeName);
                    f.setRelativeToWidgetName(d.relativeToName);
                    f.setAlign(d.align)
            }
            null != e && (e.setMargin(d.marginLeft || 0, d.marginTop || 0, d.marginRight || 0, d.marginDown || 0), a.setLayoutParameter(e))
        }
    };
    d.colorAttributes = function (a, b) {
        var d = b.opacity;
        null != d && a.setOpacity(d);
        var d = b.colorR, e = b.colorG, f = b.colorB;
        a.setColor(cc.color(null == d ? 255 : d, null == e ? 255 : e, null == f ? 255 : f));
        a.setFlippedX(b.flipX);
        a.setFlippedY(b.flipY)
    };
    d.anchorPointAttributes = function (a, b) {
        var d = b.anchorPointX, e;
        e = null != d ? b.anchorPointX : a.getAnchorPoint().x;
        var f = b.anchorPointY, s;
        s = null != f ? b.anchorPointY : a.getAnchorPoint().y;
        null == d && null == f || a.setAnchorPoint(cc.p(e, s))
    };
    d.parseChild = function (a, b, d) {
        b = b.children;
        for (var e = 0; e < b.length; e++) {
            var f = this.parseNode(b[e], d);
            if (f)if (a instanceof ccui.PageView)a.addPage(f);
            else if (a instanceof ccui.ListView)a.pushBackCustomItem(f); else {
                if (!(a instanceof ccui.Layout)) {
                    if (f.getPositionType() === ccui.Widget.POSITION_PERCENT) {
                        var s = f.getPositionPercent(), t = a.getAnchorPoint();
                        f.setPositionPercent(cc.p(s.x + t.x, s.y + t.y))
                    }
                    s = a.getAnchorPointInPoints();
                    f.setPosition(cc.p(f.getPositionX() + s.x, f.getPositionY() + s.y))
                }
                a.addChild(f)
            }
        }
    };
    var e = function (a, b, d, e) {
        d && (0 === b ? e(a + d, b) : e(d, b))
    };
    d.LayoutAttributes = function (a, b, d) {
        var f = 0, r = 0;
        b.adaptScreen ? (r = cc.director.getWinSize(), f = r.width,
            r = r.height) : (f = b.width, r = b.height);
        a.setSize(cc.size(f, r));
        a.setClippingEnabled(b.clipAble);
        f = b.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(f);
        var r = b.bgColorR, s = b.bgColorG, t = b.bgColorB, v = b.bgStartColorR, u = b.bgStartColorG, x = b.bgStartColorB, w = b.bgEndColorR, y = b.bgEndColorG, A = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var D = b.bgColorOpacity;
        a.setBackGroundColorType(b.colorType);
        a.setBackGroundColor(cc.color(v, u, x), cc.color(w, y, A));
        a.setBackGroundColor(cc.color(r,
            s, t));
        a.setBackGroundColorOpacity(D);
        (r = b.backGroundImageData) && e(d, r.resourceType, r.path, function (b, d) {
            a.setBackGroundImage(b, d)
        });
        f && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight));
        b.layoutType && a.setLayoutType(b.layoutType)
    };
    d.ButtonAttributes = function (a, b, d) {
        var f = b.scale9Enable;
        a.setScale9Enabled(f);
        var r = b.normalData;
        e(d, r.resourceType, r.path, function (b, d) {
            a.loadTextureNormal(b, d)
        });
        r = b.pressedData;
        e(d, r.resourceType, r.path, function (b, d) {
            a.loadTexturePressed(b,
                d)
        });
        r = b.disabledData;
        e(d, r.resourceType, r.path, function (b, d) {
            a.loadTextureDisabled(b, d)
        });
        f && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), d = b.scale9Width, f = b.scale9Height, null != d && null != f && a.setSize(cc.size(d, f)));
        d = b.text;
        null != d && a.setTitleText(d);
        a.setTitleColor(cc.color(null !== b.textColorR ? b.textColorR : 255, null !== b.textColorG ? b.textColorG : 255, null !== b.textColorB ? b.textColorB : 255));
        null != b.fontSize && a.setTitleFontSize(b.fontSize);
        b.fontName && a.setTitleFontName(b.fontName)
    };
    d.CheckBoxAttributes = function (a, b, d) {
        var f = b.backGroundBoxData;
        e(d, f.resourceType, f.path, function (b, d) {
            a.loadTextureBackGround(b, d)
        });
        var r = b.backGroundBoxSelectedData;
        e(d, r.resourceType || f.resourceType, r.path || f.path, function (b, d) {
            a.loadTextureBackGroundSelected(b, d)
        });
        f = b.frontCrossData;
        e(d, f.resourceType, f.path, function (b, d) {
            a.loadTextureFrontCross(b, d)
        });
        r = b.backGroundBoxDisabledData;
        e(d, r.resourceType || f.resourceType, r.path || f.path, function (b, d) {
            a.loadTextureBackGroundDisabled(b, d)
        });
        f = b.frontCrossDisabledData;
        e(d, f.resourceType, f.path, function (b, d) {
            a.loadTextureFrontCrossDisabled(b, d)
        });
        b.selectedState && a.setSelected(b.selectedState)
    };
    d.ImageViewAttributes = function (a, b, d) {
        var f = b.fileNameData;
        e(d, f.resourceType, f.path, function (b, d) {
            a.loadTexture(b, d)
        });
        d = !1;
        b.scale9Enable && (d = b.scale9Enable);
        a.setScale9Enabled(d);
        d && (d = b.scale9Height, b.scale9Width && d && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)))
    };
    d.TextAtlasAttributes =
        function (a, b, d) {
            var e = b.stringValue, f = b.charMapFileData, s = b.itemWidth, t = b.itemHeight, v = b.startCharMap;
            if (null != e && f && null != s && null != t && null != v)switch (b = b.charMapFileData, b.resourceType) {
                case 0:
                    a.setProperty(e, d + b.path, s, t, v);
                    break;
                case 1:
                    cc.log("Wrong res type of LabelAtlas!")
            }
        };
    d.TextBMFontAttributes = function (a, b, d) {
        var e = b.fileNameData;
        switch (e.resourceType) {
            case 0:
                a.setFntFile(d + e.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(b.text)
    };
    var f = /\.ttf$/;
    d.TextAttributes = function (a,
                                 b, d) {
        a.setTouchScaleChangeEnabled(b.touchScaleEnable);
        a.setString(b.text);
        null != b.fontSize && a.setFontSize(b.fontSize);
        var e = b.fontName;
        null != e && (cc.sys.isNative ? f.test(e) ? a.setFontName(cc.path.join(cc.loader.resPath, d, e)) : a.setFontName(e) : a.setFontName(e.replace(f, "")));
        d = b.areaHeight;
        null != b.areaWidth && null != d && (d = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(d));
        null != b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment);
        null != b.vAlignment && a.setTextVerticalAlignment(b.vAlignment)
    };
    d.ListViewAttributes =
        function (a, b, e) {
            d.ScrollViewAttributes(a, b, e);
            a.setDirection(b.direction);
            a.setGravity(b.gravity);
            a.setItemsMargin(b.itemMargin)
        };
    d.LoadingBarAttributes = function (a, b, d) {
        var f = b.textureData;
        e(d, f.resourceType, f.path, function (b, d) {
            a.loadTexture(b, d)
        });
        d = b.scale9Enable;
        a.setScale9Enabled(d);
        d && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setSize(cc.size(b.width, b.height)));
        a.setDirection(b.direction);
        a.setPercent(b.percent)
    };
    d.PageViewAttributes = d.LayoutAttributes;
    d.ScrollViewAttributes = function (a, b, e) {
        d.LayoutAttributes(a, b, e);
        a.setInnerContainerSize(cc.size(null != b.innerWidth ? b.innerWidth : 200, null != b.innerHeight ? b.innerHeight : 200));
        a.setDirection(null != b.direction ? b.direction : 1);
        a.setBounceEnabled(b.bounceEnable)
    };
    d.SliderAttributes = function (a, b, d) {
        var f = b.scale9Enable;
        a.setScale9Enabled(f);
        var r = b.length, s = b.barFileNameData, t = s.resourceType, s = s.path;
        null != b.barFileName ? f && (e(d, t, s, function (b, d) {
            a.loadBarTexture(b, d)
        }), a.setSize(cc.size(r, a.getContentSize().height))) :
            e(d, t, s, function (b, d) {
                a.loadBarTexture(b, d)
            });
        f = b.ballNormalData;
        e(d, f.resourceType, f.path, function (b, d) {
            a.loadSlidBallTextureNormal(b, d)
        });
        r = b.ballPressedData;
        e(d, r.resourceType || f.resourceType, r.path || f.path, function (b, d) {
            a.loadSlidBallTexturePressed(b, d)
        });
        f = b.ballDisabledData;
        e(d, f.resourceType, f.path, function (b, d) {
            a.loadSlidBallTextureDisabled(b, d)
        });
        b = b.progressBarData;
        e(d, b.resourceType, b.path, function (b, d) {
            a.loadProgressBarTexture(b, d)
        })
    };
    d.TextFieldAttributes = function (a, b, d) {
        var e = b.placeHolder;
        e && a.setPlaceHolder(e);
        a.setString(b.text || "");
        (e = b.fontSize) && a.setFontSize(e);
        e = b.fontName;
        null != e && (cc.sys.isNative ? f.test(e) ? a.setFontName(cc.path.join(cc.loader.resPath, d, e)) : a.setFontName(e) : a.setFontName(e.replace(f, "")));
        d = b.touchSizeWidth;
        e = b.touchSizeHeight;
        null != d && null != e && a.setTouchSize(d, e);
        d = b.maxLengthEnable;
        a.setMaxLengthEnabled(d);
        d && a.setMaxLength(b.maxLength);
        d = b.passwordEnable;
        a.setPasswordEnabled(d);
        d && a.setPasswordStyleText(b.passwordStyleText);
        d = b.areaWidth;
        e = b.areaHeight;
        d && e && (d = cc.size(d, e), a.setTextAreaSize(d));
        (d = b.hAlignment) && a.setTextHorizontalAlignment(d);
        (d = b.vAlignment) && a.setTextVerticalAlignment(d);
        d = b.colorR;
        e = b.colorG;
        b = b.colorB;
        void 0 !== d && void 0 !== e && void 0 !== b && a.setTextColor(cc.color(d, e, b))
    };
    [{name: "Panel", object: ccui.Layout, handle: d.LayoutAttributes}, {
        name: "Button",
        object: ccui.Button,
        handle: d.ButtonAttributes
    }, {name: "CheckBox", object: ccui.CheckBox, handle: d.CheckBoxAttributes}, {
        name: "ImageView",
        object: ccui.ImageView,
        handle: d.ImageViewAttributes
    },
        {name: "LabelAtlas", object: ccui.TextAtlas, handle: d.TextAtlasAttributes}, {
        name: "LabelBMFont",
        object: ccui.TextBMFont,
        handle: d.TextBMFontAttributes
    }, {name: "Label", object: ccui.Text, handle: d.TextAttributes}, {
        name: "ListView",
        object: ccui.ListView,
        handle: d.ListViewAttributes
    }, {name: "LoadingBar", object: ccui.LoadingBar, handle: d.LoadingBarAttributes}, {
        name: "PageView",
        object: ccui.PageView,
        handle: d.PageViewAttributes
    }, {name: "ScrollView", object: ccui.ScrollView, handle: d.ScrollViewAttributes}, {
        name: "Slider", object: ccui.Slider,
        handle: d.SliderAttributes
    }, {name: "TextField", object: ccui.TextField, handle: d.TextFieldAttributes}].forEach(function (a) {
        d.registerParser(a.name, function (b, e) {
            var f = new a.object, r = b.options;
            d.generalAttributes(f, r);
            a.handle(f, r, e);
            d.colorAttributes(f, r);
            d.anchorPointAttributes(f, r);
            d.parseChild.call(this, f, b, e);
            return f
        })
    });
    a.registerParser("ccui", "*", d)
})(ccs._load, ccs._parser);
(function (a, b) {
    var d = new (b.extend({
        getNodeJson: function (a) {
            return a.action
        }, parseNode: function (a, b, d) {
            if (!a)return null;
            var h = this, n = new ccs.ActionTimeline;
            n.setDuration(a.duration);
            n.setTimeSpeed(a.speed || 1);
            a.timelines.forEach(function (a) {
                var d = h.parsers[a.frameType], e;
                d ? e = d.call(h, a, b) : cc.log("parser does not exist : %s", a.frameType);
                e && n.addTimeline(e);
                "ColorFrame" === a.frameType && n.addTimeline(h.parsers.AlphaFrame.call(h, a, b))
            });
            return n
        }
    }));
    [{
        name: "PositionFrame", handle: function (a) {
            var b = new ccs.PositionFrame;
            b.setPosition(cc.p(a.x, a.y));
            return b
        }
    }, {
        name: "VisibleFrame", handle: function (a) {
            var b = new ccs.VisibleFrame;
            b.setVisible(a.value);
            return b
        }
    }, {
        name: "ScaleFrame", handle: function (a) {
            var b = new ccs.ScaleFrame, d = a.y;
            b.setScaleX(a.x);
            b.setScaleY(d);
            return b
        }
    }, {
        name: "RotationFrame", handle: function (a) {
            var b = new ccs.RotationFrame;
            b.setRotation(a.rotation);
            return b
        }
    }, {
        name: "SkewFrame", handle: function (a) {
            var b = new ccs.SkewFrame, d = a.y;
            b.setSkewX(a.x);
            b.setSkewY(d);
            return b
        }
    }, {
        name: "RotationSkewFrame", handle: function (a) {
            var b =
                new ccs.RotationSkewFrame, d = a.y;
            b.setSkewX(a.x);
            b.setSkewY(d);
            return b
        }
    }, {
        name: "AnchorFrame", handle: function (a) {
            var b = new ccs.AnchorPointFrame;
            b.setAnchorPoint(cc.p(a.x, a.y));
            return b
        }
    }, {
        name: "InnerActionFrame", handle: function (a) {
            var b = new ccs.InnerActionFrame, d = a.startFrame;
            b.setInnerActionType(a.innerActionType);
            b.setStartFrameIndex(d);
            return b
        }
    }, {
        name: "ColorFrame", handle: function (a) {
            var b = new ccs.ColorFrame;
            b.setColor(cc.color(a.red, a.green, a.blue));
            (new ccs.AlphaFrame).setAlpha(a.alpha);
            return b
        }
    },
        {
            name: "AlphaFrame", handle: function (a) {
            var b = new ccs.AlphaFrame;
            b.setAlpha(a.alpha);
            return b
        }
        }, {
        name: "TextureFrame", handle: function (a) {
            var b = new ccs.TextureFrame;
            a = a.value;
            if (null != a) {
                var d = a;
                null == cc.spriteFrameCache.getSpriteFrame(d) && (d = ccs.csLoader.getJsonPath() + a);
                b.setTextureName(d)
            }
            return b
        }
    }, {
        name: "EventFrame", handle: function (a) {
            var b = new ccs.EventFrame;
            a = a.value;
            null != a && b.setEvent(a);
            return b
        }
    }, {
        name: "ZOrderFrame", handle: function (a) {
            var b = new ccs.ZOrderFrame;
            b.setZOrder(a.value);
            return b
        }
    }].forEach(function (a) {
        d.registerParser(a.name,
            function (b, d) {
                var h = new ccs.Timeline;
                h.setActionTag(b.actionTag);
                var n = b.frames;
                n && n.length && n.forEach(function (b) {
                    var d = a.handle(b);
                    d.setFrameIndex(b.frameIndex);
                    d.setTween(b.tween);
                    h.addFrame(d)
                });
                return h
            })
    });
    a.registerParser("action", "0.*", d);
    a.registerParser("action", "1.*", d)
})(ccs._load, ccs._parser);
(function (a, b) {
    var d = new (b.extend({
        getNodeJson: function (a) {
            return a.Content.Content.Animation
        }, parseNode: function (a, b, d) {
            if (!a)return null;
            var e = this, p = new ccs.ActionTimeline;
            p.setDuration(a.Duration);
            p.setTimeSpeed(a.Speed || 1);
            a.Timelines.forEach(function (a) {
                var d = e.parsers[a.Property], f;
                d ? f = d.call(e, a, b) : cc.log("parser does not exist : %s", a.Property);
                f && p.addTimeline(f)
            });
            return p
        }, deferred: function (a, b, d, e) {
            b = (a = a.Content.Content.AnimationList) ? a.length : 0;
            for (e = 0; e < b; e++) {
                var p = a[e], r = {
                    name: null,
                    startIndex: null, endIndex: null
                };
                r.name = p.Name;
                r.startIndex = p.StartIndex;
                r.endIndex = p.EndIndex;
                d.addAnimationInfo(r)
            }
        }
    })), e = function (a, b) {
        a.setTweenType(b.Type);
        var d = b.Points, e = [];
        d && (d.forEach(function (a) {
            e.push(a.X);
            e.push(a.Y)
        }), a.setEasingParams(e))
    };
    [{
        name: "Position", handle: function (a) {
            var b = new ccs.PositionFrame;
            b.setPosition(cc.p(a.X, a.Y));
            return b
        }
    }, {
        name: "VisibleForFrame", handle: function (a) {
            var b = new ccs.VisibleFrame;
            b.setVisible(a.Value);
            return b
        }
    }, {
        name: "Scale", handle: function (a) {
            var b =
                new ccs.ScaleFrame, d = a.Y;
            b.setScaleX(a.X);
            b.setScaleY(d);
            return b
        }
    }, {
        name: "Rotation", handle: function (a) {
            var b = new ccs.RotationFrame;
            b.setRotation(a.Rotation || a.Value || 0);
            return b
        }
    }, {
        name: "Skew", handle: function (a) {
            var b = new ccs.SkewFrame, d = a.Y;
            b.setSkewX(a.X);
            b.setSkewY(d);
            return b
        }
    }, {
        name: "RotationSkew", handle: function (a) {
            var b = new ccs.RotationSkewFrame, d = a.Y;
            b.setSkewX(a.X);
            b.setSkewY(d);
            return b
        }
    }, {
        name: "Anchor", handle: function (a) {
            var b = new ccs.AnchorPointFrame;
            b.setAnchorPoint(cc.p(a.X, a.Y));
            return b
        }
    },
        {
            name: "AnchorPoint", handle: function (a) {
            var b = new ccs.AnchorPointFrame;
            b.setAnchorPoint(cc.p(a.X, a.Y));
            return b
        }
        }, {
        name: "InnerAction", handle: function (a) {
            var b = new ccs.InnerActionFrame, d = a.StartFrame;
            b.setInnerActionType(a.InnerActionType);
            b.setStartFrameIndex(d);
            return b
        }
    }, {
        name: "CColor", handle: function (a) {
            var b = new ccs.ColorFrame;
            (a = a.Color) || (a = {});
            a.R = void 0 === a.R ? 255 : a.R;
            a.G = void 0 === a.G ? 255 : a.G;
            a.B = void 0 === a.B ? 255 : a.B;
            b.setColor(cc.color(a.R, a.G, a.B));
            return b
        }
    }, {
        name: "Alpha", handle: function (a) {
            var b =
                new ccs.AlphaFrame;
            b.setAlpha(a.Value);
            return b
        }
    }, {
        name: "FileData", handle: function (a, b) {
            var d, e, p, r;
            d = new ccs.TextureFrame;
            e = a.TextureFile;
            null != e && (p = e.Plist, e = e.Path, r = cc.spriteFrameCache.getSpriteFrame(e), !r && p && (cc.loader.getRes(b + p) ? (cc.spriteFrameCache.addSpriteFrames(b + p), r = cc.spriteFrameCache.getSpriteFrame(e)) : cc.log("%s need to be preloaded", b + p)), null == r && (e = b + e), d.setTextureName(e));
            return d
        }
    }, {
        name: "FrameEvent", handle: function (a) {
            var b = new ccs.EventFrame;
            a = a.Value;
            null != a && b.setEvent(a);
            return b
        }
    }, {
        name: "ZOrder", handle: function (a) {
            var b = new ccs.ZOrderFrame;
            b.setZOrder(a.Value);
            return b
        }
    }, {
        name: "ActionValue", handle: function (a) {
            var b = new ccs.InnerActionFrame, d = a.InnerActionType, e = a.CurrentAniamtionName, p = a.SingleFrameIndex;
            a = a.FrameIndex;
            void 0 !== a && b.setFrameIndex(a);
            b.setInnerActionType(ccs.InnerActionType[d]);
            b.setSingleFrameIndex(p);
            b.setEnterWithName(!0);
            e && b.setAnimationName(e);
            return b
        }
    }, {
        name: "BlendFunc", handle: function (a) {
            var b = new ccs.BlendFuncFrame;
            (a = a.BlendFunc) && void 0 !==
            a.Src && void 0 !== a.Dst && b.setBlendFunc(new cc.BlendFunc(a.Src, a.Dst));
            return b
        }
    }].forEach(function (a) {
        d.registerParser(a.name, function (b, d) {
            var n = new ccs.Timeline;
            n.setActionTag(b.ActionTag);
            var p = b.Frames;
            p && p.length && p.forEach(function (b) {
                var g = a.handle(b, d);
                g.setFrameIndex(b.FrameIndex);
                g.setTween(null != b.Tween ? b.Tween : !0);
                (b = b.EasingData) && e(g, b);
                n.addFrame(g)
            });
            return n
        })
    });
    a.registerParser("action", "2.*", d);
    a.registerParser("action", "*", d)
})(ccs._load, ccs._parser);
(function (a, b) {
    var d = {}, e = new (b.extend({
        getNodeJson: function (a) {
            return a.nodeTree
        }, addSpriteFrame: function (a, b, e) {
            if (a && b && a.length === b.length)for (var f = 0; f < a.length; f++) {
                var r = e + a[f];
                cc.loader.getRes(r) || d[r] ? d[r] = !0 : cc.log("%s need to be preloaded", r);
                cc.spriteFrameCache.addSpriteFrames(r, e + b[f])
            }
        }, pretreatment: function (a, b, d) {
            this.addSpriteFrame(a.textures, a.texturesPng, b)
        }
    }));
    e.generalAttributes = function (a, b) {
        var d = null != b.width ? b.width : 0, e = null != b.height ? b.height : 0, f = null != b.x ? b.x : 0, s = null !=
        b.y ? b.y : 0, t = null != b.scaleX ? b.scaleX : 1, v = null != b.scaleY ? b.scaleY : 1, u = null != b.rotation ? b.rotation : 0, x = null != b.rotationSkewX ? b.rotationSkewX : 0, w = null != b.rotationSkewY ? b.rotationSkewY : 0, y = null != b.skewX ? b.skewX : 0, A = null != b.skewY ? b.skewY : 0, D = null != b.anchorPointX ? b.anchorPointX : 0.5, G = null != b.anchorPointY ? b.anchorPointY : 0.5, B = null != b.opacity ? b.opacity : 255, C = null != b.colorR ? b.colorR : 255, E = null != b.colorG ? b.colorG : 255, I = null != b.colorB ? b.colorB : 255, L = null != b.colorR ? b.colorR : 0, J = null != b.tag ? b.tag : 0, Q = null != b.actionTag ?
            b.actionTag : 0, M = null != b.visible ? b.visible : !0;
        0 == f && 0 == s || a.setPosition(cc.p(f, s));
        1 != t && a.setScaleX(t);
        1 != v && a.setScaleY(v);
        0 != u && a.setRotation(u);
        0 != x && a.setRotationX(x);
        0 != w && a.setRotationY(w);
        0 != y && a.setSkewX(y);
        0 != A && a.setSkewY(A);
        0.5 == D && 0.5 == G || a.setAnchorPoint(cc.p(D, G));
        0 == d && 0 == e || a.setContentSize(cc.size(d, e));
        0 != L && a.setLocalZOrder(L);
        !0 != M && a.setVisible(M);
        255 != B && a.setOpacity(B);
        255 == C && 255 == E && 255 == I || a.setColor(cc.color(C, E, I));
        a.setTag(J);
        a.setUserObject(new ccs.ActionTimelineData(Q))
    };
    e.parseComponent = function (a, b) {
        if (b)for (var d = 0; d < b.length; ++d) {
            var e = this.loadComponent(b[d]);
            e && a.addComponent(e)
        }
    };
    e.parseChild = function (a, b, d, e) {
        a = d.children;
        for (d = 0; d < a.length; d++) {
            var f = this.parseNode(a[d], e);
            if (f)if (b instanceof ccui.PageView)f instanceof ccui.Layout && b.addPage(f); else if (b instanceof ccui.ListView)f instanceof ccui.Widget && b.pushBackCustomItem(f); else {
                if (!(b instanceof ccui.Layout) && f instanceof ccui.Widget) {
                    if (f.getPositionType() === ccui.Widget.POSITION_PERCENT) {
                        var s = f.getPositionPercent(),
                            t = b.getAnchorPoint();
                        f.setPositionPercent(cc.p(s.x + t.x, s.y + t.y))
                    }
                    s = b.getAnchorPointInPoints();
                    f.setPosition(cc.p(f.getPositionX() + s.x, f.getPositionY() + s.y))
                }
                b.addChild(f)
            }
        }
    };
    e.initNode = function (a) {
        var b = new cc.Node;
        this.generalAttributes(b, a);
        return b
    };
    e.initSubGraph = function (a) {
        var b = a.fileName, b = b && "" !== b ? this.createNode(b) : new ccs.Node;
        this.generalAttributes(b, a);
        return b
    };
    e.initSprite = function (a, b) {
        var d = a.fileName;
        if (null != d) {
            var e = cc.spriteFrameCache.getSpriteFrame(d), d = e ? ccs.Sprite.createWithSpriteFrame(e) :
                new ccs.Sprite(b + d);
            d || (d = new cc.Sprite, cc.log("filePath is empty. Create a sprite with no texture"))
        } else d = new ccs.Sprite;
        this.generalAttributes(d, a);
        var e = a.flipX, f = a.flipY;
        !1 != e && d.setFlippedX(e);
        !1 != f && d.setFlippedY(f);
        return d
    };
    e.initParticle = function (a, b) {
        var d = a.tmxFile, e = new cc.ParticleSystemQuad(a.plistFile);
        e.setTotalParticles(d);
        this.generalAttributes(e, a);
        return e
    };
    e.initTMXTiledMap = function (a, b) {
        var d = a.tmxFile, e = a.tmxString, f = a.resourcePath, s = null;
        d && "" !== d ? s = new cc.TMXTiledMap(d) :
        e && "" !== e && f && "" !== f && (s = new cc.TMXTiledMap(e, f));
        return s
    };
    var f = a.getParser("ccui")["*"];
    e.initWidget = function (a, b) {
        var d = a.classname, e = f.parsers[d];
        if (!e)return cc.log("%s parser is not found", d);
        if (d = e.call(f, a, b)) {
            var e = a.rotationSkewX, r = a.rotationSkewY, s = a.skewX, t = a.skewY;
            0 != e && d.setRotationX(e);
            0 != r && d.setRotationY(r);
            0 != s && d.setSkewX(s);
            0 != t && d.setSkewY(t);
            d.setUserObject(new ccs.ActionTimelineData(a.actionTag))
        }
        return d
    };
    [{name: "Node", handle: e.initNode}, {name: "SubGraph", handle: e.initSubGraph},
        {name: "Sprite", handle: e.initSprite}, {name: "Particle", handle: e.initParticle}, {
        name: "TMXTiledMap",
        handle: e.initTMXTiledMap
    }, {name: "Widget", handle: e.initWidget}, {name: "Panel", handle: e.initWidget}, {
        name: "Button",
        handle: e.initWidget
    }, {name: "CheckBox", handle: e.initWidget}, {name: "ImageView", handle: e.initWidget}, {
        name: "LabelAtlas",
        handle: e.initWidget
    }, {name: "LabelBMFont", handle: e.initWidget}, {name: "Label", handle: e.initWidget}, {
        name: "ListView",
        handle: e.initWidget
    }, {name: "LoadingBar", handle: e.initWidget}, {
        name: "PageView",
        handle: e.initWidget
    }, {name: "ScrollView", handle: e.initWidget}, {name: "Slider", handle: e.initWidget}, {
        name: "TextField",
        handle: e.initWidget
    }].forEach(function (a) {
        e.registerParser(a.name, function (b, d, e) {
            var f = a.handle.call(this, b.options);
            this.parseComponent(f, b.components);
            this.parseChild(d, f, b, e);
            return f
        })
    });
    a.registerParser("timeline", "0.*", e);
    a.registerParser("timeline", "1.*", e)
})(ccs._load, ccs._parser);
(function (a, b) {
    var d = new (b.extend({
        parse: function (a, b, d) {
            d = void 0 !== d ? d : this._dirname(a);
            this.pretreatment(b, d, a);
            var e = this.parseNode(this.getNodeJson(b), d);
            this.deferred(b, d, e, a);
            return e
        }, getNodeJson: function (a) {
            a = a.Content;
            return a.ObjectData ? a.ObjectData : a.Content.ObjectData
        }, getClass: function (a) {
            return a.ctype
        }
    })), e = function (a, b) {
        return void 0 === a ? b : a
    };
    d.generalAttributes = function (a, b) {
        null != b.Name && a.setName(b.Name);
        var d = b.Position;
        null == d || null == d.X && null == d.Y || a.setPosition(cc.p(d.X || 0,
            d.Y || 0));
        d = b.Scale;
        null != d && (null != d.ScaleX && a.setScaleX(d.ScaleX), null != d.ScaleY && a.setScaleY(d.ScaleY));
        d = b.RotationSkewX;
        null != d && a.setRotationX(d);
        d = b.RotationSkewY;
        null != b.RotationSkewY && a.setRotationY(d);
        d = b.AnchorPoint;
        null != d && (null == d.ScaleX && (d.ScaleX = 0), null == d.ScaleY && (d.ScaleY = 0), 0.5 == d.ScaleX && 0.5 == d.ScaleY || a.setAnchorPoint(cc.p(d.ScaleX, d.ScaleY)));
        null != b.ZOrder && a.setLocalZOrder(b.ZOrder);
        d = e(b.VisibleForFrame, !0);
        a.setVisible(d);
        (d = b.Size) && v(a, d);
        null != b.Alpha && a.setOpacity(b.Alpha);
        a.setTag(b.Tag || 0);
        var d = b.ActionTag || 0, f = new ccs.ComExtensionData, h = b.UserData;
        void 0 !== h && f.setCustomProperty(h);
        f.setActionTag(d);
        a.getComponent("ComExtensionData") && a.removeComponent("ComExtensionData");
        a.addComponent(f);
        a.setCascadeColorEnabled(!0);
        a.setCascadeOpacityEnabled(!0);
        g(a, b)
    };
    d.parseChild = function (a, b, d) {
        if (a && b)for (var e = 0; e < b.length; e++) {
            var f = this.parseNode(b[e], d);
            if (f)if (a instanceof ccui.PageView)f instanceof ccui.Layout && a.addPage(f); else if (a instanceof ccui.ListView)f instanceof ccui.Widget && a.pushBackCustomItem(f); else {
                if (!(a instanceof ccui.Layout) && f instanceof ccui.Widget && f.getPositionType() === ccui.Widget.POSITION_PERCENT) {
                    var g = f.getPositionPercent(), h = a.getAnchorPoint();
                    f.setPositionPercent(cc.p(g.x + h.x, g.y + h.y))
                }
                a.addChild(f)
            }
        }
    };
    d.initSingleNode = function (a) {
        var b = new cc.Node;
        this.generalAttributes(b, a);
        a = a.CColor;
        null != a && b.setColor(t(a));
        return b
    };
    d.initSprite = function (a, b) {
        var d = new cc.Sprite;
        s(a.FileData, b, function (a, b) {
            if (0 === b)d.setTexture(a); else if (1 === b) {
                var e =
                    cc.spriteFrameCache.getSpriteFrame(a);
                e && d.setSpriteFrame(e)
            }
        });
        var e = a.BlendFunc;
        if (a.BlendFunc) {
            var f = cc.BlendFunc.ALPHA_PREMULTIPLIED;
            void 0 !== e.Src && (f.src = e.Src);
            void 0 !== e.Dst && (f.dst = e.Dst);
            d.setBlendFunc(f)
        }
        a.FlipX && d.setFlippedX(!0);
        a.FlipY && d.setFlippedY(!0);
        this.generalAttributes(d, a);
        e = a.CColor;
        null != e && d.setColor(t(e));
        return d
    };
    d.initParticle = function (a, b) {
        var d, e = this;
        s(a.FileData, b, function (b, f) {
            cc.loader.getRes(b) || cc.log("%s need to be preloaded", b);
            d = new cc.ParticleSystem(b);
            e.generalAttributes(d,
                a);
            d.setPositionType(cc.ParticleSystem.TYPE_GROUPED);
            !cc.sys.isNative && d.setDrawMode(cc.ParticleSystem.TEXTURE_MODE);
            var g = a.BlendFunc;
            if (a.BlendFunc) {
                var h = cc.BlendFunc.ALPHA_PREMULTIPLIED;
                void 0 !== g.Src && (h.src = g.Src);
                void 0 !== g.Dst && (h.dst = g.Dst);
                d.setBlendFunc(h)
            }
        });
        return d
    };
    d.widgetAttributes = function (a, b, d) {
        a.setCascadeColorEnabled(!0);
        a.setCascadeOpacityEnabled(!0);
        a.setUnifySizeEnabled(!1);
        a.ignoreContentAdaptWithSize(!1);
        !d && v(a, b.Size);
        (d = b.Name) && a.setName(d);
        d = b.ActionTag || 0;
        a.setActionTag(d);
        var h = new ccs.ComExtensionData, n = b.UserData;
        void 0 !== n && h.setCustomProperty(n);
        h.setActionTag(d);
        a.getComponent("ComExtensionData") && a.removeComponent("ComExtensionData");
        a.addComponent(h);
        (d = b.RotationSkewX) && a.setRotationX(d);
        (d = b.RotationSkewY) && a.setRotationY(d);
        b.FlipX && a.setFlippedX(!0);
        b.FlipY && a.setFlippedY(!0);
        d = b.zOrder;
        null != d && a.setLocalZOrder(d);
        d = e(b.VisibleForFrame, !0);
        a.setVisible(d);
        d = b.Alpha;
        null != d && a.setOpacity(d);
        a.setTag(b.Tag || 0);
        a.setTouchEnabled(b.TouchEnable || !1);
        d = b.CallBackType;
        null != d && a.setCallbackType(d);
        (d = b.CallBackName) && a.setCallbackName(d);
        d = b.Position;
        null != d && a.setPosition(d.X || 0, d.Y || 0);
        h = b.Scale;
        null != h && (d = e(h.ScaleX, 1), h = e(h.ScaleY, 1), a.setScaleX(d), a.setScaleY(h));
        d = b.AnchorPoint;
        null != d && a.setAnchorPoint(d.ScaleX || 0, d.ScaleY || 0);
        d = b.CColor;
        null != d && a.setColor(t(d));
        g(a, b);
        f(a, b)
    };
    var f = function (a, b) {
        var d = b.CallBackType, e = b.CallBackName, f = function (b) {
            if ("function" === typeof a[e])a[e](b)
        };
        "Click" === d ? a.addClickEventListener(f) : "Touch" === d ? a.addTouchEventListener(f) :
        "Event" === d && a.addCCSEventListener(f)
    }, g = function (a, b) {
        var d = ccui.LayoutComponent.bindLayoutComponent(a);
        if (d) {
            var e = b.PositionPercentXEnable || b.PositionPercentXEnabled || !1, f = b.PositionPercentYEnable || b.PositionPercentYEnabled || !1, g = 0, h = 0, n = b.PrePosition;
            null != n && (g = n.X || 0, h = n.Y || 0);
            var p = b.PercentWidthEnable || b.PercentWidthEnabled || !1, r = b.PercentHeightEnable || b.PercentHeightEnabled || !1, s = 0, t = 0, v = b.PreSize;
            null != n && (s = v.X || 0, t = v.Y || 0);
            var Q = b.StretchWidthEnable || !1, M = b.StretchHeightEnable || !1, K = b.HorizontalEdge,
                n = b.VerticalEdge, v = b.LeftMargin || 0, H = b.RightMargin || 0, P = b.TopMargin || 0, U = b.BottomMargin || 0;
            d.setPositionPercentXEnabled(e);
            d.setPositionPercentYEnabled(f);
            d.setPositionPercentX(g);
            d.setPositionPercentY(h);
            d.setPercentWidthEnabled(p);
            d.setPercentHeightEnabled(r);
            d.setPercentWidth(s);
            d.setPercentHeight(t);
            d.setPercentWidthEnabled(p || r);
            d.setStretchWidthEnabled(Q);
            d.setStretchHeightEnabled(M);
            e = ccui.LayoutComponent.horizontalEdge.NONE;
            "LeftEdge" === K ? e = ccui.LayoutComponent.horizontalEdge.LEFT : "RightEdge" ===
            K ? e = ccui.LayoutComponent.horizontalEdge.RIGHT : "BothEdge" === K && (e = ccui.LayoutComponent.horizontalEdge.CENTER);
            d.setHorizontalEdge(e);
            e = ccui.LayoutComponent.verticalEdge.NONE;
            "TopEdge" === n ? e = ccui.LayoutComponent.verticalEdge.TOP : "BottomEdge" === n ? e = ccui.LayoutComponent.verticalEdge.BOTTOM : "BothEdge" === n && (e = ccui.LayoutComponent.verticalEdge.CENTER);
            d.setVerticalEdge(e);
            d.setTopMargin(P);
            d.setBottomMargin(U);
            d.setLeftMargin(v);
            d.setRightMargin(H);
            d.setVerticalEdge(e);
            d.setTopMargin(P);
            d.setBottomMargin(U);
            d.setLeftMargin(v);
            d.setRightMargin(H)
        }
    }, h = function (a, b, d, e) {
        2 === a.getBackGroundColorType() ? (d = d || {}, e = e || {}, a.setBackGroundColor(t(d), t(e))) : (b = b || {}, a.setBackGroundColor(t(b)))
    }, n = function (a, b) {
        a.setBackGroundColorVector(cc.p(b.ScaleX || 0, b.ScaleY || 0))
    };
    d.initPanel = function (a, b) {
        var d = new ccui.Layout;
        this.widgetAttributes(d, a);
        var f = a.ClipAble || !1;
        null != f && d.setClippingEnabled(f);
        f = e(a.ComboBoxIndex, 0);
        d.setBackGroundColorType(f);
        f = e(a.BackColorAlpha, 255);
        null != f && d.setBackGroundColorOpacity(f);
        f = a.Scale9Enable;
        null != f && d.setBackGroundImageScale9Enabled(f);
        var g = e(a.Alpha, 255);
        d.setOpacity(g);
        s(a.FileData, b, function (a, b) {
            d.setBackGroundImage(a, b)
        });
        f ? (d.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)), v(d, a.Size)) : d.isIgnoreContentAdaptWithSize() || v(d, a.Size);
        h(d, a.SingleColor, a.FirstColor, a.EndColor);
        n(d, a.ColorVector);
        return d
    };
    d.initText = function (a, b) {
        var d = new ccui.Text, f = a.TouchScaleChangeAble;
        null != f && d.setTouchScaleChangeEnabled(f);
        f = a.LabelText;
        null != f && d.setString(f);
        f = a.FontSize;
        null != f && d.setFontSize(f);
        f = a.FontName;
        null != f && d.setFontName(f);
        var f = a.AreaWidth, g = a.areaHeight;
        f && g && d.setTextAreaSize(cc.size(f, g));
        f = a.HorizontalAlignmentType || "HT_Left";
        switch (f) {
            case "HT_Right":
                f = 2;
                break;
            case "HT_Center":
                f = 1;
                break;
            default:
                f = 0
        }
        d.setTextHorizontalAlignment(f);
        f = a.VerticalAlignmentType || "VT_Top";
        switch (f) {
            case "VT_Bottom":
                f = 2;
                break;
            case "VT_Center":
                f = 1;
                break;
            default:
                f = 0
        }
        d.setTextVerticalAlignment(f);
        f = a.FontResource;
        null != f &&
        (f = f.Path, null != f && (f = cc.sys.isNative ? cc.path.join(cc.loader.resPath, b, f) : (f = f.match(/([^\/]+)\.(\S+)/)) ? f[1] : "", d.setFontName(f)));
        a.OutlineEnabled && a.OutlineColor && d.enableOutline && d.enableOutline(t(a.OutlineColor), e(a.OutlineSize, 1));
        a.ShadowEnabled && a.ShadowColor && d.enableShadow && d.enableShadow(t(a.ShadowColor), cc.size(e(a.ShadowOffsetX, 2), e(a.ShadowOffsetY, -2)), a.ShadowBlurRadius || 0);
        f = a.IsCustomSize;
        null != f && d.ignoreContentAdaptWithSize(!f);
        d.setUnifySizeEnabled(!1);
        f = a.CColor;
        a.CColor = null;
        d.setTextColor(t(f));
        this.widgetAttributes(d, a, d.isIgnoreContentAdaptWithSize());
        a.CColor = f;
        return d
    };
    d.initButton = function (a, b) {
        var d = new ccui.Button;
        s(a.NormalFileData, b, function (a, b) {
            d.loadTextureNormal(a, b)
        });
        s(a.PressedFileData, b, function (a, b) {
            d.loadTexturePressed(a, b)
        });
        s(a.DisabledFileData, b, function (a, b) {
            d.loadTextureDisabled(a, b)
        });
        var f = e(a.Scale9Enable, !1);
        f && d.setScale9Enabled(f);
        var g = a.ButtonText;
        null != g && d.setTitleText(g);
        g = a.FontSize;
        null != g && d.setTitleFontSize(g);
        g = a.FontName;
        null !=
        g && d.setTitleFontName(g);
        g = a.TextColor;
        null != g && d.setTitleColor(t(g));
        g = e(a.DisplayState, !0);
        d.setBright(g);
        d.setEnabled(g);
        g = a.FontResource;
        null != g && (g = g.Path, null != g && (g = cc.sys.isNative ? cc.path.join(cc.loader.resPath, b, g) : (g = g.match(/([^\/]+)\.(\S+)/)) ? g[1] : "", d.setTitleFontName(g)));
        (g = d.getTitleRenderer()) && a.ShadowEnabled && a.ShadowColor && g.enableShadow && g.enableShadow(t(a.ShadowColor), cc.size(e(a.ShadowOffsetX, 2), e(a.ShadowOffsetY, -2)), a.ShadowBlurRadius || 0);
        g && a.OutlineEnabled && a.OutlineColor &&
        g.enableStroke && g.enableStroke(t(a.OutlineColor), e(a.OutlineSize, 1));
        this.widgetAttributes(d, a);
        f && (d.setUnifySizeEnabled(!1), d.ignoreContentAdaptWithSize(!1), f = cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0), d.setCapInsets(f));
        v(d, a.Size);
        return d
    };
    d.initCheckBox = function (a, b) {
        var d = new ccui.CheckBox;
        this.widgetAttributes(d, a);
        [{name: "NormalBackFileData", handle: d.loadTextureBackGround}, {
            name: "PressedBackFileData",
            handle: d.loadTextureBackGroundSelected
        }, {
            name: "NodeNormalFileData",
            handle: d.loadTextureFrontCross
        }, {name: "DisableBackFileData", handle: d.loadTextureBackGroundDisabled}, {
            name: "NodeDisableFileData",
            handle: d.loadTextureFrontCrossDisabled
        }].forEach(function (e) {
            s(a[e.name], b, function (a, b) {
                e.handle.call(d, a, b)
            })
        });
        var f = e(a.CheckedState, !1);
        d.setSelected(f);
        f = e(a.DisplayState, !0);
        d.setBright(f);
        d.setEnabled(f);
        return d
    };
    d.initScrollView = function (a, b) {
        var d = new ccui.ScrollView;
        this.widgetAttributes(d, a);
        s(a.FileData, b, function (a, b) {
            d.setBackGroundImage(a, b)
        });
        d.setClippingEnabled(a.ClipAble || !1);
        var f = e(a.ComboBoxIndex, 0);
        d.setBackGroundColorType(f);
        f = a.BackColorAlpha;
        null != f && d.setBackGroundColorOpacity(f);
        a.Scale9Enable ? (d.setBackGroundImageScale9Enabled(!0), d.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)), v(d, a.Size)) : d.isIgnoreContentAdaptWithSize() || v(d, a.Size);
        h(d, a.SingleColor, a.FirstColor, a.EndColor);
        n(d, a.ColorVector);
        f = a.InnerNodeSize;
        f = cc.size(f.Width || 0, f.Height || 0);
        d.setInnerContainerSize(f);
        f = 0;
        "Vertical" ===
        a.ScrollDirectionType && (f = 1);
        "Horizontal" === a.ScrollDirectionType && (f = 2);
        "Vertical_Horizontal" === a.ScrollDirectionType && (f = 3);
        d.setDirection(f);
        f = e(a.IsBounceEnabled, !1);
        d.setBounceEnabled(f);
        return d
    };
    d.initImageView = function (a, b) {
        var d = new ccui.ImageView;
        s(a.FileData, b, function (a, b) {
            d.loadTexture(a, b)
        });
        s(a.ImageFileData, b, function (a, b) {
            d.loadTexture(a, b)
        });
        a.Scale9Enable ? (d.setScale9Enabled(!0), d.setUnifySizeEnabled(!1), d.ignoreContentAdaptWithSize(!1), d.setCapInsets(cc.rect(a.Scale9OriginX || 0,
            a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0))) : v(d, a.Size);
        this.widgetAttributes(d, a);
        return d
    };
    d.initLoadingBar = function (a, b) {
        var d = new ccui.LoadingBar;
        this.widgetAttributes(d, a);
        s(a.ImageFileData, b, function (a, b) {
            d.loadTexture(a, b)
        });
        d.setDirection("Right_To_Left" === a.ProgressType ? 1 : 0);
        var f = e(a.ProgressInfo, 80);
        null != f && d.setPercent(f);
        return d
    };
    d.initSlider = function (a, b) {
        var d = new ccui.Slider, f = cc.loader;
        this.widgetAttributes(d, a);
        [{name: "BackGroundData", handle: d.loadBarTexture}, {
            name: "BallNormalData",
            handle: d.loadSlidBallTextureNormal
        }, {name: "BallPressedData", handle: d.loadSlidBallTexturePressed}, {
            name: "BallDisabledData",
            handle: d.loadSlidBallTextureDisabled
        }, {name: "ProgressBarData", handle: d.loadProgressBarTexture}].forEach(function (e) {
            s(a[e.name], b, function (a, b) {
                0 !== b || f.getRes(a) || cc.log("%s need to be preloaded", a);
                e.handle.call(d, a, b)
            })
        });
        d.setPercent(a.PercentInfo || 0);
        var g = e(a.DisplayState, !0);
        d.setBright(g);
        d.setEnabled(g);
        return d
    };
    d.initPageView = function (a, b) {
        var d = new ccui.PageView;
        this.widgetAttributes(d,
            a);
        s(a.FileData, b, function (a, b) {
            d.setBackGroundImage(a, b)
        });
        d.setClippingEnabled(a.ClipAble || !1);
        a.Scale9Enable && (d.setBackGroundImageScale9Enabled(!0), d.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)));
        var f = e(a.ComboBoxIndex, 0);
        d.setBackGroundColorType(f);
        h(d, a.SingleColor, a.FirstColor, a.EndColor);
        n(d, a.ColorVector);
        f = a.BackColorAlpha;
        null != f && d.setBackGroundColorOpacity(f);
        v(d, a.Size);
        return d
    };
    d.initListView = function (a, b) {
        var d = new ccui.ListView;
        this.widgetAttributes(d, a);
        s(a.FileData, b, function (a, b) {
            d.setBackGroundImage(a, b)
        });
        d.setClippingEnabled(a.ClipAble || !1);
        var f = e(a.ComboBoxIndex, 0);
        d.setBackGroundColorType(f);
        f = e(a.BackColorAlpha, 255);
        a.Scale9Enable && (d.setBackGroundImageScale9Enabled(!0), d.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)));
        var g = e(a.DirectionType, ccui.ListView.DIR_HORIZONTAL), p = e(a.VerticalType, "Align_Left"), r = e(a.HorizontalType, "Align_Top");
        g ? "Vertical" ===
        g && (d.setDirection(ccui.ScrollView.DIR_VERTICAL), "" === r ? d.setGravity(ccui.ListView.GRAVITY_LEFT) : "Align_Right" === r ? d.setGravity(ccui.ListView.GRAVITY_RIGHT) : "Align_HorizontalCenter" === r && d.setGravity(ccui.ListView.GRAVITY_CENTER_HORIZONTAL)) : (d.setDirection(ccui.ScrollView.DIR_HORIZONTAL), "Align_Bottom" === p ? d.setGravity(ccui.ListView.GRAVITY_BOTTOM) : "Align_VerticalCenter" === p ? d.setGravity(ccui.ListView.GRAVITY_CENTER_VERTICAL) : d.setGravity(ccui.ListView.GRAVITY_TOP));
        g = e(a.IsBounceEnabled, !1);
        d.setBounceEnabled(g);
        d.setItemsMargin(a.ItemMargin || 0);
        g = a.InnerNodeSize;
        null != g && d.setInnerContainerSize(cc.size(g.Widget || 0, g.Height || 0));
        h(d, a.SingleColor, a.FirstColor, a.EndColor);
        n(d, a.ColorVector);
        null != f && d.setBackGroundColorOpacity(f);
        v(d, a.Size);
        return d
    };
    d.initTextAtlas = function (a, b) {
        var d = new ccui.TextAtlas, e = a.LabelText, f = a.CharWidth, g = a.CharHeight, h = a.StartChar;
        s(a.LabelAtlasFileImage_CNB, b, function (a, b) {
            cc.loader.getRes(a) || cc.log("%s need to be preloaded", a);
            0 === b && d.setProperty(e, a, f, g, h)
        });
        this.widgetAttributes(d,
            a);
        d.ignoreContentAdaptWithSize(!0);
        return d
    };
    d.initTextBMFont = function (a, b) {
        var d = new ccui.TextBMFont;
        this.widgetAttributes(d, a);
        d.setString(a.LabelText);
        s(a.LabelBMFontFile_CNB, b, function (a, b) {
            cc.loader.getRes(a) || cc.log("%s need to be pre loaded", a);
            d.setFntFile(a)
        });
        d.ignoreContentAdaptWithSize(!0);
        return d
    };
    d.initTextField = function (a, b) {
        var d = new ccui.TextField;
        a.PasswordEnable && (d.setPasswordEnabled(!0), d.setPasswordStyleText(a.PasswordStyleText || "*"));
        var e = a.PlaceHolderText;
        null != e && d.setPlaceHolder(e);
        e = a.FontSize;
        null != e && d.setFontSize(e);
        e = a.FontName;
        null != e && d.setFontName(e);
        a.MaxLengthEnable && (d.setMaxLengthEnabled(!0), d.setMaxLength(a.MaxLengthText || 0));
        this.widgetAttributes(d, a);
        e = a.LabelText;
        null != e && d.setString(e);
        e = a.FontResource;
        null != e && (e = e.Path, null != e && (e = cc.sys.isNative ? cc.path.join(cc.loader.resPath, b, e) : (e = e.match(/([^\/]+)\.(\S+)/)) ? e[1] : "", d.setFontName(e)));
        d.setUnifySizeEnabled(!1);
        d.ignoreContentAdaptWithSize(!1);
        e = a.CColor;
        null != e && d.setTextColor(t(e));
        d.isIgnoreContentAdaptWithSize() ||
        (v(d, a.Size), cc.sys.isNative && d.getVirtualRenderer().setLineBreakWithoutSpace(!0));
        return d
    };
    d.initSimpleAudio = function (a, b) {
        var d = new ccs.ComAudio;
        d.setLoop(a.Loop || !1);
        s(a.FileData, b, function (a, b) {
            d.setFile(a)
        })
    };
    d.initGameMap = function (a, b) {
        var e = null;
        s(a.FileData, b, function (b, f) {
            0 === f && (e = new cc.TMXTiledMap(b));
            d.generalAttributes(e, a)
        });
        return e
    };
    d.initProjectNode = function (a, b) {
        var e = a.FileData;
        if (null != e && e.Path) {
            e = b + e.Path;
            if (cc.loader.getRes(e)) {
                e = ccs.load(e, b);
                d.generalAttributes(e.node, a);
                if (e.action && e.node) {
                    e.action.tag = e.node.tag;
                    var f = a.InnerActionSpeed;
                    void 0 !== f && e.action.setTimeSpeed(f);
                    e.node.runAction(e.action);
                    e.action.gotoFrameAndPlay(0, !0)
                }
                return e.node
            }
            cc.log("%s need to be preloaded", e)
        }
    };
    var p = function (a) {
        return a ? (a = a.match(/([^\/]+)\.[^\/]+$/)) && a[1] ? a[1] : "" : ""
    };
    d.initArmature = function (a, b) {
        var e = new ccs.Armature, f = a.IsLoop, g = a.IsAutoPlay, h = a.CurrentAnimationName;
        s(a.FileData, b, function (a, b) {
            var d, n, r = cc.loader.getRes(a);
            r ? (d = r.config_file_path, n = r.config_png_path,
                d.forEach(function (a, b) {
                    n[b] && cc.spriteFrameCache.addSpriteFrames(a, n[b])
                })) : cc.log("%s need to be preloaded", a);
            ccs.armatureDataManager.addArmatureFileInfo(a);
            e.init(p(a));
            g ? e.getAnimation().play(h, -1, f) : (e.getAnimation().play(h), e.getAnimation().gotoAndPause(0))
        });
        delete a.AnchorPoint;
        delete a.Size;
        d.generalAttributes(e, a);
        e.setColor(t(a.CColor));
        return e
    };
    d.initBoneNode = function (a, b) {
        var e = new ccs.BoneNode, f = a.Length;
        void 0 !== f && e.setDebugDrawLength(f);
        (f = a.BlendFunc) && void 0 !== f.Src && void 0 !==
        f.Dst && e.setBlendFunc(new cc.BlendFunc(f.Src, f.Dst));
        d.generalAttributes(e, a);
        f = a.CColor;
        !f || void 0 === f.R && void 0 === f.G && void 0 === f.B || e.setColor(t(f));
        return e
    };
    d.initSkeletonNode = function (a) {
        var b = new ccs.SkeletonNode;
        d.generalAttributes(b, a);
        a = a.CColor;
        !a || void 0 === a.R && void 0 === a.G && void 0 === a.B || b.setColor(t(a));
        return b
    };
    var r = {}, s = function (a, b, d) {
        if (null != a) {
            var e = a.Path, f;
            f = "Default" === a.Type || "Normal" === a.Type ? 0 : 1;
            if (a = a.Plist)cc.loader.getRes(b + a) ? (r[b + a] = !0, cc.spriteFrameCache.addSpriteFrames(b +
                a)) : r[b + a] || cc.spriteFrameCache.getSpriteFrame(e) || cc.log("%s need to be preloaded", b + a);
            0 !== f ? cc.spriteFrameCache.getSpriteFrame(e) ? d(e, f) : cc.log("failed to get spriteFrame: %s", e) : d(b + e, f)
        }
    }, t = function (a) {
        if (a)return cc.color(null != a.R ? a.R : 255, null != a.G ? a.G : 255, null != a.B ? a.B : 255, null != a.A ? a.A : 255)
    }, v = function (a, b) {
        var d = b.X || 0, e = b.Y || 0;
        b && a.setContentSize(cc.size(d, e))
    };
    [{name: "SingleNodeObjectData", handle: d.initSingleNode}, {name: "NodeObjectData", handle: d.initSingleNode}, {
        name: "LayerObjectData",
        handle: d.initSingleNode
    }, {name: "GameNodeObjectData", handle: d.initSingleNode}, {
        name: "GameLayerObjectData",
        handle: d.initSingleNode
    }, {name: "SpriteObjectData", handle: d.initSprite}, {
        name: "ParticleObjectData",
        handle: d.initParticle
    }, {name: "PanelObjectData", handle: d.initPanel}, {
        name: "TextObjectData",
        handle: d.initText
    }, {name: "ButtonObjectData", handle: d.initButton}, {
        name: "CheckBoxObjectData",
        handle: d.initCheckBox
    }, {name: "ScrollViewObjectData", handle: d.initScrollView}, {name: "ImageViewObjectData", handle: d.initImageView},
        {name: "LoadingBarObjectData", handle: d.initLoadingBar}, {
        name: "SliderObjectData",
        handle: d.initSlider
    }, {name: "PageViewObjectData", handle: d.initPageView}, {
        name: "ListViewObjectData",
        handle: d.initListView
    }, {name: "TextAtlasObjectData", handle: d.initTextAtlas}, {
        name: "TextBMFontObjectData",
        handle: d.initTextBMFont
    }, {name: "TextFieldObjectData", handle: d.initTextField}, {
        name: "SimpleAudioObjectData",
        handle: d.initSimpleAudio
    }, {name: "GameMapObjectData", handle: d.initGameMap}, {name: "ProjectNodeObjectData", handle: d.initProjectNode},
        {name: "ArmatureNodeObjectData", handle: d.initArmature}, {
        name: "BoneNodeObjectData",
        handle: d.initBoneNode
    }, {name: "SkeletonNodeObjectData", handle: d.initSkeletonNode}].forEach(function (a) {
        d.registerParser(a.name, function (b, d) {
            var e = a.handle.call(this, b, d);
            this.parseChild(e, b.Children, d);
            return e
        })
    });
    a.registerParser("timeline", "2.*", d);
    a.registerParser("timeline", "*", d)
})(ccs._load, ccs._parser);
(function () {
    ccs.uiReader = {
        _fileDesignSizes: {}, widgetFromJsonFile: function (a) {
            var d = cc.loader.getRes(a);
            d && (this._fileDesignSizes[a] = cc.size(d.designWidth || 0, d.designHeight || 0));
            var d = d.Version || d.version, e = ccs.uiReader.getVersionInteger(d);
            return !d || 1700 <= e ? (cc.warn("Not supported file types, Please try use the ccs.load"), null) : ccs._load(a, "ccui")
        }, registerTypeAndCallBack: function (a, d, e, f) {
            var g = ccs._load.getParser("ccui")["*"], h = f.bind(e);
            g.registerParser(a, function (f, g) {
                var r = new d, s = f.options;
                e.setPropsFromJsonDictionary && e.setPropsFromJsonDictionary(r, s);
                this.generalAttributes(r, s);
                var t = s.customProperty, t = t ? JSON.parse(t) : {};
                h(a, r, t);
                this.colorAttributes(r, s);
                this.anchorPointAttributes(r, s);
                this.parseChild.call(this, r, f, g);
                return r
            })
        }, getVersionInteger: function (a) {
            if (!a || "string" !== typeof a)return 0;
            a = a.split(".");
            if (4 !== a.length)return 0;
            var d = 0;
            a.forEach(function (a, b) {
                d += a * Math.pow(10, 3 - b)
            });
            return d
        }, storeFileDesignSize: function (a, d) {
            this._fileDesignSizes[a] = d
        }, getFileDesignSize: function (a) {
            return this._fileDesignSizes[a]
        },
        getFilePath: function () {
            return this._filePath
        }, setFilePath: function (a) {
            this._filePath = a
        }, getParseObjectMap: function () {
            return ccs._load.getParser("ccui")["*"].parsers
        }, getParseCallBackMap: function () {
            return ccs._load.getParser("ccui")["*"].parsers
        }, clear: function () {
        }
    };
    var a = ccs._load.getParser("ccui")["*"];
    ccs.imageViewReader = {setPropsFromJsonDictionary: a.ImageViewAttributes};
    ccs.buttonReader = {setPropsFromJsonDictionary: a.ButtonAttributes};
    ccs.checkBoxReader = {setPropsFromJsonDictionary: a.CheckBoxAttributes};
    ccs.labelAtlasReader = {setPropsFromJsonDictionary: a.TextAtlasAttributes};
    ccs.labelBMFontReader = {setPropsFromJsonDictionary: a.TextBMFontAttributes};
    ccs.labelReader = {setPropsFromJsonDictionary: a.TextAttributes};
    ccs.layoutReader = {setPropsFromJsonDictionary: a.LayoutAttributes};
    ccs.listViewReader = {setPropsFromJsonDictionary: a.ListViewAttributes};
    ccs.loadingBarReader = {setPropsFromJsonDictionary: a.LoadingBarAttributes};
    ccs.pageViewReader = {setPropsFromJsonDictionary: a.PageViewAttributes};
    ccs.scrollViewReader =
    {setPropsFromJsonDictionary: a.ScrollViewAttributes};
    ccs.sliderReader = {setPropsFromJsonDictionary: a.SliderAttributes};
    ccs.textFieldReader = {setPropsFromJsonDictionary: a.TextFieldAttributes}
})();
(function () {
    ccs.sceneReader = {
        _node: null, createNodeWithSceneFile: function (a) {
            return this._node = a = ccs._load(a, "scene")
        }, getNodeByTag: function (a) {
            return null == this._node ? null : this._node.getTag() === a ? this._node : this._nodeByTag(this._node, a)
        }, _nodeByTag: function (a, b) {
            if (null == a)return null;
            for (var d = null, e = a.getChildren(), f = 0; f < e.length && (!(d = e[f]) || d.getTag() !== b) && !(d = this._nodeByTag(d, b)); f++);
            return d
        }, version: function () {
            return "*"
        }, setTarget: function () {
        }, clear: function () {
            ccs.triggerManager.removeAll();
            cc.audioEngine.end()
        }
    }
})();
var spine = {
    radDeg: 180 / Math.PI,
    degRad: Math.PI / 180,
    temp: [],
    Float32Array: "undefined" === typeof Float32Array ? Array : Float32Array,
    Uint16Array: "undefined" === typeof Uint16Array ? Array : Uint16Array,
    BoneData: function (a, b) {
        this.length = this.x = this.y = this.rotation = 0;
        this.scaleX = this.scaleY = 1;
        this.name = a;
        this.parent = b
    }
};
spine.BoneData.prototype = {
    length: 0,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    inheritScale: !0,
    inheritRotation: !0,
    flipX: !1,
    flipY: !1
};
spine.BlendMode = {normal: 0, additive: 1, multiply: 2, screen: 3};
spine.SlotData = function (a, b) {
    this.r = this.g = this.b = this.a = 1;
    this.blendMode = spine.BlendMode.normal;
    this.name = a;
    this.boneData = b
};
spine.SlotData.prototype = {r: 1, g: 1, b: 1, a: 1, attachmentName: null, blendMode: spine.BlendMode.normal};
spine.IkConstraintData = function (a) {
    this.bendDirection = this.mix = 1;
    this.name = a;
    this.bones = []
};
spine.IkConstraintData.prototype = {target: null, bendDirection: 1, mix: 1};
spine.Bone = function (a, b, d) {
    this.x = this.y = this.rotation = this.rotationIK = 0;
    this.scaleX = this.scaleY = 1;
    this.flipX = this.flipY = !1;
    this.worldRotation = this.m10 = this.m11 = this.worldY = this.m00 = this.m01 = this.worldX = 0;
    this.worldScaleX = this.worldScaleY = 1;
    this.worldFlipX = this.worldFlipY = !1;
    this.data = a;
    this.skeleton = b;
    this.parent = d;
    this.setToSetupPose()
};
spine.Bone.yDown = !1;
spine.Bone.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    rotationIK: 0,
    scaleX: 1,
    scaleY: 1,
    flipX: !1,
    flipY: !1,
    m00: 0,
    m01: 0,
    worldX: 0,
    m10: 0,
    m11: 0,
    worldY: 0,
    worldRotation: 0,
    worldScaleX: 1,
    worldScaleY: 1,
    worldFlipX: !1,
    worldFlipY: !1,
    updateWorldTransform: function () {
        var a = this.parent;
        if (a)this.worldX = this.x * a.m00 + this.y * a.m01 + a.worldX, this.worldY = this.x * a.m10 + this.y * a.m11 + a.worldY, this.data.inheritScale ? (this.worldScaleX = a.worldScaleX * this.scaleX, this.worldScaleY = a.worldScaleY * this.scaleY) : (this.worldScaleX = this.scaleX, this.worldScaleY =
            this.scaleY), this.worldRotation = this.data.inheritRotation ? a.worldRotation + this.rotationIK : this.rotationIK, this.worldFlipX = a.worldFlipX != this.flipX, this.worldFlipY = a.worldFlipY != this.flipY; else {
            var a = this.skeleton.flipX, b = this.skeleton.flipY;
            this.worldX = a ? -this.x : this.x;
            this.worldY = b != spine.Bone.yDown ? -this.y : this.y;
            this.worldScaleX = this.scaleX;
            this.worldScaleY = this.scaleY;
            this.worldRotation = this.rotationIK;
            this.worldFlipX = a != this.flipX;
            this.worldFlipY = b != this.flipY
        }
        b = this.worldRotation * spine.degRad;
        a = Math.cos(b);
        b = Math.sin(b);
        this.worldFlipX ? (this.m00 = -a * this.worldScaleX, this.m01 = b * this.worldScaleY) : (this.m00 = a * this.worldScaleX, this.m01 = -b * this.worldScaleY);
        this.worldFlipY != spine.Bone.yDown ? (this.m10 = -b * this.worldScaleX, this.m11 = -a * this.worldScaleY) : (this.m10 = b * this.worldScaleX, this.m11 = a * this.worldScaleY)
    },
    setToSetupPose: function () {
        var a = this.data;
        this.x = a.x;
        this.y = a.y;
        this.rotationIK = this.rotation = a.rotation;
        this.scaleX = a.scaleX;
        this.scaleY = a.scaleY;
        this.flipX = a.flipX;
        this.flipY = a.flipY
    },
    worldToLocal: function (a) {
        var b = a[0] - this.worldX, d = a[1] - this.worldY, e = this.m00, f = this.m10, g = this.m01, h = this.m11;
        this.worldFlipX != (this.worldFlipY != spine.Bone.yDown) && (e = -e, h = -h);
        var n = 1 / (e * h - g * f);
        a[0] = b * e * n - d * g * n;
        a[1] = d * h * n - b * f * n
    },
    localToWorld: function (a) {
        var b = a[0], d = a[1];
        a[0] = b * this.m00 + d * this.m01 + this.worldX;
        a[1] = b * this.m10 + d * this.m11 + this.worldY
    }
};
spine.Slot = function (a, b) {
    this.r = this.g = this.b = this.a = 1;
    this._attachmentTime = 0;
    this.data = a;
    this.bone = b;
    this.setToSetupPose()
};
spine.Slot.prototype = {
    r: 1, g: 1, b: 1, a: 1, _attachmentTime: 0, attachment: null, attachmentVertices: [], setAttachment: function (a) {
        this.attachment = a;
        this._attachmentTime = this.bone.skeleton.time;
        this.attachmentVertices.length = 0
    }, setAttachmentTime: function (a) {
        this._attachmentTime = this.bone.skeleton.time - a
    }, getAttachmentTime: function () {
        return this.bone.skeleton.time - this._attachmentTime
    }, setToSetupPose: function () {
        var a = this.data;
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a;
        for (var b = this.bone.skeleton.data.slots,
                 d = 0, e = b.length; d < e; d++)if (b[d] == a) {
            this.setAttachment(a.attachmentName ? this.bone.skeleton.getAttachmentBySlotIndex(d, a.attachmentName) : null);
            break
        }
    }
};
spine.IkConstraint = function (a, b) {
    this.data = a;
    this.mix = a.mix;
    this.bendDirection = a.bendDirection;
    this.bones = [];
    for (var d = 0, e = a.bones.length; d < e; d++)this.bones.push(b.findBone(a.bones[d].name));
    this.target = b.findBone(a.target.name)
};
spine.IkConstraint.prototype = {
    apply: function () {
        var a = this.target, b = this.bones;
        switch (b.length) {
            case 1:
                spine.IkConstraint.apply1(b[0], a.worldX, a.worldY, this.mix);
                break;
            case 2:
                spine.IkConstraint.apply2(b[0], b[1], a.worldX, a.worldY, this.bendDirection, this.mix)
        }
    }
};
spine.IkConstraint.apply1 = function (a, b, d, e) {
    var f = a.data.inheritRotation && a.parent ? a.parent.worldRotation : 0, g = a.rotation;
    b = Math.atan2(d - a.worldY, b - a.worldX) * spine.radDeg;
    a.worldFlipX != (a.worldFlipY != spine.Bone.yDown) && (b = -b);
    a.rotationIK = g + (b - f - g) * e
};
spine.IkConstraint.apply2 = function (a, b, d, e, f, g) {
    var h = b.rotation, n = a.rotation;
    if (g) {
        var p, r, s = spine.temp;
        (p = a.parent) ? (s[0] = d, s[1] = e, p.worldToLocal(s), d = (s[0] - a.x) * p.worldScaleX, e = (s[1] - a.y) * p.worldScaleY) : (d -= a.x, e -= a.y);
        b.parent == a ? (p = b.x, r = b.y) : (s[0] = b.x, s[1] = b.y, b.parent.localToWorld(s), a.worldToLocal(s), p = s[0], r = s[1]);
        s = p * a.worldScaleX;
        r *= a.worldScaleY;
        p = Math.atan2(r, s);
        r = Math.sqrt(s * s + r * r);
        var s = b.data.length * b.worldScaleX, t = 2 * r * s;
        1E-4 > t ? b.rotationIK = h + (Math.atan2(e, d) * spine.radDeg - n - h) * g : (t =
            (d * d + e * e - r * r - s * s) / t, -1 > t ? t = -1 : 1 < t && (t = 1), f *= Math.acos(t), r += s * t, s *= Math.sin(f), d = (Math.atan2(e * r - d * s, d * r + e * s) - p) * spine.radDeg - n, 180 < d ? d -= 360 : -180 > d && (d += 360), a.rotationIK = n + d * g, d = (f + p) * spine.radDeg - h, 180 < d ? d -= 360 : -180 > d && (d += 360), b.rotationIK = h + (d + a.worldRotation - b.parent.worldRotation) * g)
    } else b.rotationIK = h, a.rotationIK = n
};
spine.Skin = function (a) {
    this.name = a;
    this.attachments = {}
};
spine.Skin.prototype = {
    addAttachment: function (a, b, d) {
        this.attachments[a + ":" + b] = d
    }, getAttachment: function (a, b) {
        return this.attachments[a + ":" + b]
    }, _attachAll: function (a, b) {
        for (var d in b.attachments) {
            var e = d.indexOf(":"), f = parseInt(d.substring(0, e)), g = d.substring(e + 1), e = a.slots[f];
            e.attachment && e.attachment.name == g && (f = this.getAttachment(f, g)) && e.setAttachment(f)
        }
    }
};
spine.Animation = function (a, b, d) {
    this.name = a;
    this.timelines = b;
    this.duration = d
};
spine.Animation.prototype = {
    apply: function (a, b, d, e, f) {
        e && 0 != this.duration && (d %= this.duration, b %= this.duration);
        e = this.timelines;
        for (var g = 0, h = e.length; g < h; g++)e[g].apply(a, b, d, f, 1)
    }, mix: function (a, b, d, e, f, g) {
        e && 0 != this.duration && (d %= this.duration, b %= this.duration);
        e = this.timelines;
        for (var h = 0, n = e.length; h < n; h++)e[h].apply(a, b, d, f, g)
    }
};
spine.Animation.binarySearch = function (a, b, d) {
    var e = 0, f = Math.floor(a.length / d) - 2;
    if (!f)return d;
    for (var g = f >>> 1; ;) {
        a[(g + 1) * d] <= b ? e = g + 1 : f = g;
        if (e == f)return (e + 1) * d;
        g = e + f >>> 1
    }
};
spine.Animation.binarySearch1 = function (a, b) {
    var d = 0, e = a.length - 2;
    if (!e)return 1;
    for (var f = e >>> 1; ;) {
        a[f + 1] <= b ? d = f + 1 : e = f;
        if (d == e)return d + 1;
        f = d + e >>> 1
    }
};
spine.Animation.linearSearch = function (a, b, d) {
    for (var e = 0, f = a.length - d; e <= f; e += d)if (a[e] > b)return e;
    return -1
};
spine.Curves = function (a) {
    this.curves = []
};
spine.Curves.prototype = {
    setLinear: function (a) {
        this.curves[19 * a] = 0
    }, setStepped: function (a) {
        this.curves[19 * a] = 1
    }, setCurve: function (a, b, d, e, f) {
        var g = 0.1 * 0.1, h = 0.1 * g, n = 3 * 0.1, p = 3 * g, r = 6 * g, g = 6 * h, s = 2 * -b + e, t = 2 * -d + f;
        e = 3 * (b - e) + 1;
        f = 3 * (d - f) + 1;
        b = b * n + s * p + e * h;
        d = d * n + t * p + f * h;
        h = s * r + e * g;
        r = t * r + f * g;
        t = e * g;
        g *= f;
        a *= 19;
        e = this.curves;
        e[a++] = 2;
        f = b;
        n = d;
        for (p = a + 19 - 1; a < p; a += 2)e[a] = f, e[a + 1] = n, b += h, d += r, h += t, r += g, f += b, n += d
    }, getCurvePercent: function (a, b) {
        b = 0 > b ? 0 : 1 < b ? 1 : b;
        var d = this.curves, e = 19 * a, f = d[e];
        if (0 === f)return b;
        if (1 == f)return 0;
        e++;
        for (var f = 0, g = e, h = e + 19 - 1; e < h; e += 2)if (f = d[e], f >= b)return e == g ? h = g = 0 : (g = d[e - 2], h = d[e - 1]), h + (d[e + 1] - h) * (b - g) / (f - g);
        d = d[e - 1];
        return d + (1 - d) * (b - f) / (1 - f)
    }
};
spine.RotateTimeline = function (a) {
    this.boneIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = 2 * a
};
spine.RotateTimeline.prototype = {
    boneIndex: 0, getFrameCount: function () {
        return this.frames.length / 2
    }, setFrame: function (a, b, d) {
        a *= 2;
        this.frames[a] = b;
        this.frames[a + 1] = d
    }, apply: function (a, b, d, e, f) {
        b = this.frames;
        if (!(d < b[0])) {
            a = a.bones[this.boneIndex];
            if (d >= b[b.length - 2])b = a.data.rotation + b[b.length - 1] - a.rotation; else {
                var g = spine.Animation.binarySearch(b, d, 2);
                e = b[g - 1];
                var h = b[g];
                d = 1 - (d - h) / (b[g - 2] - h);
                d = this.curves.getCurvePercent(g / 2 - 1, d);
                for (b = b[g + 1] - e; 180 < b;)b -= 360;
                for (; -180 > b;)b += 360;
                b = a.data.rotation +
                    (e + b * d) - a.rotation
            }
            for (; 180 < b;)b -= 360;
            for (; -180 > b;)b += 360;
            a.rotation += b * f
        }
    }
};
spine.TranslateTimeline = function (a) {
    this.boneIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = 3 * a
};
spine.TranslateTimeline.prototype = {
    boneIndex: 0, getFrameCount: function () {
        return this.frames.length / 3
    }, setFrame: function (a, b, d, e) {
        a *= 3;
        this.frames[a] = b;
        this.frames[a + 1] = d;
        this.frames[a + 2] = e
    }, apply: function (a, b, d, e, f) {
        b = this.frames;
        if (!(d < b[0]))if (a = a.bones[this.boneIndex], d >= b[b.length - 3])a.x += (a.data.x + b[b.length - 2] - a.x) * f, a.y += (a.data.y + b[b.length - 1] - a.y) * f; else {
            e = spine.Animation.binarySearch(b, d, 3);
            var g = b[e - 2], h = b[e - 1], n = b[e];
            d = 1 - (d - n) / (b[e + -3] - n);
            d = this.curves.getCurvePercent(e / 3 - 1, d);
            a.x += (a.data.x +
                g + (b[e + 1] - g) * d - a.x) * f;
            a.y += (a.data.y + h + (b[e + 2] - h) * d - a.y) * f
        }
    }
};
spine.ScaleTimeline = function (a) {
    this.boneIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = 3 * a
};
spine.ScaleTimeline.prototype = {
    boneIndex: 0, getFrameCount: function () {
        return this.frames.length / 3
    }, setFrame: function (a, b, d, e) {
        a *= 3;
        this.frames[a] = b;
        this.frames[a + 1] = d;
        this.frames[a + 2] = e
    }, apply: function (a, b, d, e, f) {
        b = this.frames;
        if (!(d < b[0]))if (a = a.bones[this.boneIndex], d >= b[b.length - 3])a.scaleX += (a.data.scaleX * b[b.length - 2] - a.scaleX) * f, a.scaleY += (a.data.scaleY * b[b.length - 1] - a.scaleY) * f; else {
            e = spine.Animation.binarySearch(b, d, 3);
            var g = b[e - 2], h = b[e - 1], n = b[e];
            d = 1 - (d - n) / (b[e + -3] - n);
            d = this.curves.getCurvePercent(e /
                3 - 1, d);
            a.scaleX += (a.data.scaleX * (g + (b[e + 1] - g) * d) - a.scaleX) * f;
            a.scaleY += (a.data.scaleY * (h + (b[e + 2] - h) * d) - a.scaleY) * f
        }
    }
};
spine.ColorTimeline = function (a) {
    this.boneIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = 5 * a
};
spine.ColorTimeline.prototype = {
    slotIndex: 0, getFrameCount: function () {
        return this.frames.length / 5
    }, setFrame: function (a, b, d, e, f, g) {
        a *= 5;
        this.frames[a] = b;
        this.frames[a + 1] = d;
        this.frames[a + 2] = e;
        this.frames[a + 3] = f;
        this.frames[a + 4] = g
    }, apply: function (a, b, d, e, f) {
        b = this.frames;
        if (!(d < b[0])) {
            var g, h;
            if (d >= b[b.length - 5])e = b.length - 1, d = b[e - 3], g = b[e - 2], h = b[e - 1], b = b[e]; else {
                e = spine.Animation.binarySearch(b, d, 5);
                var n = b[e - 4];
                g = b[e - 3];
                h = b[e - 2];
                var p = b[e - 1], r = b[e], r = 1 - (d - r) / (b[e - 5] - r), r = this.curves.getCurvePercent(e /
                    5 - 1, r);
                d = n + (b[e + 1] - n) * r;
                g += (b[e + 2] - g) * r;
                h += (b[e + 3] - h) * r;
                b = p + (b[e + 4] - p) * r
            }
            a = a.slots[this.slotIndex];
            1 > f ? (a.r += (d - a.r) * f, a.g += (g - a.g) * f, a.b += (h - a.b) * f, a.a += (b - a.a) * f) : (a.r = d, a.g = g, a.b = h, a.a = b)
        }
    }
};
spine.AttachmentTimeline = function (a) {
    this.slotIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = a;
    this.attachmentNames = [];
    this.attachmentNames.length = a
};
spine.AttachmentTimeline.prototype = {
    slotIndex: 0, getFrameCount: function () {
        return this.frames.length
    }, setFrame: function (a, b, d) {
        this.frames[a] = b;
        this.attachmentNames[a] = d
    }, apply: function (a, b, d, e, f) {
        e = this.frames;
        d < e[0] ? b > d && this.apply(a, b, Number.MAX_VALUE, null, 0) : (b > d && (b = -1), d = d >= e[e.length - 1] ? e.length - 1 : spine.Animation.binarySearch1(e, d) - 1, e[d] < b || (b = this.attachmentNames[d], a.slots[this.slotIndex].setAttachment(b ? a.getAttachmentBySlotIndex(this.slotIndex, b) : null)))
    }
};
spine.EventTimeline = function (a) {
    this.frames = [];
    this.frames.length = a;
    this.events = [];
    this.events.length = a
};
spine.EventTimeline.prototype = {
    getFrameCount: function () {
        return this.frames.length
    }, setFrame: function (a, b, d) {
        this.frames[a] = b;
        this.events[a] = d
    }, apply: function (a, b, d, e, f) {
        if (e) {
            var g = this.frames, h = g.length;
            if (b > d)this.apply(a, b, Number.MAX_VALUE, e, f), b = -1; else if (b >= g[h - 1])return;
            if (!(d < g[0])) {
                if (b < g[0])a = 0; else for (a = spine.Animation.binarySearch1(g, b), b = g[a]; 0 < a && g[a - 1] == b;)a--;
                for (b = this.events; a < h && d >= g[a]; a++)e.push(b[a])
            }
        }
    }
};
spine.DrawOrderTimeline = function (a) {
    this.frames = [];
    this.frames.length = a;
    this.drawOrders = [];
    this.drawOrders.length = a
};
spine.DrawOrderTimeline.prototype = {
    getFrameCount: function () {
        return this.frames.length
    }, setFrame: function (a, b, d) {
        this.frames[a] = b;
        this.drawOrders[a] = d
    }, apply: function (a, b, d, e, f) {
        b = this.frames;
        if (!(d < b[0]))if (e = d >= b[b.length - 1] ? b.length - 1 : spine.Animation.binarySearch1(b, d) - 1, d = a.drawOrder, b = a.slots, e = this.drawOrders[e])for (f = 0, g = e.length; f < g; f++)d[f] = a.slots[e[f]]; else {
            f = 0;
            for (var g = b.length; f < g; f++)d[f] = b[f]
        }
    }
};
spine.FfdTimeline = function (a) {
    this.slotIndex = this.attachment = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = a;
    this.frameVertices = [];
    this.frameVertices.length = a
};
spine.FfdTimeline.prototype = {
    slotIndex: 0, attachment: 0, getFrameCount: function () {
        return this.frames.length
    }, setFrame: function (a, b, d) {
        this.frames[a] = b;
        this.frameVertices[a] = d
    }, apply: function (a, b, d, e, f) {
        b = a.slots[this.slotIndex];
        if (b.attachment == this.attachment) {
            var g = this.frames;
            if (!(d < g[0]))if (e = this.frameVertices, a = e[0].length, b = b.attachmentVertices, b.length != a && (f = 1), b.length = a, d >= g[g.length - 1])if (d = e[g.length - 1], 1 > f)for (e = 0; e < a; e++)b[e] += (d[e] - b[e]) * f; else for (e = 0; e < a; e++)b[e] = d[e]; else {
                var h = spine.Animation.binarySearch1(g,
                    d), n = g[h];
                d = 1 - (d - n) / (g[h - 1] - n);
                d = this.curves.getCurvePercent(h - 1, 0 > d ? 0 : 1 < d ? 1 : d);
                g = e[h - 1];
                h = e[h];
                if (1 > f)for (e = 0; e < a; e++)n = g[e], b[e] += (n + (h[e] - n) * d - b[e]) * f; else for (e = 0; e < a; e++)n = g[e], b[e] = n + (h[e] - n) * d
            }
        }
    }
};
spine.IkConstraintTimeline = function (a) {
    this.ikConstraintIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = 3 * a
};
spine.IkConstraintTimeline.prototype = {
    ikConstraintIndex: 0, getFrameCount: function () {
        return this.frames.length / 3
    }, setFrame: function (a, b, d, e) {
        a *= 3;
        this.frames[a] = b;
        this.frames[a + 1] = d;
        this.frames[a + 2] = e
    }, apply: function (a, b, d, e, f) {
        b = this.frames;
        if (!(d < b[0]))if (a = a.ikConstraints[this.ikConstraintIndex], d >= b[b.length - 3])a.mix += (b[b.length - 2] - a.mix) * f, a.bendDirection = b[b.length - 1]; else {
            e = spine.Animation.binarySearch(b, d, 3);
            var g = b[e + -2], h = b[e];
            d = 1 - (d - h) / (b[e + -3] - h);
            d = this.curves.getCurvePercent(e / 3 - 1, d);
            a.mix += (g + (b[e + 1] - g) * d - a.mix) * f;
            a.bendDirection = b[e + -1]
        }
    }
};
spine.FlipXTimeline = function (a) {
    this.boneIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = 2 * a
};
spine.FlipXTimeline.prototype = {
    boneIndex: 0, getFrameCount: function () {
        return this.frames.length / 2
    }, setFrame: function (a, b, d) {
        a *= 2;
        this.frames[a] = b;
        this.frames[a + 1] = d ? 1 : 0
    }, apply: function (a, b, d, e, f) {
        e = this.frames;
        d < e[0] ? b > d && this.apply(a, b, Number.MAX_VALUE, null, 0) : (b > d && (b = -1), d = (d >= e[e.length - 2] ? e.length : spine.Animation.binarySearch(e, d, 2)) - 2, e[d] < b || (a.bones[this.boneIndex].flipX = 0 != e[d + 1]))
    }
};
spine.FlipYTimeline = function (a) {
    this.boneIndex = 0;
    this.curves = new spine.Curves(a);
    this.frames = [];
    this.frames.length = 2 * a
};
spine.FlipYTimeline.prototype = {
    boneIndex: 0, getFrameCount: function () {
        return this.frames.length / 2
    }, setFrame: function (a, b, d) {
        a *= 2;
        this.frames[a] = b;
        this.frames[a + 1] = d ? 1 : 0
    }, apply: function (a, b, d, e, f) {
        e = this.frames;
        d < e[0] ? b > d && this.apply(a, b, Number.MAX_VALUE, null, 0) : (b > d && (b = -1), d = (d >= e[e.length - 2] ? e.length : spine.Animation.binarySearch(e, d, 2)) - 2, e[d] < b || (a.bones[this.boneIndex].flipY = 0 != e[d + 1]))
    }
};
spine.SkeletonData = function () {
    this.width = this.height = 0;
    this.bones = [];
    this.slots = [];
    this.skins = [];
    this.events = [];
    this.animations = [];
    this.ikConstraints = []
};
spine.SkeletonData.prototype = {
    name: null, defaultSkin: null, width: 0, height: 0, version: null, hash: null, findBone: function (a) {
        for (var b = this.bones, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return b[d];
        return null
    }, findBoneIndex: function (a) {
        for (var b = this.bones, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return d;
        return -1
    }, findSlot: function (a) {
        for (var b = this.slots, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return slot[d];
        return null
    }, findSlotIndex: function (a) {
        for (var b = this.slots, d = 0, e = b.length; d < e; d++)if (b[d].name ==
            a)return d;
        return -1
    }, findSkin: function (a) {
        for (var b = this.skins, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return b[d];
        return null
    }, findEvent: function (a) {
        for (var b = this.events, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return b[d];
        return null
    }, findAnimation: function (a) {
        for (var b = this.animations, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return b[d];
        return null
    }, findIkConstraint: function (a) {
        for (var b = this.ikConstraints, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return b[d];
        return null
    }
};
spine.Skeleton = function (a) {
    this.x = this.y = 0;
    this.r = this.g = this.b = this.a = 1;
    this.time = 0;
    this.flipX = this.flipY = !1;
    this.data = a;
    this.bones = [];
    for (var b = 0, d = a.bones.length; b < d; b++) {
        var e = a.bones[b], f = e.parent ? this.bones[a.bones.indexOf(e.parent)] : null;
        this.bones.push(new spine.Bone(e, this, f))
    }
    this.slots = [];
    this.drawOrder = [];
    b = 0;
    for (d = a.slots.length; b < d; b++)e = a.slots[b], f = this.bones[a.bones.indexOf(e.boneData)], e = new spine.Slot(e, f), this.slots.push(e), this.drawOrder.push(e);
    this.ikConstraints = [];
    b = 0;
    for (d =
             a.ikConstraints.length; b < d; b++)this.ikConstraints.push(new spine.IkConstraint(a.ikConstraints[b], this));
    this.boneCache = [];
    this.updateCache()
};
spine.Skeleton.prototype = {
    x: 0, y: 0, skin: null, r: 1, g: 1, b: 1, a: 1, time: 0, flipX: !1, flipY: !1, updateCache: function () {
        var a = this.ikConstraints, b = a.length, d = b + 1, e = this.boneCache;
        e.length > d && (e.length = d);
        for (var f = 0, g = e.length; f < g; f++)e[f].length = 0;
        for (; e.length < d;)e[e.length] = [];
        var d = e[0], h = this.bones, f = 0, g = h.length;
        a:for (; f < g; f++) {
            var n = h[f], p = n;
            do {
                for (var r = 0; r < b; r++)for (var s = a[r], t = s.bones[0], s = s.bones[s.bones.length - 1]; ;) {
                    if (p == s) {
                        e[r].push(n);
                        e[r + 1].push(n);
                        continue a
                    }
                    if (s == t)break;
                    s = s.parent
                }
                p = p.parent
            } while (p);
            d[d.length] = n
        }
    }, updateWorldTransform: function () {
        for (var a = this.bones, b = 0, d = a.length; b < d; b++) {
            var e = a[b];
            e.rotationIK = e.rotation
        }
        b = 0;
        for (a = this.boneCache.length - 1; ;) {
            for (var d = this.boneCache[b], e = 0, f = d.length; e < f; e++)d[e].updateWorldTransform();
            if (b == a)break;
            this.ikConstraints[b].apply();
            b++
        }
    }, setToSetupPose: function () {
        this.setBonesToSetupPose();
        this.setSlotsToSetupPose()
    }, setBonesToSetupPose: function () {
        for (var a = this.bones, b = 0, d = a.length; b < d; b++)a[b].setToSetupPose();
        a = this.ikConstraints;
        b = 0;
        for (d =
                 a.length; b < d; b++) {
            var e = a[b];
            e.bendDirection = e.data.bendDirection;
            e.mix = e.data.mix
        }
    }, setSlotsToSetupPose: function () {
        for (var a = this.slots, b = this.drawOrder, d = 0, e = a.length; d < e; d++)b[d] = a[d], a[d].setToSetupPose(d)
    }, getRootBone: function () {
        return this.bones.length ? this.bones[0] : null
    }, findBone: function (a) {
        for (var b = this.bones, d = 0, e = b.length; d < e; d++)if (b[d].data.name == a)return b[d];
        return null
    }, findBoneIndex: function (a) {
        for (var b = this.bones, d = 0, e = b.length; d < e; d++)if (b[d].data.name == a)return d;
        return -1
    }, findSlot: function (a) {
        for (var b =
            this.slots, d = 0, e = b.length; d < e; d++)if (b[d].data.name == a)return b[d];
        return null
    }, findSlotIndex: function (a) {
        for (var b = this.slots, d = 0, e = b.length; d < e; d++)if (b[d].data.name == a)return d;
        return -1
    }, setSkinByName: function (a) {
        var b = this.data.findSkin(a);
        if (!b)throw Error("Skin not found: " + a);
        this.setSkin(b)
    }, setSkin: function (a) {
        if (a)if (this.skin)a._attachAll(this, this.skin); else for (var b = this.slots, d = 0, e = b.length; d < e; d++) {
            var f = b[d], g = f.data.attachmentName;
            g && (g = a.getAttachment(d, g)) && f.setAttachment(g)
        }
        this.skin =
            a
    }, getAttachmentBySlotName: function (a, b) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(a), b)
    }, getAttachmentBySlotIndex: function (a, b) {
        if (this.skin) {
            var d = this.skin.getAttachment(a, b);
            if (d)return d
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(a, b) : null
    }, setAttachment: function (a, b) {
        for (var d = this.slots, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g.data.name == a) {
                d = null;
                if (b && (d = this.getAttachmentBySlotIndex(e, b), !d))throw Error("Attachment not found: " + b + ", for slot: " + a);
                g.setAttachment(d);
                return
            }
        }
        throw Error("Slot not found: " + a);
    }, findIkConstraint: function (a) {
        for (var b = this.ikConstraints, d = 0, e = b.length; d < e; d++)if (b[d].data.name == a)return b[d];
        return null
    }, update: function (a) {
        this.time += a
    }
};
spine.EventData = function (a) {
    this.intValue = this.floatValue = 0;
    this.name = a
};
spine.EventData.prototype = {intValue: 0, floatValue: 0, stringValue: null};
spine.Event = function (a) {
    this.intValue = this.floatValue = 0;
    this.data = a
};
spine.Event.prototype = {intValue: 0, floatValue: 0, stringValue: null};
spine.AttachmentType = {region: 0, boundingbox: 1, mesh: 2, skinnedmesh: 3};
spine.RegionAttachment = function (a) {
    this.type = spine.AttachmentType.region;
    this.x = this.y = this.rotation = 0;
    this.scaleX = this.scaleY = 1;
    this.width = this.height = 0;
    this.r = this.g = this.b = this.a = 1;
    this.regionOffsetX = this.regionOffsetY = this.regionWidth = this.regionHeight = this.regionOriginalWidth = this.regionOriginalHeight = 0;
    this.name = a;
    this.offset = [];
    this.offset.length = 8;
    this.uvs = [];
    this.uvs.length = 8
};
spine.RegionAttachment.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    width: 0,
    height: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    setUVs: function (a, b, d, e, f) {
        var g = this.uvs;
        f ? (g[2] = a, g[3] = e, g[4] = a, g[5] = b, g[6] = d, g[7] = b, g[0] = d, g[1] = e) : (g[0] = a, g[1] = e, g[2] = a, g[3] = b, g[4] = d, g[5] = b, g[6] = d, g[7] = e)
    },
    updateOffset: function () {
        var a = this.width / this.regionOriginalWidth * this.scaleX, b = this.height / this.regionOriginalHeight *
            this.scaleY, d = -this.width / 2 * this.scaleX + this.regionOffsetX * a, e = -this.height / 2 * this.scaleY + this.regionOffsetY * b, f = d + this.regionWidth * a, a = e + this.regionHeight * b, b = this.rotation * spine.degRad, g = Math.cos(b), h = Math.sin(b), b = d * g + this.x, d = d * h, n = e * g + this.y, e = e * h, p = f * g + this.x, f = f * h, g = a * g + this.y, a = a * h, h = this.offset;
        h[0] = b - e;
        h[1] = n + d;
        h[2] = b - a;
        h[3] = g + d;
        h[4] = p - a;
        h[5] = g + f;
        h[6] = p - e;
        h[7] = n + f
    },
    computeVertices: function (a, b, d, e) {
        a += d.worldX;
        b += d.worldY;
        var f = d.m00, g = d.m01, h = d.m10;
        d = d.m11;
        var n = this.offset;
        e[0] = n[0] * f +
            n[1] * g + a;
        e[1] = n[0] * h + n[1] * d + b;
        e[2] = n[2] * f + n[3] * g + a;
        e[3] = n[2] * h + n[3] * d + b;
        e[4] = n[4] * f + n[5] * g + a;
        e[5] = n[4] * h + n[5] * d + b;
        e[6] = n[6] * f + n[7] * g + a;
        e[7] = n[6] * h + n[7] * d + b
    }
};
spine.MeshAttachment = function (a) {
    this.type = spine.AttachmentType.mesh;
    this.hullLength = 0;
    this.r = this.g = this.b = this.a = 1;
    this.regionU = this.regionV = this.regionV2 = 0;
    this.regionRotate = !1;
    this.width = this.height = this.regionOffsetX = this.regionOffsetY = this.regionWidth = this.regionHeight = this.regionOriginalWidth = this.regionOriginalHeight = 0;
    this.name = a
};
spine.MeshAttachment.prototype = {
    vertices: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function () {
        var a = this.regionU2 - this.regionU, b = this.regionV2 - this.regionV, d = this.regionUVs.length;
        this.uvs && this.uvs.length == d || (this.uvs = new spine.Float32Array(d));
        if (this.regionRotate)for (var e = 0; e < d; e += 2)this.uvs[e] = this.regionU + this.regionUVs[e + 1] * a, this.uvs[e + 1] = this.regionV + b - this.regionUVs[e] * b; else for (e = 0; e < d; e += 2)this.uvs[e] = this.regionU + this.regionUVs[e] * a, this.uvs[e + 1] = this.regionV + this.regionUVs[e + 1] * b
    },
    computeWorldVertices: function (a, b, d, e) {
        var f = d.bone;
        a += f.worldX;
        b += f.worldY;
        var g = f.m00, h = f.m01, n = f.m10, f = f.m11, p = this.vertices, r = p.length;
        d.attachmentVertices.length == r && (p = d.attachmentVertices);
        for (d = 0; d < r; d += 2) {
            var s = p[d], t = p[d + 1];
            e[d] = s * g + t * h +
                a;
            e[d + 1] = s * n + t * f + b
        }
    }
};
spine.SkinnedMeshAttachment = function (a) {
    this.type = spine.AttachmentType.skinnedmesh;
    this.hullLength = 0;
    this.r = this.g = this.b = this.a = 1;
    this.regionU = this.regionV = this.regionU2 = this.regionV2 = 0;
    this.regionRotate = !1;
    this.width = this.height = this.regionOffsetX = this.regionOffsetY = this.regionWidth = this.regionHeight = this.regionOriginalWidth = this.regionOriginalHeight = 0;
    this.name = a
};
spine.SkinnedMeshAttachment.prototype = {
    bones: null,
    weights: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function (a, b, d, e, f) {
        a = this.regionU2 - this.regionU;
        b = this.regionV2 - this.regionV;
        d = this.regionUVs.length;
        this.uvs && this.uvs.length == d || (this.uvs =
            new spine.Float32Array(d));
        if (this.regionRotate)for (e = 0; e < d; e += 2)this.uvs[e] = this.regionU + this.regionUVs[e + 1] * a, this.uvs[e + 1] = this.regionV + b - this.regionUVs[e] * b; else for (e = 0; e < d; e += 2)this.uvs[e] = this.regionU + this.regionUVs[e] * a, this.uvs[e + 1] = this.regionV + this.regionUVs[e + 1] * b
    },
    computeWorldVertices: function (a, b, d, e) {
        var f = d.bone.skeleton.bones, g = this.weights, h = this.bones, n = 0, p = 0, r = 0, s = 0, t = h.length, v, u, x, w, y, A;
        if (d.attachmentVertices.length)for (var D = d.attachmentVertices; p < t; n += 2) {
            u = v = 0;
            for (d = h[p++] +
                p; p < d; p++, r += 3, s += 2)x = f[h[p]], w = g[r] + D[s], y = g[r + 1] + D[s + 1], A = g[r + 2], v += (w * x.m00 + y * x.m01 + x.worldX) * A, u += (w * x.m10 + y * x.m11 + x.worldY) * A;
            e[n] = v + a;
            e[n + 1] = u + b
        } else for (; p < t; n += 2) {
            u = v = 0;
            for (d = h[p++] + p; p < d; p++, r += 3)x = f[h[p]], w = g[r], y = g[r + 1], A = g[r + 2], v += (w * x.m00 + y * x.m01 + x.worldX) * A, u += (w * x.m10 + y * x.m11 + x.worldY) * A;
            e[n] = v + a;
            e[n + 1] = u + b
        }
    }
};
spine.BoundingBoxAttachment = function (a) {
    this.type = spine.AttachmentType.boundingbox;
    this.name = a;
    this.vertices = []
};
spine.BoundingBoxAttachment.prototype = {
    computeWorldVertices: function (a, b, d, e) {
        a += d.worldX;
        b += d.worldY;
        var f = d.m00, g = d.m01, h = d.m10;
        d = d.m11;
        for (var n = this.vertices, p = 0, r = n.length; p < r; p += 2) {
            var s = n[p], t = n[p + 1];
            e[p] = s * f + t * g + a;
            e[p + 1] = s * h + t * d + b
        }
    }
};
spine.AnimationStateData = function (a) {
    this.skeletonData = a;
    this.animationToMixTime = {};
    this.defaultMix = 0
};
spine.AnimationStateData.prototype = {
    defaultMix: 0, setMixByName: function (a, b, d) {
        var e = this.skeletonData.findAnimation(a);
        if (!e)throw Error("Animation not found: " + a);
        a = this.skeletonData.findAnimation(b);
        if (!a)throw Error("Animation not found: " + b);
        this.setMix(e, a, d)
    }, setMix: function (a, b, d) {
        this.animationToMixTime[a.name + ":" + b.name] = d
    }, getMix: function (a, b) {
        var d = a.name + ":" + b.name;
        return this.animationToMixTime.hasOwnProperty(d) ? this.animationToMixTime[d] : this.defaultMix
    }
};
spine.TrackEntry = function () {
    this.delay = this.time = this.endTime = 0;
    this.lastTime = -1;
    this.mix = this.mixTime = this.mixDuration = this.timeScale = 1
};
spine.TrackEntry.prototype = {
    next: null,
    previous: null,
    animation: null,
    loop: !1,
    delay: 0,
    time: 0,
    lastTime: -1,
    endTime: 0,
    timeScale: 1,
    mixTime: 0,
    mixDuration: 0,
    mix: 1,
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null
};
spine.AnimationState = function (a) {
    this.timeScale = 1;
    this.data = a;
    this.tracks = [];
    this.events = []
};
spine.AnimationState.prototype = {
    onStart: null, onEnd: null, onComplete: null, onEvent: null, timeScale: 1, update: function (a) {
        a *= this.timeScale;
        for (var b = 0; b < this.tracks.length; b++) {
            var d = this.tracks[b];
            if (d) {
                d.time += a * d.timeScale;
                if (d.previous) {
                    var e = a * d.previous.timeScale;
                    d.previous.time += e;
                    d.mixTime += e
                }
                (e = d.next) ? (e.time = d.lastTime - e.delay, 0 <= e.time && this.setCurrent(b, e)) : !d.loop && d.lastTime >= d.endTime && this.clearTrack(b)
            }
        }
    }, apply: function (a) {
        for (var b = 0; b < this.tracks.length; b++) {
            var d = this.tracks[b];
            if (d) {
                this.events.length =
                    0;
                var e = d.time, f = d.lastTime, g = d.endTime, h = d.loop;
                !h && e > g && (e = g);
                var n = d.previous;
                if (n) {
                    var p = n.time;
                    !n.loop && p > n.endTime && (p = n.endTime);
                    n.animation.apply(a, p, p, n.loop, null);
                    n = d.mixTime / d.mixDuration * d.mix;
                    1 <= n && (n = 1, d.previous = null);
                    d.animation.mix(a, d.lastTime, e, h, this.events, n)
                } else 1 == d.mix ? d.animation.apply(a, d.lastTime, e, h, this.events) : d.animation.mix(a, d.lastTime, e, h, this.events, d.mix);
                n = 0;
                for (p = this.events.length; n < p; n++) {
                    var r = this.events[n];
                    if (d.onEvent)d.onEvent(b, r);
                    if (this.onEvent)this.onEvent(b,
                        r)
                }
                if (h ? f % g > e % g : f < g && e >= g) {
                    e = Math.floor(e / g);
                    if (d.onComplete)d.onComplete(b, e);
                    if (this.onComplete)this.onComplete(b, e)
                }
                d.lastTime = d.time
            }
        }
    }, clearTracks: function () {
        for (var a = 0, b = this.tracks.length; a < b; a++)this.clearTrack(a);
        this.tracks.length = 0
    }, clearTrack: function (a) {
        if (!(a >= this.tracks.length)) {
            var b = this.tracks[a];
            if (b) {
                if (b.onEnd)b.onEnd(a);
                if (this.onEnd)this.onEnd(a);
                this.tracks[a] = null
            }
        }
    }, _expandToIndex: function (a) {
        if (a < this.tracks.length)return this.tracks[a];
        for (; a >= this.tracks.length;)this.tracks.push(null);
        return null
    }, setCurrent: function (a, b) {
        var d = this._expandToIndex(a);
        if (d) {
            var e = d.previous;
            d.previous = null;
            if (d.onEnd)d.onEnd(a);
            if (this.onEnd)this.onEnd(a);
            b.mixDuration = this.data.getMix(d.animation, b.animation);
            0 < b.mixDuration && (b.mixTime = 0, b.previous = e && 0.5 > d.mixTime / d.mixDuration ? e : d)
        }
        this.tracks[a] = b;
        if (b.onStart)b.onStart(a);
        if (this.onStart)this.onStart(a)
    }, setAnimationByName: function (a, b, d) {
        var e = this.data.skeletonData.findAnimation(b);
        if (!e)throw Error("Animation not found: " + b);
        return this.setAnimation(a,
            e, d)
    }, setAnimation: function (a, b, d) {
        var e = new spine.TrackEntry;
        e.animation = b;
        e.loop = d;
        e.endTime = b.duration;
        this.setCurrent(a, e);
        return e
    }, addAnimationByName: function (a, b, d, e) {
        var f = this.data.skeletonData.findAnimation(b);
        if (!f)throw Error("Animation not found: " + b);
        return this.addAnimation(a, f, d, e)
    }, addAnimation: function (a, b, d, e) {
        var f = new spine.TrackEntry;
        f.animation = b;
        f.loop = d;
        f.endTime = b.duration;
        if (d = this._expandToIndex(a)) {
            for (; d.next;)d = d.next;
            d.next = f
        } else this.tracks[a] = f;
        0 >= e && (e = d ? e + (d.endTime -
        this.data.getMix(d.animation, b)) : 0);
        f.delay = e;
        return f
    }, getCurrent: function (a) {
        return a >= this.tracks.length ? null : this.tracks[a]
    }
};
spine.SkeletonJson = function (a) {
    this.scale = 1;
    this.attachmentLoader = a
};
spine.SkeletonJson.prototype = {
    scale: 1, readSkeletonData: function (a, b) {
        var d = new spine.SkeletonData;
        d.name = b;
        var e = a.skeleton;
        e && (d.hash = e.hash, d.version = e.spine, d.width = e.width || 0, d.height = e.height || 0);
        for (var f = a.bones, e = 0, g = f.length; e < g; e++) {
            var h = f[e], n = null;
            if (h.parent && (n = d.findBone(h.parent), !n))throw Error("Parent bone not found: " + h.parent);
            n = new spine.BoneData(h.name, n);
            n.length = (h.length || 0) * this.scale;
            n.x = (h.x || 0) * this.scale;
            n.y = (h.y || 0) * this.scale;
            n.rotation = h.rotation || 0;
            n.scaleX = h.hasOwnProperty("scaleX") ?
                h.scaleX : 1;
            n.scaleY = h.hasOwnProperty("scaleY") ? h.scaleY : 1;
            n.inheritScale = h.hasOwnProperty("inheritScale") ? h.inheritScale : !0;
            n.inheritRotation = h.hasOwnProperty("inheritRotation") ? h.inheritRotation : !0;
            d.bones.push(n)
        }
        if (n = a.ik)for (e = 0, g = n.length; e < g; e++) {
            for (var h = n[e], p = new spine.IkConstraintData(h.name), f = h.bones, r = 0, s = f.length; r < s; r++) {
                var t = d.findBone(f[r]);
                if (!t)throw Error("IK bone not found: " + f[r]);
                p.bones.push(t)
            }
            p.target = d.findBone(h.target);
            if (!p.target)throw Error("Target bone not found: " +
                h.target);
            p.bendDirection = !h.hasOwnProperty("bendPositive") || h.bendPositive ? 1 : -1;
            p.mix = h.hasOwnProperty("mix") ? h.mix : 1;
            d.ikConstraints.push(p)
        }
        f = a.slots;
        e = 0;
        for (g = f.length; e < g; e++) {
            h = f[e];
            n = d.findBone(h.bone);
            if (!n)throw Error("Slot bone not found: " + h.bone);
            n = new spine.SlotData(h.name, n);
            if (p = h.color)n.r = this.toColor(p, 0), n.g = this.toColor(p, 1), n.b = this.toColor(p, 2), n.a = this.toColor(p, 3);
            n.attachmentName = h.attachment;
            n.blendMode = spine.AttachmentType[h.blend || "normal"];
            d.slots.push(n)
        }
        var e = a.skins,
            v;
        for (v in e)if (e.hasOwnProperty(v)) {
            var g = e[v], f = new spine.Skin(v), u;
            for (u in g)if (g.hasOwnProperty(u)) {
                var n = d.findSlotIndex(u), h = g[u], x;
                for (x in h)h.hasOwnProperty(x) && (p = this.readAttachment(f, x, h[x])) && f.addAttachment(n, x, p)
            }
            d.skins.push(f);
            "default" == f.name && (d.defaultSkin = f)
        }
        v = a.events;
        for (var w in v)v.hasOwnProperty(w) && (u = v[w], x = new spine.EventData(w), x.intValue = u["int"] || 0, x.floatValue = u["float"] || 0, x.stringValue = u.string || null, d.events.push(x));
        w = a.animations;
        for (var y in w)w.hasOwnProperty(y) &&
        this.readAnimation(y, w[y], d);
        return d
    }, readAttachment: function (a, b, d) {
        b = d.name || b;
        var e = spine.AttachmentType[d.type || "region"], f = d.path || b, g = this.scale;
        if (e == spine.AttachmentType.region) {
            a = this.attachmentLoader.newRegionAttachment(a, b, f);
            if (!a)return null;
            a.path = f;
            a.x = (d.x || 0) * g;
            a.y = (d.y || 0) * g;
            a.scaleX = d.hasOwnProperty("scaleX") ? d.scaleX : 1;
            a.scaleY = d.hasOwnProperty("scaleY") ? d.scaleY : 1;
            a.rotation = d.rotation || 0;
            a.width = (d.width || 0) * g;
            a.height = (d.height || 0) * g;
            if (f = d.color)a.r = this.toColor(f, 0), a.g =
                this.toColor(f, 1), a.b = this.toColor(f, 2), a.a = this.toColor(f, 3);
            a.updateOffset();
            return a
        }
        if (e == spine.AttachmentType.mesh) {
            a = this.attachmentLoader.newMeshAttachment(a, b, f);
            if (!a)return null;
            a.path = f;
            a.vertices = this.getFloatArray(d, "vertices", g);
            a.triangles = this.getIntArray(d, "triangles");
            a.regionUVs = this.getFloatArray(d, "uvs", 1);
            a.updateUVs();
            if (f = d.color)a.r = this.toColor(f, 0), a.g = this.toColor(f, 1), a.b = this.toColor(f, 2), a.a = this.toColor(f, 3);
            a.hullLength = 2 * (d.hull || 0);
            d.edges && (a.edges = this.getIntArray(d,
                "edges"));
            a.width = (d.width || 0) * g;
            a.height = (d.height || 0) * g;
            return a
        }
        if (e == spine.AttachmentType.skinnedmesh) {
            a = this.attachmentLoader.newSkinnedMeshAttachment(a, b, f);
            if (!a)return null;
            a.path = f;
            var h = this.getFloatArray(d, "uvs", 1), f = this.getFloatArray(d, "vertices", 1), n = [], p = [];
            b = 0;
            for (e = f.length; b < e;) {
                var r = f[b++] | 0;
                p[p.length] = r;
                for (r = b + 4 * r; b < r;)p[p.length] = f[b], n[n.length] = f[b + 1] * g, n[n.length] = f[b + 2] * g, n[n.length] = f[b + 3], b += 4
            }
            a.bones = p;
            a.weights = n;
            a.triangles = this.getIntArray(d, "triangles");
            a.regionUVs =
                h;
            a.updateUVs();
            if (f = d.color)a.r = this.toColor(f, 0), a.g = this.toColor(f, 1), a.b = this.toColor(f, 2), a.a = this.toColor(f, 3);
            a.hullLength = 2 * (d.hull || 0);
            d.edges && (a.edges = this.getIntArray(d, "edges"));
            a.width = (d.width || 0) * g;
            a.height = (d.height || 0) * g;
            return a
        }
        if (e == spine.AttachmentType.boundingbox) {
            a = this.attachmentLoader.newBoundingBoxAttachment(a, b);
            f = d.vertices;
            b = 0;
            for (e = f.length; b < e; b++)a.vertices.push(f[b] * g);
            return a
        }
        throw Error("Unknown attachment type: " + e);
    }, readAnimation: function (a, b, d) {
        var e = [], f =
            0, g = b.slots, h;
        for (h in g)if (g.hasOwnProperty(h)) {
            var n = g[h], p = d.findSlotIndex(h), r;
            for (r in n)if (n.hasOwnProperty(r)) {
                var s = n[r];
                if ("color" == r) {
                    var t = new spine.ColorTimeline(s.length);
                    t.slotIndex = p;
                    for (var v = 0, u = 0, x = s.length; u < x; u++) {
                        var w = s[u], y = w.color, A = this.toColor(y, 0), D = this.toColor(y, 1), G = this.toColor(y, 2), y = this.toColor(y, 3);
                        t.setFrame(v, w.time, A, D, G, y);
                        this.readCurve(t, v, w);
                        v++
                    }
                    e.push(t);
                    f = Math.max(f, t.frames[5 * t.getFrameCount() - 5])
                } else if ("attachment" == r) {
                    t = new spine.AttachmentTimeline(s.length);
                    t.slotIndex = p;
                    u = v = 0;
                    for (x = s.length; u < x; u++)w = s[u], t.setFrame(v++, w.time, w.name);
                    e.push(t);
                    f = Math.max(f, t.frames[t.getFrameCount() - 1])
                } else throw Error("Invalid timeline type for a slot: " + r + " (" + h + ")");
            }
        }
        var p = b.bones, B;
        for (B in p)if (p.hasOwnProperty(B)) {
            n = d.findBoneIndex(B);
            if (-1 == n)throw Error("Bone not found: " + B);
            g = p[B];
            for (r in g)if (g.hasOwnProperty(r))if (s = g[r], "rotate" == r) {
                t = new spine.RotateTimeline(s.length);
                t.boneIndex = n;
                u = v = 0;
                for (x = s.length; u < x; u++)w = s[u], t.setFrame(v, w.time, w.angle), this.readCurve(t,
                    v, w), v++;
                e.push(t);
                f = Math.max(f, t.frames[2 * t.getFrameCount() - 2])
            } else if ("translate" == r || "scale" == r) {
                A = 1;
                "scale" == r ? t = new spine.ScaleTimeline(s.length) : (t = new spine.TranslateTimeline(s.length), A = this.scale);
                t.boneIndex = n;
                u = v = 0;
                for (x = s.length; u < x; u++)w = s[u], D = (w.x || 0) * A, t.setFrame(v, w.time, D, (w.y || 0) * A), this.readCurve(t, v, w), v++;
                e.push(t);
                f = Math.max(f, t.frames[3 * t.getFrameCount() - 3])
            } else if ("flipX" == r || "flipY" == r) {
                t = (D = "flipX" == r) ? new spine.FlipXTimeline(s.length) : new spine.FlipYTimeline(s.length);
                t.boneIndex = n;
                A = D ? "x" : "y";
                u = v = 0;
                for (x = s.length; u < x; u++)w = s[u], t.setFrame(v, w.time, w[A] || !1), v++;
                e.push(t);
                f = Math.max(f, t.frames[2 * t.getFrameCount() - 2])
            } else throw Error("Invalid timeline type for a bone: " + r + " (" + B + ")");
        }
        var p = b.ik, C;
        for (C in p)if (p.hasOwnProperty(C)) {
            v = d.findIkConstraint(C);
            s = p[C];
            t = new spine.IkConstraintTimeline(s.length);
            t.ikConstraintIndex = d.ikConstraints.indexOf(v);
            u = v = 0;
            for (x = s.length; u < x; u++)w = s[u], n = w.hasOwnProperty("mix") ? w.mix : 1, r = !w.hasOwnProperty("bendPositive") || w.bendPositive ?
                1 : -1, t.setFrame(v, w.time, n, r), this.readCurve(t, v, w), v++;
            e.push(t);
            f = Math.max(f, t.frames[3 * t.frameCount - 3])
        }
        B = b.ffd;
        for (var E in B)for (h in g = d.findSkin(E), n = B[E], n) {
            var p = d.findSlotIndex(h), A = n[h], I;
            for (I in A) {
                s = A[I];
                t = new spine.FfdTimeline(s.length);
                D = g.getAttachment(p, I);
                if (!D)throw Error("FFD attachment not found: " + I);
                t.slotIndex = p;
                t.attachment = D;
                y = (G = D.type == spine.AttachmentType.mesh) ? D.vertices.length : D.weights.length / 3 * 2;
                u = v = 0;
                for (x = s.length; u < x; u++) {
                    var w = s[u], L;
                    if (w.vertices) {
                        var J = w.vertices;
                        L = [];
                        L.length = y;
                        var Q = w.offset || 0;
                        C = J.length;
                        if (1 == this.scale)for (r = 0; r < C; r++)L[r + Q] = J[r]; else for (r = 0; r < C; r++)L[r + Q] = J[r] * this.scale;
                        if (G)for (J = D.vertices, r = 0, C = L.length; r < C; r++)L[r] += J[r]
                    } else G ? L = D.vertices : (L = [], L.length = y);
                    t.setFrame(v, w.time, L);
                    this.readCurve(t, v, w);
                    v++
                }
                e[e.length] = t;
                f = Math.max(f, t.frames[t.frameCount - 1])
            }
        }
        (h = b.drawOrder) || (h = b.draworder);
        if (h) {
            t = new spine.DrawOrderTimeline(h.length);
            s = d.slots.length;
            u = v = 0;
            for (x = h.length; u < x; u++) {
                E = h[u];
                I = null;
                if (E.offsets) {
                    I = [];
                    I.length = s;
                    for (r = s - 1; 0 <= r; r--)I[r] = -1;
                    w = E.offsets;
                    n = [];
                    n.length = s - w.length;
                    r = g = B = 0;
                    for (C = w.length; r < C; r++) {
                        A = w[r];
                        p = d.findSlotIndex(A.slot);
                        if (-1 == p)throw Error("Slot not found: " + A.slot);
                        for (; B != p;)n[g++] = B++;
                        I[B + A.offset] = B++
                    }
                    for (; B < s;)n[g++] = B++;
                    for (r = s - 1; 0 <= r; r--)-1 == I[r] && (I[r] = n[--g])
                }
                t.setFrame(v++, E.time, I)
            }
            e.push(t);
            f = Math.max(f, t.frames[t.getFrameCount() - 1])
        }
        if (b = b.events) {
            t = new spine.EventTimeline(b.length);
            u = v = 0;
            for (x = b.length; u < x; u++) {
                h = b[u];
                s = d.findEvent(h.name);
                if (!s)throw Error("Event not found: " +
                    h.name);
                E = new spine.Event(s);
                E.intValue = h.hasOwnProperty("int") ? h["int"] : s.intValue;
                E.floatValue = h.hasOwnProperty("float") ? h["float"] : s.floatValue;
                E.stringValue = h.hasOwnProperty("string") ? h.string : s.stringValue;
                t.setFrame(v++, h.time, E)
            }
            e.push(t);
            f = Math.max(f, t.frames[t.getFrameCount() - 1])
        }
        d.animations.push(new spine.Animation(a, e, f))
    }, readCurve: function (a, b, d) {
        (d = d.curve) ? "stepped" == d ? a.curves.setStepped(b) : d instanceof Array && a.curves.setCurve(b, d[0], d[1], d[2], d[3]) : a.curves.setLinear(b)
    }, toColor: function (a,
                          b) {
        if (8 != a.length)throw Error("Color hexadecimal length must be 8, received: " + a);
        return parseInt(a.substring(2 * b, 2 * b + 2), 16) / 255
    }, getFloatArray: function (a, b, d) {
        a = a[b];
        b = new spine.Float32Array(a.length);
        var e = 0, f = a.length;
        if (1 == d)for (; e < f; e++)b[e] = a[e]; else for (; e < f; e++)b[e] = a[e] * d;
        return b
    }, getIntArray: function (a, b) {
        for (var d = a[b], e = new spine.Uint16Array(d.length), f = 0, g = d.length; f < g; f++)e[f] = d[f] | 0;
        return e
    }
};
spine.Atlas = function (a, b) {
    this.textureLoader = b;
    this.pages = [];
    this.regions = [];
    var d = new spine.AtlasReader(a), e = [];
    e.length = 4;
    for (var f = null; ;) {
        var g = d.readLine();
        if (null === g)break;
        g = d.trim(g);
        if (g.length)if (f) {
            var h = new spine.AtlasRegion;
            h.name = g;
            h.page = f;
            h.rotate = "true" == d.readValue();
            d.readTuple(e);
            var g = parseInt(e[0]), n = parseInt(e[1]);
            d.readTuple(e);
            var p = parseInt(e[0]), r = parseInt(e[1]);
            h.u = g / f.width;
            h.v = n / f.height;
            h.rotate ? (h.u2 = (g + r) / f.width, h.v2 = (n + p) / f.height) : (h.u2 = (g + p) / f.width, h.v2 = (n + r) /
                f.height);
            h.x = g;
            h.y = n;
            h.width = Math.abs(p);
            h.height = Math.abs(r);
            4 == d.readTuple(e) && (h.splits = [parseInt(e[0]), parseInt(e[1]), parseInt(e[2]), parseInt(e[3])], 4 == d.readTuple(e) && (h.pads = [parseInt(e[0]), parseInt(e[1]), parseInt(e[2]), parseInt(e[3])], d.readTuple(e)));
            h.originalWidth = parseInt(e[0]);
            h.originalHeight = parseInt(e[1]);
            d.readTuple(e);
            h.offsetX = parseInt(e[0]);
            h.offsetY = parseInt(e[1]);
            h.index = parseInt(d.readValue());
            this.regions.push(h)
        } else f = new spine.AtlasPage, f.name = g, 2 == d.readTuple(e) && (f.width =
            parseInt(e[0]), f.height = parseInt(e[1]), d.readTuple(e)), f.format = spine.Atlas.Format[e[0]], d.readTuple(e), f.minFilter = spine.Atlas.TextureFilter[e[0]], f.magFilter = spine.Atlas.TextureFilter[e[1]], h = d.readValue(), f.uWrap = spine.Atlas.TextureWrap.clampToEdge, f.vWrap = spine.Atlas.TextureWrap.clampToEdge, "x" == h ? f.uWrap = spine.Atlas.TextureWrap.repeat : "y" == h ? f.vWrap = spine.Atlas.TextureWrap.repeat : "xy" == h && (f.uWrap = f.vWrap = spine.Atlas.TextureWrap.repeat), b.load(f, g, this), this.pages.push(f); else f = null
    }
};
spine.Atlas.prototype = {
    findRegion: function (a) {
        for (var b = this.regions, d = 0, e = b.length; d < e; d++)if (b[d].name == a)return b[d];
        return null
    }, dispose: function () {
        for (var a = this.pages, b = 0, d = a.length; b < d; b++)this.textureLoader.unload(a[b].rendererObject)
    }, updateUVs: function (a) {
        for (var b = this.regions, d = 0, e = b.length; d < e; d++) {
            var f = b[d];
            f.page == a && (f.u = f.x / a.width, f.v = f.y / a.height, f.rotate ? (f.u2 = (f.x + f.height) / a.width, f.v2 = (f.y + f.width) / a.height) : (f.u2 = (f.x + f.width) / a.width, f.v2 = (f.y + f.height) / a.height))
        }
    }
};
spine.Atlas.Format = {alpha: 0, intensity: 1, luminanceAlpha: 2, rgb565: 3, rgba4444: 4, rgb888: 5, rgba8888: 6};
spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
};
spine.Atlas.TextureWrap = {mirroredRepeat: 0, clampToEdge: 1, repeat: 2};
spine.AtlasPage = function () {
    this.width = this.height = 0
};
spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
};
spine.AtlasRegion = function () {
    this.index = this.x = this.y = this.width = this.height = this.u = this.v = this.u2 = this.v2 = this.offsetX = this.offsetY = this.originalWidth = this.originalHeight = 0
};
spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    u: 0,
    v: 0,
    u2: 0,
    v2: 0,
    offsetX: 0,
    offsetY: 0,
    originalWidth: 0,
    originalHeight: 0,
    index: 0,
    rotate: !1,
    splits: null,
    pads: null
};
spine.AtlasReader = function (a) {
    this.index = 0;
    this.lines = a.split(/\r\n|\r|\n/)
};
spine.AtlasReader.prototype = {
    index: 0, trim: function (a) {
        return a.replace(/^\s+|\s+$/g, "")
    }, readLine: function () {
        return this.index >= this.lines.length ? null : this.lines[this.index++]
    }, readValue: function () {
        var a = this.readLine(), b = a.indexOf(":");
        if (-1 == b)throw Error("Invalid line: " + a);
        return this.trim(a.substring(b + 1))
    }, readTuple: function (a) {
        var b = this.readLine(), d = b.indexOf(":");
        if (-1 == d)throw Error("Invalid line: " + b);
        for (var e = 0, d = d + 1; 3 > e; e++) {
            var f = b.indexOf(",", d);
            if (-1 == f)break;
            a[e] = this.trim(b.substr(d,
                f - d));
            d = f + 1
        }
        a[e] = this.trim(b.substring(d));
        return e + 1
    }
};
spine.AtlasAttachmentLoader = function (a) {
    this.atlas = a
};
spine.AtlasAttachmentLoader.prototype = {
    newRegionAttachment: function (a, b, d) {
        a = this.atlas.findRegion(d);
        if (!a)throw Error("Region not found in atlas: " + d + " (region attachment: " + b + ")");
        b = new spine.RegionAttachment(b);
        b.rendererObject = a;
        b.setUVs(a.u, a.v, a.u2, a.v2, a.rotate);
        b.regionOffsetX = a.offsetX;
        b.regionOffsetY = a.offsetY;
        b.regionWidth = a.width;
        b.regionHeight = a.height;
        b.regionOriginalWidth = a.originalWidth;
        b.regionOriginalHeight = a.originalHeight;
        return b
    }, newMeshAttachment: function (a, b, d) {
        a = this.atlas.findRegion(d);
        if (!a)throw Error("Region not found in atlas: " + d + " (mesh attachment: " + b + ")");
        b = new spine.MeshAttachment(b);
        b.rendererObject = a;
        b.regionU = a.u;
        b.regionV = a.v;
        b.regionU2 = a.u2;
        b.regionV2 = a.v2;
        b.regionRotate = a.rotate;
        b.regionOffsetX = a.offsetX;
        b.regionOffsetY = a.offsetY;
        b.regionWidth = a.width;
        b.regionHeight = a.height;
        b.regionOriginalWidth = a.originalWidth;
        b.regionOriginalHeight = a.originalHeight;
        return b
    }, newSkinnedMeshAttachment: function (a, b, d) {
        a = this.atlas.findRegion(d);
        if (!a)throw Error("Region not found in atlas: " +
            d + " (skinned mesh attachment: " + b + ")");
        b = new spine.SkinnedMeshAttachment(b);
        b.rendererObject = a;
        b.regionU = a.u;
        b.regionV = a.v;
        b.regionU2 = a.u2;
        b.regionV2 = a.v2;
        b.regionRotate = a.rotate;
        b.regionOffsetX = a.offsetX;
        b.regionOffsetY = a.offsetY;
        b.regionWidth = a.width;
        b.regionHeight = a.height;
        b.regionOriginalWidth = a.originalWidth;
        b.regionOriginalHeight = a.originalHeight;
        return b
    }, newBoundingBoxAttachment: function (a, b) {
        return new spine.BoundingBoxAttachment(b)
    }
};
spine.SkeletonBounds = function () {
    this.minX = this.minY = this.maxX = this.maxY = 0;
    this.polygonPool = [];
    this.polygons = [];
    this.boundingBoxes = []
};
spine.SkeletonBounds.prototype = {
    minX: 0, minY: 0, maxX: 0, maxY: 0, update: function (a, b) {
        for (var d = a.slots, e = d.length, f = a.x, g = a.y, h = this.boundingBoxes, n = this.polygonPool, p = this.polygons, r = h.length = 0, s = p.length; r < s; r++)n.push(p[r]);
        for (r = p.length = 0; r < e; r++) {
            var s = d[r], t = s.attachment;
            if (t.type == spine.AttachmentType.boundingbox) {
                h.push(t);
                var v = n.length, u;
                0 < v ? (u = n[v - 1], n.splice(v - 1, 1)) : u = [];
                p.push(u);
                u.length = t.vertices.length;
                t.computeWorldVertices(f, g, s.bone, u)
            }
        }
        b && this.aabbCompute()
    }, aabbCompute: function () {
        for (var a =
            this.polygons, b = Number.MAX_VALUE, d = Number.MAX_VALUE, e = Number.MIN_VALUE, f = Number.MIN_VALUE, g = 0, h = a.length; g < h; g++)for (var n = a[g], p = 0, r = n.length; p < r; p += 2)var s = n[p], t = n[p + 1], b = Math.min(b, s), d = Math.min(d, t), e = Math.max(e, s), f = Math.max(f, t);
        this.minX = b;
        this.minY = d;
        this.maxX = e;
        this.maxY = f
    }, aabbContainsPoint: function (a, b) {
        return a >= this.minX && a <= this.maxX && b >= this.minY && b <= this.maxY
    }, aabbIntersectsSegment: function (a, b, d, e) {
        var f = this.minX, g = this.minY, h = this.maxX, n = this.maxY;
        if (a <= f && d <= f || b <= g && e <= g || a >=
            h && d >= h || b >= n && e >= n)return !1;
        d = (e - b) / (d - a);
        e = d * (f - a) + b;
        if (e > g && e < n)return !0;
        e = d * (h - a) + b;
        if (e > g && e < n)return !0;
        g = (g - b) / d + a;
        if (g > f && g < h)return !0;
        g = (n - b) / d + a;
        return g > f && g < h ? !0 : !1
    }, aabbIntersectsSkeleton: function (a) {
        return this.minX < a.maxX && this.maxX > a.minX && this.minY < a.maxY && this.maxY > a.minY
    }, containsPoint: function (a, b) {
        for (var d = this.polygons, e = 0, f = d.length; e < f; e++)if (this.polygonContainsPoint(d[e], a, b))return this.boundingBoxes[e];
        return null
    }, intersectsSegment: function (a, b, d, e) {
        for (var f = this.polygons,
                 g = 0, h = f.length; g < h; g++)if (f[g].intersectsSegment(a, b, d, e))return this.boundingBoxes[g];
        return null
    }, polygonContainsPoint: function (a, b, d) {
        for (var e = a.length, f = e - 2, g = !1, h = 0; h < e; h += 2) {
            var n = a[h + 1], p = a[f + 1];
            if (n < d && p >= d || p < d && n >= d) {
                var r = a[h];
                r + (d - n) / (p - n) * (a[f] - r) < b && (g = !g)
            }
            f = h
        }
        return g
    }, polygonIntersectsSegment: function (a, b, d, e, f) {
        for (var g = a.length, h = b - e, n = d - f, p = b * f - d * e, r = a[g - 2], s = a[g - 1], t = 0; t < g; t += 2) {
            var v = a[t], u = a[t + 1], x = r * u - s * v, w = r - v, y = s - u, A = h * y - n * w, w = (p * w - h * x) / A;
            if ((w >= r && w <= v || w >= v && w <= r) && (w >=
                b && w <= e || w >= e && w <= b) && (r = (p * y - n * x) / A, (r >= s && r <= u || r >= u && r <= s) && (r >= d && r <= f || r >= f && r <= d)))return !0;
            r = v;
            s = u
        }
        return !1
    }, getPolygon: function (a) {
        a = this.boundingBoxes.indexOf(a);
        return -1 == a ? null : this.polygons[a]
    }, getWidth: function () {
        return this.maxX - this.minX
    }, getHeight: function () {
        return this.maxY - this.minY
    }
};
var sp = sp || {};
sp.VERTEX_INDEX = {X1: 0, Y1: 1, X2: 2, Y2: 3, X3: 4, Y3: 5, X4: 6, Y4: 7};
sp.ATTACHMENT_TYPE = {REGION: 0, BOUNDING_BOX: 1, MESH: 2, SKINNED_MESH: 3};
sp.Skeleton = cc.Node.extend({
    _skeleton: null,
    _rootBone: null,
    _timeScale: 1,
    _debugSlots: !1,
    _debugBones: !1,
    _premultipliedAlpha: !1,
    _ownsSkeletonData: null,
    _atlas: null,
    _blendFunc: null,
    ctor: function (a, b, d) {
        cc.Node.prototype.ctor.call(this);
        0 === arguments.length ? this.init() : this.initWithArgs(a, b, d)
    },
    _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new sp.Skeleton.CanvasRenderCmd(this) : new sp.Skeleton.WebGLRenderCmd(this)
    },
    init: function () {
        cc.Node.prototype.init.call(this);
        this._premultipliedAlpha =
            cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA;
        this._blendFunc = {src: cc.BLEND_SRC, dst: cc.BLEND_DST};
        this.scheduleUpdate()
    },
    setDebugSolots: function (a) {
        this._debugSlots = a
    },
    setDebugBones: function (a) {
        this._debugBones = a
    },
    setDebugSlotsEnabled: function (a) {
        this._debugSlots = a
    },
    getDebugSlotsEnabled: function () {
        return this._debugSlots
    },
    setDebugBonesEnabled: function (a) {
        this._debugBones = a
    },
    getDebugBonesEnabled: function () {
        return this._debugBones
    },
    setTimeScale: function (a) {
        this._timeScale =
            a
    },
    getTimeScale: function () {
        return this._timeScale
    },
    initWithArgs: function (a, b, d) {
        if (cc.isString(a)) {
            if (cc.isString(b)) {
                var e = cc.loader.getRes(b);
                sp._atlasLoader.setAtlasFile(b);
                b = new spine.Atlas(e, sp._atlasLoader)
            }
            d = d || 1 / cc.director.getContentScaleFactor();
            e = new spine.AtlasAttachmentLoader(b);
            e = new spine.SkeletonJson(e);
            e.scale = d;
            a = cc.loader.getRes(a);
            a = e.readSkeletonData(a);
            b.dispose(e);
            d = !0
        } else d = b;
        this.setSkeletonData(a, d);
        this.init()
    },
    getBoundingBox: function () {
        for (var a = cc.FLT_MAX, b = cc.FLT_MAX,
                 d = cc.FLT_MIN, e = cc.FLT_MIN, f = this.getScaleX(), g = this.getScaleY(), h = [], n = this._skeleton.slots, p = sp.VERTEX_INDEX, r = 0, s = n.length; r < s; ++r) {
            var t = n[r];
            t.attachment && t.attachment.type == sp.ATTACHMENT_TYPE.REGION && (this._computeRegionAttachmentWorldVertices(t.attachment, t.bone.skeleton.x, t.bone.skeleton.y, t.bone, h), a = Math.min(a, h[p.X1] * f, h[p.X4] * f, h[p.X2] * f, h[p.X3] * f), b = Math.min(b, h[p.Y1] * g, h[p.Y4] * g, h[p.Y2] * g, h[p.Y3] * g), d = Math.max(d, h[p.X1] * f, h[p.X4] * f, h[p.X2] * f, h[p.X3] * f), e = Math.max(e, h[p.Y1] * g, h[p.Y4] *
                g, h[p.Y2] * g, h[p.Y3] * g))
        }
        f = this.getPosition();
        return cc.rect(f.x + a, f.y + b, d - a, e - b)
    },
    _computeRegionAttachmentWorldVertices: function (a, b, d, e, f) {
        a = a.offset;
        var g = sp.VERTEX_INDEX;
        b += e.worldX;
        d += e.worldY;
        f[g.X1] = a[g.X1] * e.m00 + a[g.Y1] * e.m01 + b;
        f[g.Y1] = a[g.X1] * e.m10 + a[g.Y1] * e.m11 + d;
        f[g.X2] = a[g.X2] * e.m00 + a[g.Y2] * e.m01 + b;
        f[g.Y2] = a[g.X2] * e.m10 + a[g.Y2] * e.m11 + d;
        f[g.X3] = a[g.X3] * e.m00 + a[g.Y3] * e.m01 + b;
        f[g.Y3] = a[g.X3] * e.m10 + a[g.Y3] * e.m11 + d;
        f[g.X4] = a[g.X4] * e.m00 + a[g.Y4] * e.m01 + b;
        f[g.Y4] = a[g.X4] * e.m10 + a[g.Y4] * e.m11 + d
    },
    updateWorldTransform: function () {
        this._skeleton.updateWorldTransform()
    },
    setToSetupPose: function () {
        this._skeleton.setToSetupPose()
    },
    setBonesToSetupPose: function () {
        this._skeleton.setBonesToSetupPose()
    },
    setSlotsToSetupPose: function () {
        this._skeleton.setSlotsToSetupPose()
    },
    findBone: function (a) {
        return this._skeleton.findBone(a)
    },
    findSlot: function (a) {
        return this._skeleton.findSlot(a)
    },
    setSkin: function (a) {
        return this._skeleton.setSkinByName(a)
    },
    getAttachment: function (a, b) {
        return this._skeleton.getAttachmentBySlotName(a,
            b)
    },
    setAttachment: function (a, b) {
        this._skeleton.setAttachment(a, b)
    },
    setPremultipliedAlpha: function (a) {
        this._premultipliedAlpha = a
    },
    isPremultipliedAlpha: function () {
        return this._premultipliedAlpha
    },
    setSkeletonData: function (a, b) {
        null != a.width && null != a.height && this.setContentSize(a.width / cc.director.getContentScaleFactor(), a.height / cc.director.getContentScaleFactor());
        this._skeleton = new spine.Skeleton(a);
        this._skeleton.updateWorldTransform();
        this._rootBone = this._skeleton.getRootBone();
        this._ownsSkeletonData =
            b;
        this._renderCmd._createChildFormSkeletonData()
    },
    getTextureAtlas: function (a) {
        return a.rendererObject.page.rendererObject
    },
    getBlendFunc: function () {
        return this._blendFunc
    },
    setBlendFunc: function (a, b) {
        var d = this._blendFunc;
        void 0 === b ? (d.src = a.src, d.dst = a.dst) : (d.src = a, d.dst = b)
    },
    update: function (a) {
        this._skeleton.update(a)
    }
});
sp.Skeleton.create = function (a, b, d) {
    return new sp.Skeleton(a, b, d)
};
sp._atlasPage_createTexture_webGL = function (a, b) {
    var d = cc.textureCache.addImage(b);
    a.rendererObject = new cc.TextureAtlas(d, 128);
    a.width = d.getPixelsWide();
    a.height = d.getPixelsHigh()
};
sp._atlasPage_createTexture_canvas = function (a, b) {
    a._texture = cc.textureCache.addImage(b)
};
sp._atlasPage_disposeTexture = function (a) {
    a.rendererObject.release()
};
sp._atlasLoader = {
    spAtlasFile: null, setAtlasFile: function (a) {
        this.spAtlasFile = a
    }, load: function (a, b, d) {
        b = cc.path.join(cc.path.dirname(this.spAtlasFile), b);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL ? sp._atlasPage_createTexture_webGL(a, b) : sp._atlasPage_createTexture_canvas(a, b)
    }, unload: function (a) {
    }
};
sp.ANIMATION_EVENT_TYPE = {START: 0, END: 1, COMPLETE: 2, EVENT: 3};
sp.TrackEntryListeners = function (a, b, d, e) {
    this.startListener = a || null;
    this.endListener = b || null;
    this.completeListener = d || null;
    this.eventListener = e || null
};
sp.TrackEntryListeners.getListeners = function (a) {
    a.rendererObject || (a.rendererObject = new sp.TrackEntryListeners, a.listener = sp.trackEntryCallback);
    return a.rendererObject
};
sp.trackEntryCallback = function (a, b, d, e, f) {
    a.rendererObject.onTrackEntryEvent(b, d, e, f)
};
sp.SkeletonAnimation = sp.Skeleton.extend({
    _state: null,
    _target: null,
    _callback: null,
    _ownsAnimationStateData: !1,
    _startListener: null,
    _endListener: null,
    _completeListener: null,
    _eventListener: null,
    init: function () {
        sp.Skeleton.prototype.init.call(this);
        this._ownsAnimationStateData = !0;
        this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data))
    },
    setAnimationStateData: function (a) {
        a = new spine.AnimationState(a);
        a.rendererObject = this;
        a.onStart = this._onAnimationStateStart.bind(this);
        a.onComplete =
            this._onAnimationStateComplete.bind(this);
        a.onEnd = this._onAnimationStateEnd.bind(this);
        a.onEvent = this._onAnimationStateEvent.bind(this);
        this._state = a
    },
    setMix: function (a, b, d) {
        this._state.data.setMixByName(a, b, d)
    },
    setAnimationListener: function (a, b) {
        this._target = a;
        this._callback = b
    },
    setAnimation: function (a, b, d) {
        var e = this._skeleton.data.findAnimation(b);
        return e ? this._state.setAnimation(a, e, d) : (cc.log("Spine: Animation not found: " + b), null)
    },
    addAnimation: function (a, b, d, e) {
        e = null == e ? 0 : e;
        var f = this._skeleton.data.findAnimation(b);
        return f ? this._state.addAnimation(a, f, d, e) : (cc.log("Spine: Animation not found:" + b), null)
    },
    getCurrent: function (a) {
        return this._state.getCurrent(a)
    },
    clearTracks: function () {
        this._state.clearTracks()
    },
    clearTrack: function (a) {
        this._state.clearTrack(a)
    },
    update: function (a) {
        this._super(a);
        a *= this._timeScale;
        this._state.update(a);
        this._state.apply(this._skeleton);
        this._skeleton.updateWorldTransform();
        this._renderCmd._updateChild()
    },
    setStartListener: function (a) {
        this._startListener = a
    },
    setEndListener: function (a) {
        this._endListener =
            a
    },
    setCompleteListener: function (a) {
        this._completeListener = a
    },
    setEventListener: function (a) {
        this._eventListener = a
    },
    setTrackStartListener: function (a, b) {
        sp.TrackEntryListeners.getListeners(a).startListener = b
    },
    setTrackEndListener: function (a, b) {
        sp.TrackEntryListeners.getListeners(a).endListener = b
    },
    setTrackCompleteListener: function (a, b) {
        sp.TrackEntryListeners.getListeners(a).completeListener = b
    },
    setTrackEventListener: function (a, b) {
        sp.TrackEntryListeners.getListeners(a).eventListener = b
    },
    onTrackEntryEvent: function (a,
                                 b, d, e) {
        var f = this._state.getCurrent(a);
        if (f.rendererObject)switch (f = f.rendererObject, b) {
            case sp.ANIMATION_EVENT_TYPE.START:
                f.startListener && f.startListener(a);
                break;
            case sp.ANIMATION_EVENT_TYPE.END:
                f.endListener && f.endListener(a);
                break;
            case sp.ANIMATION_EVENT_TYPE.COMPLETE:
                f.completeListener && f.completeListener(a, e);
                break;
            case sp.ANIMATION_EVENT_TYPE.EVENT:
                f.eventListener && f.eventListener(a, d)
        }
    },
    onAnimationStateEvent: function (a, b, d, e) {
        switch (b) {
            case sp.ANIMATION_EVENT_TYPE.START:
                this._startListener &&
                this._startListener(a);
                break;
            case sp.ANIMATION_EVENT_TYPE.END:
                this._endListener && this._endListener(a);
                break;
            case sp.ANIMATION_EVENT_TYPE.COMPLETE:
                this._completeListener && this._completeListener(a, e);
                break;
            case sp.ANIMATION_EVENT_TYPE.EVENT:
                this._eventListener && this._eventListener(a, d)
        }
    },
    getState: function () {
        return this._state
    },
    _onAnimationStateStart: function (a) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.START, null, 0)
    },
    _onAnimationStateEnd: function (a) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.END,
            null, 0)
    },
    _onAnimationStateComplete: function (a, b) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.COMPLETE, null, b)
    },
    _onAnimationStateEvent: function (a, b) {
        this._animationStateCallback(a, sp.ANIMATION_EVENT_TYPE.EVENT, b, 0)
    },
    _animationStateCallback: function (a, b, d, e) {
        this.onAnimationStateEvent(a, b, d, e);
        this._target && this._callback && this._callback.call(this._target, this, a, b, d, e)
    }
});
sp.SkeletonAnimation.create = function (a, b, d) {
    return new sp.SkeletonAnimation(a, b, d)
};
(function () {
    sp.Skeleton.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = sp.Skeleton.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = sp.Skeleton.CanvasRenderCmd;
    a.rendering = function (a, d, e) {
        var f = this._node, g, h, n, p;
        a = a || cc._renderContext;
        var r = f._skeleton, s = r.drawOrder;
        g = 0;
        for (h = s.length; g < h; g++)n = s[g], p = n._slotNode, p._visible && p._renderCmd && n.currentSprite && (p._renderCmd.transform(this, !0), n.currentSprite._renderCmd.rendering(a,
            d, e), p._renderCmd._dirtyFlag = n.currentSprite._renderCmd._dirtyFlag = 0);
        if (f._debugSlots || f._debugBones) {
            a.setTransform(this._worldTransform, d, e);
            a.setGlobalAlpha(1);
            a = cc._drawingUtil;
            if (f._debugSlots)for (a.setDrawColor(0, 0, 255, 255), a.setLineWidth(1), e = [], g = 0, h = r.slots.length; g < h; g++)n = r.drawOrder[g], n.attachment && n.attachment.type == sp.ATTACHMENT_TYPE.REGION && (d = n.attachment, this._updateRegionAttachmentSlot(d, n, e), a.drawPoly(e, 4, !0));
            if (f._debugBones) {
                a.setLineWidth(2);
                a.setDrawColor(255, 0, 0, 255);
                g =
                    0;
                for (h = r.bones.length; g < h; g++)f = r.bones[g], a.drawLine({
                    x: f.worldX,
                    y: f.worldY
                }, {x: f.data.length * f.m00 + f.worldX, y: f.data.length * f.m10 + f.worldY});
                a.setPointSize(4);
                a.setDrawColor(0, 0, 255, 255);
                g = 0;
                for (h = r.bones.length; g < h; g++)f = r.bones[g], a.drawPoint({
                    x: f.worldX,
                    y: f.worldY
                }), 0 === g && a.setDrawColor(0, 255, 0, 255)
            }
        }
    };
    a._updateRegionAttachmentSlot = function (a, d, e) {
        if (e) {
            var f = {}, g = sp.VERTEX_INDEX;
            d = d.bone;
            a.computeVertices(d.skeleton.x, d.skeleton.y, d, f);
            e.length = 0;
            e.push(cc.p(f[g.X1], f[g.Y1]));
            e.push(cc.p(f[g.X4],
                f[g.Y4]));
            e.push(cc.p(f[g.X3], f[g.Y3]));
            e.push(cc.p(f[g.X2], f[g.Y2]))
        }
    };
    a._createChildFormSkeletonData = function () {
        for (var a = this._node._skeleton, d, e, f = 0, g = a.slots.length; f < g; f++) {
            var h = a.slots[f];
            e = h.attachment;
            var n = new cc.Node;
            h._slotNode = n;
            e instanceof spine.RegionAttachment && (d = e.rendererObject.name, e = this._createSprite(h, e), h.currentSprite = e, h.currentSpriteName = d, n.addChild(e))
        }
    };
    a._createSprite = function (a, d) {
        var e = d.rendererObject, f = new cc.Rect(e.x, e.y, e.width, e.height), g = new cc.Sprite;
        g.initWithTexture(e.page._texture,
            f, e.rotate, !1);
        g._rect.width = d.width;
        g._rect.height = d.height;
        g.setContentSize(d.width, d.height);
        g.setRotation(-d.rotation);
        g.setScale(e.width / e.originalWidth * d.scaleX, e.height / e.originalHeight * d.scaleY);
        a.sprites = a.sprites || {};
        return a.sprites[e.name] = g
    };
    a._updateChild = function () {
        var a = this._node._skeleton, d = a.slots, e, f, g, h, n, p;
        e = 0;
        for (f = d.length; e < f; e++)if (h = d[e], n = h.attachment, p = h._slotNode, n) {
            g = n.type;
            if (g === spine.AttachmentType.region) {
                if (n.rendererObject && (!h.currentSpriteName || h.currentSpriteName !==
                    n.name)) {
                    g = n.rendererObject.name;
                    void 0 !== h.currentSprite && h.currentSprite.setVisible(!1);
                    h.sprites = h.sprites || {};
                    if (void 0 !== h.sprites[g])h.sprites[g].setVisible(!0); else {
                        var r = this._createSprite(h, n);
                        p.addChild(r)
                    }
                    h.currentSprite = h.sprites[g];
                    h.currentSpriteName = g
                }
                r = h.bone;
                p.setPosition(r.worldX + n.x * r.m00 + n.y * r.m01, r.worldY + n.x * r.m10 + n.y * r.m11);
                p.setScale(r.worldScaleX, r.worldScaleY);
                g = h.currentSprite;
                g._flippedX = r.worldFlipX;
                g._flippedY = r.worldFlipY;
                g._flippedY || g._flippedX ? (p.setRotation(r.worldRotation),
                    g.setRotation(n.rotation)) : (p.setRotation(-r.worldRotation), g.setRotation(-n.rotation));
                g._renderCmd._displayedOpacity = 0 | a.a * h.a * 255;
                g.setColor(cc.color(0 | a.r * h.r * 255, 0 | a.g * h.g * 255, 0 | a.b * h.b * 255));
                g._renderCmd._updateColor()
            } else if (g !== spine.AttachmentType.skinnedmesh) {
                p.setVisible(!1);
                continue
            }
            p.setVisible(!0)
        } else p.setVisible(!1)
    }
})();
(function () {
    sp.Skeleton.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
        this._tmpQuad = new cc.V3F_C4B_T2F_Quad
    };
    var a = sp.Skeleton.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = sp.Skeleton.WebGLRenderCmd;
    a.rendering = function (a) {
        var d = this._node, e = this._tmpQuad, f = d.getColor();
        a = d._skeleton;
        var g, h, n, p, r, s = d._blendFunc, t = d._premultipliedAlpha;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        a.r = f.r / 255;
        a.g = f.g / 255;
        a.b = f.b / 255;
        a.a = d.getOpacity() / 255;
        t && (a.r *= a.a, a.g *= a.a, a.b *= a.a);
        f = 0;
        for (r = a.drawOrder.length; f < r; f++)if (p = a.drawOrder[f], p.attachment) {
            n = p.attachment;
            switch (p.attachment.type) {
                case sp.ATTACHMENT_TYPE.REGION:
                    this._updateRegionAttachmentQuad(n, p, e, t);
                    break;
                case sp.ATTACHMENT_TYPE.MESH:
                    this._updateMeshAttachmentQuad(n, p, e, t);
                    break;
                case sp.ATTACHMENT_TYPE.SKINNED_MESH:
                    break;
                default:
                    continue
            }
            n = d.getTextureAtlas(n);
            if (p.data.blendMode != g)switch (h && (h.drawQuads(), h.removeAllQuads()), g = p.data.blendMode, g) {
                case spine.BlendMode.additive:
                    cc.glBlendFunc(t ? cc.ONE : cc.SRC_ALPHA, cc.ONE);
                    break;
                case spine.BlendMode.multiply:
                    cc.glBlendFunc(cc.DST_COLOR, cc.ONE_MINUS_SRC_ALPHA);
                    break;
                case spine.BlendMode.screen:
                    cc.glBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_COLOR);
                    break;
                default:
                    cc.glBlendFunc(s.src, s.dst)
            } else n != h && h && (h.drawQuads(), h.removeAllQuads());
            h = n;
            p = h.getTotalQuads();
            if (h.getCapacity() == p && (h.drawQuads(), h.removeAllQuads(),
                    !h.resizeCapacity(2 * h.getCapacity())))return;
            h.updateQuad(e, p)
        }
        h && (h.drawQuads(), h.removeAllQuads());
        if (d._debugBones || d._debugSlots) {
            cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
            cc.current_stack.stack.push(cc.current_stack.top);
            cc.current_stack.top = this._stackMatrix;
            g = cc._drawingUtil;
            if (d._debugSlots)for (g.setDrawColor(0, 0, 255, 255), g.setLineWidth(1), f = 0, r = a.slots.length; f < r; f++)p = a.drawOrder[f], p.attachment && p.attachment.type == sp.ATTACHMENT_TYPE.REGION && (n = p.attachment, this._updateRegionAttachmentQuad(n,
                p, e), h = [], h.push(cc.p(e.bl.vertices.x, e.bl.vertices.y)), h.push(cc.p(e.br.vertices.x, e.br.vertices.y)), h.push(cc.p(e.tr.vertices.x, e.tr.vertices.y)), h.push(cc.p(e.tl.vertices.x, e.tl.vertices.y)), g.drawPoly(h, 4, !0));
            if (d._debugBones) {
                g.setLineWidth(2);
                g.setDrawColor(255, 0, 0, 255);
                f = 0;
                for (r = a.bones.length; f < r; f++)d = a.bones[f], e = d.data.length * d.m00 + d.worldX, h = d.data.length * d.m10 + d.worldY, g.drawLine(cc.p(d.worldX, d.worldY), cc.p(e, h));
                g.setPointSize(4);
                g.setDrawColor(0, 0, 255, 255);
                f = 0;
                for (r = a.bones.length; f <
                r; f++)d = a.bones[f], g.drawPoint(cc.p(d.worldX, d.worldY)), 0 == f && g.setDrawColor(0, 255, 0, 255)
            }
            cc.kmGLPopMatrix()
        }
    };
    a._createChildFormSkeletonData = function () {
    };
    a._updateChild = function () {
    };
    a._updateRegionAttachmentQuad = function (a, d, e, f) {
        var g = {};
        a.computeVertices(d.bone.skeleton.x, d.bone.skeleton.y, d.bone, g);
        var h = d.bone.skeleton.r * d.r * 255, n = d.bone.skeleton.g * d.g * 255, p = d.bone.skeleton.b * d.b * 255;
        d = d.bone.skeleton.a * d.a;
        f && (h *= d, n *= d, p *= d);
        e.bl.colors.r = e.tl.colors.r = e.tr.colors.r = e.br.colors.r = h;
        e.bl.colors.g =
            e.tl.colors.g = e.tr.colors.g = e.br.colors.g = n;
        e.bl.colors.b = e.tl.colors.b = e.tr.colors.b = e.br.colors.b = p;
        e.bl.colors.a = e.tl.colors.a = e.tr.colors.a = e.br.colors.a = 255 * d;
        f = sp.VERTEX_INDEX;
        e.bl.vertices.x = g[f.X1];
        e.bl.vertices.y = g[f.Y1];
        e.tl.vertices.x = g[f.X2];
        e.tl.vertices.y = g[f.Y2];
        e.tr.vertices.x = g[f.X3];
        e.tr.vertices.y = g[f.Y3];
        e.br.vertices.x = g[f.X4];
        e.br.vertices.y = g[f.Y4];
        e.bl.texCoords.u = a.uvs[f.X1];
        e.bl.texCoords.v = a.uvs[f.Y1];
        e.tl.texCoords.u = a.uvs[f.X2];
        e.tl.texCoords.v = a.uvs[f.Y2];
        e.tr.texCoords.u =
            a.uvs[f.X3];
        e.tr.texCoords.v = a.uvs[f.Y3];
        e.br.texCoords.u = a.uvs[f.X4];
        e.br.texCoords.v = a.uvs[f.Y4]
    };
    a._updateMeshAttachmentQuad = function (a, d, e, f) {
        var g = {};
        a.computeWorldVertices(d.bone.x, d.bone.y, d, g);
        var h = d.bone.skeleton.r * d.r * 255, n = d.bone.skeleton.g * d.g * 255, p = d.bone.skeleton.b * d.b * 255;
        d = d.bone.skeleton.a * d.a;
        f && (h *= d, n *= d, p *= d);
        e.bl.colors.r = e.tl.colors.r = e.tr.colors.r = e.br.colors.r = h;
        e.bl.colors.g = e.tl.colors.g = e.tr.colors.g = e.br.colors.g = n;
        e.bl.colors.b = e.tl.colors.b = e.tr.colors.b = e.br.colors.b =
            p;
        e.bl.colors.a = e.tl.colors.a = e.tr.colors.a = e.br.colors.a = 255 * d;
        f = sp.VERTEX_INDEX;
        e.bl.vertices.x = g[f.X1];
        e.bl.vertices.y = g[f.Y1];
        e.tl.vertices.x = g[f.X2];
        e.tl.vertices.y = g[f.Y2];
        e.tr.vertices.x = g[f.X3];
        e.tr.vertices.y = g[f.Y3];
        e.br.vertices.x = g[f.X4];
        e.br.vertices.y = g[f.Y4];
        e.bl.texCoords.u = a.uvs[f.X1];
        e.bl.texCoords.v = a.uvs[f.Y1];
        e.tl.texCoords.u = a.uvs[f.X2];
        e.tl.texCoords.v = a.uvs[f.Y2];
        e.tr.texCoords.u = a.uvs[f.X3];
        e.tr.texCoords.v = a.uvs[f.Y3];
        e.br.texCoords.u = a.uvs[f.X4];
        e.br.texCoords.v = a.uvs[f.Y4]
    }
})();
cc.pool = {
    _pool: {}, _releaseCB: function () {
        this.release()
    }, _autoRelease: function (a) {
        var b = void 0 === a._running ? !1 : !a._running;
        cc.director.getScheduler().schedule(this._releaseCB, a, 0, 0, 0, b)
    }, putInPool: function (a) {
        var b = a.constructor.prototype.__pid;
        if (!b) {
            var d = {writable: !0, enumerable: !1, configurable: !0};
            d.value = ClassManager.getNewID();
            Object.defineProperty(a.constructor.prototype, "__pid", d)
        }
        this._pool[b] || (this._pool[b] = []);
        a.retain && a.retain();
        a.unuse && a.unuse();
        this._pool[b].push(a)
    }, hasObject: function (a) {
        return (a =
            this._pool[a.prototype.__pid]) && 0 !== a.length ? !0 : !1
    }, removeObject: function (a) {
        var b = a.constructor.prototype.__pid;
        if (b && (b = this._pool[b]))for (var d = 0; d < b.length; d++)a === b[d] && (a.release && a.release(), b.splice(d, 1))
    }, getFromPool: function (a) {
        if (this.hasObject(a)) {
            var b = this._pool[a.prototype.__pid], d = Array.prototype.slice.call(arguments);
            d.shift();
            b = b.pop();
            b.reuse && b.reuse.apply(b, d);
            cc.sys.isNative && b.release && this._autoRelease(b);
            return b
        }
    }, drainAllPools: function () {
        for (var a in this._pool)for (var b =
            0; b < this._pool[a].length; b++) {
            var d = this._pool[a][b];
            d.release && d.release()
        }
        this._pool = {}
    }
};
(function () {
    cc.PhysicsSprite = cc.Sprite.extend({
        _ignoreBodyRotation: !1, _body: null, _rotation: 1, ctor: function (a, d) {
            cc.Sprite.prototype.ctor.call(this);
            if (void 0 === a)cc.PhysicsSprite.prototype.init.call(this); else if (cc.isString(a))if ("#" === a[0]) {
                var e = a.substr(1, a.length - 1), e = cc.spriteFrameCache.getSpriteFrame(e);
                this.initWithSpriteFrame(e)
            } else this.init(a, d); else cc.isObject(a) && (a instanceof cc.Texture2D ? this.initWithTexture(a, d) : a instanceof cc.SpriteFrame && this.initWithSpriteFrame(a));
            cc.renderer.pushRenderCommand(this._renderCmd)
        },
        visit: function () {
            cc.renderer.pushRenderCommand(this._renderCmd);
            cc.Sprite.prototype.visit.call(this)
        }, setBody: function (a) {
            this._body = a
        }, getBody: function () {
            return this._body
        }, getPosition: function () {
            var a = this._body;
            return {x: a.p.x, y: a.p.y}
        }, getPositionX: function () {
            return this._body.p.x
        }, getPositionY: function () {
            return this._body.p.y
        }, setPosition: function (a, d) {
            void 0 === d ? (this._body.p.x = a.x, this._body.p.y = a.y) : (this._body.p.x = a, this._body.p.y = d)
        }, setPositionX: function (a) {
            this._body.p.x = a
        }, setPositionY: function (a) {
            this._body.p.y =
                a
        }, _syncPosition: function () {
            var a = this._position, d = this._body;
            a.x === d.p.x && a.y === d.p.y || cc.Sprite.prototype.setPosition.call(this, d.p.x, d.p.y)
        }, getRotation: function () {
            return this._ignoreBodyRotation ? this._rotationX : -cc.radiansToDegrees(this._body.a)
        }, setRotation: function (a) {
            this._ignoreBodyRotation ? cc.Sprite.prototype.setRotation.call(this, a) : this._body.a = -cc.degreesToRadians(a)
        }, _syncRotation: function () {
            this._rotationX !== -cc.radiansToDegrees(this._body.a) && cc.Sprite.prototype.setRotation.call(this,
                -cc.radiansToDegrees(this._body.a))
        }, getNodeToParentTransform: function () {
            return this._renderCmd.getNodeToParentTransform()
        }, isDirty: function () {
            return !this._body.isSleeping()
        }, setDirty: function () {
        }, setIgnoreBodyRotation: function (a) {
            this._ignoreBodyRotation = a
        }, _createRenderCmd: function () {
            return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.PhysicsSprite.CanvasRenderCmd(this) : new cc.PhysicsSprite.WebGLRenderCmd(this)
        }
    });
    cc.PhysicsSprite._className = "PhysicsSprite";
    var a = cc.PhysicsSprite.prototype;
    cc.defineGetterSetter(a, "body", a.getBody, a.setBody);
    cc.defineGetterSetter(a, "dirty", a.isDirty, a.setDirty);
    cc.PhysicsSprite.create = function (a, d) {
        return new cc.PhysicsSprite(a, d)
    };
    cc.PhysicsSprite.createWithSpriteFrameName = cc.PhysicsSprite.create;
    cc.PhysicsSprite.createWithSpriteFrame = cc.PhysicsSprite.create
})();
cc.__convertVerts = function (a) {
    for (var b = [], d = 0; d < a.length / 2; d++)b[d] = {x: a[2 * d], y: a[2 * d + 1]};
    return b
};
cc.ColorForBody = function (a) {
    return a.isRogue() || a.isSleeping() ? cc.color(128, 128, 128, 128) : a.nodeIdleTime > a.space.sleepTimeThreshold ? cc.color(84, 84, 84, 128) : cc.color(255, 0, 0, 128)
};
cc.DrawShape = function (a, b) {
    var d = a.body, e = cc.ColorForBody(d);
    switch (a.collisionCode) {
        case cp.CircleShape.prototype.collisionCode:
            this.drawDot(a.tc, Math.max(a.r, 1), e);
            this.drawSegment(a.tc, cp.v.add(a.tc, cp.v.mult(d.rot, a.r)), 1, e);
            break;
        case cp.SegmentShape.prototype.collisionCode:
            this.drawSegment(a.ta, a.tb, Math.max(a.r, 2), e);
            break;
        case cp.PolyShape.prototype.collisionCode:
            d = cc.color(e.r, e.g, e.b, cc.lerp(e.a, 255, 0.5));
            this.drawPoly(cc.__convertVerts(a.tVerts), e, 1, d);
            break;
        default:
            cc.log("cc.DrawShape(): Bad assertion in DrawShape()")
    }
};
cc.DrawConstraint = function (a, b) {
    var d = a.a, e = a.b, f;
    a instanceof cp.PinJoint ? (f = d.local2World(a.anchr1), d = e.local2World(a.anchr2), this.drawDot(f, 3, cc.CONSTRAINT_COLOR), this.drawDot(d, 3, cc.CONSTRAINT_COLOR), this.drawSegment(f, d, 1, cc.CONSTRAINT_COLOR)) : a instanceof cp.SlideJoint ? (f = d.local2World(a.anchr1), d = e.local2World(a.anchr2), this.drawDot(f, 3, cc.CONSTRAINT_COLOR), this.drawDot(d, 3, cc.CONSTRAINT_COLOR), this.drawSegment(f, d, 1, cc.CONSTRAINT_COLOR)) : a instanceof cp.PivotJoint ? (f = d.local2World(a.anchr1),
        d = e.local2World(a.anchr2), this.drawDot(f, 3, cc.CONSTRAINT_COLOR), this.drawDot(d, 3, cc.CONSTRAINT_COLOR)) : a instanceof cp.GrooveJoint && (f = d.local2World(a.grv_a), d = d.local2World(a.grv_b), e = e.local2World(a.anchr2), this.drawDot(e, 3, cc.CONSTRAINT_COLOR), this.drawSegment(f, d, 1, cc.CONSTRAINT_COLOR))
};
cc.CONSTRAINT_COLOR = cc.color(0, 255, 0, 128);
cc.PhysicsDebugNode = cc.DrawNode.extend({
    _space: null, _className: "PhysicsDebugNode", ctor: function (a) {
        cc.DrawNode.prototype.ctor.call(this);
        this._space = a
    }, getSpace: function () {
        return this._space
    }, setSpace: function (a) {
        this._space = a
    }, draw: function (a) {
        this._space && (this._space.eachShape(cc.DrawShape.bind(this)), this._space.eachConstraint(cc.DrawConstraint.bind(this)), cc.DrawNode.prototype.draw.call(this), this.clear())
    }, _createRenderCmd: function () {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.PhysicsDebugNode.CanvasRenderCmd(this) :
            new cc.PhysicsDebugNode.WebGLRenderCmd(this)
    }
});
cc.PhysicsDebugNode.create = function (a) {
    return new cc.PhysicsDebugNode(a)
};
(function () {
    cc.PhysicsDebugNode.CanvasRenderCmd = function (a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._buffer = a._buffer;
        this._needDraw = !0
    };
    var a = cc.PhysicsDebugNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.PhysicsDebugNode.CanvasRenderCmd;
    a.rendering = function (a, d, e) {
        var f = this._node;
        f._space && (f._space.eachShape(cc.DrawShape.bind(f)), f._space.eachConstraint(cc.DrawConstraint.bind(f)), cc.DrawNode.CanvasRenderCmd.prototype.rendering.call(this, a, d, e),
            f.clear())
    };
    a._drawDot = cc.DrawNode.CanvasRenderCmd.prototype._drawDot;
    a._drawSegment = cc.DrawNode.CanvasRenderCmd.prototype._drawSegment;
    a._drawPoly = cc.DrawNode.CanvasRenderCmd.prototype._drawPoly
})();
(function () {
    cc.PhysicsDebugNode.WebGLRenderCmd = function (a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    cc.PhysicsDebugNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.PhysicsDebugNode.WebGLRenderCmd.prototype.constructor = cc.PhysicsDebugNode.WebGLRenderCmd;
    cc.PhysicsDebugNode.WebGLRenderCmd.prototype.rendering = function (a) {
        a = this._node;
        a._space && (a._space.eachShape(cc.DrawShape.bind(a)), a._space.eachConstraint(cc.DrawConstraint.bind(a)), cc.glBlendFunc(a._blendFunc.src,
            a._blendFunc.dst), this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._render(), a.clear())
    }
})();
(function () {
    cc.PhysicsSprite.CanvasRenderCmd = function (a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.PhysicsSprite.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    a.constructor = cc.PhysicsSprite.CanvasRenderCmd;
    a.rendering = function (a, d, e) {
        var f = this._node;
        f._syncPosition();
        f._ignoreBodyRotation || f._syncRotation();
        this.transform(this.getParentRenderCmd());
        cc.Sprite.CanvasRenderCmd.prototype.rendering.call(this, a, d, e)
    };
    a.getNodeToParentTransform = function () {
        var a =
            this._node, d = this._transform, e = a._body, f = a._scaleX, g = a._scaleY, h = this._anchorPointInPoints;
        d.tx = e.p.x;
        d.ty = e.p.y;
        var e = -e.a, n = 1, p = 0;
        e && !a._ignoreBodyRotation && (n = Math.cos(e), p = Math.sin(e));
        d.a = d.d = n;
        d.b = -p;
        d.c = p;
        if (1 !== f || 1 !== g)d.a *= f, d.c *= f, d.b *= g, d.d *= g;
        d.tx += n * -h.x * f + -p * h.y * g;
        d.ty -= p * -h.x * f + n * h.y * g;
        this._ignoreAnchorPointForPosition && (d.tx += h.x, d.ty += h.y);
        return this._transform
    }
})();
(function () {
    cc.PhysicsSprite.WebGLRenderCmd = function (a) {
        cc.Sprite.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.PhysicsSprite.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    a.constructor = cc.PhysicsSprite.WebGLRenderCmd;
    a.rendering = function (a) {
        var d = this._node;
        d._syncPosition();
        d._ignoreBodyRotation || d._syncRotation();
        this.transform(this.getParentRenderCmd(), !0);
        cc.Sprite.WebGLRenderCmd.prototype.rendering.call(this, a)
    };
    a.getNodeToParentTransform = function () {
        var a =
            this._node, d = a._body, e = this._anchorPointInPoints, f = a._scaleX, g = a._scaleY, h = d.p.x, n = d.p.y;
        this._ignoreAnchorPointForPosition && (h += e.x, n += e.y);
        var d = d.a, p = 1, r = 0;
        d && !a._ignoreBodyRotation && (p = Math.cos(d), r = Math.sin(d));
        cc._rectEqualToZero(e) || (h += p * -e.x * f + -r * -e.y * g, n += r * -e.x * f + p * -e.y * g);
        return this._transform = cc.affineTransformMake(p * f, r * f, -r * g, p * g, h, n)
    };
    a.updateTransform = function () {
        var a = this._node;
        a.isDirty() && (a = a._renderCmd) && a.setDirtyRecursively(!0);
        cc.Sprite.WebGLRenderCmd.prototype.updateTransform.call(this)
    }
})();
var Box2D = {};
(function (a, b) {
    function d() {
    }

    !(Object.defineProperty instanceof Function) && Object.prototype.__defineGetter__ instanceof Function && Object.prototype.__defineSetter__ instanceof Function && (Object.defineProperty = function (a, b, d) {
        d.get instanceof Function && a.__defineGetter__(b, d.get);
        d.set instanceof Function && a.__defineSetter__(b, d.set)
    });
    a.inherit = function (a, b) {
        d.prototype = b.prototype;
        a.prototype = new d;
        a.prototype.constructor = a
    };
    a.generateCallback = function (a, b) {
        return function () {
            b.apply(a, arguments)
        }
    };
    a.NVector = function (a) {
        a === b && (a = 0);
        for (var d = Array(a || 0), g = 0; g < a; ++g)d[g] = 0;
        return d
    };
    a.is = function (a, d) {
        return null === a ? !1 : d instanceof Function && a instanceof d || a.constructor.__implements != b && a.constructor.__implements[d] ? !0 : !1
    };
    a.parseUInt = function (a) {
        return Math.abs(parseInt(a))
    }
})(Box2D);
var Vector = Array, Vector_a2j_Number = Box2D.NVector;
"undefined" === typeof Box2D && (Box2D = {});
"undefined" === typeof Box2D.Collision && (Box2D.Collision = {});
"undefined" === typeof Box2D.Collision.Shapes && (Box2D.Collision.Shapes = {});
"undefined" === typeof Box2D.Common && (Box2D.Common = {});
"undefined" === typeof Box2D.Common.Math && (Box2D.Common.Math = {});
"undefined" === typeof Box2D.Dynamics && (Box2D.Dynamics = {});
"undefined" === typeof Box2D.Dynamics.Contacts && (Box2D.Dynamics.Contacts = {});
"undefined" === typeof Box2D.Dynamics.Controllers && (Box2D.Dynamics.Controllers = {});
"undefined" === typeof Box2D.Dynamics.Joints && (Box2D.Dynamics.Joints = {});
(function () {
    function a() {
        a.b2AABB.apply(this, arguments)
    }

    function b() {
        b.b2Bound.apply(this, arguments)
    }

    function d() {
        d.b2BoundValues.apply(this, arguments);
        this.constructor === d && this.b2BoundValues.apply(this, arguments)
    }

    function e() {
        e.b2Collision.apply(this, arguments)
    }

    function f() {
        f.b2ContactID.apply(this, arguments);
        this.constructor === f && this.b2ContactID.apply(this, arguments)
    }

    function g() {
        g.b2ContactPoint.apply(this, arguments)
    }

    function h() {
        h.b2Distance.apply(this, arguments)
    }

    function n() {
        n.b2DistanceInput.apply(this,
            arguments)
    }

    function p() {
        p.b2DistanceOutput.apply(this, arguments)
    }

    function r() {
        r.b2DistanceProxy.apply(this, arguments)
    }

    function s() {
        s.b2DynamicTree.apply(this, arguments);
        this.constructor === s && this.b2DynamicTree.apply(this, arguments)
    }

    function t() {
        t.b2DynamicTreeBroadPhase.apply(this, arguments)
    }

    function v() {
        v.b2DynamicTreeNode.apply(this, arguments)
    }

    function u() {
        u.b2DynamicTreePair.apply(this, arguments)
    }

    function x() {
        x.b2Manifold.apply(this, arguments);
        this.constructor === x && this.b2Manifold.apply(this, arguments)
    }

    function w() {
        w.b2ManifoldPoint.apply(this, arguments);
        this.constructor === w && this.b2ManifoldPoint.apply(this, arguments)
    }

    function y() {
        y.b2Point.apply(this, arguments)
    }

    function A() {
        A.b2RayCastInput.apply(this, arguments);
        this.constructor === A && this.b2RayCastInput.apply(this, arguments)
    }

    function D() {
        D.b2RayCastOutput.apply(this, arguments)
    }

    function G() {
        G.b2Segment.apply(this, arguments)
    }

    function B() {
        B.b2SeparationFunction.apply(this, arguments)
    }

    function C() {
        C.b2Simplex.apply(this, arguments);
        this.constructor ===
        C && this.b2Simplex.apply(this, arguments)
    }

    function E() {
        E.b2SimplexCache.apply(this, arguments)
    }

    function I() {
        I.b2SimplexVertex.apply(this, arguments)
    }

    function L() {
        L.b2TimeOfImpact.apply(this, arguments)
    }

    function J() {
        J.b2TOIInput.apply(this, arguments)
    }

    function Q() {
        Q.b2WorldManifold.apply(this, arguments);
        this.constructor === Q && this.b2WorldManifold.apply(this, arguments)
    }

    function M() {
        M.ClipVertex.apply(this, arguments)
    }

    function K() {
        K.Features.apply(this, arguments)
    }

    function H() {
        H.b2CircleShape.apply(this, arguments);
        this.constructor === H && this.b2CircleShape.apply(this, arguments)
    }

    function P() {
        P.b2EdgeChainDef.apply(this, arguments);
        this.constructor === P && this.b2EdgeChainDef.apply(this, arguments)
    }

    function U() {
        U.b2EdgeShape.apply(this, arguments);
        this.constructor === U && this.b2EdgeShape.apply(this, arguments)
    }

    function O() {
        O.b2MassData.apply(this, arguments)
    }

    function Y() {
        Y.b2PolygonShape.apply(this, arguments);
        this.constructor === Y && this.b2PolygonShape.apply(this, arguments)
    }

    function V() {
        V.b2Shape.apply(this, arguments);
        this.constructor ===
        V && this.b2Shape.apply(this, arguments)
    }

    function F() {
        F.b2Color.apply(this, arguments);
        this.constructor === F && this.b2Color.apply(this, arguments)
    }

    function N() {
        N.b2Settings.apply(this, arguments)
    }

    function W() {
        W.b2Mat22.apply(this, arguments);
        this.constructor === W && this.b2Mat22.apply(this, arguments)
    }

    function R() {
        R.b2Mat33.apply(this, arguments);
        this.constructor === R && this.b2Mat33.apply(this, arguments)
    }

    function X() {
        X.b2Math.apply(this, arguments)
    }

    function fa() {
        fa.b2Sweep.apply(this, arguments)
    }

    function sa() {
        sa.b2Transform.apply(this,
            arguments);
        this.constructor === sa && this.b2Transform.apply(this, arguments)
    }

    function ma() {
        ma.b2Vec2.apply(this, arguments);
        this.constructor === ma && this.b2Vec2.apply(this, arguments)
    }

    function ba() {
        ba.b2Vec3.apply(this, arguments);
        this.constructor === ba && this.b2Vec3.apply(this, arguments)
    }

    function ua() {
        ua.b2Body.apply(this, arguments);
        this.constructor === ua && this.b2Body.apply(this, arguments)
    }

    function oa() {
        oa.b2BodyDef.apply(this, arguments);
        this.constructor === oa && this.b2BodyDef.apply(this, arguments)
    }

    function pa() {
        pa.b2ContactFilter.apply(this,
            arguments)
    }

    function Ca() {
        Ca.b2ContactImpulse.apply(this, arguments)
    }

    function la() {
        la.b2ContactListener.apply(this, arguments)
    }

    function Da() {
        Da.b2ContactManager.apply(this, arguments);
        this.constructor === Da && this.b2ContactManager.apply(this, arguments)
    }

    function ca() {
        ca.b2DebugDraw.apply(this, arguments);
        this.constructor === ca && this.b2DebugDraw.apply(this, arguments)
    }

    function Ea() {
        Ea.b2DestructionListener.apply(this, arguments)
    }

    function ob() {
        ob.b2FilterData.apply(this, arguments)
    }

    function S() {
        S.b2Fixture.apply(this,
            arguments);
        this.constructor === S && this.b2Fixture.apply(this, arguments)
    }

    function va() {
        va.b2FixtureDef.apply(this, arguments);
        this.constructor === va && this.b2FixtureDef.apply(this, arguments)
    }

    function wa() {
        wa.b2Island.apply(this, arguments);
        this.constructor === wa && this.b2Island.apply(this, arguments)
    }

    function Ia() {
        Ia.b2TimeStep.apply(this, arguments)
    }

    function xa() {
        xa.b2World.apply(this, arguments);
        this.constructor === xa && this.b2World.apply(this, arguments)
    }

    function $() {
        $.b2CircleContact.apply(this, arguments)
    }

    function Xa() {
        Xa.b2Contact.apply(this,
            arguments);
        this.constructor === Xa && this.b2Contact.apply(this, arguments)
    }

    function ea() {
        ea.b2ContactConstraint.apply(this, arguments);
        this.constructor === ea && this.b2ContactConstraint.apply(this, arguments)
    }

    function pb() {
        pb.b2ContactConstraintPoint.apply(this, arguments)
    }

    function ha() {
        ha.b2ContactEdge.apply(this, arguments)
    }

    function Ya() {
        Ya.b2ContactFactory.apply(this, arguments);
        this.constructor === Ya && this.b2ContactFactory.apply(this, arguments)
    }

    function Za() {
        Za.b2ContactRegister.apply(this, arguments)
    }

    function Ua() {
        Ua.b2ContactResult.apply(this,
            arguments)
    }

    function Fa() {
        Fa.b2ContactSolver.apply(this, arguments);
        this.constructor === Fa && this.b2ContactSolver.apply(this, arguments)
    }

    function Va() {
        Va.b2EdgeAndCircleContact.apply(this, arguments)
    }

    function Ga() {
        Ga.b2NullContact.apply(this, arguments);
        this.constructor === Ga && this.b2NullContact.apply(this, arguments)
    }

    function ra() {
        ra.b2PolyAndCircleContact.apply(this, arguments)
    }

    function Ha() {
        Ha.b2PolyAndEdgeContact.apply(this, arguments)
    }

    function Wa() {
        Wa.b2PolygonContact.apply(this, arguments)
    }

    function qa() {
        qa.b2PositionSolverManifold.apply(this,
            arguments);
        this.constructor === qa && this.b2PositionSolverManifold.apply(this, arguments)
    }

    function $a() {
        $a.b2BuoyancyController.apply(this, arguments)
    }

    function ab() {
        ab.b2ConstantAccelController.apply(this, arguments)
    }

    function qb() {
        qb.b2ConstantForceController.apply(this, arguments)
    }

    function bb() {
        bb.b2Controller.apply(this, arguments)
    }

    function Ja() {
        Ja.b2ControllerEdge.apply(this, arguments)
    }

    function Ka() {
        Ka.b2GravityController.apply(this, arguments)
    }

    function na() {
        na.b2TensorDampingController.apply(this, arguments)
    }

    function aa() {
        aa.b2DistanceJoint.apply(this, arguments);
        this.constructor === aa && this.b2DistanceJoint.apply(this, arguments)
    }

    function La() {
        La.b2DistanceJointDef.apply(this, arguments);
        this.constructor === La && this.b2DistanceJointDef.apply(this, arguments)
    }

    function Ma() {
        Ma.b2FrictionJoint.apply(this, arguments);
        this.constructor === Ma && this.b2FrictionJoint.apply(this, arguments)
    }

    function cb() {
        cb.b2FrictionJointDef.apply(this, arguments);
        this.constructor === cb && this.b2FrictionJointDef.apply(this, arguments)
    }

    function db() {
        db.b2GearJoint.apply(this,
            arguments);
        this.constructor === db && this.b2GearJoint.apply(this, arguments)
    }

    function eb() {
        eb.b2GearJointDef.apply(this, arguments);
        this.constructor === eb && this.b2GearJointDef.apply(this, arguments)
    }

    function ia() {
        ia.b2Jacobian.apply(this, arguments)
    }

    function da() {
        da.b2Joint.apply(this, arguments);
        this.constructor === da && this.b2Joint.apply(this, arguments)
    }

    function ja() {
        ja.b2JointDef.apply(this, arguments);
        this.constructor === ja && this.b2JointDef.apply(this, arguments)
    }

    function Na() {
        Na.b2JointEdge.apply(this, arguments)
    }

    function Oa() {
        Oa.b2LineJoint.apply(this, arguments);
        this.constructor === Oa && this.b2LineJoint.apply(this, arguments)
    }

    function Pa() {
        Pa.b2LineJointDef.apply(this, arguments);
        this.constructor === Pa && this.b2LineJointDef.apply(this, arguments)
    }

    function Qa() {
        Qa.b2MouseJoint.apply(this, arguments);
        this.constructor === Qa && this.b2MouseJoint.apply(this, arguments)
    }

    function Ra() {
        Ra.b2MouseJointDef.apply(this, arguments);
        this.constructor === Ra && this.b2MouseJointDef.apply(this, arguments)
    }

    function ya() {
        ya.b2PrismaticJoint.apply(this,
            arguments);
        this.constructor === ya && this.b2PrismaticJoint.apply(this, arguments)
    }

    function Sa() {
        Sa.b2PrismaticJointDef.apply(this, arguments);
        this.constructor === Sa && this.b2PrismaticJointDef.apply(this, arguments)
    }

    function T() {
        T.b2PulleyJoint.apply(this, arguments);
        this.constructor === T && this.b2PulleyJoint.apply(this, arguments)
    }

    function ga() {
        ga.b2PulleyJointDef.apply(this, arguments);
        this.constructor === ga && this.b2PulleyJointDef.apply(this, arguments)
    }

    function za() {
        za.b2RevoluteJoint.apply(this, arguments);
        this.constructor ===
        za && this.b2RevoluteJoint.apply(this, arguments)
    }

    function fb() {
        fb.b2RevoluteJointDef.apply(this, arguments);
        this.constructor === fb && this.b2RevoluteJointDef.apply(this, arguments)
    }

    function Aa() {
        Aa.b2WeldJoint.apply(this, arguments);
        this.constructor === Aa && this.b2WeldJoint.apply(this, arguments)
    }

    function Ba() {
        Ba.b2WeldJointDef.apply(this, arguments);
        this.constructor === Ba && this.b2WeldJointDef.apply(this, arguments)
    }

    Box2D.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase";
    Box2D.Collision.b2AABB = a;
    Box2D.Collision.b2Bound =
        b;
    Box2D.Collision.b2BoundValues = d;
    Box2D.Collision.b2Collision = e;
    Box2D.Collision.b2ContactID = f;
    Box2D.Collision.b2ContactPoint = g;
    Box2D.Collision.b2Distance = h;
    Box2D.Collision.b2DistanceInput = n;
    Box2D.Collision.b2DistanceOutput = p;
    Box2D.Collision.b2DistanceProxy = r;
    Box2D.Collision.b2DynamicTree = s;
    Box2D.Collision.b2DynamicTreeBroadPhase = t;
    Box2D.Collision.b2DynamicTreeNode = v;
    Box2D.Collision.b2DynamicTreePair = u;
    Box2D.Collision.b2Manifold = x;
    Box2D.Collision.b2ManifoldPoint = w;
    Box2D.Collision.b2Point = y;
    Box2D.Collision.b2RayCastInput =
        A;
    Box2D.Collision.b2RayCastOutput = D;
    Box2D.Collision.b2Segment = G;
    Box2D.Collision.b2SeparationFunction = B;
    Box2D.Collision.b2Simplex = C;
    Box2D.Collision.b2SimplexCache = E;
    Box2D.Collision.b2SimplexVertex = I;
    Box2D.Collision.b2TimeOfImpact = L;
    Box2D.Collision.b2TOIInput = J;
    Box2D.Collision.b2WorldManifold = Q;
    Box2D.Collision.ClipVertex = M;
    Box2D.Collision.Features = K;
    Box2D.Collision.Shapes.b2CircleShape = H;
    Box2D.Collision.Shapes.b2EdgeChainDef = P;
    Box2D.Collision.Shapes.b2EdgeShape = U;
    Box2D.Collision.Shapes.b2MassData = O;
    Box2D.Collision.Shapes.b2PolygonShape = Y;
    Box2D.Collision.Shapes.b2Shape = V;
    Box2D.Common.b2internal = "Box2D.Common.b2internal";
    Box2D.Common.b2Color = F;
    Box2D.Common.b2Settings = N;
    Box2D.Common.Math.b2Mat22 = W;
    Box2D.Common.Math.b2Mat33 = R;
    Box2D.Common.Math.b2Math = X;
    Box2D.Common.Math.b2Sweep = fa;
    Box2D.Common.Math.b2Transform = sa;
    Box2D.Common.Math.b2Vec2 = ma;
    Box2D.Common.Math.b2Vec3 = ba;
    Box2D.Dynamics.b2Body = ua;
    Box2D.Dynamics.b2BodyDef = oa;
    Box2D.Dynamics.b2ContactFilter = pa;
    Box2D.Dynamics.b2ContactImpulse = Ca;
    Box2D.Dynamics.b2ContactListener =
        la;
    Box2D.Dynamics.b2ContactManager = Da;
    Box2D.Dynamics.b2DebugDraw = ca;
    Box2D.Dynamics.b2DestructionListener = Ea;
    Box2D.Dynamics.b2FilterData = ob;
    Box2D.Dynamics.b2Fixture = S;
    Box2D.Dynamics.b2FixtureDef = va;
    Box2D.Dynamics.b2Island = wa;
    Box2D.Dynamics.b2TimeStep = Ia;
    Box2D.Dynamics.b2World = xa;
    Box2D.Dynamics.Contacts.b2CircleContact = $;
    Box2D.Dynamics.Contacts.b2Contact = Xa;
    Box2D.Dynamics.Contacts.b2ContactConstraint = ea;
    Box2D.Dynamics.Contacts.b2ContactConstraintPoint = pb;
    Box2D.Dynamics.Contacts.b2ContactEdge = ha;
    Box2D.Dynamics.Contacts.b2ContactFactory =
        Ya;
    Box2D.Dynamics.Contacts.b2ContactRegister = Za;
    Box2D.Dynamics.Contacts.b2ContactResult = Ua;
    Box2D.Dynamics.Contacts.b2ContactSolver = Fa;
    Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = Va;
    Box2D.Dynamics.Contacts.b2NullContact = Ga;
    Box2D.Dynamics.Contacts.b2PolyAndCircleContact = ra;
    Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = Ha;
    Box2D.Dynamics.Contacts.b2PolygonContact = Wa;
    Box2D.Dynamics.Contacts.b2PositionSolverManifold = qa;
    Box2D.Dynamics.Controllers.b2BuoyancyController = $a;
    Box2D.Dynamics.Controllers.b2ConstantAccelController =
        ab;
    Box2D.Dynamics.Controllers.b2ConstantForceController = qb;
    Box2D.Dynamics.Controllers.b2Controller = bb;
    Box2D.Dynamics.Controllers.b2ControllerEdge = Ja;
    Box2D.Dynamics.Controllers.b2GravityController = Ka;
    Box2D.Dynamics.Controllers.b2TensorDampingController = na;
    Box2D.Dynamics.Joints.b2DistanceJoint = aa;
    Box2D.Dynamics.Joints.b2DistanceJointDef = La;
    Box2D.Dynamics.Joints.b2FrictionJoint = Ma;
    Box2D.Dynamics.Joints.b2FrictionJointDef = cb;
    Box2D.Dynamics.Joints.b2GearJoint = db;
    Box2D.Dynamics.Joints.b2GearJointDef = eb;
    Box2D.Dynamics.Joints.b2Jacobian = ia;
    Box2D.Dynamics.Joints.b2Joint = da;
    Box2D.Dynamics.Joints.b2JointDef = ja;
    Box2D.Dynamics.Joints.b2JointEdge = Na;
    Box2D.Dynamics.Joints.b2LineJoint = Oa;
    Box2D.Dynamics.Joints.b2LineJointDef = Pa;
    Box2D.Dynamics.Joints.b2MouseJoint = Qa;
    Box2D.Dynamics.Joints.b2MouseJointDef = Ra;
    Box2D.Dynamics.Joints.b2PrismaticJoint = ya;
    Box2D.Dynamics.Joints.b2PrismaticJointDef = Sa;
    Box2D.Dynamics.Joints.b2PulleyJoint = T;
    Box2D.Dynamics.Joints.b2PulleyJointDef = ga;
    Box2D.Dynamics.Joints.b2RevoluteJoint =
        za;
    Box2D.Dynamics.Joints.b2RevoluteJointDef = fb;
    Box2D.Dynamics.Joints.b2WeldJoint = Aa;
    Box2D.Dynamics.Joints.b2WeldJointDef = Ba
})();
Box2D.postDefs = [];
(function () {
    var a = Box2D.Collision.Shapes.b2CircleShape, b = Box2D.Collision.Shapes.b2PolygonShape, d = Box2D.Collision.Shapes.b2Shape, e = Box2D.Common.b2Settings, f = Box2D.Common.Math.b2Math, g = Box2D.Common.Math.b2Sweep, h = Box2D.Common.Math.b2Transform, n = Box2D.Common.Math.b2Vec2, p = Box2D.Collision.b2AABB, r = Box2D.Collision.b2Bound, s = Box2D.Collision.b2BoundValues, t = Box2D.Collision.b2Collision, v = Box2D.Collision.b2ContactID, u = Box2D.Collision.b2ContactPoint, x = Box2D.Collision.b2Distance, w = Box2D.Collision.b2DistanceInput,
        y = Box2D.Collision.b2DistanceOutput, A = Box2D.Collision.b2DistanceProxy, D = Box2D.Collision.b2DynamicTree, G = Box2D.Collision.b2DynamicTreeBroadPhase, B = Box2D.Collision.b2DynamicTreeNode, C = Box2D.Collision.b2DynamicTreePair, E = Box2D.Collision.b2Manifold, I = Box2D.Collision.b2ManifoldPoint, L = Box2D.Collision.b2Point, J = Box2D.Collision.b2RayCastInput, Q = Box2D.Collision.b2RayCastOutput, M = Box2D.Collision.b2Segment, K = Box2D.Collision.b2SeparationFunction, H = Box2D.Collision.b2Simplex, P = Box2D.Collision.b2SimplexCache, U =
            Box2D.Collision.b2SimplexVertex, O = Box2D.Collision.b2TimeOfImpact, Y = Box2D.Collision.b2TOIInput, V = Box2D.Collision.b2WorldManifold, F = Box2D.Collision.ClipVertex, N = Box2D.Collision.Features, W = Box2D.Collision.IBroadPhase;
    p.b2AABB = function () {
        this.lowerBound = new n;
        this.upperBound = new n
    };
    p.prototype.IsValid = function () {
        var a = this.upperBound.y - this.lowerBound.y;
        return a = (a = 0 <= this.upperBound.x - this.lowerBound.x && 0 <= a) && this.lowerBound.IsValid() && this.upperBound.IsValid()
    };
    p.prototype.GetCenter = function () {
        return new n((this.lowerBound.x +
            this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
    };
    p.prototype.GetExtents = function () {
        return new n((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
    };
    p.prototype.Contains = function (a) {
        var b;
        return b = (b = (b = (b = this.lowerBound.x <= a.lowerBound.x) && this.lowerBound.y <= a.lowerBound.y) && a.upperBound.x <= this.upperBound.x) && a.upperBound.y <= this.upperBound.y
    };
    p.prototype.RayCast = function (a, b) {
        var d = -Number.MAX_VALUE, e = Number.MAX_VALUE, f = b.p1.x, g = b.p1.y, h = b.p2.x - b.p1.x,
            n = b.p2.y - b.p1.y, p = Math.abs(h), r = Math.abs(n), s = a.normal, F = 0, t = 0, N = F = 0, N = 0;
        if (p < Number.MIN_VALUE) {
            if (f < this.lowerBound.x || this.upperBound.x < f)return !1
        } else if (F = 1 / h, t = (this.lowerBound.x - f) * F, F *= this.upperBound.x - f, N = -1, t > F && (N = t, t = F, F = N, N = 1), t > d && (s.x = N, s.y = 0, d = t), e = Math.min(e, F), d > e)return !1;
        if (r < Number.MIN_VALUE) {
            if (g < this.lowerBound.y || this.upperBound.y < g)return !1
        } else if (F = 1 / n, t = (this.lowerBound.y - g) * F, F *= this.upperBound.y - g, N = -1, t > F && (N = t, t = F, F = N, N = 1), t > d && (s.y = N, s.x = 0, d = t), e = Math.min(e, F), d > e)return !1;
        a.fraction = d;
        return !0
    };
    p.prototype.TestOverlap = function (a) {
        var b = a.lowerBound.y - this.upperBound.y, d = this.lowerBound.y - a.upperBound.y;
        return 0 < a.lowerBound.x - this.upperBound.x || 0 < b || 0 < this.lowerBound.x - a.upperBound.x || 0 < d ? !1 : !0
    };
    p.Combine = function (a, b) {
        var d = new p;
        d.Combine(a, b);
        return d
    };
    p.prototype.Combine = function (a, b) {
        this.lowerBound.x = Math.min(a.lowerBound.x, b.lowerBound.x);
        this.lowerBound.y = Math.min(a.lowerBound.y, b.lowerBound.y);
        this.upperBound.x = Math.max(a.upperBound.x, b.upperBound.x);
        this.upperBound.y =
            Math.max(a.upperBound.y, b.upperBound.y)
    };
    r.b2Bound = function () {
    };
    r.prototype.IsLower = function () {
        return 0 == (this.value & 1)
    };
    r.prototype.IsUpper = function () {
        return 1 == (this.value & 1)
    };
    r.prototype.Swap = function (a) {
        var b = this.value, d = this.proxy, e = this.stabbingCount;
        this.value = a.value;
        this.proxy = a.proxy;
        this.stabbingCount = a.stabbingCount;
        a.value = b;
        a.proxy = d;
        a.stabbingCount = e
    };
    s.b2BoundValues = function () {
    };
    s.prototype.b2BoundValues = function () {
        this.lowerValues = new Vector_a2j_Number;
        this.lowerValues[0] = 0;
        this.lowerValues[1] =
            0;
        this.upperValues = new Vector_a2j_Number;
        this.upperValues[0] = 0;
        this.upperValues[1] = 0
    };
    t.b2Collision = function () {
    };
    t.ClipSegmentToLine = function (a, b, d, e) {
        void 0 === e && (e = 0);
        var f, g = 0;
        f = b[0];
        var h = f.v;
        f = b[1];
        var n = f.v, p = d.x * h.x + d.y * h.y - e;
        f = d.x * n.x + d.y * n.y - e;
        0 >= p && a[g++].Set(b[0]);
        0 >= f && a[g++].Set(b[1]);
        0 > p * f && (d = p / (p - f), f = a[g], f = f.v, f.x = h.x + d * (n.x - h.x), f.y = h.y + d * (n.y - h.y), f = a[g], f.id = (0 < p ? b[0] : b[1]).id, ++g);
        return g
    };
    t.EdgeSeparation = function (a, b, d, e, f) {
        void 0 === d && (d = 0);
        parseInt(a.m_vertexCount);
        var g =
            a.m_vertices;
        a = a.m_normals;
        var h = parseInt(e.m_vertexCount), n = e.m_vertices, p, r;
        p = b.R;
        r = a[d];
        a = p.col1.x * r.x + p.col2.x * r.y;
        e = p.col1.y * r.x + p.col2.y * r.y;
        p = f.R;
        var s = p.col1.x * a + p.col1.y * e;
        p = p.col2.x * a + p.col2.y * e;
        for (var F = 0, t = Number.MAX_VALUE, N = 0; N < h; ++N)r = n[N], r = r.x * s + r.y * p, r < t && (t = r, F = N);
        r = g[d];
        p = b.R;
        d = b.position.x + (p.col1.x * r.x + p.col2.x * r.y);
        b = b.position.y + (p.col1.y * r.x + p.col2.y * r.y);
        r = n[F];
        p = f.R;
        g = f.position.x + (p.col1.x * r.x + p.col2.x * r.y);
        f = f.position.y + (p.col1.y * r.x + p.col2.y * r.y);
        return (g - d) * a + (f - b) *
            e
    };
    t.FindMaxSeparation = function (a, b, d, e, f) {
        var g = parseInt(b.m_vertexCount), h = b.m_normals, n, p;
        p = f.R;
        n = e.m_centroid;
        var r = f.position.x + (p.col1.x * n.x + p.col2.x * n.y), s = f.position.y + (p.col1.y * n.x + p.col2.y * n.y);
        p = d.R;
        n = b.m_centroid;
        r -= d.position.x + (p.col1.x * n.x + p.col2.x * n.y);
        s -= d.position.y + (p.col1.y * n.x + p.col2.y * n.y);
        p = r * d.R.col1.x + s * d.R.col1.y;
        for (var s = r * d.R.col2.x + s * d.R.col2.y, r = 0, F = -Number.MAX_VALUE, N = 0; N < g; ++N)n = h[N], n = n.x * p + n.y * s, n > F && (F = n, r = N);
        h = t.EdgeSeparation(b, d, r, e, f);
        n = parseInt(0 <= r - 1 ? r - 1 :
        g - 1);
        p = t.EdgeSeparation(b, d, n, e, f);
        var s = parseInt(r + 1 < g ? r + 1 : 0), F = t.EdgeSeparation(b, d, s, e, f), K = N = 0, u = 0;
        if (p > h && p > F)u = -1, N = n, K = p; else if (F > h)u = 1, N = s, K = F; else return a[0] = r, h;
        for (; ;)if (r = -1 == u ? 0 <= N - 1 ? N - 1 : g - 1 : N + 1 < g ? N + 1 : 0, h = t.EdgeSeparation(b, d, r, e, f), h > K)N = r, K = h; else break;
        a[0] = N;
        return K
    };
    t.FindIncidentEdge = function (a, b, d, e, f, g) {
        void 0 === e && (e = 0);
        parseInt(b.m_vertexCount);
        var h = b.m_normals, n = parseInt(f.m_vertexCount);
        b = f.m_vertices;
        f = f.m_normals;
        var p;
        p = d.R;
        d = h[e];
        var h = p.col1.x * d.x + p.col2.x * d.y, r =
            p.col1.y * d.x + p.col2.y * d.y;
        p = g.R;
        d = p.col1.x * h + p.col1.y * r;
        r = p.col2.x * h + p.col2.y * r;
        h = d;
        p = 0;
        for (var s = Number.MAX_VALUE, F = 0; F < n; ++F)d = f[F], d = h * d.x + r * d.y, d < s && (s = d, p = F);
        f = parseInt(p);
        h = parseInt(f + 1 < n ? f + 1 : 0);
        n = a[0];
        d = b[f];
        p = g.R;
        n.v.x = g.position.x + (p.col1.x * d.x + p.col2.x * d.y);
        n.v.y = g.position.y + (p.col1.y * d.x + p.col2.y * d.y);
        n.id.features.referenceEdge = e;
        n.id.features.incidentEdge = f;
        n.id.features.incidentVertex = 0;
        n = a[1];
        d = b[h];
        p = g.R;
        n.v.x = g.position.x + (p.col1.x * d.x + p.col2.x * d.y);
        n.v.y = g.position.y + (p.col1.y *
            d.x + p.col2.y * d.y);
        n.id.features.referenceEdge = e;
        n.id.features.incidentEdge = h;
        n.id.features.incidentVertex = 1
    };
    t.MakeClipPointVector = function () {
        var a = new Vector(2);
        a[0] = new F;
        a[1] = new F;
        return a
    };
    t.CollidePolygons = function (a, b, d, f, g) {
        var h;
        a.m_pointCount = 0;
        var n = b.m_radius + f.m_radius;
        t.s_edgeAO[0] = 0;
        var p = t.FindMaxSeparation(t.s_edgeAO, b, d, f, g);
        h = t.s_edgeAO[0];
        if (!(p > n)) {
            var r;
            t.s_edgeBO[0] = 0;
            var s = t.FindMaxSeparation(t.s_edgeBO, f, g, b, d);
            r = t.s_edgeBO[0];
            if (!(s > n)) {
                var F = 0, N = 0;
                s > 0.98 * p + 0.001 ? (p = f, f =
                    b, b = g, F = r, a.m_type = E.e_faceB, N = 1) : (p = b, b = d, d = g, F = h, a.m_type = E.e_faceA, N = 0);
                h = t.s_incidentEdge;
                t.FindIncidentEdge(h, p, b, F, f, d);
                r = parseInt(p.m_vertexCount);
                g = p.m_vertices;
                var p = g[F], K;
                K = F + 1 < r ? g[parseInt(F + 1)] : g[0];
                F = t.s_localTangent;
                F.Set(K.x - p.x, K.y - p.y);
                F.Normalize();
                g = t.s_localNormal;
                g.x = F.y;
                g.y = -F.x;
                f = t.s_planePoint;
                f.Set(0.5 * (p.x + K.x), 0.5 * (p.y + K.y));
                s = t.s_tangent;
                r = b.R;
                s.x = r.col1.x * F.x + r.col2.x * F.y;
                s.y = r.col1.y * F.x + r.col2.y * F.y;
                var u = t.s_tangent2;
                u.x = -s.x;
                u.y = -s.y;
                F = t.s_normal;
                F.x = s.y;
                F.y = -s.x;
                var y = t.s_v11, v = t.s_v12;
                y.x = b.position.x + (r.col1.x * p.x + r.col2.x * p.y);
                y.y = b.position.y + (r.col1.y * p.x + r.col2.y * p.y);
                v.x = b.position.x + (r.col1.x * K.x + r.col2.x * K.y);
                v.y = b.position.y + (r.col1.y * K.x + r.col2.y * K.y);
                b = F.x * y.x + F.y * y.y;
                r = s.x * v.x + s.y * v.y + n;
                K = t.s_clipPoints1;
                p = t.s_clipPoints2;
                v = 0;
                v = t.ClipSegmentToLine(K, h, u, -s.x * y.x - s.y * y.y + n);
                if (!(2 > v || (v = t.ClipSegmentToLine(p, K, s, r), 2 > v))) {
                    a.m_localPlaneNormal.SetV(g);
                    a.m_localPoint.SetV(f);
                    for (f = g = 0; f < e.b2_maxManifoldPoints; ++f)h = p[f], F.x * h.v.x + F.y * h.v.y - b <= n &&
                    (s = a.m_points[g], r = d.R, u = h.v.x - d.position.x, y = h.v.y - d.position.y, s.m_localPoint.x = u * r.col1.x + y * r.col1.y, s.m_localPoint.y = u * r.col2.x + y * r.col2.y, s.m_id.Set(h.id), s.m_id.features.flip = N, ++g);
                    a.m_pointCount = g
                }
            }
        }
    };
    t.CollideCircles = function (a, b, d, e, f) {
        a.m_pointCount = 0;
        var g, h;
        g = d.R;
        h = b.m_p;
        var n = d.position.x + (g.col1.x * h.x + g.col2.x * h.y);
        d = d.position.y + (g.col1.y * h.x + g.col2.y * h.y);
        g = f.R;
        h = e.m_p;
        n = f.position.x + (g.col1.x * h.x + g.col2.x * h.y) - n;
        f = f.position.y + (g.col1.y * h.x + g.col2.y * h.y) - d;
        g = b.m_radius + e.m_radius;
        n * n + f * f > g * g || (a.m_type = E.e_circles, a.m_localPoint.SetV(b.m_p), a.m_localPlaneNormal.SetZero(), a.m_pointCount = 1, a.m_points[0].m_localPoint.SetV(e.m_p), a.m_points[0].m_id.key = 0)
    };
    t.CollidePolygonAndCircle = function (a, b, d, e, f) {
        var g = a.m_pointCount = 0, h = 0, n, p;
        p = f.R;
        n = e.m_p;
        var r = f.position.y + (p.col1.y * n.x + p.col2.y * n.y), g = f.position.x + (p.col1.x * n.x + p.col2.x * n.y) - d.position.x, h = r - d.position.y;
        p = d.R;
        d = g * p.col1.x + h * p.col1.y;
        p = g * p.col2.x + h * p.col2.y;
        var s = 0, r = -Number.MAX_VALUE;
        f = b.m_radius + e.m_radius;
        var F = parseInt(b.m_vertexCount),
            t = b.m_vertices;
        b = b.m_normals;
        for (var N = 0; N < F; ++N) {
            n = t[N];
            g = d - n.x;
            h = p - n.y;
            n = b[N];
            g = n.x * g + n.y * h;
            if (g > f)return;
            g > r && (r = g, s = N)
        }
        g = parseInt(s);
        h = parseInt(g + 1 < F ? g + 1 : 0);
        n = t[g];
        t = t[h];
        r < Number.MIN_VALUE ? (a.m_pointCount = 1, a.m_type = E.e_faceA, a.m_localPlaneNormal.SetV(b[s]), a.m_localPoint.x = 0.5 * (n.x + t.x), a.m_localPoint.y = 0.5 * (n.y + t.y), a.m_points[0].m_localPoint.SetV(e.m_p), a.m_points[0].m_id.key = 0) : (r = (d - t.x) * (n.x - t.x) + (p - t.y) * (n.y - t.y), 0 >= (d - n.x) * (t.x - n.x) + (p - n.y) * (t.y - n.y) ? (d - n.x) * (d - n.x) + (p - n.y) * (p - n.y) > f *
        f || (a.m_pointCount = 1, a.m_type = E.e_faceA, a.m_localPlaneNormal.x = d - n.x, a.m_localPlaneNormal.y = p - n.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(n), a.m_points[0].m_localPoint.SetV(e.m_p), a.m_points[0].m_id.key = 0) : 0 >= r ? (d - t.x) * (d - t.x) + (p - t.y) * (p - t.y) > f * f || (a.m_pointCount = 1, a.m_type = E.e_faceA, a.m_localPlaneNormal.x = d - t.x, a.m_localPlaneNormal.y = p - t.y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.SetV(t), a.m_points[0].m_localPoint.SetV(e.m_p), a.m_points[0].m_id.key = 0) : (s = 0.5 * (n.x + t.x), n = 0.5 * (n.y +
            t.y), r = (d - s) * b[g].x + (p - n) * b[g].y, r > f || (a.m_pointCount = 1, a.m_type = E.e_faceA, a.m_localPlaneNormal.x = b[g].x, a.m_localPlaneNormal.y = b[g].y, a.m_localPlaneNormal.Normalize(), a.m_localPoint.Set(s, n), a.m_points[0].m_localPoint.SetV(e.m_p), a.m_points[0].m_id.key = 0)))
    };
    t.TestOverlap = function (a, b) {
        var d = b.lowerBound, e = a.upperBound, f = d.x - e.x, g = d.y - e.y, d = a.lowerBound, e = b.upperBound, h = d.y - e.y;
        return 0 < f || 0 < g || 0 < d.x - e.x || 0 < h ? !1 : !0
    };
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Collision.s_incidentEdge = t.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints1 = t.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints2 = t.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_localTangent = new n;
        Box2D.Collision.b2Collision.s_localNormal = new n;
        Box2D.Collision.b2Collision.s_planePoint = new n;
        Box2D.Collision.b2Collision.s_normal = new n;
        Box2D.Collision.b2Collision.s_tangent = new n;
        Box2D.Collision.b2Collision.s_tangent2 =
            new n;
        Box2D.Collision.b2Collision.s_v11 = new n;
        Box2D.Collision.b2Collision.s_v12 = new n;
        Box2D.Collision.b2Collision.b2CollidePolyTempVec = new n;
        Box2D.Collision.b2Collision.b2_nullFeature = 255
    });
    v.b2ContactID = function () {
        this.features = new N
    };
    v.prototype.b2ContactID = function () {
        this.features._m_id = this
    };
    v.prototype.Set = function (a) {
        this.key = a._key
    };
    v.prototype.Copy = function () {
        var a = new v;
        a.key = this.key;
        return a
    };
    Object.defineProperty(v.prototype, "key", {
        enumerable: !1, configurable: !0, get: function () {
            return this._key
        }
    });
    Object.defineProperty(v.prototype, "key", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a && (a = 0);
            this._key = a;
            this.features._referenceEdge = this._key & 255;
            this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
            this.features._incidentVertex = (this._key & 16711680) >> 16 & 255;
            this.features._flip = (this._key & 4278190080) >> 24 & 255
        }
    });
    u.b2ContactPoint = function () {
        this.position = new n;
        this.velocity = new n;
        this.normal = new n;
        this.id = new v
    };
    x.b2Distance = function () {
    };
    x.Distance = function (a, b, d) {
        ++x.b2_gjkCalls;
        var g =
            d.proxyA, h = d.proxyB, p = d.transformA, r = d.transformB, s = x.s_simplex;
        s.ReadCache(b, g, p, h, r);
        var F = s.m_vertices, t = x.s_saveA, N = x.s_saveB, K = 0;
        s.GetClosestPoint().LengthSquared();
        for (var u = 0, y, v = 0; 20 > v;) {
            K = s.m_count;
            for (u = 0; u < K; u++)t[u] = F[u].indexA, N[u] = F[u].indexB;
            switch (s.m_count) {
                case 1:
                    break;
                case 2:
                    s.Solve2();
                    break;
                case 3:
                    s.Solve3();
                    break;
                default:
                    e.b2Assert(!1)
            }
            if (3 == s.m_count)break;
            y = s.GetClosestPoint();
            y.LengthSquared();
            u = s.GetSearchDirection();
            if (u.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE)break;
            y = F[s.m_count];
            y.indexA = g.GetSupport(f.MulTMV(p.R, u.GetNegative()));
            y.wA = f.MulX(p, g.GetVertex(y.indexA));
            y.indexB = h.GetSupport(f.MulTMV(r.R, u));
            y.wB = f.MulX(r, h.GetVertex(y.indexB));
            y.w = f.SubtractVV(y.wB, y.wA);
            ++v;
            ++x.b2_gjkIters;
            for (var H = !1, u = 0; u < K; u++)if (y.indexA == t[u] && y.indexB == N[u]) {
                H = !0;
                break
            }
            if (H)break;
            ++s.m_count
        }
        x.b2_gjkMaxIters = f.Max(x.b2_gjkMaxIters, v);
        s.GetWitnessPoints(a.pointA, a.pointB);
        a.distance = f.SubtractVV(a.pointA, a.pointB).Length();
        a.iterations = v;
        s.WriteCache(b);
        d.useRadii && (b =
            g.m_radius, h = h.m_radius, a.distance > b + h && a.distance > Number.MIN_VALUE ? (a.distance -= b + h, d = f.SubtractVV(a.pointB, a.pointA), d.Normalize(), a.pointA.x += b * d.x, a.pointA.y += b * d.y, a.pointB.x -= h * d.x, a.pointB.y -= h * d.y) : (y = new n, y.x = 0.5 * (a.pointA.x + a.pointB.x), y.y = 0.5 * (a.pointA.y + a.pointB.y), a.pointA.x = a.pointB.x = y.x, a.pointA.y = a.pointB.y = y.y, a.distance = 0))
    };
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Distance.s_simplex = new H;
        Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
        Box2D.Collision.b2Distance.s_saveB =
            new Vector_a2j_Number(3)
    });
    w.b2DistanceInput = function () {
    };
    y.b2DistanceOutput = function () {
        this.pointA = new n;
        this.pointB = new n
    };
    A.b2DistanceProxy = function () {
    };
    A.prototype.Set = function (f) {
        switch (f.GetType()) {
            case d.e_circleShape:
                f = f instanceof a ? f : null;
                this.m_vertices = new Vector(1, !0);
                this.m_vertices[0] = f.m_p;
                this.m_count = 1;
                this.m_radius = f.m_radius;
                break;
            case d.e_polygonShape:
                f = f instanceof b ? f : null;
                this.m_vertices = f.m_vertices;
                this.m_count = f.m_vertexCount;
                this.m_radius = f.m_radius;
                break;
            default:
                e.b2Assert(!1)
        }
    };
    A.prototype.GetSupport = function (a) {
        for (var b = 0, d = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, e = 1; e < this.m_count; ++e) {
            var f = this.m_vertices[e].x * a.x + this.m_vertices[e].y * a.y;
            f > d && (b = e, d = f)
        }
        return b
    };
    A.prototype.GetSupportVertex = function (a) {
        for (var b = 0, d = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, e = 1; e < this.m_count; ++e) {
            var f = this.m_vertices[e].x * a.x + this.m_vertices[e].y * a.y;
            f > d && (b = e, d = f)
        }
        return this.m_vertices[b]
    };
    A.prototype.GetVertexCount = function () {
        return this.m_count
    };
    A.prototype.GetVertex =
        function (a) {
            void 0 === a && (a = 0);
            e.b2Assert(0 <= a && a < this.m_count);
            return this.m_vertices[a]
        };
    D.b2DynamicTree = function () {
    };
    D.prototype.b2DynamicTree = function () {
        this.m_freeList = this.m_root = null;
        this.m_insertionCount = this.m_path = 0
    };
    D.prototype.CreateProxy = function (a, b) {
        var d = this.AllocateNode(), f = e.b2_aabbExtension, g = e.b2_aabbExtension;
        d.aabb.lowerBound.x = a.lowerBound.x - f;
        d.aabb.lowerBound.y = a.lowerBound.y - g;
        d.aabb.upperBound.x = a.upperBound.x + f;
        d.aabb.upperBound.y = a.upperBound.y + g;
        d.userData = b;
        this.InsertLeaf(d);
        return d
    };
    D.prototype.DestroyProxy = function (a) {
        this.RemoveLeaf(a);
        this.FreeNode(a)
    };
    D.prototype.MoveProxy = function (a, b, d) {
        e.b2Assert(a.IsLeaf());
        if (a.aabb.Contains(b))return !1;
        this.RemoveLeaf(a);
        var f = e.b2_aabbExtension + e.b2_aabbMultiplier * (0 < d.x ? d.x : -d.x);
        d = e.b2_aabbExtension + e.b2_aabbMultiplier * (0 < d.y ? d.y : -d.y);
        a.aabb.lowerBound.x = b.lowerBound.x - f;
        a.aabb.lowerBound.y = b.lowerBound.y - d;
        a.aabb.upperBound.x = b.upperBound.x + f;
        a.aabb.upperBound.y = b.upperBound.y + d;
        this.InsertLeaf(a);
        return !0
    };
    D.prototype.Rebalance =
        function (a) {
            void 0 === a && (a = 0);
            if (null != this.m_root)for (var b = 0; b < a; b++) {
                for (var d = this.m_root, e = 0; !1 == d.IsLeaf();)d = this.m_path >> e & 1 ? d.child2 : d.child1, e = e + 1 & 31;
                ++this.m_path;
                this.RemoveLeaf(d);
                this.InsertLeaf(d)
            }
        };
    D.prototype.GetFatAABB = function (a) {
        return a.aabb
    };
    D.prototype.GetUserData = function (a) {
        return a.userData
    };
    D.prototype.Query = function (a, b) {
        if (null != this.m_root) {
            var d = new Vector, e = 0;
            for (d[e++] = this.m_root; 0 < e;) {
                var f = d[--e];
                if (f.aabb.TestOverlap(b))if (f.IsLeaf()) {
                    if (!a(f))break
                } else d[e++] =
                    f.child1, d[e++] = f.child2
            }
        }
    };
    D.prototype.RayCast = function (a, b) {
        if (null != this.m_root) {
            var d = b.p1, e = b.p2, g = f.SubtractVV(d, e);
            g.Normalize();
            var g = f.CrossFV(1, g), h = f.AbsV(g), n = b.maxFraction, r = new p, s = 0, F = 0, s = d.x + n * (e.x - d.x), F = d.y + n * (e.y - d.y);
            r.lowerBound.x = Math.min(d.x, s);
            r.lowerBound.y = Math.min(d.y, F);
            r.upperBound.x = Math.max(d.x, s);
            r.upperBound.y = Math.max(d.y, F);
            var t = new Vector, N = 0;
            for (t[N++] = this.m_root; 0 < N;)if (n = t[--N], !1 != n.aabb.TestOverlap(r) && (s = n.aabb.GetCenter(), F = n.aabb.GetExtents(), !(0 < Math.abs(g.x *
                    (d.x - s.x) + g.y * (d.y - s.y)) - h.x * F.x - h.y * F.y)))if (n.IsLeaf()) {
                s = new J;
                s.p1 = b.p1;
                s.p2 = b.p2;
                s.maxFraction = b.maxFraction;
                n = a(s, n);
                if (0 == n)break;
                0 < n && (s = d.x + n * (e.x - d.x), F = d.y + n * (e.y - d.y), r.lowerBound.x = Math.min(d.x, s), r.lowerBound.y = Math.min(d.y, F), r.upperBound.x = Math.max(d.x, s), r.upperBound.y = Math.max(d.y, F))
            } else t[N++] = n.child1, t[N++] = n.child2
        }
    };
    D.prototype.AllocateNode = function () {
        if (this.m_freeList) {
            var a = this.m_freeList;
            this.m_freeList = a.parent;
            a.parent = null;
            a.child1 = null;
            a.child2 = null;
            return a
        }
        return new B
    };
    D.prototype.FreeNode = function (a) {
        a.parent = this.m_freeList;
        this.m_freeList = a
    };
    D.prototype.InsertLeaf = function (a) {
        ++this.m_insertionCount;
        if (null == this.m_root)this.m_root = a, this.m_root.parent = null; else {
            var b = a.aabb.GetCenter(), d = this.m_root;
            if (!1 == d.IsLeaf()) {
                do var e = d.child1, d = d.child2, f = Math.abs((e.aabb.lowerBound.x + e.aabb.upperBound.x) / 2 - b.x) + Math.abs((e.aabb.lowerBound.y + e.aabb.upperBound.y) / 2 - b.y), g = Math.abs((d.aabb.lowerBound.x + d.aabb.upperBound.x) / 2 - b.x) + Math.abs((d.aabb.lowerBound.y + d.aabb.upperBound.y) /
                        2 - b.y), d = f < g ? e : d; while (!1 == d.IsLeaf())
            }
            b = d.parent;
            e = this.AllocateNode();
            e.parent = b;
            e.userData = null;
            e.aabb.Combine(a.aabb, d.aabb);
            if (b) {
                d.parent.child1 == d ? b.child1 = e : b.child2 = e;
                e.child1 = d;
                e.child2 = a;
                d.parent = e;
                a.parent = e;
                do {
                    if (b.aabb.Contains(e.aabb))break;
                    b.aabb.Combine(b.child1.aabb, b.child2.aabb);
                    e = b;
                    b = b.parent
                } while (b)
            } else e.child1 = d, e.child2 = a, d.parent = e, this.m_root = a.parent = e
        }
    };
    D.prototype.RemoveLeaf = function (a) {
        if (a == this.m_root)this.m_root = null; else {
            var b = a.parent, d = b.parent;
            a = b.child1 == a ?
                b.child2 : b.child1;
            if (d)for (d.child1 == b ? d.child1 = a : d.child2 = a, a.parent = d, this.FreeNode(b); d;) {
                b = d.aabb;
                d.aabb = p.Combine(d.child1.aabb, d.child2.aabb);
                if (b.Contains(d.aabb))break;
                d = d.parent
            } else this.m_root = a, a.parent = null, this.FreeNode(b)
        }
    };
    G.b2DynamicTreeBroadPhase = function () {
        this.m_tree = new D;
        this.m_moveBuffer = new Vector;
        this.m_pairBuffer = new Vector;
        this.m_pairCount = 0
    };
    G.prototype.CreateProxy = function (a, b) {
        var d = this.m_tree.CreateProxy(a, b);
        ++this.m_proxyCount;
        this.BufferMove(d);
        return d
    };
    G.prototype.DestroyProxy =
        function (a) {
            this.UnBufferMove(a);
            --this.m_proxyCount;
            this.m_tree.DestroyProxy(a)
        };
    G.prototype.MoveProxy = function (a, b, d) {
        this.m_tree.MoveProxy(a, b, d) && this.BufferMove(a)
    };
    G.prototype.TestOverlap = function (a, b) {
        var d = this.m_tree.GetFatAABB(a), e = this.m_tree.GetFatAABB(b);
        return d.TestOverlap(e)
    };
    G.prototype.GetUserData = function (a) {
        return this.m_tree.GetUserData(a)
    };
    G.prototype.GetFatAABB = function (a) {
        return this.m_tree.GetFatAABB(a)
    };
    G.prototype.GetProxyCount = function () {
        return this.m_proxyCount
    };
    G.prototype.UpdatePairs =
        function (a) {
            for (var b = this, d = b.m_pairCount = 0, e, d = 0; d < b.m_moveBuffer.length; ++d) {
                e = b.m_moveBuffer[d];
                var f = b.m_tree.GetFatAABB(e);
                b.m_tree.Query(function (a) {
                    if (a == e)return !0;
                    b.m_pairCount == b.m_pairBuffer.length && (b.m_pairBuffer[b.m_pairCount] = new C);
                    var d = b.m_pairBuffer[b.m_pairCount];
                    d.proxyA = a < e ? a : e;
                    d.proxyB = a >= e ? a : e;
                    ++b.m_pairCount;
                    return !0
                }, f)
            }
            for (d = b.m_moveBuffer.length = 0; d < b.m_pairCount;) {
                var f = b.m_pairBuffer[d], g = b.m_tree.GetUserData(f.proxyA), h = b.m_tree.GetUserData(f.proxyB);
                a(g, h);
                for (++d; d <
                b.m_pairCount;) {
                    g = b.m_pairBuffer[d];
                    if (g.proxyA != f.proxyA || g.proxyB != f.proxyB)break;
                    ++d
                }
            }
        };
    G.prototype.Query = function (a, b) {
        this.m_tree.Query(a, b)
    };
    G.prototype.RayCast = function (a, b) {
        this.m_tree.RayCast(a, b)
    };
    G.prototype.Validate = function () {
    };
    G.prototype.Rebalance = function (a) {
        void 0 === a && (a = 0);
        this.m_tree.Rebalance(a)
    };
    G.prototype.BufferMove = function (a) {
        this.m_moveBuffer[this.m_moveBuffer.length] = a
    };
    G.prototype.UnBufferMove = function (a) {
        a = parseInt(this.m_moveBuffer.indexOf(a));
        this.m_moveBuffer.splice(a,
            1)
    };
    G.prototype.ComparePairs = function (a, b) {
        return 0
    };
    G.__implements = {};
    G.__implements[W] = !0;
    B.b2DynamicTreeNode = function () {
        this.aabb = new p
    };
    B.prototype.IsLeaf = function () {
        return null == this.child1
    };
    C.b2DynamicTreePair = function () {
    };
    E.b2Manifold = function () {
        this.m_pointCount = 0
    };
    E.prototype.b2Manifold = function () {
        this.m_points = new Vector(e.b2_maxManifoldPoints);
        for (var a = 0; a < e.b2_maxManifoldPoints; a++)this.m_points[a] = new I;
        this.m_localPlaneNormal = new n;
        this.m_localPoint = new n
    };
    E.prototype.Reset = function () {
        for (var a =
            0; a < e.b2_maxManifoldPoints; a++)(this.m_points[a] instanceof I ? this.m_points[a] : null).Reset();
        this.m_localPlaneNormal.SetZero();
        this.m_localPoint.SetZero();
        this.m_pointCount = this.m_type = 0
    };
    E.prototype.Set = function (a) {
        this.m_pointCount = a.m_pointCount;
        for (var b = 0; b < e.b2_maxManifoldPoints; b++)(this.m_points[b] instanceof I ? this.m_points[b] : null).Set(a.m_points[b]);
        this.m_localPlaneNormal.SetV(a.m_localPlaneNormal);
        this.m_localPoint.SetV(a.m_localPoint);
        this.m_type = a.m_type
    };
    E.prototype.Copy = function () {
        var a =
            new E;
        a.Set(this);
        return a
    };
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2Manifold.e_circles = 1;
        Box2D.Collision.b2Manifold.e_faceA = 2;
        Box2D.Collision.b2Manifold.e_faceB = 4
    });
    I.b2ManifoldPoint = function () {
        this.m_localPoint = new n;
        this.m_id = new v
    };
    I.prototype.b2ManifoldPoint = function () {
        this.Reset()
    };
    I.prototype.Reset = function () {
        this.m_localPoint.SetZero();
        this.m_tangentImpulse = this.m_normalImpulse = 0;
        this.m_id.key = 0
    };
    I.prototype.Set = function (a) {
        this.m_localPoint.SetV(a.m_localPoint);
        this.m_normalImpulse =
            a.m_normalImpulse;
        this.m_tangentImpulse = a.m_tangentImpulse;
        this.m_id.Set(a.m_id)
    };
    L.b2Point = function () {
        this.p = new n
    };
    L.prototype.Support = function (a, b, d) {
        return this.p
    };
    L.prototype.GetFirstVertex = function (a) {
        return this.p
    };
    J.b2RayCastInput = function () {
        this.p1 = new n;
        this.p2 = new n
    };
    J.prototype.b2RayCastInput = function (a, b, d) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        void 0 === d && (d = 1);
        a && this.p1.SetV(a);
        b && this.p2.SetV(b);
        this.maxFraction = d
    };
    Q.b2RayCastOutput = function () {
        this.normal = new n
    };
    M.b2Segment = function () {
        this.p1 =
            new n;
        this.p2 = new n
    };
    M.prototype.TestSegment = function (a, b, d, e) {
        void 0 === e && (e = 0);
        var f = d.p1, g = d.p2.x - f.x, h = d.p2.y - f.y;
        d = this.p2.y - this.p1.y;
        var n = -(this.p2.x - this.p1.x), p = 100 * Number.MIN_VALUE, r = -(g * d + h * n);
        if (r > p) {
            var s = f.x - this.p1.x, F = f.y - this.p1.y, f = s * d + F * n;
            if (0 <= f && f <= e * r && (e = -g * F + h * s, -p * r <= e && e <= r * (1 + p)))return f /= r, e = Math.sqrt(d * d + n * n), a[0] = f, b.Set(d / e, n / e), !0
        }
        return !1
    };
    M.prototype.Extend = function (a) {
        this.ExtendForward(a);
        this.ExtendBackward(a)
    };
    M.prototype.ExtendForward = function (a) {
        var b = this.p2.x -
            this.p1.x, d = this.p2.y - this.p1.y;
        a = Math.min(0 < b ? (a.upperBound.x - this.p1.x) / b : 0 > b ? (a.lowerBound.x - this.p1.x) / b : Number.POSITIVE_INFINITY, 0 < d ? (a.upperBound.y - this.p1.y) / d : 0 > d ? (a.lowerBound.y - this.p1.y) / d : Number.POSITIVE_INFINITY);
        this.p2.x = this.p1.x + b * a;
        this.p2.y = this.p1.y + d * a
    };
    M.prototype.ExtendBackward = function (a) {
        var b = -this.p2.x + this.p1.x, d = -this.p2.y + this.p1.y;
        a = Math.min(0 < b ? (a.upperBound.x - this.p2.x) / b : 0 > b ? (a.lowerBound.x - this.p2.x) / b : Number.POSITIVE_INFINITY, 0 < d ? (a.upperBound.y - this.p2.y) / d : 0 >
        d ? (a.lowerBound.y - this.p2.y) / d : Number.POSITIVE_INFINITY);
        this.p1.x = this.p2.x + b * a;
        this.p1.y = this.p2.y + d * a
    };
    K.b2SeparationFunction = function () {
        this.m_localPoint = new n;
        this.m_axis = new n
    };
    K.prototype.Initialize = function (a, b, d, g, h) {
        this.m_proxyA = b;
        this.m_proxyB = g;
        var p = parseInt(a.count);
        e.b2Assert(0 < p && 3 > p);
        var r, s, F, t, N = t = F = g = b = 0, u = 0, N = 0;
        1 == p ? (this.m_type = K.e_points, r = this.m_proxyA.GetVertex(a.indexA[0]), s = this.m_proxyB.GetVertex(a.indexB[0]), p = r, a = d.R, b = d.position.x + (a.col1.x * p.x + a.col2.x * p.y), g = d.position.y +
            (a.col1.y * p.x + a.col2.y * p.y), p = s, a = h.R, F = h.position.x + (a.col1.x * p.x + a.col2.x * p.y), t = h.position.y + (a.col1.y * p.x + a.col2.y * p.y), this.m_axis.x = F - b, this.m_axis.y = t - g, this.m_axis.Normalize()) : (a.indexB[0] == a.indexB[1] ? (this.m_type = K.e_faceA, b = this.m_proxyA.GetVertex(a.indexA[0]), g = this.m_proxyA.GetVertex(a.indexA[1]), s = this.m_proxyB.GetVertex(a.indexB[0]), this.m_localPoint.x = 0.5 * (b.x + g.x), this.m_localPoint.y = 0.5 * (b.y + g.y), this.m_axis = f.CrossVF(f.SubtractVV(g, b), 1), this.m_axis.Normalize(), p = this.m_axis, a =
            d.R, N = a.col1.x * p.x + a.col2.x * p.y, u = a.col1.y * p.x + a.col2.y * p.y, p = this.m_localPoint, a = d.R, b = d.position.x + (a.col1.x * p.x + a.col2.x * p.y), g = d.position.y + (a.col1.y * p.x + a.col2.y * p.y), p = s, a = h.R, F = h.position.x + (a.col1.x * p.x + a.col2.x * p.y), t = h.position.y + (a.col1.y * p.x + a.col2.y * p.y), N = (F - b) * N + (t - g) * u) : a.indexA[0] == a.indexA[0] ? (this.m_type = K.e_faceB, F = this.m_proxyB.GetVertex(a.indexB[0]), t = this.m_proxyB.GetVertex(a.indexB[1]), r = this.m_proxyA.GetVertex(a.indexA[0]), this.m_localPoint.x = 0.5 * (F.x + t.x), this.m_localPoint.y =
            0.5 * (F.y + t.y), this.m_axis = f.CrossVF(f.SubtractVV(t, F), 1), this.m_axis.Normalize(), p = this.m_axis, a = h.R, N = a.col1.x * p.x + a.col2.x * p.y, u = a.col1.y * p.x + a.col2.y * p.y, p = this.m_localPoint, a = h.R, F = h.position.x + (a.col1.x * p.x + a.col2.x * p.y), t = h.position.y + (a.col1.y * p.x + a.col2.y * p.y), p = r, a = d.R, b = d.position.x + (a.col1.x * p.x + a.col2.x * p.y), g = d.position.y + (a.col1.y * p.x + a.col2.y * p.y), N = (b - F) * N + (g - t) * u) : (b = this.m_proxyA.GetVertex(a.indexA[0]), g = this.m_proxyA.GetVertex(a.indexA[1]), F = this.m_proxyB.GetVertex(a.indexB[0]),
            t = this.m_proxyB.GetVertex(a.indexB[1]), f.MulX(d, r), r = f.MulMV(d.R, f.SubtractVV(g, b)), f.MulX(h, s), N = f.MulMV(h.R, f.SubtractVV(t, F)), h = r.x * r.x + r.y * r.y, s = N.x * N.x + N.y * N.y, a = f.SubtractVV(N, r), d = r.x * a.x + r.y * a.y, a = N.x * a.x + N.y * a.y, r = r.x * N.x + r.y * N.y, u = h * s - r * r, N = 0, 0 != u && (N = f.Clamp((r * a - d * s) / u, 0, 1)), 0 > (r * N + a) / s && (N = f.Clamp((r - d) / h, 0, 1)), r = new n, r.x = b.x + N * (g.x - b.x), r.y = b.y + N * (g.y - b.y), s = new n, s.x = F.x + N * (t.x - F.x), s.y = F.y + N * (t.y - F.y), 0 == N || 1 == N ? (this.m_type = K.e_faceB, this.m_axis = f.CrossVF(f.SubtractVV(t, F), 1), this.m_axis.Normalize(),
            this.m_localPoint = s) : (this.m_type = K.e_faceA, this.m_axis = f.CrossVF(f.SubtractVV(g, b), 1), this.m_localPoint = r)), 0 > N && this.m_axis.NegativeSelf())
    };
    K.prototype.Evaluate = function (a, b) {
        var d, g, h = 0;
        switch (this.m_type) {
            case K.e_points:
                return d = f.MulTMV(a.R, this.m_axis), g = f.MulTMV(b.R, this.m_axis.GetNegative()), d = this.m_proxyA.GetSupportVertex(d), g = this.m_proxyB.GetSupportVertex(g), d = f.MulX(a, d), g = f.MulX(b, g), h = (g.x - d.x) * this.m_axis.x + (g.y - d.y) * this.m_axis.y;
            case K.e_faceA:
                return h = f.MulMV(a.R, this.m_axis),
                    d = f.MulX(a, this.m_localPoint), g = f.MulTMV(b.R, h.GetNegative()), g = this.m_proxyB.GetSupportVertex(g), g = f.MulX(b, g), h = (g.x - d.x) * h.x + (g.y - d.y) * h.y;
            case K.e_faceB:
                return h = f.MulMV(b.R, this.m_axis), g = f.MulX(b, this.m_localPoint), d = f.MulTMV(a.R, h.GetNegative()), d = this.m_proxyA.GetSupportVertex(d), d = f.MulX(a, d), h = (d.x - g.x) * h.x + (d.y - g.y) * h.y;
            default:
                return e.b2Assert(!1), 0
        }
    };
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2SeparationFunction.e_points = 1;
        Box2D.Collision.b2SeparationFunction.e_faceA = 2;
        Box2D.Collision.b2SeparationFunction.e_faceB =
            4
    });
    H.b2Simplex = function () {
        this.m_v1 = new U;
        this.m_v2 = new U;
        this.m_v3 = new U;
        this.m_vertices = new Vector(3)
    };
    H.prototype.b2Simplex = function () {
        this.m_vertices[0] = this.m_v1;
        this.m_vertices[1] = this.m_v2;
        this.m_vertices[2] = this.m_v3
    };
    H.prototype.ReadCache = function (a, b, d, g, h) {
        e.b2Assert(0 <= a.count && 3 >= a.count);
        var n, p;
        this.m_count = a.count;
        for (var r = this.m_vertices, s = 0; s < this.m_count; s++) {
            var F = r[s];
            F.indexA = a.indexA[s];
            F.indexB = a.indexB[s];
            n = b.GetVertex(F.indexA);
            p = g.GetVertex(F.indexB);
            F.wA = f.MulX(d, n);
            F.wB = f.MulX(h, p);
            F.w = f.SubtractVV(F.wB, F.wA);
            F.a = 0
        }
        1 < this.m_count && (a = a.metric, n = this.GetMetric(), n < 0.5 * a || 2 * a < n || n < Number.MIN_VALUE) && (this.m_count = 0);
        0 == this.m_count && (F = r[0], F.indexA = 0, F.indexB = 0, n = b.GetVertex(0), p = g.GetVertex(0), F.wA = f.MulX(d, n), F.wB = f.MulX(h, p), F.w = f.SubtractVV(F.wB, F.wA), this.m_count = 1)
    };
    H.prototype.WriteCache = function (a) {
        a.metric = this.GetMetric();
        a.count = Box2D.parseUInt(this.m_count);
        for (var b = this.m_vertices, d = 0; d < this.m_count; d++)a.indexA[d] = Box2D.parseUInt(b[d].indexA),
            a.indexB[d] = Box2D.parseUInt(b[d].indexB)
    };
    H.prototype.GetSearchDirection = function () {
        switch (this.m_count) {
            case 1:
                return this.m_v1.w.GetNegative();
            case 2:
                var a = f.SubtractVV(this.m_v2.w, this.m_v1.w);
                return 0 < f.CrossVV(a, this.m_v1.w.GetNegative()) ? f.CrossFV(1, a) : f.CrossVF(a, 1);
            default:
                return e.b2Assert(!1), new n
        }
    };
    H.prototype.GetClosestPoint = function () {
        switch (this.m_count) {
            case 0:
                return e.b2Assert(!1), new n;
            case 1:
                return this.m_v1.w;
            case 2:
                return new n(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x,
                    this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
            default:
                return e.b2Assert(!1), new n
        }
    };
    H.prototype.GetWitnessPoints = function (a, b) {
        switch (this.m_count) {
            case 0:
                e.b2Assert(!1);
                break;
            case 1:
                a.SetV(this.m_v1.wA);
                b.SetV(this.m_v1.wB);
                break;
            case 2:
                a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
                a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
                b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
                b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                break;
            case 3:
                b.x = a.x = this.m_v1.a *
                    this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
                b.y = a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                break;
            default:
                e.b2Assert(!1)
        }
    };
    H.prototype.GetMetric = function () {
        switch (this.m_count) {
            case 0:
                return e.b2Assert(!1), 0;
            case 1:
                return 0;
            case 2:
                return f.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
            case 3:
                return f.CrossVV(f.SubtractVV(this.m_v2.w, this.m_v1.w), f.SubtractVV(this.m_v3.w, this.m_v1.w));
            default:
                return e.b2Assert(!1), 0
        }
    };
    H.prototype.Solve2 =
        function () {
            var a = this.m_v1.w, b = this.m_v2.w, d = f.SubtractVV(b, a), a = -(a.x * d.x + a.y * d.y);
            0 >= a ? this.m_count = this.m_v1.a = 1 : (b = b.x * d.x + b.y * d.y, 0 >= b ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : (d = 1 / (b + a), this.m_v1.a = b * d, this.m_v2.a = a * d, this.m_count = 2))
        };
    H.prototype.Solve3 = function () {
        var a = this.m_v1.w, b = this.m_v2.w, d = this.m_v3.w, e = f.SubtractVV(b, a), g = f.Dot(a, e), h = f.Dot(b, e), g = -g, n = f.SubtractVV(d, a), p = f.Dot(a, n), r = f.Dot(d, n), p = -p, s = f.SubtractVV(d, b), F = f.Dot(b, s), s = f.Dot(d, s), F = -F, n = f.CrossVV(e, n),
            e = n * f.CrossVV(b, d), d = n * f.CrossVV(d, a), a = n * f.CrossVV(a, b);
        0 >= g && 0 >= p ? this.m_count = this.m_v1.a = 1 : 0 < h && 0 < g && 0 >= a ? (r = 1 / (h + g), this.m_v1.a = h * r, this.m_v2.a = g * r, this.m_count = 2) : 0 < r && 0 < p && 0 >= d ? (h = 1 / (r + p), this.m_v1.a = r * h, this.m_v3.a = p * h, this.m_count = 2, this.m_v2.Set(this.m_v3)) : 0 >= h && 0 >= F ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : 0 >= r && 0 >= s ? (this.m_count = this.m_v3.a = 1, this.m_v1.Set(this.m_v3)) : 0 < s && 0 < F && 0 >= e ? (h = 1 / (s + F), this.m_v2.a = s * h, this.m_v3.a = F * h, this.m_count = 2, this.m_v1.Set(this.m_v3)) : (h = 1 /
            (e + d + a), this.m_v1.a = e * h, this.m_v2.a = d * h, this.m_v3.a = a * h, this.m_count = 3)
    };
    P.b2SimplexCache = function () {
        this.indexA = new Vector_a2j_Number(3);
        this.indexB = new Vector_a2j_Number(3)
    };
    U.b2SimplexVertex = function () {
    };
    U.prototype.Set = function (a) {
        this.wA.SetV(a.wA);
        this.wB.SetV(a.wB);
        this.w.SetV(a.w);
        this.a = a.a;
        this.indexA = a.indexA;
        this.indexB = a.indexB
    };
    O.b2TimeOfImpact = function () {
    };
    O.TimeOfImpact = function (a) {
        ++O.b2_toiCalls;
        var b = a.proxyA, d = a.proxyB, g = a.sweepA, h = a.sweepB;
        e.b2Assert(g.t0 == h.t0);
        e.b2Assert(1 -
            g.t0 > Number.MIN_VALUE);
        var n = b.m_radius + d.m_radius;
        a = a.tolerance;
        var p = 0, r = 0, s = 0;
        O.s_cache.count = 0;
        for (O.s_distanceInput.useRadii = !1; ;) {
            g.GetTransform(O.s_xfA, p);
            h.GetTransform(O.s_xfB, p);
            O.s_distanceInput.proxyA = b;
            O.s_distanceInput.proxyB = d;
            O.s_distanceInput.transformA = O.s_xfA;
            O.s_distanceInput.transformB = O.s_xfB;
            x.Distance(O.s_distanceOutput, O.s_cache, O.s_distanceInput);
            if (0 >= O.s_distanceOutput.distance) {
                p = 1;
                break
            }
            O.s_fcn.Initialize(O.s_cache, b, O.s_xfA, d, O.s_xfB);
            var F = O.s_fcn.Evaluate(O.s_xfA,
                O.s_xfB);
            if (0 >= F) {
                p = 1;
                break
            }
            0 == r && (s = F > n ? f.Max(n - a, 0.75 * n) : f.Max(F - a, 0.02 * n));
            if (F - s < 0.5 * a) {
                if (0 == r) {
                    p = 1;
                    break
                }
                break
            }
            var t = p, N = p, K = 1;
            g.GetTransform(O.s_xfA, K);
            h.GetTransform(O.s_xfB, K);
            var u = O.s_fcn.Evaluate(O.s_xfA, O.s_xfB);
            if (u >= s) {
                p = 1;
                break
            }
            for (var y = 0; ;) {
                var v = 0, v = y & 1 ? N + (s - F) * (K - N) / (u - F) : 0.5 * (N + K);
                g.GetTransform(O.s_xfA, v);
                h.GetTransform(O.s_xfB, v);
                var H = O.s_fcn.Evaluate(O.s_xfA, O.s_xfB);
                if (f.Abs(H - s) < 0.025 * a) {
                    t = v;
                    break
                }
                H > s ? (N = v, F = H) : (K = v, u = H);
                ++y;
                ++O.b2_toiRootIters;
                if (50 == y)break
            }
            O.b2_toiMaxRootIters =
                f.Max(O.b2_toiMaxRootIters, y);
            if (t < (1 + 100 * Number.MIN_VALUE) * p)break;
            p = t;
            r++;
            ++O.b2_toiIters;
            if (1E3 == r)break
        }
        O.b2_toiMaxIters = f.Max(O.b2_toiMaxIters, r);
        return p
    };
    Box2D.postDefs.push(function () {
        Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.s_cache = new P;
        Box2D.Collision.b2TimeOfImpact.s_distanceInput =
            new w;
        Box2D.Collision.b2TimeOfImpact.s_xfA = new h;
        Box2D.Collision.b2TimeOfImpact.s_xfB = new h;
        Box2D.Collision.b2TimeOfImpact.s_fcn = new K;
        Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new y
    });
    Y.b2TOIInput = function () {
        this.proxyA = new A;
        this.proxyB = new A;
        this.sweepA = new g;
        this.sweepB = new g
    };
    V.b2WorldManifold = function () {
        this.m_normal = new n
    };
    V.prototype.b2WorldManifold = function () {
        this.m_points = new Vector(e.b2_maxManifoldPoints);
        for (var a = 0; a < e.b2_maxManifoldPoints; a++)this.m_points[a] = new n
    };
    V.prototype.Initialize =
        function (a, b, d, e, f) {
            void 0 === d && (d = 0);
            void 0 === f && (f = 0);
            if (0 != a.m_pointCount) {
                var g = 0, h, n, p = 0, r = 0, s = 0, F = 0, t = 0;
                h = 0;
                switch (a.m_type) {
                    case E.e_circles:
                        n = b.R;
                        h = a.m_localPoint;
                        g = b.position.x + n.col1.x * h.x + n.col2.x * h.y;
                        b = b.position.y + n.col1.y * h.x + n.col2.y * h.y;
                        n = e.R;
                        h = a.m_points[0].m_localPoint;
                        a = e.position.x + n.col1.x * h.x + n.col2.x * h.y;
                        e = e.position.y + n.col1.y * h.x + n.col2.y * h.y;
                        h = a - g;
                        n = e - b;
                        p = h * h + n * n;
                        p > Number.MIN_VALUE * Number.MIN_VALUE ? (p = Math.sqrt(p), this.m_normal.x = h / p, this.m_normal.y = n / p) : (this.m_normal.x =
                            1, this.m_normal.y = 0);
                        h = b + d * this.m_normal.y;
                        e -= f * this.m_normal.y;
                        this.m_points[0].x = 0.5 * (g + d * this.m_normal.x + (a - f * this.m_normal.x));
                        this.m_points[0].y = 0.5 * (h + e);
                        break;
                    case E.e_faceA:
                        n = b.R;
                        h = a.m_localPlaneNormal;
                        p = n.col1.x * h.x + n.col2.x * h.y;
                        r = n.col1.y * h.x + n.col2.y * h.y;
                        n = b.R;
                        h = a.m_localPoint;
                        s = b.position.x + n.col1.x * h.x + n.col2.x * h.y;
                        F = b.position.y + n.col1.y * h.x + n.col2.y * h.y;
                        this.m_normal.x = p;
                        this.m_normal.y = r;
                        for (g = 0; g < a.m_pointCount; g++)n = e.R, h = a.m_points[g].m_localPoint, t = e.position.x + n.col1.x * h.x + n.col2.x *
                            h.y, h = e.position.y + n.col1.y * h.x + n.col2.y * h.y, this.m_points[g].x = t + 0.5 * (d - (t - s) * p - (h - F) * r - f) * p, this.m_points[g].y = h + 0.5 * (d - (t - s) * p - (h - F) * r - f) * r;
                        break;
                    case E.e_faceB:
                        for (n = e.R, h = a.m_localPlaneNormal, p = n.col1.x * h.x + n.col2.x * h.y, r = n.col1.y * h.x + n.col2.y * h.y, n = e.R, h = a.m_localPoint, s = e.position.x + n.col1.x * h.x + n.col2.x * h.y, F = e.position.y + n.col1.y * h.x + n.col2.y * h.y, this.m_normal.x = -p, this.m_normal.y = -r, g = 0; g < a.m_pointCount; g++)n = b.R, h = a.m_points[g].m_localPoint, t = b.position.x + n.col1.x * h.x + n.col2.x * h.y, h = b.position.y +
                            n.col1.y * h.x + n.col2.y * h.y, this.m_points[g].x = t + 0.5 * (f - (t - s) * p - (h - F) * r - d) * p, this.m_points[g].y = h + 0.5 * (f - (t - s) * p - (h - F) * r - d) * r
                }
            }
        };
    F.ClipVertex = function () {
        this.v = new n;
        this.id = new v
    };
    F.prototype.Set = function (a) {
        this.v.SetV(a.v);
        this.id.Set(a.id)
    };
    N.Features = function () {
    };
    Object.defineProperty(N.prototype, "referenceEdge", {
        enumerable: !1, configurable: !0, get: function () {
            return this._referenceEdge
        }
    });
    Object.defineProperty(N.prototype, "referenceEdge", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a &&
            (a = 0);
            this._referenceEdge = a;
            this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
        }
    });
    Object.defineProperty(N.prototype, "incidentEdge", {
        enumerable: !1, configurable: !0, get: function () {
            return this._incidentEdge
        }
    });
    Object.defineProperty(N.prototype, "incidentEdge", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a && (a = 0);
            this._incidentEdge = a;
            this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
        }
    });
    Object.defineProperty(N.prototype, "incidentVertex", {
        enumerable: !1, configurable: !0,
        get: function () {
            return this._incidentVertex
        }
    });
    Object.defineProperty(N.prototype, "incidentVertex", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a && (a = 0);
            this._incidentVertex = a;
            this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
        }
    });
    Object.defineProperty(N.prototype, "flip", {
        enumerable: !1, configurable: !0, get: function () {
            return this._flip
        }
    });
    Object.defineProperty(N.prototype, "flip", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a && (a = 0);
            this._flip = a;
            this._m_id._key =
                this._m_id._key & 16777215 | this._flip << 24 & 4278190080
        }
    })
})();
(function () {
    var a = Box2D.Common.b2Settings, b = Box2D.Collision.Shapes.b2CircleShape, d = Box2D.Collision.Shapes.b2EdgeChainDef, e = Box2D.Collision.Shapes.b2EdgeShape, f = Box2D.Collision.Shapes.b2MassData, g = Box2D.Collision.Shapes.b2PolygonShape, h = Box2D.Collision.Shapes.b2Shape, n = Box2D.Common.Math.b2Mat22, p = Box2D.Common.Math.b2Math, r = Box2D.Common.Math.b2Transform, s = Box2D.Common.Math.b2Vec2, t = Box2D.Collision.b2Distance, v = Box2D.Collision.b2DistanceInput, u = Box2D.Collision.b2DistanceOutput, x = Box2D.Collision.b2DistanceProxy,
        w = Box2D.Collision.b2SimplexCache;
    Box2D.inherit(b, Box2D.Collision.Shapes.b2Shape);
    b.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    b.b2CircleShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.m_p = new s
    };
    b.prototype.Copy = function () {
        var a = new b;
        a.Set(this);
        return a
    };
    b.prototype.Set = function (a) {
        this.__super.Set.call(this, a);
        Box2D.is(a, b) && this.m_p.SetV((a instanceof b ? a : null).m_p)
    };
    b.prototype.TestPoint = function (a, b) {
        var d = a.R, e = a.position.x + (d.col1.x * this.m_p.x +
            d.col2.x * this.m_p.y), d = a.position.y + (d.col1.y * this.m_p.x + d.col2.y * this.m_p.y), e = b.x - e, d = b.y - d;
        return e * e + d * d <= this.m_radius * this.m_radius
    };
    b.prototype.RayCast = function (a, b, d) {
        var e = d.R, f = b.p1.x - (d.position.x + (e.col1.x * this.m_p.x + e.col2.x * this.m_p.y));
        d = b.p1.y - (d.position.y + (e.col1.y * this.m_p.x + e.col2.y * this.m_p.y));
        var e = b.p2.x - b.p1.x, g = b.p2.y - b.p1.y, h = f * e + d * g, n = e * e + g * g, p = h * h - n * (f * f + d * d - this.m_radius * this.m_radius);
        if (0 > p || n < Number.MIN_VALUE)return !1;
        h = -(h + Math.sqrt(p));
        return 0 <= h && h <= b.maxFraction *
        n ? (h /= n, a.fraction = h, a.normal.x = f + h * e, a.normal.y = d + h * g, a.normal.Normalize(), !0) : !1
    };
    b.prototype.ComputeAABB = function (a, b) {
        var d = b.R, e = b.position.x + (d.col1.x * this.m_p.x + d.col2.x * this.m_p.y), d = b.position.y + (d.col1.y * this.m_p.x + d.col2.y * this.m_p.y);
        a.lowerBound.Set(e - this.m_radius, d - this.m_radius);
        a.upperBound.Set(e + this.m_radius, d + this.m_radius)
    };
    b.prototype.ComputeMass = function (b, d) {
        void 0 === d && (d = 0);
        b.mass = d * a.b2_pi * this.m_radius * this.m_radius;
        b.center.SetV(this.m_p);
        b.I = b.mass * (0.5 * this.m_radius *
            this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
    };
    b.prototype.ComputeSubmergedArea = function (a, b, d, e) {
        void 0 === b && (b = 0);
        d = p.MulX(d, this.m_p);
        var f = -(p.Dot(a, d) - b);
        if (f < -this.m_radius + Number.MIN_VALUE)return 0;
        if (f > this.m_radius)return e.SetV(d), Math.PI * this.m_radius * this.m_radius;
        b = this.m_radius * this.m_radius;
        var g = f * f, f = b * (Math.asin(f / this.m_radius) + Math.PI / 2) + f * Math.sqrt(b - g);
        b = -2 / 3 * Math.pow(b - g, 1.5) / f;
        e.x = d.x + a.x * b;
        e.y = d.y + a.y * b;
        return f
    };
    b.prototype.GetLocalPosition = function () {
        return this.m_p
    };
    b.prototype.SetLocalPosition = function (a) {
        this.m_p.SetV(a)
    };
    b.prototype.GetRadius = function () {
        return this.m_radius
    };
    b.prototype.SetRadius = function (a) {
        void 0 === a && (a = 0);
        this.m_radius = a
    };
    b.prototype.b2CircleShape = function (a) {
        void 0 === a && (a = 0);
        this.__super.b2Shape.call(this);
        this.m_type = h.e_circleShape;
        this.m_radius = a
    };
    d.b2EdgeChainDef = function () {
    };
    d.prototype.b2EdgeChainDef = function () {
        this.vertexCount = 0;
        this.isALoop = !0;
        this.vertices = []
    };
    Box2D.inherit(e, Box2D.Collision.Shapes.b2Shape);
    e.prototype.__super =
        Box2D.Collision.Shapes.b2Shape.prototype;
    e.b2EdgeShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.s_supportVec = new s;
        this.m_v1 = new s;
        this.m_v2 = new s;
        this.m_coreV1 = new s;
        this.m_coreV2 = new s;
        this.m_normal = new s;
        this.m_direction = new s;
        this.m_cornerDir1 = new s;
        this.m_cornerDir2 = new s
    };
    e.prototype.TestPoint = function (a, b) {
        return !1
    };
    e.prototype.RayCast = function (a, b, d) {
        var e, f = b.p2.x - b.p1.x, g = b.p2.y - b.p1.y;
        e = d.R;
        var h = d.position.x + (e.col1.x * this.m_v1.x + e.col2.x * this.m_v1.y),
            n = d.position.y + (e.col1.y * this.m_v1.x + e.col2.y * this.m_v1.y), p = d.position.y + (e.col1.y * this.m_v2.x + e.col2.y * this.m_v2.y) - n;
        d = -(d.position.x + (e.col1.x * this.m_v2.x + e.col2.x * this.m_v2.y) - h);
        e = 100 * Number.MIN_VALUE;
        var r = -(f * p + g * d);
        if (r > e) {
            var h = b.p1.x - h, s = b.p1.y - n, n = h * p + s * d;
            if (0 <= n && n <= b.maxFraction * r && (b = -f * s + g * h, -e * r <= b && b <= r * (1 + e)))return a.fraction = n / r, b = Math.sqrt(p * p + d * d), a.normal.x = p / b, a.normal.y = d / b, !0
        }
        return !1
    };
    e.prototype.ComputeAABB = function (a, b) {
        var d = b.R, e = b.position.x + (d.col1.x * this.m_v1.x +
            d.col2.x * this.m_v1.y), f = b.position.y + (d.col1.y * this.m_v1.x + d.col2.y * this.m_v1.y), g = b.position.x + (d.col1.x * this.m_v2.x + d.col2.x * this.m_v2.y), d = b.position.y + (d.col1.y * this.m_v2.x + d.col2.y * this.m_v2.y);
        e < g ? (a.lowerBound.x = e, a.upperBound.x = g) : (a.lowerBound.x = g, a.upperBound.x = e);
        f < d ? (a.lowerBound.y = f, a.upperBound.y = d) : (a.lowerBound.y = d, a.upperBound.y = f)
    };
    e.prototype.ComputeMass = function (a, b) {
        a.mass = 0;
        a.center.SetV(this.m_v1);
        a.I = 0
    };
    e.prototype.ComputeSubmergedArea = function (a, b, d, e) {
        void 0 === b && (b = 0);
        var f =
            new s(a.x * b, a.y * b), g = p.MulX(d, this.m_v1);
        d = p.MulX(d, this.m_v2);
        var h = p.Dot(a, g) - b;
        a = p.Dot(a, d) - b;
        if (0 < h) {
            if (0 < a)return 0;
            g.x = -a / (h - a) * g.x + h / (h - a) * d.x;
            g.y = -a / (h - a) * g.y + h / (h - a) * d.y
        } else 0 < a && (d.x = -a / (h - a) * g.x + h / (h - a) * d.x, d.y = -a / (h - a) * g.y + h / (h - a) * d.y);
        e.x = (f.x + g.x + d.x) / 3;
        e.y = (f.y + g.y + d.y) / 3;
        return 0.5 * ((g.x - f.x) * (d.y - f.y) - (g.y - f.y) * (d.x - f.x))
    };
    e.prototype.GetLength = function () {
        return this.m_length
    };
    e.prototype.GetVertex1 = function () {
        return this.m_v1
    };
    e.prototype.GetVertex2 = function () {
        return this.m_v2
    };
    e.prototype.GetCoreVertex1 = function () {
        return this.m_coreV1
    };
    e.prototype.GetCoreVertex2 = function () {
        return this.m_coreV2
    };
    e.prototype.GetNormalVector = function () {
        return this.m_normal
    };
    e.prototype.GetDirectionVector = function () {
        return this.m_direction
    };
    e.prototype.GetCorner1Vector = function () {
        return this.m_cornerDir1
    };
    e.prototype.GetCorner2Vector = function () {
        return this.m_cornerDir2
    };
    e.prototype.Corner1IsConvex = function () {
        return this.m_cornerConvex1
    };
    e.prototype.Corner2IsConvex = function () {
        return this.m_cornerConvex2
    };
    e.prototype.GetFirstVertex = function (a) {
        var b = a.R;
        return new s(a.position.x + (b.col1.x * this.m_coreV1.x + b.col2.x * this.m_coreV1.y), a.position.y + (b.col1.y * this.m_coreV1.x + b.col2.y * this.m_coreV1.y))
    };
    e.prototype.GetNextEdge = function () {
        return this.m_nextEdge
    };
    e.prototype.GetPrevEdge = function () {
        return this.m_prevEdge
    };
    e.prototype.Support = function (a, b, d) {
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        var e = a.R, f = a.position.x + (e.col1.x * this.m_coreV1.x + e.col2.x * this.m_coreV1.y), g = a.position.y + (e.col1.y * this.m_coreV1.x +
            e.col2.y * this.m_coreV1.y), h = a.position.x + (e.col1.x * this.m_coreV2.x + e.col2.x * this.m_coreV2.y);
        a = a.position.y + (e.col1.y * this.m_coreV2.x + e.col2.y * this.m_coreV2.y);
        f * b + g * d > h * b + a * d ? (this.s_supportVec.x = f, this.s_supportVec.y = g) : (this.s_supportVec.x = h, this.s_supportVec.y = a);
        return this.s_supportVec
    };
    e.prototype.b2EdgeShape = function (b, d) {
        this.__super.b2Shape.call(this);
        this.m_type = h.e_edgeShape;
        this.m_nextEdge = this.m_prevEdge = null;
        this.m_v1 = b;
        this.m_v2 = d;
        this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y -
            this.m_v1.y);
        this.m_length = this.m_direction.Normalize();
        this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
        this.m_coreV1.Set(-a.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -a.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
        this.m_coreV2.Set(-a.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -a.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
        this.m_cornerDir1 = this.m_normal;
        this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
    };
    e.prototype.SetPrevEdge =
        function (a, b, d, e) {
            this.m_prevEdge = a;
            this.m_coreV1 = b;
            this.m_cornerDir1 = d;
            this.m_cornerConvex1 = e
        };
    e.prototype.SetNextEdge = function (a, b, d, e) {
        this.m_nextEdge = a;
        this.m_coreV2 = b;
        this.m_cornerDir2 = d;
        this.m_cornerConvex2 = e
    };
    f.b2MassData = function () {
        this.mass = 0;
        this.center = new s(0, 0);
        this.I = 0
    };
    Box2D.inherit(g, Box2D.Collision.Shapes.b2Shape);
    g.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    g.b2PolygonShape = function () {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments)
    };
    g.prototype.Copy =
        function () {
            var a = new g;
            a.Set(this);
            return a
        };
    g.prototype.Set = function (a) {
        this.__super.Set.call(this, a);
        if (Box2D.is(a, g)) {
            a = a instanceof g ? a : null;
            this.m_centroid.SetV(a.m_centroid);
            this.m_vertexCount = a.m_vertexCount;
            this.Reserve(this.m_vertexCount);
            for (var b = 0; b < this.m_vertexCount; b++)this.m_vertices[b].SetV(a.m_vertices[b]), this.m_normals[b].SetV(a.m_normals[b])
        }
    };
    g.prototype.SetAsArray = function (a, b) {
        void 0 === b && (b = 0);
        for (var d = new Vector, e = 0, f, e = 0; e < a.length; ++e)f = a[e], d.push(f);
        this.SetAsVector(d,
            b)
    };
    g.AsArray = function (a, b) {
        void 0 === b && (b = 0);
        var d = new g;
        d.SetAsArray(a, b);
        return d
    };
    g.prototype.SetAsVector = function (b, d) {
        void 0 === d && (d = 0);
        0 == d && (d = b.length);
        a.b2Assert(2 <= d);
        this.m_vertexCount = d;
        this.Reserve(d);
        for (var e = 0, e = 0; e < this.m_vertexCount; e++)this.m_vertices[e].SetV(b[e]);
        for (e = 0; e < this.m_vertexCount; ++e) {
            var f = parseInt(e), h = parseInt(e + 1 < this.m_vertexCount ? e + 1 : 0), f = p.SubtractVV(this.m_vertices[h], this.m_vertices[f]);
            a.b2Assert(f.LengthSquared() > Number.MIN_VALUE);
            this.m_normals[e].SetV(p.CrossVF(f,
                1));
            this.m_normals[e].Normalize()
        }
        this.m_centroid = g.ComputeCentroid(this.m_vertices, this.m_vertexCount)
    };
    g.AsVector = function (a, b) {
        void 0 === b && (b = 0);
        var d = new g;
        d.SetAsVector(a, b);
        return d
    };
    g.prototype.SetAsBox = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set(-a, -b);
        this.m_vertices[1].Set(a, -b);
        this.m_vertices[2].Set(a, b);
        this.m_vertices[3].Set(-a, b);
        this.m_normals[0].Set(0, -1);
        this.m_normals[1].Set(1, 0);
        this.m_normals[2].Set(0, 1);
        this.m_normals[3].Set(-1,
            0);
        this.m_centroid.SetZero()
    };
    g.AsBox = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        var d = new g;
        d.SetAsBox(a, b);
        return d
    };
    g.prototype.SetAsOrientedBox = function (a, b, d, e) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === d && (d = null);
        void 0 === e && (e = 0);
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set(-a, -b);
        this.m_vertices[1].Set(a, -b);
        this.m_vertices[2].Set(a, b);
        this.m_vertices[3].Set(-a, b);
        this.m_normals[0].Set(0, -1);
        this.m_normals[1].Set(1, 0);
        this.m_normals[2].Set(0, 1);
        this.m_normals[3].Set(-1,
            0);
        this.m_centroid = d;
        a = new r;
        a.position = d;
        a.R.Set(e);
        for (d = 0; d < this.m_vertexCount; ++d)this.m_vertices[d] = p.MulX(a, this.m_vertices[d]), this.m_normals[d] = p.MulMV(a.R, this.m_normals[d])
    };
    g.AsOrientedBox = function (a, b, d, e) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === d && (d = null);
        void 0 === e && (e = 0);
        var f = new g;
        f.SetAsOrientedBox(a, b, d, e);
        return f
    };
    g.prototype.SetAsEdge = function (a, b) {
        this.m_vertexCount = 2;
        this.Reserve(2);
        this.m_vertices[0].SetV(a);
        this.m_vertices[1].SetV(b);
        this.m_centroid.x = 0.5 * (a.x + b.x);
        this.m_centroid.y = 0.5 * (a.y + b.y);
        this.m_normals[0] = p.CrossVF(p.SubtractVV(b, a), 1);
        this.m_normals[0].Normalize();
        this.m_normals[1].x = -this.m_normals[0].x;
        this.m_normals[1].y = -this.m_normals[0].y
    };
    g.AsEdge = function (a, b) {
        var d = new g;
        d.SetAsEdge(a, b);
        return d
    };
    g.prototype.TestPoint = function (a, b) {
        var d;
        d = a.R;
        for (var e = b.x - a.position.x, f = b.y - a.position.y, g = e * d.col1.x + f * d.col1.y, h = e * d.col2.x + f * d.col2.y, n = 0; n < this.m_vertexCount; ++n)if (d = this.m_vertices[n], e = g - d.x, f = h - d.y, d = this.m_normals[n], 0 < d.x * e + d.y * f)return !1;
        return !0
    };
    g.prototype.RayCast = function (a, b, d) {
        var e = 0, f = b.maxFraction, g = 0, h = 0, n, p, g = b.p1.x - d.position.x, h = b.p1.y - d.position.y;
        n = d.R;
        var r = g * n.col1.x + h * n.col1.y, s = g * n.col2.x + h * n.col2.y, g = b.p2.x - d.position.x, h = b.p2.y - d.position.y;
        n = d.R;
        b = g * n.col1.x + h * n.col1.y - r;
        n = g * n.col2.x + h * n.col2.y - s;
        for (var t = -1, K = 0; K < this.m_vertexCount; ++K) {
            p = this.m_vertices[K];
            g = p.x - r;
            h = p.y - s;
            p = this.m_normals[K];
            g = p.x * g + p.y * h;
            h = p.x * b + p.y * n;
            if (0 == h) {
                if (0 > g)return !1
            } else 0 > h && g < e * h ? (e = g / h, t = K) : 0 < h && g < f * h && (f = g / h);
            if (f < e - Number.MIN_VALUE)return !1
        }
        return 0 <=
        t ? (a.fraction = e, n = d.R, p = this.m_normals[t], a.normal.x = n.col1.x * p.x + n.col2.x * p.y, a.normal.y = n.col1.y * p.x + n.col2.y * p.y, !0) : !1
    };
    g.prototype.ComputeAABB = function (a, b) {
        for (var d = b.R, e = this.m_vertices[0], f = b.position.x + (d.col1.x * e.x + d.col2.x * e.y), g = b.position.y + (d.col1.y * e.x + d.col2.y * e.y), h = f, n = g, p = 1; p < this.m_vertexCount; ++p)var e = this.m_vertices[p], r = b.position.x + (d.col1.x * e.x + d.col2.x * e.y), e = b.position.y + (d.col1.y * e.x + d.col2.y * e.y), f = f < r ? f : r, g = g < e ? g : e, h = h > r ? h : r, n = n > e ? n : e;
        a.lowerBound.x = f - this.m_radius;
        a.lowerBound.y = g - this.m_radius;
        a.upperBound.x = h + this.m_radius;
        a.upperBound.y = n + this.m_radius
    };
    g.prototype.ComputeMass = function (a, b) {
        void 0 === b && (b = 0);
        if (2 == this.m_vertexCount)a.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x), a.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y), a.mass = 0, a.I = 0; else {
            for (var d = 0, e = 0, f = 0, g = 0, h = 1 / 3, n = 0; n < this.m_vertexCount; ++n)var p = this.m_vertices[n], r = n + 1 < this.m_vertexCount ? this.m_vertices[parseInt(n + 1)] : this.m_vertices[0], s = p.x - 0, t = p.y - 0, K = r.x - 0, u = r.y -
                0, v = s * u - t * K, x = 0.5 * v, f = f + x, d = d + x * h * (0 + p.x + r.x), e = e + x * h * (0 + p.y + r.y), p = s, g = g + v * (h * (0.25 * (p * p + K * p + K * K) + (0 * p + 0 * K)) + 0 + (h * (0.25 * (t * t + u * t + u * u) + (0 * t + 0 * u)) + 0));
            a.mass = b * f;
            a.center.Set(1 / f * d, 1 / f * e);
            a.I = b * g
        }
    };
    g.prototype.ComputeSubmergedArea = function (a, b, d, e) {
        void 0 === b && (b = 0);
        var g = p.MulTMV(d.R, a), h = b - p.Dot(a, d.position), n = new Vector_a2j_Number, r = 0, t = -1;
        b = -1;
        var u = !1;
        for (a = a = 0; a < this.m_vertexCount; ++a) {
            n[a] = p.Dot(g, this.m_vertices[a]) - h;
            var v = n[a] < -Number.MIN_VALUE;
            0 < a && (v ? u || (t = a - 1, r++) : u && (b = a - 1, r++));
            u = v
        }
        switch (r) {
            case 0:
                return u ?
                    (a = new f, this.ComputeMass(a, 1), e.SetV(p.MulX(d, a.center)), a.mass) : 0;
            case 1:
                -1 == t ? t = this.m_vertexCount - 1 : b = this.m_vertexCount - 1
        }
        a = parseInt((t + 1) % this.m_vertexCount);
        g = parseInt((b + 1) % this.m_vertexCount);
        h = (0 - n[t]) / (n[a] - n[t]);
        n = (0 - n[b]) / (n[g] - n[b]);
        t = new s(this.m_vertices[t].x * (1 - h) + this.m_vertices[a].x * h, this.m_vertices[t].y * (1 - h) + this.m_vertices[a].y * h);
        b = new s(this.m_vertices[b].x * (1 - n) + this.m_vertices[g].x * n, this.m_vertices[b].y * (1 - n) + this.m_vertices[g].y * n);
        n = 0;
        h = new s;
        for (r = this.m_vertices[a]; a !=
        g;)a = (a + 1) % this.m_vertexCount, u = a == g ? b : this.m_vertices[a], v = 0.5 * ((r.x - t.x) * (u.y - t.y) - (r.y - t.y) * (u.x - t.x)), n += v, h.x += v * (t.x + r.x + u.x) / 3, h.y += v * (t.y + r.y + u.y) / 3, r = u;
        h.Multiply(1 / n);
        e.SetV(p.MulX(d, h));
        return n
    };
    g.prototype.GetVertexCount = function () {
        return this.m_vertexCount
    };
    g.prototype.GetVertices = function () {
        return this.m_vertices
    };
    g.prototype.GetNormals = function () {
        return this.m_normals
    };
    g.prototype.GetSupport = function (a) {
        for (var b = 0, d = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, e = 1; e < this.m_vertexCount; ++e) {
            var f =
                this.m_vertices[e].x * a.x + this.m_vertices[e].y * a.y;
            f > d && (b = e, d = f)
        }
        return b
    };
    g.prototype.GetSupportVertex = function (a) {
        for (var b = 0, d = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, e = 1; e < this.m_vertexCount; ++e) {
            var f = this.m_vertices[e].x * a.x + this.m_vertices[e].y * a.y;
            f > d && (b = e, d = f)
        }
        return this.m_vertices[b]
    };
    g.prototype.Validate = function () {
        return !1
    };
    g.prototype.b2PolygonShape = function () {
        this.__super.b2Shape.call(this);
        this.m_type = h.e_polygonShape;
        this.m_centroid = new s;
        this.m_vertices = new Vector;
        this.m_normals =
            new Vector
    };
    g.prototype.Reserve = function (a) {
        void 0 === a && (a = 0);
        for (var b = parseInt(this.m_vertices.length); b < a; b++)this.m_vertices[b] = new s, this.m_normals[b] = new s
    };
    g.ComputeCentroid = function (a, b) {
        void 0 === b && (b = 0);
        for (var d = new s, e = 0, f = 1 / 3, g = 0; g < b; ++g) {
            var h = a[g], n = g + 1 < b ? a[parseInt(g + 1)] : a[0], p = 0.5 * ((h.x - 0) * (n.y - 0) - (h.y - 0) * (n.x - 0)), e = e + p;
            d.x += p * f * (0 + h.x + n.x);
            d.y += p * f * (0 + h.y + n.y)
        }
        d.x *= 1 / e;
        d.y *= 1 / e;
        return d
    };
    g.ComputeOBB = function (a, b, d) {
        void 0 === d && (d = 0);
        for (var e = 0, f = new Vector(d + 1), e = 0; e < d; ++e)f[e] =
            b[e];
        f[d] = f[0];
        b = Number.MAX_VALUE;
        for (e = 1; e <= d; ++e) {
            for (var g = f[parseInt(e - 1)], h = f[e].x - g.x, n = f[e].y - g.y, p = Math.sqrt(h * h + n * n), h = h / p, n = n / p, r = -n, s = h, t = p = Number.MAX_VALUE, K = -Number.MAX_VALUE, u = -Number.MAX_VALUE, v = 0; v < d; ++v) {
                var x = f[v].x - g.x, w = f[v].y - g.y, Y = h * x + n * w, x = r * x + s * w;
                Y < p && (p = Y);
                x < t && (t = x);
                Y > K && (K = Y);
                x > u && (u = x)
            }
            v = (K - p) * (u - t);
            v < 0.95 * b && (b = v, a.R.col1.x = h, a.R.col1.y = n, a.R.col2.x = r, a.R.col2.y = s, h = 0.5 * (p + K), n = 0.5 * (t + u), r = a.R, a.center.x = g.x + (r.col1.x * h + r.col2.x * n), a.center.y = g.y + (r.col1.y * h + r.col2.y *
                n), a.extents.x = 0.5 * (K - p), a.extents.y = 0.5 * (u - t))
        }
    };
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2PolygonShape.s_mat = new n
    });
    h.b2Shape = function () {
    };
    h.prototype.Copy = function () {
        return null
    };
    h.prototype.Set = function (a) {
        this.m_radius = a.m_radius
    };
    h.prototype.GetType = function () {
        return this.m_type
    };
    h.prototype.TestPoint = function (a, b) {
        return !1
    };
    h.prototype.RayCast = function (a, b, d) {
        return !1
    };
    h.prototype.ComputeAABB = function (a, b) {
    };
    h.prototype.ComputeMass = function (a, b) {
    };
    h.prototype.ComputeSubmergedArea =
        function (a, b, d, e) {
            return 0
        };
    h.TestOverlap = function (a, b, d, e) {
        var f = new v;
        f.proxyA = new x;
        f.proxyA.Set(a);
        f.proxyB = new x;
        f.proxyB.Set(d);
        f.transformA = b;
        f.transformB = e;
        f.useRadii = !0;
        a = new w;
        a.count = 0;
        b = new u;
        t.Distance(b, a, f);
        return b.distance < 10 * Number.MIN_VALUE
    };
    h.prototype.b2Shape = function () {
        this.m_type = h.e_unknownShape;
        this.m_radius = a.b2_linearSlop
    };
    Box2D.postDefs.push(function () {
        Box2D.Collision.Shapes.b2Shape.e_unknownShape = -1;
        Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
        Box2D.Collision.Shapes.b2Shape.e_polygonShape =
            1;
        Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
        Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
        Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
        Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
        Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = -1
    })
})();
(function () {
    var a = Box2D.Common.b2Color, b = Box2D.Common.b2Settings, d = Box2D.Common.Math.b2Math;
    a.b2Color = function () {
        this._b = this._g = this._r = 0
    };
    a.prototype.b2Color = function (a, b, g) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === g && (g = 0);
        this._r = Box2D.parseUInt(255 * d.Clamp(a, 0, 1));
        this._g = Box2D.parseUInt(255 * d.Clamp(b, 0, 1));
        this._b = Box2D.parseUInt(255 * d.Clamp(g, 0, 1))
    };
    a.prototype.Set = function (a, b, g) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === g && (g = 0);
        this._r = Box2D.parseUInt(255 * d.Clamp(a, 0, 1));
        this._g =
            Box2D.parseUInt(255 * d.Clamp(b, 0, 1));
        this._b = Box2D.parseUInt(255 * d.Clamp(g, 0, 1))
    };
    Object.defineProperty(a.prototype, "r", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a && (a = 0);
            this._r = Box2D.parseUInt(255 * d.Clamp(a, 0, 1))
        }
    });
    Object.defineProperty(a.prototype, "g", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a && (a = 0);
            this._g = Box2D.parseUInt(255 * d.Clamp(a, 0, 1))
        }
    });
    Object.defineProperty(a.prototype, "b", {
        enumerable: !1, configurable: !0, set: function (a) {
            void 0 === a && (a = 0);
            this._b = Box2D.parseUInt(255 *
                d.Clamp(a, 0, 1))
        }
    });
    Object.defineProperty(a.prototype, "color", {
        enumerable: !1, configurable: !0, get: function () {
            return this._r << 16 | this._g << 8 | this._b
        }
    });
    b.b2Settings = function () {
    };
    b.b2MixFriction = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return Math.sqrt(a * b)
    };
    b.b2MixRestitution = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return a > b ? a : b
    };
    b.b2Assert = function (a) {
        if (!a)throw"Assertion Failed";
    };
    Box2D.postDefs.push(function () {
        Box2D.Common.b2Settings.VERSION = "2.1alpha";
        Box2D.Common.b2Settings.USHRT_MAX =
            65535;
        Box2D.Common.b2Settings.b2_pi = Math.PI;
        Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
        Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
        Box2D.Common.b2Settings.b2_aabbMultiplier = 2;
        Box2D.Common.b2Settings.b2_polygonRadius = 2 * b.b2_linearSlop;
        Box2D.Common.b2Settings.b2_linearSlop = 0.005;
        Box2D.Common.b2Settings.b2_angularSlop = 2 / 180 * b.b2_pi;
        Box2D.Common.b2Settings.b2_toiSlop = 8 * b.b2_linearSlop;
        Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
        Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
        Box2D.Common.b2Settings.b2_velocityThreshold =
            1;
        Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
        Box2D.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * b.b2_pi;
        Box2D.Common.b2Settings.b2_maxTranslation = 2;
        Box2D.Common.b2Settings.b2_maxTranslationSquared = b.b2_maxTranslation * b.b2_maxTranslation;
        Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b.b2_pi;
        Box2D.Common.b2Settings.b2_maxRotationSquared = b.b2_maxRotation * b.b2_maxRotation;
        Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
        Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
        Box2D.Common.b2Settings.b2_linearSleepTolerance =
            0.01;
        Box2D.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * b.b2_pi
    })
})();
(function () {
    var a = Box2D.Common.Math.b2Mat22, b = Box2D.Common.Math.b2Mat33, d = Box2D.Common.Math.b2Math, e = Box2D.Common.Math.b2Sweep, f = Box2D.Common.Math.b2Transform, g = Box2D.Common.Math.b2Vec2, h = Box2D.Common.Math.b2Vec3;
    a.b2Mat22 = function () {
        this.col1 = new g;
        this.col2 = new g
    };
    a.prototype.b2Mat22 = function () {
        this.SetIdentity()
    };
    a.FromAngle = function (b) {
        void 0 === b && (b = 0);
        var d = new a;
        d.Set(b);
        return d
    };
    a.FromVV = function (b, d) {
        var e = new a;
        e.SetVV(b, d);
        return e
    };
    a.prototype.Set = function (a) {
        void 0 === a && (a = 0);
        var b =
            Math.cos(a);
        a = Math.sin(a);
        this.col1.x = b;
        this.col2.x = -a;
        this.col1.y = a;
        this.col2.y = b
    };
    a.prototype.SetVV = function (a, b) {
        this.col1.SetV(a);
        this.col2.SetV(b)
    };
    a.prototype.Copy = function () {
        var b = new a;
        b.SetM(this);
        return b
    };
    a.prototype.SetM = function (a) {
        this.col1.SetV(a.col1);
        this.col2.SetV(a.col2)
    };
    a.prototype.AddM = function (a) {
        this.col1.x += a.col1.x;
        this.col1.y += a.col1.y;
        this.col2.x += a.col2.x;
        this.col2.y += a.col2.y
    };
    a.prototype.SetIdentity = function () {
        this.col1.x = 1;
        this.col2.x = 0;
        this.col1.y = 0;
        this.col2.y = 1
    };
    a.prototype.SetZero = function () {
        this.col1.x = 0;
        this.col2.x = 0;
        this.col1.y = 0;
        this.col2.y = 0
    };
    a.prototype.GetAngle = function () {
        return Math.atan2(this.col1.y, this.col1.x)
    };
    a.prototype.GetInverse = function (a) {
        var b = this.col1.x, d = this.col2.x, e = this.col1.y, f = this.col2.y, g = b * f - d * e;
        0 != g && (g = 1 / g);
        a.col1.x = g * f;
        a.col2.x = -g * d;
        a.col1.y = -g * e;
        a.col2.y = g * b;
        return a
    };
    a.prototype.Solve = function (a, b, d) {
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        var e = this.col1.x, f = this.col2.x, g = this.col1.y, h = this.col2.y, x = e * h - f * g;
        0 != x && (x = 1 / x);
        a.x = x * (h * b - f * d);
        a.y = x * (e * d - g * b);
        return a
    };
    a.prototype.Abs = function () {
        this.col1.Abs();
        this.col2.Abs()
    };
    b.b2Mat33 = function () {
        this.col1 = new h;
        this.col2 = new h;
        this.col3 = new h
    };
    b.prototype.b2Mat33 = function (a, b, d) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        void 0 === d && (d = null);
        a || b || d ? (this.col1.SetV(a), this.col2.SetV(b), this.col3.SetV(d)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero())
    };
    b.prototype.SetVVV = function (a, b, d) {
        this.col1.SetV(a);
        this.col2.SetV(b);
        this.col3.SetV(d)
    };
    b.prototype.Copy =
        function () {
            return new b(this.col1, this.col2, this.col3)
        };
    b.prototype.SetM = function (a) {
        this.col1.SetV(a.col1);
        this.col2.SetV(a.col2);
        this.col3.SetV(a.col3)
    };
    b.prototype.AddM = function (a) {
        this.col1.x += a.col1.x;
        this.col1.y += a.col1.y;
        this.col1.z += a.col1.z;
        this.col2.x += a.col2.x;
        this.col2.y += a.col2.y;
        this.col2.z += a.col2.z;
        this.col3.x += a.col3.x;
        this.col3.y += a.col3.y;
        this.col3.z += a.col3.z
    };
    b.prototype.SetIdentity = function () {
        this.col1.x = 1;
        this.col2.x = 0;
        this.col3.x = 0;
        this.col1.y = 0;
        this.col2.y = 1;
        this.col3.y = 0;
        this.col1.z = 0;
        this.col2.z = 0;
        this.col3.z = 1
    };
    b.prototype.SetZero = function () {
        this.col1.x = 0;
        this.col2.x = 0;
        this.col3.x = 0;
        this.col1.y = 0;
        this.col2.y = 0;
        this.col3.y = 0;
        this.col1.z = 0;
        this.col2.z = 0;
        this.col3.z = 0
    };
    b.prototype.Solve22 = function (a, b, d) {
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        var e = this.col1.x, f = this.col2.x, g = this.col1.y, h = this.col2.y, x = e * h - f * g;
        0 != x && (x = 1 / x);
        a.x = x * (h * b - f * d);
        a.y = x * (e * d - g * b);
        return a
    };
    b.prototype.Solve33 = function (a, b, d, e) {
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        void 0 === e && (e = 0);
        var f = this.col1.x,
            g = this.col1.y, h = this.col1.z, x = this.col2.x, w = this.col2.y, y = this.col2.z, A = this.col3.x, D = this.col3.y, G = this.col3.z, B = f * (w * G - y * D) + g * (y * A - x * G) + h * (x * D - w * A);
        0 != B && (B = 1 / B);
        a.x = B * (b * (w * G - y * D) + d * (y * A - x * G) + e * (x * D - w * A));
        a.y = B * (f * (d * G - e * D) + g * (e * A - b * G) + h * (b * D - d * A));
        a.z = B * (f * (w * e - y * d) + g * (y * b - x * e) + h * (x * d - w * b));
        return a
    };
    d.b2Math = function () {
    };
    d.IsValid = function (a) {
        void 0 === a && (a = 0);
        return isFinite(a)
    };
    d.Dot = function (a, b) {
        return a.x * b.x + a.y * b.y
    };
    d.CrossVV = function (a, b) {
        return a.x * b.y - a.y * b.x
    };
    d.CrossVF = function (a,
                          b) {
        void 0 === b && (b = 0);
        return new g(b * a.y, -b * a.x)
    };
    d.CrossFV = function (a, b) {
        void 0 === a && (a = 0);
        return new g(-a * b.y, a * b.x)
    };
    d.MulMV = function (a, b) {
        return new g(a.col1.x * b.x + a.col2.x * b.y, a.col1.y * b.x + a.col2.y * b.y)
    };
    d.MulTMV = function (a, b) {
        return new g(d.Dot(b, a.col1), d.Dot(b, a.col2))
    };
    d.MulX = function (a, b) {
        var e = d.MulMV(a.R, b);
        e.x += a.position.x;
        e.y += a.position.y;
        return e
    };
    d.MulXT = function (a, b) {
        var e = d.SubtractVV(b, a.position), f = e.x * a.R.col1.x + e.y * a.R.col1.y;
        e.y = e.x * a.R.col2.x + e.y * a.R.col2.y;
        e.x = f;
        return e
    };
    d.AddVV = function (a, b) {
        return new g(a.x + b.x, a.y + b.y)
    };
    d.SubtractVV = function (a, b) {
        return new g(a.x - b.x, a.y - b.y)
    };
    d.Distance = function (a, b) {
        var d = a.x - b.x, e = a.y - b.y;
        return Math.sqrt(d * d + e * e)
    };
    d.DistanceSquared = function (a, b) {
        var d = a.x - b.x, e = a.y - b.y;
        return d * d + e * e
    };
    d.MulFV = function (a, b) {
        void 0 === a && (a = 0);
        return new g(a * b.x, a * b.y)
    };
    d.AddMM = function (b, e) {
        return a.FromVV(d.AddVV(b.col1, e.col1), d.AddVV(b.col2, e.col2))
    };
    d.MulMM = function (b, e) {
        return a.FromVV(d.MulMV(b, e.col1), d.MulMV(b, e.col2))
    };
    d.MulTMM = function (b,
                         e) {
        var f = new g(d.Dot(b.col1, e.col1), d.Dot(b.col2, e.col1)), h = new g(d.Dot(b.col1, e.col2), d.Dot(b.col2, e.col2));
        return a.FromVV(f, h)
    };
    d.Abs = function (a) {
        void 0 === a && (a = 0);
        return 0 < a ? a : -a
    };
    d.AbsV = function (a) {
        return new g(d.Abs(a.x), d.Abs(a.y))
    };
    d.AbsM = function (b) {
        return a.FromVV(d.AbsV(b.col1), d.AbsV(b.col2))
    };
    d.Min = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return a < b ? a : b
    };
    d.MinV = function (a, b) {
        return new g(d.Min(a.x, b.x), d.Min(a.y, b.y))
    };
    d.Max = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return a > b ? a : b
    };
    d.MaxV = function (a, b) {
        return new g(d.Max(a.x, b.x), d.Max(a.y, b.y))
    };
    d.Clamp = function (a, b, d) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        return a < b ? b : a > d ? d : a
    };
    d.ClampV = function (a, b, e) {
        return d.MaxV(b, d.MinV(a, e))
    };
    d.Swap = function (a, b) {
        var d = a[0];
        a[0] = b[0];
        b[0] = d
    };
    d.Random = function () {
        return 2 * Math.random() - 1
    };
    d.RandomRange = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        var d = Math.random();
        return (b - a) * d + a
    };
    d.NextPowerOfTwo = function (a) {
        void 0 === a && (a = 0);
        a |= a >> 1 & 2147483647;
        a |=
            a >> 2 & 1073741823;
        a |= a >> 4 & 268435455;
        a |= a >> 8 & 16777215;
        return (a | a >> 16 & 65535) + 1
    };
    d.IsPowerOfTwo = function (a) {
        void 0 === a && (a = 0);
        return 0 < a && 0 == (a & a - 1)
    };
    Box2D.postDefs.push(function () {
        Box2D.Common.Math.b2Math.b2Vec2_zero = new g(0, 0);
        Box2D.Common.Math.b2Math.b2Mat22_identity = a.FromVV(new g(1, 0), new g(0, 1));
        Box2D.Common.Math.b2Math.b2Transform_identity = new f(d.b2Vec2_zero, d.b2Mat22_identity)
    });
    e.b2Sweep = function () {
        this.localCenter = new g;
        this.c0 = new g;
        this.c = new g
    };
    e.prototype.Set = function (a) {
        this.localCenter.SetV(a.localCenter);
        this.c0.SetV(a.c0);
        this.c.SetV(a.c);
        this.a0 = a.a0;
        this.a = a.a;
        this.t0 = a.t0
    };
    e.prototype.Copy = function () {
        var a = new e;
        a.localCenter.SetV(this.localCenter);
        a.c0.SetV(this.c0);
        a.c.SetV(this.c);
        a.a0 = this.a0;
        a.a = this.a;
        a.t0 = this.t0;
        return a
    };
    e.prototype.GetTransform = function (a, b) {
        void 0 === b && (b = 0);
        a.position.x = (1 - b) * this.c0.x + b * this.c.x;
        a.position.y = (1 - b) * this.c0.y + b * this.c.y;
        a.R.Set((1 - b) * this.a0 + b * this.a);
        var d = a.R;
        a.position.x -= d.col1.x * this.localCenter.x + d.col2.x * this.localCenter.y;
        a.position.y -= d.col1.y *
            this.localCenter.x + d.col2.y * this.localCenter.y
    };
    e.prototype.Advance = function (a) {
        void 0 === a && (a = 0);
        if (this.t0 < a && 1 - this.t0 > Number.MIN_VALUE) {
            var b = (a - this.t0) / (1 - this.t0);
            this.c0.x = (1 - b) * this.c0.x + b * this.c.x;
            this.c0.y = (1 - b) * this.c0.y + b * this.c.y;
            this.a0 = (1 - b) * this.a0 + b * this.a;
            this.t0 = a
        }
    };
    f.b2Transform = function () {
        this.position = new g;
        this.R = new a
    };
    f.prototype.b2Transform = function (a, b) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        a && (this.position.SetV(a), this.R.SetM(b))
    };
    f.prototype.Initialize = function (a,
                                       b) {
        this.position.SetV(a);
        this.R.SetM(b)
    };
    f.prototype.SetIdentity = function () {
        this.position.SetZero();
        this.R.SetIdentity()
    };
    f.prototype.Set = function (a) {
        this.position.SetV(a.position);
        this.R.SetM(a.R)
    };
    f.prototype.GetAngle = function () {
        return Math.atan2(this.R.col1.y, this.R.col1.x)
    };
    g.b2Vec2 = function () {
    };
    g.prototype.b2Vec2 = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.x = a;
        this.y = b
    };
    g.prototype.SetZero = function () {
        this.y = this.x = 0
    };
    g.prototype.Set = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.x = a;
        this.y = b
    };
    g.prototype.SetV = function (a) {
        this.x = a.x;
        this.y = a.y
    };
    g.prototype.GetNegative = function () {
        return new g(-this.x, -this.y)
    };
    g.prototype.NegativeSelf = function () {
        this.x = -this.x;
        this.y = -this.y
    };
    g.Make = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return new g(a, b)
    };
    g.prototype.Copy = function () {
        return new g(this.x, this.y)
    };
    g.prototype.Add = function (a) {
        this.x += a.x;
        this.y += a.y
    };
    g.prototype.Subtract = function (a) {
        this.x -= a.x;
        this.y -= a.y
    };
    g.prototype.Multiply = function (a) {
        void 0 === a && (a = 0);
        this.x *=
            a;
        this.y *= a
    };
    g.prototype.MulM = function (a) {
        var b = this.x;
        this.x = a.col1.x * b + a.col2.x * this.y;
        this.y = a.col1.y * b + a.col2.y * this.y
    };
    g.prototype.MulTM = function (a) {
        var b = d.Dot(this, a.col1);
        this.y = d.Dot(this, a.col2);
        this.x = b
    };
    g.prototype.CrossVF = function (a) {
        void 0 === a && (a = 0);
        var b = this.x;
        this.x = a * this.y;
        this.y = -a * b
    };
    g.prototype.CrossFV = function (a) {
        void 0 === a && (a = 0);
        var b = this.x;
        this.x = -a * this.y;
        this.y = a * b
    };
    g.prototype.MinV = function (a) {
        this.x = this.x < a.x ? this.x : a.x;
        this.y = this.y < a.y ? this.y : a.y
    };
    g.prototype.MaxV =
        function (a) {
            this.x = this.x > a.x ? this.x : a.x;
            this.y = this.y > a.y ? this.y : a.y
        };
    g.prototype.Abs = function () {
        0 > this.x && (this.x = -this.x);
        0 > this.y && (this.y = -this.y)
    };
    g.prototype.Length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    };
    g.prototype.LengthSquared = function () {
        return this.x * this.x + this.y * this.y
    };
    g.prototype.Normalize = function () {
        var a = Math.sqrt(this.x * this.x + this.y * this.y);
        if (a < Number.MIN_VALUE)return 0;
        var b = 1 / a;
        this.x *= b;
        this.y *= b;
        return a
    };
    g.prototype.IsValid = function () {
        return d.IsValid(this.x) &&
            d.IsValid(this.y)
    };
    h.b2Vec3 = function () {
    };
    h.prototype.b2Vec3 = function (a, b, d) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        this.x = a;
        this.y = b;
        this.z = d
    };
    h.prototype.SetZero = function () {
        this.x = this.y = this.z = 0
    };
    h.prototype.Set = function (a, b, d) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        this.x = a;
        this.y = b;
        this.z = d
    };
    h.prototype.SetV = function (a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z
    };
    h.prototype.GetNegative = function () {
        return new h(-this.x, -this.y, -this.z)
    };
    h.prototype.NegativeSelf = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z
    };
    h.prototype.Copy = function () {
        return new h(this.x, this.y, this.z)
    };
    h.prototype.Add = function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z
    };
    h.prototype.Subtract = function (a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z
    };
    h.prototype.Multiply = function (a) {
        void 0 === a && (a = 0);
        this.x *= a;
        this.y *= a;
        this.z *= a
    }
})();
(function () {
    var a = Box2D.Common.Math.b2Math, b = Box2D.Common.Math.b2Sweep, d = Box2D.Common.Math.b2Transform, e = Box2D.Common.Math.b2Vec2, f = Box2D.Common.b2Color, g = Box2D.Common.b2Settings, h = Box2D.Collision.b2AABB, n = Box2D.Collision.b2ContactPoint, p = Box2D.Collision.b2DynamicTreeBroadPhase, r = Box2D.Collision.b2RayCastInput, s = Box2D.Collision.b2RayCastOutput, t = Box2D.Collision.Shapes.b2CircleShape, v = Box2D.Collision.Shapes.b2EdgeShape, u = Box2D.Collision.Shapes.b2MassData, x = Box2D.Collision.Shapes.b2PolygonShape, w = Box2D.Collision.Shapes.b2Shape,
        y = Box2D.Dynamics.b2Body, A = Box2D.Dynamics.b2BodyDef, D = Box2D.Dynamics.b2ContactFilter, G = Box2D.Dynamics.b2ContactImpulse, B = Box2D.Dynamics.b2ContactListener, C = Box2D.Dynamics.b2ContactManager, E = Box2D.Dynamics.b2DebugDraw, I = Box2D.Dynamics.b2DestructionListener, L = Box2D.Dynamics.b2FilterData, J = Box2D.Dynamics.b2Fixture, Q = Box2D.Dynamics.b2FixtureDef, M = Box2D.Dynamics.b2Island, K = Box2D.Dynamics.b2TimeStep, H = Box2D.Dynamics.b2World, P = Box2D.Dynamics.Contacts.b2Contact, U = Box2D.Dynamics.Contacts.b2ContactFactory, O =
            Box2D.Dynamics.Contacts.b2ContactSolver, Y = Box2D.Dynamics.Joints.b2Joint, V = Box2D.Dynamics.Joints.b2PulleyJoint;
    y.b2Body = function () {
        this.m_xf = new d;
        this.m_sweep = new b;
        this.m_linearVelocity = new e;
        this.m_force = new e
    };
    y.prototype.connectEdges = function (b, d, e) {
        void 0 === e && (e = 0);
        var f = Math.atan2(d.GetDirectionVector().y, d.GetDirectionVector().x);
        e = Math.tan(0.5 * (f - e));
        e = a.MulFV(e, d.GetDirectionVector());
        e = a.SubtractVV(e, d.GetNormalVector());
        e = a.MulFV(g.b2_toiSlop, e);
        e = a.AddVV(e, d.GetVertex1());
        var h = a.AddVV(b.GetDirectionVector(),
            d.GetDirectionVector());
        h.Normalize();
        var n = 0 < a.Dot(b.GetDirectionVector(), d.GetNormalVector());
        b.SetNextEdge(d, e, h, n);
        d.SetPrevEdge(b, e, h, n);
        return f
    };
    y.prototype.CreateFixture = function (a) {
        if (!0 == this.m_world.IsLocked())return null;
        var b = new J;
        b.Create(this, this.m_xf, a);
        this.m_flags & y.e_activeFlag && b.CreateProxy(this.m_world.m_contactManager.m_broadPhase, this.m_xf);
        b.m_next = this.m_fixtureList;
        this.m_fixtureList = b;
        ++this.m_fixtureCount;
        b.m_body = this;
        0 < b.m_density && this.ResetMassData();
        this.m_world.m_flags |=
            H.e_newFixture;
        return b
    };
    y.prototype.CreateFixture2 = function (a, b) {
        void 0 === b && (b = 0);
        var d = new Q;
        d.shape = a;
        d.density = b;
        return this.CreateFixture(d)
    };
    y.prototype.DestroyFixture = function (a) {
        if (!0 != this.m_world.IsLocked()) {
            for (var b = this.m_fixtureList, d = null; null != b;) {
                if (b == a) {
                    d ? d.m_next = a.m_next : this.m_fixtureList = a.m_next;
                    break
                }
                d = b;
                b = b.m_next
            }
            for (b = this.m_contactList; b;) {
                var d = b.contact, b = b.next, e = d.GetFixtureA(), f = d.GetFixtureB();
                a != e && a != f || this.m_world.m_contactManager.Destroy(d)
            }
            this.m_flags & y.e_activeFlag &&
            a.DestroyProxy(this.m_world.m_contactManager.m_broadPhase);
            a.Destroy();
            a.m_body = null;
            a.m_next = null;
            --this.m_fixtureCount;
            this.ResetMassData()
        }
    };
    y.prototype.SetPositionAndAngle = function (a, b) {
        void 0 === b && (b = 0);
        var d;
        if (!0 != this.m_world.IsLocked()) {
            this.m_xf.R.Set(b);
            this.m_xf.position.SetV(a);
            d = this.m_xf.R;
            var e = this.m_sweep.localCenter;
            this.m_sweep.c.x = d.col1.x * e.x + d.col2.x * e.y;
            this.m_sweep.c.y = d.col1.y * e.x + d.col2.y * e.y;
            this.m_sweep.c.x += this.m_xf.position.x;
            this.m_sweep.c.y += this.m_xf.position.y;
            this.m_sweep.c0.SetV(this.m_sweep.c);
            this.m_sweep.a0 = this.m_sweep.a = b;
            e = this.m_world.m_contactManager.m_broadPhase;
            for (d = this.m_fixtureList; d; d = d.m_next)d.Synchronize(e, this.m_xf, this.m_xf);
            this.m_world.m_contactManager.FindNewContacts()
        }
    };
    y.prototype.SetTransform = function (a) {
        this.SetPositionAndAngle(a.position, a.GetAngle())
    };
    y.prototype.GetTransform = function () {
        return this.m_xf
    };
    y.prototype.GetPosition = function () {
        return this.m_xf.position
    };
    y.prototype.SetPosition = function (a) {
        this.SetPositionAndAngle(a,
            this.GetAngle())
    };
    y.prototype.GetAngle = function () {
        return this.m_sweep.a
    };
    y.prototype.SetAngle = function (a) {
        void 0 === a && (a = 0);
        this.SetPositionAndAngle(this.GetPosition(), a)
    };
    y.prototype.GetWorldCenter = function () {
        return this.m_sweep.c
    };
    y.prototype.GetLocalCenter = function () {
        return this.m_sweep.localCenter
    };
    y.prototype.SetLinearVelocity = function (a) {
        this.m_type != y.b2_staticBody && this.m_linearVelocity.SetV(a)
    };
    y.prototype.GetLinearVelocity = function () {
        return this.m_linearVelocity
    };
    y.prototype.SetAngularVelocity =
        function (a) {
            void 0 === a && (a = 0);
            this.m_type != y.b2_staticBody && (this.m_angularVelocity = a)
        };
    y.prototype.GetAngularVelocity = function () {
        return this.m_angularVelocity
    };
    y.prototype.GetDefinition = function () {
        var a = new A;
        a.type = this.GetType();
        a.allowSleep = (this.m_flags & y.e_allowSleepFlag) == y.e_allowSleepFlag;
        a.angle = this.GetAngle();
        a.angularDamping = this.m_angularDamping;
        a.angularVelocity = this.m_angularVelocity;
        a.fixedRotation = (this.m_flags & y.e_fixedRotationFlag) == y.e_fixedRotationFlag;
        a.bullet = (this.m_flags &
            y.e_bulletFlag) == y.e_bulletFlag;
        a.awake = (this.m_flags & y.e_awakeFlag) == y.e_awakeFlag;
        a.linearDamping = this.m_linearDamping;
        a.linearVelocity.SetV(this.GetLinearVelocity());
        a.position = this.GetPosition();
        a.userData = this.GetUserData();
        return a
    };
    y.prototype.ApplyForce = function (a, b) {
        this.m_type == y.b2_dynamicBody && (!1 == this.IsAwake() && this.SetAwake(!0), this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)
    };
    y.prototype.ApplyTorque = function (a) {
        void 0 ===
        a && (a = 0);
        this.m_type == y.b2_dynamicBody && (!1 == this.IsAwake() && this.SetAwake(!0), this.m_torque += a)
    };
    y.prototype.ApplyImpulse = function (a, b) {
        this.m_type == y.b2_dynamicBody && (!1 == this.IsAwake() && this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))
    };
    y.prototype.Split = function (b) {
        for (var d = this.GetLinearVelocity().Copy(), e = this.GetAngularVelocity(), f = this.GetWorldCenter(),
                 g = this.m_world.CreateBody(this.GetDefinition()), h, n = this.m_fixtureList; n;)if (b(n)) {
            var p = n.m_next;
            h ? h.m_next = p : this.m_fixtureList = p;
            this.m_fixtureCount--;
            n.m_next = g.m_fixtureList;
            g.m_fixtureList = n;
            g.m_fixtureCount++;
            n.m_body = g;
            n = p
        } else h = n, n = n.m_next;
        this.ResetMassData();
        g.ResetMassData();
        h = this.GetWorldCenter();
        b = g.GetWorldCenter();
        h = a.AddVV(d, a.CrossFV(e, a.SubtractVV(h, f)));
        d = a.AddVV(d, a.CrossFV(e, a.SubtractVV(b, f)));
        this.SetLinearVelocity(h);
        g.SetLinearVelocity(d);
        this.SetAngularVelocity(e);
        g.SetAngularVelocity(e);
        this.SynchronizeFixtures();
        g.SynchronizeFixtures();
        return g
    };
    y.prototype.Merge = function (a) {
        var b;
        for (b = a.m_fixtureList; b;) {
            var d = b.m_next;
            a.m_fixtureCount--;
            b.m_next = this.m_fixtureList;
            this.m_fixtureList = b;
            this.m_fixtureCount++;
            b.m_body = f;
            b = d
        }
        e.m_fixtureCount = 0;
        var e = this, f = a;
        e.GetWorldCenter();
        f.GetWorldCenter();
        e.GetLinearVelocity().Copy();
        f.GetLinearVelocity().Copy();
        e.GetAngularVelocity();
        f.GetAngularVelocity();
        e.ResetMassData();
        this.SynchronizeFixtures()
    };
    y.prototype.GetMass = function () {
        return this.m_mass
    };
    y.prototype.GetInertia = function () {
        return this.m_I
    };
    y.prototype.GetMassData = function (a) {
        a.mass = this.m_mass;
        a.I = this.m_I;
        a.center.SetV(this.m_sweep.localCenter)
    };
    y.prototype.SetMassData = function (b) {
        g.b2Assert(!1 == this.m_world.IsLocked());
        if (!0 != this.m_world.IsLocked() && this.m_type == y.b2_dynamicBody) {
            this.m_invI = this.m_I = this.m_invMass = 0;
            this.m_mass = b.mass;
            0 >= this.m_mass && (this.m_mass = 1);
            this.m_invMass = 1 / this.m_mass;
            0 < b.I && 0 == (this.m_flags & y.e_fixedRotationFlag) && (this.m_I = b.I - this.m_mass * (b.center.x *
                b.center.x + b.center.y * b.center.y), this.m_invI = 1 / this.m_I);
            var d = this.m_sweep.c.Copy();
            this.m_sweep.localCenter.SetV(b.center);
            this.m_sweep.c0.SetV(a.MulX(this.m_xf, this.m_sweep.localCenter));
            this.m_sweep.c.SetV(this.m_sweep.c0);
            this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - d.y);
            this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - d.x)
        }
    };
    y.prototype.ResetMassData = function () {
        this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0;
        this.m_sweep.localCenter.SetZero();
        if (this.m_type !=
            y.b2_staticBody && this.m_type != y.b2_kinematicBody) {
            for (var b = e.Make(0, 0), d = this.m_fixtureList; d; d = d.m_next)if (0 != d.m_density) {
                var f = d.GetMassData();
                this.m_mass += f.mass;
                b.x += f.center.x * f.mass;
                b.y += f.center.y * f.mass;
                this.m_I += f.I
            }
            0 < this.m_mass ? (this.m_invMass = 1 / this.m_mass, b.x *= this.m_invMass, b.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1;
            0 < this.m_I && 0 == (this.m_flags & y.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (b.x * b.x + b.y * b.y), this.m_I *= this.m_inertiaScale, g.b2Assert(0 < this.m_I), this.m_invI = 1 /
                this.m_I) : this.m_invI = this.m_I = 0;
            d = this.m_sweep.c.Copy();
            this.m_sweep.localCenter.SetV(b);
            this.m_sweep.c0.SetV(a.MulX(this.m_xf, this.m_sweep.localCenter));
            this.m_sweep.c.SetV(this.m_sweep.c0);
            this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - d.y);
            this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - d.x)
        }
    };
    y.prototype.GetWorldPoint = function (a) {
        var b = this.m_xf.R;
        a = new e(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
        a.x += this.m_xf.position.x;
        a.y += this.m_xf.position.y;
        return a
    };
    y.prototype.GetWorldVector = function (b) {
        return a.MulMV(this.m_xf.R, b)
    };
    y.prototype.GetLocalPoint = function (b) {
        return a.MulXT(this.m_xf, b)
    };
    y.prototype.GetLocalVector = function (b) {
        return a.MulTMV(this.m_xf.R, b)
    };
    y.prototype.GetLinearVelocityFromWorldPoint = function (a) {
        return new e(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x))
    };
    y.prototype.GetLinearVelocityFromLocalPoint = function (a) {
        var b = this.m_xf.R;
        a = new e(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
        a.x += this.m_xf.position.x;
        a.y += this.m_xf.position.y;
        return new e(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x))
    };
    y.prototype.GetLinearDamping = function () {
        return this.m_linearDamping
    };
    y.prototype.SetLinearDamping = function (a) {
        void 0 === a && (a = 0);
        this.m_linearDamping = a
    };
    y.prototype.GetAngularDamping = function () {
        return this.m_angularDamping
    };
    y.prototype.SetAngularDamping =
        function (a) {
            void 0 === a && (a = 0);
            this.m_angularDamping = a
        };
    y.prototype.SetType = function (a) {
        void 0 === a && (a = 0);
        if (this.m_type != a)for (this.m_type = a, this.ResetMassData(), this.m_type == y.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0, a = this.m_contactList; a; a = a.next)a.contact.FlagForFiltering()
    };
    y.prototype.GetType = function () {
        return this.m_type
    };
    y.prototype.SetBullet = function (a) {
        this.m_flags = a ? this.m_flags | y.e_bulletFlag : this.m_flags & ~y.e_bulletFlag
    };
    y.prototype.IsBullet = function () {
        return (this.m_flags & y.e_bulletFlag) == y.e_bulletFlag
    };
    y.prototype.SetSleepingAllowed = function (a) {
        a ? this.m_flags |= y.e_allowSleepFlag : (this.m_flags &= ~y.e_allowSleepFlag, this.SetAwake(!0))
    };
    y.prototype.SetAwake = function (a) {
        a ? (this.m_flags |= y.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~y.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
    };
    y.prototype.IsAwake = function () {
        return (this.m_flags &
            y.e_awakeFlag) == y.e_awakeFlag
    };
    y.prototype.SetFixedRotation = function (a) {
        this.m_flags = a ? this.m_flags | y.e_fixedRotationFlag : this.m_flags & ~y.e_fixedRotationFlag;
        this.ResetMassData()
    };
    y.prototype.IsFixedRotation = function () {
        return (this.m_flags & y.e_fixedRotationFlag) == y.e_fixedRotationFlag
    };
    y.prototype.SetActive = function (a) {
        if (a != this.IsActive()) {
            var b;
            if (a)for (this.m_flags |= y.e_activeFlag, a = this.m_world.m_contactManager.m_broadPhase, b = this.m_fixtureList; b; b = b.m_next)b.CreateProxy(a, this.m_xf); else {
                this.m_flags &= ~y.e_activeFlag;
                a = this.m_world.m_contactManager.m_broadPhase;
                for (b = this.m_fixtureList; b; b = b.m_next)b.DestroyProxy(a);
                for (a = this.m_contactList; a;)b = a, a = a.next, this.m_world.m_contactManager.Destroy(b.contact);
                this.m_contactList = null
            }
        }
    };
    y.prototype.IsActive = function () {
        return (this.m_flags & y.e_activeFlag) == y.e_activeFlag
    };
    y.prototype.IsSleepingAllowed = function () {
        return (this.m_flags & y.e_allowSleepFlag) == y.e_allowSleepFlag
    };
    y.prototype.GetFixtureList = function () {
        return this.m_fixtureList
    };
    y.prototype.GetJointList =
        function () {
            return this.m_jointList
        };
    y.prototype.GetControllerList = function () {
        return this.m_controllerList
    };
    y.prototype.GetContactList = function () {
        return this.m_contactList
    };
    y.prototype.GetNext = function () {
        return this.m_next
    };
    y.prototype.GetUserData = function () {
        return this.m_userData
    };
    y.prototype.SetUserData = function (a) {
        this.m_userData = a
    };
    y.prototype.GetWorld = function () {
        return this.m_world
    };
    y.prototype.b2Body = function (a, b) {
        this.m_flags = 0;
        a.bullet && (this.m_flags |= y.e_bulletFlag);
        a.fixedRotation && (this.m_flags |=
            y.e_fixedRotationFlag);
        a.allowSleep && (this.m_flags |= y.e_allowSleepFlag);
        a.awake && (this.m_flags |= y.e_awakeFlag);
        a.active && (this.m_flags |= y.e_activeFlag);
        this.m_world = b;
        this.m_xf.position.SetV(a.position);
        this.m_xf.R.Set(a.angle);
        this.m_sweep.localCenter.SetZero();
        this.m_sweep.t0 = 1;
        this.m_sweep.a0 = this.m_sweep.a = a.angle;
        var d = this.m_xf.R, e = this.m_sweep.localCenter;
        this.m_sweep.c.x = d.col1.x * e.x + d.col2.x * e.y;
        this.m_sweep.c.y = d.col1.y * e.x + d.col2.y * e.y;
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y +=
            this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_contactList = this.m_controllerList = this.m_jointList = null;
        this.m_controllerCount = 0;
        this.m_next = this.m_prev = null;
        this.m_linearVelocity.SetV(a.linearVelocity);
        this.m_angularVelocity = a.angularVelocity;
        this.m_linearDamping = a.linearDamping;
        this.m_angularDamping = a.angularDamping;
        this.m_force.Set(0, 0);
        this.m_sleepTime = this.m_torque = 0;
        this.m_type = a.type;
        this.m_invMass = this.m_type == y.b2_dynamicBody ? this.m_mass = 1 : this.m_mass = 0;
        this.m_invI = this.m_I =
            0;
        this.m_inertiaScale = a.inertiaScale;
        this.m_userData = a.userData;
        this.m_fixtureList = null;
        this.m_fixtureCount = 0
    };
    y.prototype.SynchronizeFixtures = function () {
        var a = y.s_xf1;
        a.R.Set(this.m_sweep.a0);
        var b = a.R, d = this.m_sweep.localCenter;
        a.position.x = this.m_sweep.c0.x - (b.col1.x * d.x + b.col2.x * d.y);
        a.position.y = this.m_sweep.c0.y - (b.col1.y * d.x + b.col2.y * d.y);
        d = this.m_world.m_contactManager.m_broadPhase;
        for (b = this.m_fixtureList; b; b = b.m_next)b.Synchronize(d, a, this.m_xf)
    };
    y.prototype.SynchronizeTransform = function () {
        this.m_xf.R.Set(this.m_sweep.a);
        var a = this.m_xf.R, b = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (a.col1.x * b.x + a.col2.x * b.y);
        this.m_xf.position.y = this.m_sweep.c.y - (a.col1.y * b.x + a.col2.y * b.y)
    };
    y.prototype.ShouldCollide = function (a) {
        if (this.m_type != y.b2_dynamicBody && a.m_type != y.b2_dynamicBody)return !1;
        for (var b = this.m_jointList; b; b = b.next)if (b.other == a && !1 == b.joint.m_collideConnected)return !1;
        return !0
    };
    y.prototype.Advance = function (a) {
        void 0 === a && (a = 0);
        this.m_sweep.Advance(a);
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_sweep.a =
            this.m_sweep.a0;
        this.SynchronizeTransform()
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Body.s_xf1 = new d;
        Box2D.Dynamics.b2Body.e_islandFlag = 1;
        Box2D.Dynamics.b2Body.e_awakeFlag = 2;
        Box2D.Dynamics.b2Body.e_allowSleepFlag = 4;
        Box2D.Dynamics.b2Body.e_bulletFlag = 8;
        Box2D.Dynamics.b2Body.e_fixedRotationFlag = 16;
        Box2D.Dynamics.b2Body.e_activeFlag = 32;
        Box2D.Dynamics.b2Body.b2_staticBody = 0;
        Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
        Box2D.Dynamics.b2Body.b2_dynamicBody = 2
    });
    A.b2BodyDef = function () {
        this.position =
            new e;
        this.linearVelocity = new e
    };
    A.prototype.b2BodyDef = function () {
        this.userData = null;
        this.position.Set(0, 0);
        this.angle = 0;
        this.linearVelocity.Set(0, 0);
        this.angularDamping = this.linearDamping = this.angularVelocity = 0;
        this.awake = this.allowSleep = !0;
        this.bullet = this.fixedRotation = !1;
        this.type = y.b2_staticBody;
        this.active = !0;
        this.inertiaScale = 1
    };
    D.b2ContactFilter = function () {
    };
    D.prototype.ShouldCollide = function (a, b) {
        var d = a.GetFilterData(), e = b.GetFilterData();
        return d.groupIndex == e.groupIndex && 0 != d.groupIndex ?
        0 < d.groupIndex : 0 != (d.maskBits & e.categoryBits) && 0 != (d.categoryBits & e.maskBits)
    };
    D.prototype.RayCollide = function (a, b) {
        return a ? this.ShouldCollide(a instanceof J ? a : null, b) : !0
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new D
    });
    G.b2ContactImpulse = function () {
        this.normalImpulses = new Vector_a2j_Number(g.b2_maxManifoldPoints);
        this.tangentImpulses = new Vector_a2j_Number(g.b2_maxManifoldPoints)
    };
    B.b2ContactListener = function () {
    };
    B.prototype.BeginContact = function (a) {
    };
    B.prototype.EndContact =
        function (a) {
        };
    B.prototype.PreSolve = function (a, b) {
    };
    B.prototype.PostSolve = function (a, b) {
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactListener.b2_defaultListener = new B
    });
    C.b2ContactManager = function () {
    };
    C.prototype.b2ContactManager = function () {
        this.m_world = null;
        this.m_contactCount = 0;
        this.m_contactFilter = D.b2_defaultFilter;
        this.m_contactListener = B.b2_defaultListener;
        this.m_contactFactory = new U(this.m_allocator);
        this.m_broadPhase = new p
    };
    C.prototype.AddPair = function (a, b) {
        var d = a instanceof J ?
            a : null, e = b instanceof J ? b : null, f = d.GetBody(), g = e.GetBody();
        if (f != g) {
            for (var h = g.GetContactList(); h;) {
                if (h.other == f) {
                    var n = h.contact.GetFixtureA(), p = h.contact.GetFixtureB();
                    if (n == d && p == e || n == e && p == d)return
                }
                h = h.next
            }
            !1 != g.ShouldCollide(f) && !1 != this.m_contactFilter.ShouldCollide(d, e) && (h = this.m_contactFactory.Create(d, e), d = h.GetFixtureA(), e = h.GetFixtureB(), f = d.m_body, g = e.m_body, h.m_prev = null, h.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = h), this.m_world.m_contactList =
                h, h.m_nodeA.contact = h, h.m_nodeA.other = g, h.m_nodeA.prev = null, h.m_nodeA.next = f.m_contactList, null != f.m_contactList && (f.m_contactList.prev = h.m_nodeA), f.m_contactList = h.m_nodeA, h.m_nodeB.contact = h, h.m_nodeB.other = f, h.m_nodeB.prev = null, h.m_nodeB.next = g.m_contactList, null != g.m_contactList && (g.m_contactList.prev = h.m_nodeB), g.m_contactList = h.m_nodeB, ++this.m_world.m_contactCount)
        }
    };
    C.prototype.FindNewContacts = function () {
        this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair))
    };
    C.prototype.Destroy =
        function (a) {
            var b = a.GetFixtureA(), d = a.GetFixtureB(), b = b.GetBody(), d = d.GetBody();
            a.IsTouching() && this.m_contactListener.EndContact(a);
            a.m_prev && (a.m_prev.m_next = a.m_next);
            a.m_next && (a.m_next.m_prev = a.m_prev);
            a == this.m_world.m_contactList && (this.m_world.m_contactList = a.m_next);
            a.m_nodeA.prev && (a.m_nodeA.prev.next = a.m_nodeA.next);
            a.m_nodeA.next && (a.m_nodeA.next.prev = a.m_nodeA.prev);
            a.m_nodeA == b.m_contactList && (b.m_contactList = a.m_nodeA.next);
            a.m_nodeB.prev && (a.m_nodeB.prev.next = a.m_nodeB.next);
            a.m_nodeB.next &&
            (a.m_nodeB.next.prev = a.m_nodeB.prev);
            a.m_nodeB == d.m_contactList && (d.m_contactList = a.m_nodeB.next);
            this.m_contactFactory.Destroy(a);
            --this.m_contactCount
        };
    C.prototype.Collide = function () {
        for (var a = this.m_world.m_contactList; a;) {
            var b = a.GetFixtureA(), d = a.GetFixtureB(), e = b.GetBody(), f = d.GetBody();
            if (!1 == e.IsAwake() && !1 == f.IsAwake())a = a.GetNext(); else {
                if (a.m_flags & P.e_filterFlag) {
                    if (!1 == f.ShouldCollide(e)) {
                        b = a;
                        a = b.GetNext();
                        this.Destroy(b);
                        continue
                    }
                    if (!1 == this.m_contactFilter.ShouldCollide(b, d)) {
                        b = a;
                        a =
                            b.GetNext();
                        this.Destroy(b);
                        continue
                    }
                    a.m_flags &= ~P.e_filterFlag
                }
                !1 == this.m_broadPhase.TestOverlap(b.m_proxy, d.m_proxy) ? (b = a, a = b.GetNext(), this.Destroy(b)) : (a.Update(this.m_contactListener), a = a.GetNext())
            }
        }
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2ContactManager.s_evalCP = new n
    });
    E.b2DebugDraw = function () {
    };
    E.prototype.b2DebugDraw = function () {
    };
    E.prototype.SetFlags = function (a) {
    };
    E.prototype.GetFlags = function () {
    };
    E.prototype.AppendFlags = function (a) {
    };
    E.prototype.ClearFlags = function (a) {
    };
    E.prototype.SetSprite =
        function (a) {
        };
    E.prototype.GetSprite = function () {
    };
    E.prototype.SetDrawScale = function (a) {
    };
    E.prototype.GetDrawScale = function () {
    };
    E.prototype.SetLineThickness = function (a) {
    };
    E.prototype.GetLineThickness = function () {
    };
    E.prototype.SetAlpha = function (a) {
    };
    E.prototype.GetAlpha = function () {
    };
    E.prototype.SetFillAlpha = function (a) {
    };
    E.prototype.GetFillAlpha = function () {
    };
    E.prototype.SetXFormScale = function (a) {
    };
    E.prototype.GetXFormScale = function () {
    };
    E.prototype.DrawPolygon = function (a, b, d) {
    };
    E.prototype.DrawSolidPolygon =
        function (a, b, d) {
        };
    E.prototype.DrawCircle = function (a, b, d) {
    };
    E.prototype.DrawSolidCircle = function (a, b, d, e) {
    };
    E.prototype.DrawSegment = function (a, b, d) {
    };
    E.prototype.DrawTransform = function (a) {
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2DebugDraw.e_shapeBit = 1;
        Box2D.Dynamics.b2DebugDraw.e_jointBit = 2;
        Box2D.Dynamics.b2DebugDraw.e_aabbBit = 4;
        Box2D.Dynamics.b2DebugDraw.e_pairBit = 8;
        Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 16;
        Box2D.Dynamics.b2DebugDraw.e_controllerBit = 32
    });
    I.b2DestructionListener = function () {
    };
    I.prototype.SayGoodbyeJoint = function (a) {
    };
    I.prototype.SayGoodbyeFixture = function (a) {
    };
    L.b2FilterData = function () {
        this.categoryBits = 1;
        this.maskBits = 65535;
        this.groupIndex = 0
    };
    L.prototype.Copy = function () {
        var a = new L;
        a.categoryBits = this.categoryBits;
        a.maskBits = this.maskBits;
        a.groupIndex = this.groupIndex;
        return a
    };
    J.b2Fixture = function () {
        this.m_filter = new L
    };
    J.prototype.GetType = function () {
        return this.m_shape.GetType()
    };
    J.prototype.GetShape = function () {
        return this.m_shape
    };
    J.prototype.SetSensor = function (a) {
        if (this.m_isSensor !=
            a && (this.m_isSensor = a, null != this.m_body))for (a = this.m_body.GetContactList(); a;) {
            var b = a.contact, d = b.GetFixtureA(), e = b.GetFixtureB();
            d != this && e != this || b.SetSensor(d.IsSensor() || e.IsSensor());
            a = a.next
        }
    };
    J.prototype.IsSensor = function () {
        return this.m_isSensor
    };
    J.prototype.SetFilterData = function (a) {
        this.m_filter = a.Copy();
        if (!this.m_body)for (a = this.m_body.GetContactList(); a;) {
            var b = a.contact, d = b.GetFixtureA(), e = b.GetFixtureB();
            d != this && e != this || b.FlagForFiltering();
            a = a.next
        }
    };
    J.prototype.GetFilterData =
        function () {
            return this.m_filter.Copy()
        };
    J.prototype.GetBody = function () {
        return this.m_body
    };
    J.prototype.GetNext = function () {
        return this.m_next
    };
    J.prototype.GetUserData = function () {
        return this.m_userData
    };
    J.prototype.SetUserData = function (a) {
        this.m_userData = a
    };
    J.prototype.TestPoint = function (a) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), a)
    };
    J.prototype.RayCast = function (a, b) {
        return this.m_shape.RayCast(a, b, this.m_body.GetTransform())
    };
    J.prototype.GetMassData = function (a) {
        void 0 === a && (a = null);
        null == a && (a = new u);
        this.m_shape.ComputeMass(a, this.m_density);
        return a
    };
    J.prototype.SetDensity = function (a) {
        void 0 === a && (a = 0);
        this.m_density = a
    };
    J.prototype.GetDensity = function () {
        return this.m_density
    };
    J.prototype.GetFriction = function () {
        return this.m_friction
    };
    J.prototype.SetFriction = function (a) {
        void 0 === a && (a = 0);
        this.m_friction = a
    };
    J.prototype.GetRestitution = function () {
        return this.m_restitution
    };
    J.prototype.SetRestitution = function (a) {
        void 0 === a && (a = 0);
        this.m_restitution = a
    };
    J.prototype.GetAABB = function () {
        return this.m_aabb
    };
    J.prototype.b2Fixture = function () {
        this.m_aabb = new h;
        this.m_shape = this.m_next = this.m_body = this.m_userData = null;
        this.m_restitution = this.m_friction = this.m_density = 0
    };
    J.prototype.Create = function (a, b, d) {
        this.m_userData = d.userData;
        this.m_friction = d.friction;
        this.m_restitution = d.restitution;
        this.m_body = a;
        this.m_next = null;
        this.m_filter = d.filter.Copy();
        this.m_isSensor = d.isSensor;
        this.m_shape = d.shape.Copy();
        this.m_density = d.density
    };
    J.prototype.Destroy = function () {
        this.m_shape = null
    };
    J.prototype.CreateProxy = function (a,
                                        b) {
        this.m_shape.ComputeAABB(this.m_aabb, b);
        this.m_proxy = a.CreateProxy(this.m_aabb, this)
    };
    J.prototype.DestroyProxy = function (a) {
        null != this.m_proxy && (a.DestroyProxy(this.m_proxy), this.m_proxy = null)
    };
    J.prototype.Synchronize = function (b, d, e) {
        if (this.m_proxy) {
            var f = new h, g = new h;
            this.m_shape.ComputeAABB(f, d);
            this.m_shape.ComputeAABB(g, e);
            this.m_aabb.Combine(f, g);
            d = a.SubtractVV(e.position, d.position);
            b.MoveProxy(this.m_proxy, this.m_aabb, d)
        }
    };
    Q.b2FixtureDef = function () {
        this.filter = new L
    };
    Q.prototype.b2FixtureDef =
        function () {
            this.userData = this.shape = null;
            this.friction = 0.2;
            this.density = this.restitution = 0;
            this.filter.categoryBits = 1;
            this.filter.maskBits = 65535;
            this.filter.groupIndex = 0;
            this.isSensor = !1
        };
    M.b2Island = function () {
    };
    M.prototype.b2Island = function () {
        this.m_bodies = new Vector;
        this.m_contacts = new Vector;
        this.m_joints = new Vector
    };
    M.prototype.Initialize = function (a, b, d, e, f, g) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        var h = 0;
        this.m_bodyCapacity = a;
        this.m_contactCapacity = b;
        this.m_jointCapacity = d;
        this.m_jointCount =
            this.m_contactCount = this.m_bodyCount = 0;
        this.m_allocator = e;
        this.m_listener = f;
        this.m_contactSolver = g;
        for (h = this.m_bodies.length; h < a; h++)this.m_bodies[h] = null;
        for (h = this.m_contacts.length; h < b; h++)this.m_contacts[h] = null;
        for (h = this.m_joints.length; h < d; h++)this.m_joints[h] = null
    };
    M.prototype.Clear = function () {
        this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0
    };
    M.prototype.Solve = function (b, d, e) {
        for (var f = 0, h = 0, n, f = 0; f < this.m_bodyCount; ++f)h = this.m_bodies[f], h.GetType() == y.b2_dynamicBody && (h.m_linearVelocity.x +=
            b.dt * (d.x + h.m_invMass * h.m_force.x), h.m_linearVelocity.y += b.dt * (d.y + h.m_invMass * h.m_force.y), h.m_angularVelocity += b.dt * h.m_invI * h.m_torque, h.m_linearVelocity.Multiply(a.Clamp(1 - b.dt * h.m_linearDamping, 0, 1)), h.m_angularVelocity *= a.Clamp(1 - b.dt * h.m_angularDamping, 0, 1));
        this.m_contactSolver.Initialize(b, this.m_contacts, this.m_contactCount, this.m_allocator);
        d = this.m_contactSolver;
        d.InitVelocityConstraints(b);
        for (f = 0; f < this.m_jointCount; ++f)n = this.m_joints[f], n.InitVelocityConstraints(b);
        for (f = 0; f < b.velocityIterations; ++f) {
            for (h =
                     0; h < this.m_jointCount; ++h)n = this.m_joints[h], n.SolveVelocityConstraints(b);
            d.SolveVelocityConstraints()
        }
        for (f = 0; f < this.m_jointCount; ++f)n = this.m_joints[f], n.FinalizeVelocityConstraints();
        d.FinalizeVelocityConstraints();
        for (f = 0; f < this.m_bodyCount; ++f)if (h = this.m_bodies[f], h.GetType() != y.b2_staticBody) {
            var p = b.dt * h.m_linearVelocity.x, r = b.dt * h.m_linearVelocity.y;
            p * p + r * r > g.b2_maxTranslationSquared && (h.m_linearVelocity.Normalize(), h.m_linearVelocity.x = h.m_linearVelocity.x * g.b2_maxTranslation * b.inv_dt,
                h.m_linearVelocity.y = h.m_linearVelocity.y * g.b2_maxTranslation * b.inv_dt);
            p = b.dt * h.m_angularVelocity;
            p * p > g.b2_maxRotationSquared && (h.m_angularVelocity = 0 > h.m_angularVelocity ? -g.b2_maxRotation * b.inv_dt : g.b2_maxRotation * b.inv_dt);
            h.m_sweep.c0.SetV(h.m_sweep.c);
            h.m_sweep.a0 = h.m_sweep.a;
            h.m_sweep.c.x += b.dt * h.m_linearVelocity.x;
            h.m_sweep.c.y += b.dt * h.m_linearVelocity.y;
            h.m_sweep.a += b.dt * h.m_angularVelocity;
            h.SynchronizeTransform()
        }
        for (f = 0; f < b.positionIterations; ++f) {
            p = d.SolvePositionConstraints(g.b2_contactBaumgarte);
            r = !0;
            for (h = 0; h < this.m_jointCount; ++h)n = this.m_joints[h], n = n.SolvePositionConstraints(g.b2_contactBaumgarte), r = r && n;
            if (p && r)break
        }
        this.Report(d.m_constraints);
        if (e) {
            e = Number.MAX_VALUE;
            d = g.b2_linearSleepTolerance * g.b2_linearSleepTolerance;
            p = g.b2_angularSleepTolerance * g.b2_angularSleepTolerance;
            for (f = 0; f < this.m_bodyCount; ++f)h = this.m_bodies[f], h.GetType() != y.b2_staticBody && (0 == (h.m_flags & y.e_allowSleepFlag) && (e = h.m_sleepTime = 0), 0 == (h.m_flags & y.e_allowSleepFlag) || h.m_angularVelocity * h.m_angularVelocity >
            p || a.Dot(h.m_linearVelocity, h.m_linearVelocity) > d ? e = h.m_sleepTime = 0 : (h.m_sleepTime += b.dt, e = a.Min(e, h.m_sleepTime)));
            if (e >= g.b2_timeToSleep)for (f = 0; f < this.m_bodyCount; ++f)h = this.m_bodies[f], h.SetAwake(!1)
        }
    };
    M.prototype.SolveTOI = function (a) {
        var b = 0, d = 0;
        this.m_contactSolver.Initialize(a, this.m_contacts, this.m_contactCount, this.m_allocator);
        for (var e = this.m_contactSolver, b = 0; b < this.m_jointCount; ++b)this.m_joints[b].InitVelocityConstraints(a);
        for (b = 0; b < a.velocityIterations; ++b)for (e.SolveVelocityConstraints(),
                                                           d = 0; d < this.m_jointCount; ++d)this.m_joints[d].SolveVelocityConstraints(a);
        for (b = 0; b < this.m_bodyCount; ++b)if (d = this.m_bodies[b], d.GetType() != y.b2_staticBody) {
            var f = a.dt * d.m_linearVelocity.x, h = a.dt * d.m_linearVelocity.y;
            f * f + h * h > g.b2_maxTranslationSquared && (d.m_linearVelocity.Normalize(), d.m_linearVelocity.x = d.m_linearVelocity.x * g.b2_maxTranslation * a.inv_dt, d.m_linearVelocity.y = d.m_linearVelocity.y * g.b2_maxTranslation * a.inv_dt);
            f = a.dt * d.m_angularVelocity;
            f * f > g.b2_maxRotationSquared && (d.m_angularVelocity =
                0 > d.m_angularVelocity ? -g.b2_maxRotation * a.inv_dt : g.b2_maxRotation * a.inv_dt);
            d.m_sweep.c0.SetV(d.m_sweep.c);
            d.m_sweep.a0 = d.m_sweep.a;
            d.m_sweep.c.x += a.dt * d.m_linearVelocity.x;
            d.m_sweep.c.y += a.dt * d.m_linearVelocity.y;
            d.m_sweep.a += a.dt * d.m_angularVelocity;
            d.SynchronizeTransform()
        }
        for (b = 0; b < a.positionIterations; ++b) {
            f = e.SolvePositionConstraints(0.75);
            h = !0;
            for (d = 0; d < this.m_jointCount; ++d)var n = this.m_joints[d].SolvePositionConstraints(g.b2_contactBaumgarte), h = h && n;
            if (f && h)break
        }
        this.Report(e.m_constraints)
    };
    M.prototype.Report = function (a) {
        if (null != this.m_listener)for (var b = 0; b < this.m_contactCount; ++b) {
            for (var d = this.m_contacts[b], e = a[b], f = 0; f < e.pointCount; ++f)M.s_impulse.normalImpulses[f] = e.points[f].normalImpulse, M.s_impulse.tangentImpulses[f] = e.points[f].tangentImpulse;
            this.m_listener.PostSolve(d, M.s_impulse)
        }
    };
    M.prototype.AddBody = function (a) {
        a.m_islandIndex = this.m_bodyCount;
        this.m_bodies[this.m_bodyCount++] = a
    };
    M.prototype.AddContact = function (a) {
        this.m_contacts[this.m_contactCount++] = a
    };
    M.prototype.AddJoint =
        function (a) {
            this.m_joints[this.m_jointCount++] = a
        };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2Island.s_impulse = new G
    });
    K.b2TimeStep = function () {
    };
    K.prototype.Set = function (a) {
        this.dt = a.dt;
        this.inv_dt = a.inv_dt;
        this.positionIterations = a.positionIterations;
        this.velocityIterations = a.velocityIterations;
        this.warmStarting = a.warmStarting
    };
    H.b2World = function () {
        this.s_stack = new Vector;
        this.m_contactManager = new C;
        this.m_contactSolver = new O;
        this.m_island = new M
    };
    H.prototype.b2World = function (a, b) {
        this.m_controllerList =
            this.m_jointList = this.m_contactList = this.m_bodyList = this.m_debugDraw = this.m_destructionListener = null;
        this.m_controllerCount = this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0;
        H.m_warmStarting = !0;
        H.m_continuousPhysics = !0;
        this.m_allowSleep = b;
        a.y = a.y;
        this.m_gravity = a;
        this.m_inv_dt0 = 0;
        this.m_contactManager.m_world = this;
        var d = new A;
        this.m_groundBody = this.CreateBody(d)
    };
    H.prototype.SetDestructionListener = function (a) {
        this.m_destructionListener = a
    };
    H.prototype.SetContactFilter = function (a) {
        this.m_contactManager.m_contactFilter =
            a
    };
    H.prototype.SetContactListener = function (a) {
        this.m_contactManager.m_contactListener = a
    };
    H.prototype.SetDebugDraw = function (a) {
        this.m_debugDraw = a
    };
    H.prototype.SetBroadPhase = function (a) {
        var b = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = a;
        for (var d = this.m_bodyList; d; d = d.m_next)for (var e = d.m_fixtureList; e; e = e.m_next)e.m_proxy = a.CreateProxy(b.GetFatAABB(e.m_proxy), e)
    };
    H.prototype.Validate = function () {
        this.m_contactManager.m_broadPhase.Validate()
    };
    H.prototype.GetProxyCount = function () {
        return this.m_contactManager.m_broadPhase.GetProxyCount()
    };
    H.prototype.CreateBody = function (a) {
        if (!0 == this.IsLocked())return null;
        a = new y(a, this);
        a.m_prev = null;
        if (a.m_next = this.m_bodyList)this.m_bodyList.m_prev = a;
        this.m_bodyList = a;
        ++this.m_bodyCount;
        return a
    };
    H.prototype.DestroyBody = function (a) {
        if (!0 != this.IsLocked()) {
            for (var b = a.m_jointList; b;) {
                var d = b, b = b.next;
                this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(d.joint);
                this.DestroyJoint(d.joint)
            }
            for (b = a.m_controllerList; b;)d = b, b = b.nextController, d.controller.RemoveBody(a);
            for (b = a.m_contactList; b;)d =
                b, b = b.next, this.m_contactManager.Destroy(d.contact);
            a.m_contactList = null;
            for (b = a.m_fixtureList; b;)d = b, b = b.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(d), d.DestroyProxy(this.m_contactManager.m_broadPhase), d.Destroy();
            a.m_fixtureList = null;
            a.m_fixtureCount = 0;
            a.m_prev && (a.m_prev.m_next = a.m_next);
            a.m_next && (a.m_next.m_prev = a.m_prev);
            a == this.m_bodyList && (this.m_bodyList = a.m_next);
            --this.m_bodyCount
        }
    };
    H.prototype.CreateJoint = function (a) {
        var b = Y.Create(a, null);
        b.m_prev =
            null;
        if (b.m_next = this.m_jointList)this.m_jointList.m_prev = b;
        this.m_jointList = b;
        ++this.m_jointCount;
        b.m_edgeA.joint = b;
        b.m_edgeA.other = b.m_bodyB;
        b.m_edgeA.prev = null;
        if (b.m_edgeA.next = b.m_bodyA.m_jointList)b.m_bodyA.m_jointList.prev = b.m_edgeA;
        b.m_bodyA.m_jointList = b.m_edgeA;
        b.m_edgeB.joint = b;
        b.m_edgeB.other = b.m_bodyA;
        b.m_edgeB.prev = null;
        if (b.m_edgeB.next = b.m_bodyB.m_jointList)b.m_bodyB.m_jointList.prev = b.m_edgeB;
        b.m_bodyB.m_jointList = b.m_edgeB;
        var d = a.bodyA, e = a.bodyB;
        if (!1 == a.collideConnected)for (a =
                                              e.GetContactList(); a;)a.other == d && a.contact.FlagForFiltering(), a = a.next;
        return b
    };
    H.prototype.DestroyJoint = function (a) {
        var b = a.m_collideConnected;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_jointList && (this.m_jointList = a.m_next);
        var d = a.m_bodyA, e = a.m_bodyB;
        d.SetAwake(!0);
        e.SetAwake(!0);
        a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next);
        a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev);
        a.m_edgeA == d.m_jointList && (d.m_jointList = a.m_edgeA.next);
        a.m_edgeA.prev =
            null;
        a.m_edgeA.next = null;
        a.m_edgeB.prev && (a.m_edgeB.prev.next = a.m_edgeB.next);
        a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev);
        a.m_edgeB == e.m_jointList && (e.m_jointList = a.m_edgeB.next);
        a.m_edgeB.prev = null;
        a.m_edgeB.next = null;
        Y.Destroy(a, null);
        --this.m_jointCount;
        if (!1 == b)for (a = e.GetContactList(); a;)a.other == d && a.contact.FlagForFiltering(), a = a.next
    };
    H.prototype.AddController = function (a) {
        a.m_next = this.m_controllerList;
        a.m_prev = null;
        this.m_controllerList = a;
        a.m_world = this;
        this.m_controllerCount++;
        return a
    };
    H.prototype.RemoveController = function (a) {
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        this.m_controllerList == a && (this.m_controllerList = a.m_next);
        this.m_controllerCount--
    };
    H.prototype.CreateController = function (a) {
        if (a.m_world != this)throw Error("Controller can only be a member of one world");
        a.m_next = this.m_controllerList;
        a.m_prev = null;
        this.m_controllerList && (this.m_controllerList.m_prev = a);
        this.m_controllerList = a;
        ++this.m_controllerCount;
        a.m_world = this;
        return a
    };
    H.prototype.DestroyController = function (a) {
        a.Clear();
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a == this.m_controllerList && (this.m_controllerList = a.m_next);
        --this.m_controllerCount
    };
    H.prototype.SetWarmStarting = function (a) {
        H.m_warmStarting = a
    };
    H.prototype.SetContinuousPhysics = function (a) {
        H.m_continuousPhysics = a
    };
    H.prototype.GetBodyCount = function () {
        return this.m_bodyCount
    };
    H.prototype.GetJointCount = function () {
        return this.m_jointCount
    };
    H.prototype.GetContactCount = function () {
        return this.m_contactCount
    };
    H.prototype.SetGravity = function (a) {
        this.m_gravity = a
    };
    H.prototype.GetGravity = function () {
        return this.m_gravity
    };
    H.prototype.GetGroundBody = function () {
        return this.m_groundBody
    };
    H.prototype.Step = function (a, b, d) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        this.m_flags & H.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~H.e_newFixture);
        this.m_flags |= H.e_locked;
        var e = H.s_timestep2;
        e.dt = a;
        e.velocityIterations = b;
        e.positionIterations = d;
        e.inv_dt = 0 < a ? 1 / a : 0;
        e.dtRatio = this.m_inv_dt0 *
            a;
        e.warmStarting = H.m_warmStarting;
        this.m_contactManager.Collide();
        0 < e.dt && this.Solve(e);
        H.m_continuousPhysics && 0 < e.dt && this.SolveTOI(e);
        0 < e.dt && (this.m_inv_dt0 = e.inv_dt);
        this.m_flags &= ~H.e_locked
    };
    H.prototype.ClearForces = function () {
        for (var a = this.m_bodyList; a; a = a.m_next)a.m_force.SetZero(), a.m_torque = 0
    };
    H.prototype.DrawDebugData = function () {
        if (null != this.m_debugDraw) {
            this.m_debugDraw.m_sprite.graphics.clear();
            var a = this.m_debugDraw.GetFlags(), b, d, g;
            new e;
            new e;
            new e;
            var n;
            new h;
            new h;
            n = [new e, new e,
                new e, new e];
            var p = new f(0, 0, 0);
            if (a & E.e_shapeBit)for (b = this.m_bodyList; b; b = b.m_next)for (n = b.m_xf, d = b.GetFixtureList(); d; d = d.m_next)g = d.GetShape(), !1 == b.IsActive() ? p.Set(0.5, 0.5, 0.3) : b.GetType() == y.b2_staticBody ? p.Set(0.5, 0.9, 0.5) : b.GetType() == y.b2_kinematicBody ? p.Set(0.5, 0.5, 0.9) : !1 == b.IsAwake() ? p.Set(0.6, 0.6, 0.6) : p.Set(0.9, 0.7, 0.7), this.DrawShape(g, n, p);
            if (a & E.e_jointBit)for (b = this.m_jointList; b; b = b.m_next)this.DrawJoint(b);
            if (a & E.e_controllerBit)for (b = this.m_controllerList; b; b = b.m_next)b.Draw(this.m_debugDraw);
            if (a & E.e_pairBit)for (p.Set(0.3, 0.9, 0.9), b = this.m_contactManager.m_contactList; b; b = b.GetNext())g = b.GetFixtureA(), d = b.GetFixtureB(), g = g.GetAABB().GetCenter(), d = d.GetAABB().GetCenter(), this.m_debugDraw.DrawSegment(g, d, p);
            if (a & E.e_aabbBit)for (g = this.m_contactManager.m_broadPhase, n = [new e, new e, new e, new e], b = this.m_bodyList; b; b = b.GetNext())if (!1 != b.IsActive())for (d = b.GetFixtureList(); d; d = d.GetNext()) {
                var r = g.GetFatAABB(d.m_proxy);
                n[0].Set(r.lowerBound.x, r.lowerBound.y);
                n[1].Set(r.upperBound.x, r.lowerBound.y);
                n[2].Set(r.upperBound.x, r.upperBound.y);
                n[3].Set(r.lowerBound.x, r.upperBound.y);
                this.m_debugDraw.DrawPolygon(n, 4, p)
            }
            if (a & E.e_centerOfMassBit)for (b = this.m_bodyList; b; b = b.m_next)n = H.s_xf, n.R = b.m_xf.R, n.position = b.GetWorldCenter(), this.m_debugDraw.DrawTransform(n)
        }
    };
    H.prototype.QueryAABB = function (a, b) {
        var d = this.m_contactManager.m_broadPhase;
        d.Query(function (b) {
            return a(d.GetUserData(b))
        }, b)
    };
    H.prototype.QueryShape = function (a, b, e) {
        void 0 === e && (e = null);
        null == e && (e = new d, e.SetIdentity());
        var f = this.m_contactManager.m_broadPhase,
            g = new h;
        b.ComputeAABB(g, e);
        f.Query(function (d) {
            d = f.GetUserData(d) instanceof J ? f.GetUserData(d) : null;
            return w.TestOverlap(b, e, d.GetShape(), d.GetBody().GetTransform()) ? a(d) : !0
        }, g)
    };
    H.prototype.QueryPoint = function (a, b) {
        var d = this.m_contactManager.m_broadPhase, e = new h;
        e.lowerBound.Set(b.x - g.b2_linearSlop, b.y - g.b2_linearSlop);
        e.upperBound.Set(b.x + g.b2_linearSlop, b.y + g.b2_linearSlop);
        d.Query(function (e) {
            e = d.GetUserData(e) instanceof J ? d.GetUserData(e) : null;
            return e.TestPoint(b) ? a(e) : !0
        }, e)
    };
    H.prototype.RayCast =
        function (a, b, d) {
            var f = this.m_contactManager.m_broadPhase, g = new s, h = new r(b, d);
            f.RayCast(function (h, n) {
                var p = f.GetUserData(n), p = p instanceof J ? p : null;
                if (p.RayCast(g, h)) {
                    var r = g.fraction, s = new e((1 - r) * b.x + r * d.x, (1 - r) * b.y + r * d.y);
                    return a(p, s, g.normal, r)
                }
                return h.maxFraction
            }, h)
        };
    H.prototype.RayCastOne = function (a, b) {
        var d;
        this.RayCast(function (a, b, e, f) {
            void 0 === f && (f = 0);
            d = a;
            return f
        }, a, b);
        return d
    };
    H.prototype.RayCastAll = function (a, b) {
        var d = new Vector;
        this.RayCast(function (a, b, e, f) {
                d[d.length] = a;
                return 1
            },
            a, b);
        return d
    };
    H.prototype.GetBodyList = function () {
        return this.m_bodyList
    };
    H.prototype.GetJointList = function () {
        return this.m_jointList
    };
    H.prototype.GetContactList = function () {
        return this.m_contactList
    };
    H.prototype.IsLocked = function () {
        return 0 < (this.m_flags & H.e_locked)
    };
    H.prototype.Solve = function (a) {
        for (var b, d = this.m_controllerList; d; d = d.m_next)d.Step(a);
        d = this.m_island;
        d.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        for (b = this.m_bodyList; b; b = b.m_next)b.m_flags &= ~y.e_islandFlag;
        for (var e = this.m_contactList; e; e = e.m_next)e.m_flags &= ~P.e_islandFlag;
        for (e = this.m_jointList; e; e = e.m_next)e.m_islandFlag = !1;
        parseInt(this.m_bodyCount);
        for (var e = this.s_stack, f = this.m_bodyList; f; f = f.m_next)if (!(f.m_flags & y.e_islandFlag) && !1 != f.IsAwake() && !1 != f.IsActive() && f.GetType() != y.b2_staticBody) {
            d.Clear();
            var g = 0;
            e[g++] = f;
            for (f.m_flags |= y.e_islandFlag; 0 < g;)if (b = e[--g], d.AddBody(b), !1 == b.IsAwake() && b.SetAwake(!0), b.GetType() != y.b2_staticBody) {
                for (var h,
                         n = b.m_contactList; n; n = n.next)n.contact.m_flags & P.e_islandFlag || !0 == n.contact.IsSensor() || !1 == n.contact.IsEnabled() || !1 == n.contact.IsTouching() || (d.AddContact(n.contact), n.contact.m_flags |= P.e_islandFlag, h = n.other, h.m_flags & y.e_islandFlag || (e[g++] = h, h.m_flags |= y.e_islandFlag));
                for (b = b.m_jointList; b; b = b.next)!0 != b.joint.m_islandFlag && (h = b.other, !1 != h.IsActive() && (d.AddJoint(b.joint), b.joint.m_islandFlag = !0, h.m_flags & y.e_islandFlag || (e[g++] = h, h.m_flags |= y.e_islandFlag)))
            }
            d.Solve(a, this.m_gravity, this.m_allowSleep);
            for (g = 0; g < d.m_bodyCount; ++g)b = d.m_bodies[g], b.GetType() == y.b2_staticBody && (b.m_flags &= ~y.e_islandFlag)
        }
        for (g = 0; g < e.length && e[g]; ++g)e[g] = null;
        for (b = this.m_bodyList; b; b = b.m_next)!1 != b.IsAwake() && !1 != b.IsActive() && b.GetType() != y.b2_staticBody && b.SynchronizeFixtures();
        this.m_contactManager.FindNewContacts()
    };
    H.prototype.SolveTOI = function (a) {
        var b, d, e, f = this.m_island;
        f.Initialize(this.m_bodyCount, g.b2_maxTOIContactsPerIsland, g.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var h = H.s_queue;
        for (b = this.m_bodyList; b; b = b.m_next)b.m_flags &= ~y.e_islandFlag, b.m_sweep.t0 = 0;
        for (e = this.m_contactList; e; e = e.m_next)e.m_flags &= ~(P.e_toiFlag | P.e_islandFlag);
        for (e = this.m_jointList; e; e = e.m_next)e.m_islandFlag = !1;
        for (; ;) {
            var n = null, p = 1;
            for (e = this.m_contactList; e; e = e.m_next)if (!0 != e.IsSensor() && !1 != e.IsEnabled() && !1 != e.IsContinuous()) {
                b = 1;
                if (e.m_flags & P.e_toiFlag)b = e.m_toi; else {
                    b = e.m_fixtureA;
                    d = e.m_fixtureB;
                    b = b.m_body;
                    d = d.m_body;
                    if (!(b.GetType() == y.b2_dynamicBody && !1 != b.IsAwake() || d.GetType() ==
                        y.b2_dynamicBody && !1 != d.IsAwake()))continue;
                    var r = b.m_sweep.t0;
                    b.m_sweep.t0 < d.m_sweep.t0 ? (r = d.m_sweep.t0, b.m_sweep.Advance(r)) : d.m_sweep.t0 < b.m_sweep.t0 && (r = b.m_sweep.t0, d.m_sweep.Advance(r));
                    b = e.ComputeTOI(b.m_sweep, d.m_sweep);
                    g.b2Assert(0 <= b && 1 >= b);
                    0 < b && 1 > b && (b = (1 - b) * r + b, 1 < b && (b = 1));
                    e.m_toi = b;
                    e.m_flags |= P.e_toiFlag
                }
                Number.MIN_VALUE < b && b < p && (n = e, p = b)
            }
            if (null == n || 1 - 100 * Number.MIN_VALUE < p)break;
            b = n.m_fixtureA;
            d = n.m_fixtureB;
            b = b.m_body;
            d = d.m_body;
            H.s_backupA.Set(b.m_sweep);
            H.s_backupB.Set(d.m_sweep);
            b.Advance(p);
            d.Advance(p);
            n.Update(this.m_contactManager.m_contactListener);
            n.m_flags &= ~P.e_toiFlag;
            if (!0 == n.IsSensor() || !1 == n.IsEnabled())b.m_sweep.Set(H.s_backupA), d.m_sweep.Set(H.s_backupB), b.SynchronizeTransform(), d.SynchronizeTransform(); else if (!1 != n.IsTouching()) {
                b.GetType() != y.b2_dynamicBody && (b = d);
                f.Clear();
                n = e = 0;
                h[e + n++] = b;
                for (b.m_flags |= y.e_islandFlag; 0 < n;)if (b = h[e++], --n, f.AddBody(b), !1 == b.IsAwake() && b.SetAwake(!0), b.GetType() == y.b2_dynamicBody) {
                    for (d = b.m_contactList; d && f.m_contactCount !=
                    f.m_contactCapacity; d = d.next)d.contact.m_flags & P.e_islandFlag || !0 == d.contact.IsSensor() || !1 == d.contact.IsEnabled() || !1 == d.contact.IsTouching() || (f.AddContact(d.contact), d.contact.m_flags |= P.e_islandFlag, r = d.other, r.m_flags & y.e_islandFlag || (r.GetType() != y.b2_staticBody && (r.Advance(p), r.SetAwake(!0)), h[e + n] = r, ++n, r.m_flags |= y.e_islandFlag));
                    for (b = b.m_jointList; b; b = b.next)f.m_jointCount != f.m_jointCapacity && !0 != b.joint.m_islandFlag && (r = b.other, !1 != r.IsActive() && (f.AddJoint(b.joint), b.joint.m_islandFlag = !0, r.m_flags & y.e_islandFlag || (r.GetType() != y.b2_staticBody && (r.Advance(p), r.SetAwake(!0)), h[e + n] = r, ++n, r.m_flags |= y.e_islandFlag)))
                }
                e = H.s_timestep;
                e.warmStarting = !1;
                e.dt = (1 - p) * a.dt;
                e.inv_dt = 1 / e.dt;
                e.dtRatio = 0;
                e.velocityIterations = a.velocityIterations;
                e.positionIterations = a.positionIterations;
                f.SolveTOI(e);
                for (p = p = 0; p < f.m_bodyCount; ++p)if (b = f.m_bodies[p], b.m_flags &= ~y.e_islandFlag, !1 != b.IsAwake() && b.GetType() == y.b2_dynamicBody)for (b.SynchronizeFixtures(), d = b.m_contactList; d; d = d.next)d.contact.m_flags &= ~P.e_toiFlag;
                for (p = 0; p < f.m_contactCount; ++p)e = f.m_contacts[p], e.m_flags &= ~(P.e_toiFlag | P.e_islandFlag);
                for (p = 0; p < f.m_jointCount; ++p)e = f.m_joints[p], e.m_islandFlag = !1;
                this.m_contactManager.FindNewContacts()
            }
        }
    };
    H.prototype.DrawJoint = function (a) {
        var b = a.GetBodyA(), d = a.GetBodyB(), e = b.m_xf.position, f = d.m_xf.position, g = a.GetAnchorA(), h = a.GetAnchorB(), n = H.s_jointColor;
        switch (a.m_type) {
            case Y.e_distanceJoint:
                this.m_debugDraw.DrawSegment(g, h, n);
                break;
            case Y.e_pulleyJoint:
                b = a instanceof V ? a : null;
                a = b.GetGroundAnchorA();
                b = b.GetGroundAnchorB();
                this.m_debugDraw.DrawSegment(a, g, n);
                this.m_debugDraw.DrawSegment(b, h, n);
                this.m_debugDraw.DrawSegment(a, b, n);
                break;
            case Y.e_mouseJoint:
                this.m_debugDraw.DrawSegment(g, h, n);
                break;
            default:
                b != this.m_groundBody && this.m_debugDraw.DrawSegment(e, g, n), this.m_debugDraw.DrawSegment(g, h, n), d != this.m_groundBody && this.m_debugDraw.DrawSegment(f, h, n)
        }
    };
    H.prototype.DrawShape = function (b, d, e) {
        switch (b.m_type) {
            case w.e_circleShape:
                var f = b instanceof t ? b : null;
                b = a.MulX(d, f.m_p);
                this.m_debugDraw.DrawSolidCircle(b,
                    f.m_radius, d.R.col1, e);
                break;
            case w.e_polygonShape:
                f = 0;
                f = b instanceof x ? b : null;
                b = parseInt(f.GetVertexCount());
                for (var g = f.GetVertices(), h = new Vector(b), f = 0; f < b; ++f)h[f] = a.MulX(d, g[f]);
                this.m_debugDraw.DrawSolidPolygon(h, b, e);
                break;
            case w.e_edgeShape:
                f = b instanceof v ? b : null, this.m_debugDraw.DrawSegment(a.MulX(d, f.GetVertex1()), a.MulX(d, f.GetVertex2()), e)
        }
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.b2World.s_timestep2 = new K;
        Box2D.Dynamics.b2World.s_xf = new d;
        Box2D.Dynamics.b2World.s_backupA = new b;
        Box2D.Dynamics.b2World.s_backupB = new b;
        Box2D.Dynamics.b2World.s_timestep = new K;
        Box2D.Dynamics.b2World.s_queue = new Vector;
        Box2D.Dynamics.b2World.s_jointColor = new f(0.5, 0.8, 0.8);
        Box2D.Dynamics.b2World.e_newFixture = 1;
        Box2D.Dynamics.b2World.e_locked = 2
    })
})();
(function () {
    var a = Box2D.Collision.Shapes.b2CircleShape, b = Box2D.Collision.Shapes.b2EdgeShape, d = Box2D.Collision.Shapes.b2PolygonShape, e = Box2D.Collision.Shapes.b2Shape, f = Box2D.Dynamics.Contacts.b2CircleContact, g = Box2D.Dynamics.Contacts.b2Contact, h = Box2D.Dynamics.Contacts.b2ContactConstraint, n = Box2D.Dynamics.Contacts.b2ContactConstraintPoint, p = Box2D.Dynamics.Contacts.b2ContactEdge, r = Box2D.Dynamics.Contacts.b2ContactFactory, s = Box2D.Dynamics.Contacts.b2ContactRegister, t = Box2D.Dynamics.Contacts.b2ContactResult,
        v = Box2D.Dynamics.Contacts.b2ContactSolver, u = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, x = Box2D.Dynamics.Contacts.b2NullContact, w = Box2D.Dynamics.Contacts.b2PolyAndCircleContact, y = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, A = Box2D.Dynamics.Contacts.b2PolygonContact, D = Box2D.Dynamics.Contacts.b2PositionSolverManifold, G = Box2D.Dynamics.b2Body, B = Box2D.Dynamics.b2TimeStep, C = Box2D.Common.b2Settings, E = Box2D.Common.Math.b2Mat22, I = Box2D.Common.Math.b2Math, L = Box2D.Common.Math.b2Vec2, J = Box2D.Collision.b2Collision,
        Q = Box2D.Collision.b2ContactID, M = Box2D.Collision.b2Manifold, K = Box2D.Collision.b2TimeOfImpact, H = Box2D.Collision.b2TOIInput, P = Box2D.Collision.b2WorldManifold;
    Box2D.inherit(f, Box2D.Dynamics.Contacts.b2Contact);
    f.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    f.b2CircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    f.Create = function (a) {
        return new f
    };
    f.Destroy = function (a, b) {
    };
    f.prototype.Reset = function (a, b) {
        this.__super.Reset.call(this, a, b)
    };
    f.prototype.Evaluate =
        function () {
            var b = this.m_fixtureA.GetBody(), d = this.m_fixtureB.GetBody();
            J.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof a ? this.m_fixtureA.GetShape() : null, b.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, d.m_xf)
        };
    g.b2Contact = function () {
        this.m_nodeA = new p;
        this.m_nodeB = new p;
        this.m_manifold = new M;
        this.m_oldManifold = new M
    };
    g.prototype.GetManifold = function () {
        return this.m_manifold
    };
    g.prototype.GetWorldManifold = function (a) {
        var b = this.m_fixtureA.GetBody(),
            d = this.m_fixtureB.GetBody(), e = this.m_fixtureA.GetShape(), f = this.m_fixtureB.GetShape();
        a.Initialize(this.m_manifold, b.GetTransform(), e.m_radius, d.GetTransform(), f.m_radius)
    };
    g.prototype.IsTouching = function () {
        return (this.m_flags & g.e_touchingFlag) == g.e_touchingFlag
    };
    g.prototype.IsContinuous = function () {
        return (this.m_flags & g.e_continuousFlag) == g.e_continuousFlag
    };
    g.prototype.SetSensor = function (a) {
        this.m_flags = a ? this.m_flags | g.e_sensorFlag : this.m_flags & ~g.e_sensorFlag
    };
    g.prototype.IsSensor = function () {
        return (this.m_flags &
            g.e_sensorFlag) == g.e_sensorFlag
    };
    g.prototype.SetEnabled = function (a) {
        this.m_flags = a ? this.m_flags | g.e_enabledFlag : this.m_flags & ~g.e_enabledFlag
    };
    g.prototype.IsEnabled = function () {
        return (this.m_flags & g.e_enabledFlag) == g.e_enabledFlag
    };
    g.prototype.GetNext = function () {
        return this.m_next
    };
    g.prototype.GetFixtureA = function () {
        return this.m_fixtureA
    };
    g.prototype.GetFixtureB = function () {
        return this.m_fixtureB
    };
    g.prototype.FlagForFiltering = function () {
        this.m_flags |= g.e_filterFlag
    };
    g.prototype.b2Contact = function () {
    };
    g.prototype.Reset = function (a, b) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        this.m_flags = g.e_enabledFlag;
        if (a && b) {
            if (a.IsSensor() || b.IsSensor())this.m_flags |= g.e_sensorFlag;
            var d = a.GetBody(), e = b.GetBody();
            if (d.GetType() != G.b2_dynamicBody || d.IsBullet() || e.GetType() != G.b2_dynamicBody || e.IsBullet())this.m_flags |= g.e_continuousFlag;
            this.m_fixtureA = a;
            this.m_fixtureB = b;
            this.m_manifold.m_pointCount = 0;
            this.m_next = this.m_prev = null;
            this.m_nodeA.contact = null;
            this.m_nodeA.prev = null;
            this.m_nodeA.next = null;
            this.m_nodeA.other =
                null;
            this.m_nodeB.contact = null;
            this.m_nodeB.prev = null;
            this.m_nodeB.next = null;
            this.m_nodeB.other = null
        } else this.m_fixtureB = this.m_fixtureA = null
    };
    g.prototype.Update = function (a) {
        var b = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold;
        this.m_manifold = b;
        this.m_flags |= g.e_enabledFlag;
        var d = !1, b = (this.m_flags & g.e_touchingFlag) == g.e_touchingFlag, f = this.m_fixtureA.m_body, h = this.m_fixtureB.m_body, n = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & g.e_sensorFlag)n && (d = this.m_fixtureA.GetShape(),
            n = this.m_fixtureB.GetShape(), f = f.GetTransform(), h = h.GetTransform(), d = e.TestOverlap(d, f, n, h)), this.m_manifold.m_pointCount = 0; else {
            f.GetType() != G.b2_dynamicBody || f.IsBullet() || h.GetType() != G.b2_dynamicBody || h.IsBullet() ? this.m_flags |= g.e_continuousFlag : this.m_flags &= ~g.e_continuousFlag;
            if (n)for (this.Evaluate(), d = 0 < this.m_manifold.m_pointCount, n = 0; n < this.m_manifold.m_pointCount; ++n) {
                var p = this.m_manifold.m_points[n];
                p.m_normalImpulse = 0;
                p.m_tangentImpulse = 0;
                for (var r = p.m_id, s = 0; s < this.m_oldManifold.m_pointCount; ++s) {
                    var t =
                        this.m_oldManifold.m_points[s];
                    if (t.m_id.key == r.key) {
                        p.m_normalImpulse = t.m_normalImpulse;
                        p.m_tangentImpulse = t.m_tangentImpulse;
                        break
                    }
                }
            } else this.m_manifold.m_pointCount = 0;
            d != b && (f.SetAwake(!0), h.SetAwake(!0))
        }
        this.m_flags = d ? this.m_flags | g.e_touchingFlag : this.m_flags & ~g.e_touchingFlag;
        !1 == b && !0 == d && a.BeginContact(this);
        !0 == b && !1 == d && a.EndContact(this);
        0 == (this.m_flags & g.e_sensorFlag) && a.PreSolve(this, this.m_oldManifold)
    };
    g.prototype.Evaluate = function () {
    };
    g.prototype.ComputeTOI = function (a, b) {
        g.s_input.proxyA.Set(this.m_fixtureA.GetShape());
        g.s_input.proxyB.Set(this.m_fixtureB.GetShape());
        g.s_input.sweepA = a;
        g.s_input.sweepB = b;
        g.s_input.tolerance = C.b2_linearSlop;
        return K.TimeOfImpact(g.s_input)
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 1;
        Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 2;
        Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 4;
        Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 8;
        Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 16;
        Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 32;
        Box2D.Dynamics.Contacts.b2Contact.e_filterFlag =
            64;
        Box2D.Dynamics.Contacts.b2Contact.s_input = new H
    });
    h.b2ContactConstraint = function () {
        this.localPlaneNormal = new L;
        this.localPoint = new L;
        this.normal = new L;
        this.normalMass = new E;
        this.K = new E
    };
    h.prototype.b2ContactConstraint = function () {
        this.points = new Vector(C.b2_maxManifoldPoints);
        for (var a = 0; a < C.b2_maxManifoldPoints; a++)this.points[a] = new n
    };
    n.b2ContactConstraintPoint = function () {
        this.localPoint = new L;
        this.rA = new L;
        this.rB = new L
    };
    p.b2ContactEdge = function () {
    };
    r.b2ContactFactory = function () {
    };
    r.prototype.b2ContactFactory =
        function (a) {
            this.m_allocator = a;
            this.InitializeRegisters()
        };
    r.prototype.AddType = function (a, b, d, e) {
        void 0 === d && (d = 0);
        void 0 === e && (e = 0);
        this.m_registers[d][e].createFcn = a;
        this.m_registers[d][e].destroyFcn = b;
        this.m_registers[d][e].primary = !0;
        d != e && (this.m_registers[e][d].createFcn = a, this.m_registers[e][d].destroyFcn = b, this.m_registers[e][d].primary = !1)
    };
    r.prototype.InitializeRegisters = function () {
        this.m_registers = new Vector(e.e_shapeTypeCount);
        for (var a = 0; a < e.e_shapeTypeCount; a++) {
            this.m_registers[a] =
                new Vector(e.e_shapeTypeCount);
            for (var b = 0; b < e.e_shapeTypeCount; b++)this.m_registers[a][b] = new s
        }
        this.AddType(f.Create, f.Destroy, e.e_circleShape, e.e_circleShape);
        this.AddType(w.Create, w.Destroy, e.e_polygonShape, e.e_circleShape);
        this.AddType(A.Create, A.Destroy, e.e_polygonShape, e.e_polygonShape);
        this.AddType(u.Create, u.Destroy, e.e_edgeShape, e.e_circleShape);
        this.AddType(y.Create, y.Destroy, e.e_polygonShape, e.e_edgeShape)
    };
    r.prototype.Create = function (a, b) {
        var d = parseInt(a.GetType()), e = parseInt(b.GetType()),
            d = this.m_registers[d][e];
        if (d.pool)return e = d.pool, d.pool = e.m_next, d.poolCount--, e.Reset(a, b), e;
        e = d.createFcn;
        return null != e ? (d.primary ? (e = e(this.m_allocator), e.Reset(a, b)) : (e = e(this.m_allocator), e.Reset(b, a)), e) : null
    };
    r.prototype.Destroy = function (a) {
        0 < a.m_manifold.m_pointCount && (a.m_fixtureA.m_body.SetAwake(!0), a.m_fixtureB.m_body.SetAwake(!0));
        var b = parseInt(a.m_fixtureA.GetType()), d = parseInt(a.m_fixtureB.GetType()), b = this.m_registers[b][d];
        b.poolCount++;
        a.m_next = b.pool;
        b.pool = a;
        b = b.destroyFcn;
        b(a, this.m_allocator)
    };
    s.b2ContactRegister = function () {
    };
    t.b2ContactResult = function () {
        this.position = new L;
        this.normal = new L;
        this.id = new Q
    };
    v.b2ContactSolver = function () {
        this.m_step = new B;
        this.m_constraints = new Vector
    };
    v.prototype.b2ContactSolver = function () {
    };
    v.prototype.Initialize = function (a, b, d, e) {
        void 0 === d && (d = 0);
        var f;
        this.m_step.Set(a);
        this.m_allocator = e;
        a = 0;
        for (this.m_constraintCount = d; this.m_constraints.length < this.m_constraintCount;)this.m_constraints[this.m_constraints.length] = new h;
        for (a =
                 0; a < d; ++a) {
            f = b[a];
            e = f.m_fixtureA;
            var g = f.m_fixtureB, n = e.m_shape.m_radius, p = g.m_shape.m_radius, r = e.m_body, s = g.m_body, t = f.GetManifold(), K = C.b2MixFriction(e.GetFriction(), g.GetFriction()), u = C.b2MixRestitution(e.GetRestitution(), g.GetRestitution()), x = r.m_linearVelocity.x, H = r.m_linearVelocity.y, w = s.m_linearVelocity.x, y = s.m_linearVelocity.y, P = r.m_angularVelocity, A = s.m_angularVelocity;
            C.b2Assert(0 < t.m_pointCount);
            v.s_worldManifold.Initialize(t, r.m_xf, n, s.m_xf, p);
            g = v.s_worldManifold.m_normal.x;
            f = v.s_worldManifold.m_normal.y;
            e = this.m_constraints[a];
            e.bodyA = r;
            e.bodyB = s;
            e.manifold = t;
            e.normal.x = g;
            e.normal.y = f;
            e.pointCount = t.m_pointCount;
            e.friction = K;
            e.restitution = u;
            e.localPlaneNormal.x = t.m_localPlaneNormal.x;
            e.localPlaneNormal.y = t.m_localPlaneNormal.y;
            e.localPoint.x = t.m_localPoint.x;
            e.localPoint.y = t.m_localPoint.y;
            e.radius = n + p;
            e.type = t.m_type;
            for (n = 0; n < e.pointCount; ++n) {
                K = t.m_points[n];
                p = e.points[n];
                p.normalImpulse = K.m_normalImpulse;
                p.tangentImpulse = K.m_tangentImpulse;
                p.localPoint.SetV(K.m_localPoint);
                var K = p.rA.x = v.s_worldManifold.m_points[n].x -
                    r.m_sweep.c.x, u = p.rA.y = v.s_worldManifold.m_points[n].y - r.m_sweep.c.y, B = p.rB.x = v.s_worldManifold.m_points[n].x - s.m_sweep.c.x, D = p.rB.y = v.s_worldManifold.m_points[n].y - s.m_sweep.c.y, E = K * f - u * g, I = B * f - D * g, E = E * E, I = I * I;
                p.normalMass = 1 / (r.m_invMass + s.m_invMass + r.m_invI * E + s.m_invI * I);
                var G = r.m_mass * r.m_invMass + s.m_mass * s.m_invMass, G = G + (r.m_mass * r.m_invI * E + s.m_mass * s.m_invI * I);
                p.equalizedMass = 1 / G;
                I = f;
                G = -g;
                E = K * G - u * I;
                I = B * G - D * I;
                E *= E;
                I *= I;
                p.tangentMass = 1 / (r.m_invMass + s.m_invMass + r.m_invI * E + s.m_invI * I);
                p.velocityBias =
                    0;
                K = e.normal.x * (w + -A * D - x - -P * u) + e.normal.y * (y + A * B - H - P * K);
                K < -C.b2_velocityThreshold && (p.velocityBias += -e.restitution * K)
            }
            2 == e.pointCount && (y = e.points[0], w = e.points[1], t = r.m_invMass, r = r.m_invI, x = s.m_invMass, s = s.m_invI, H = y.rA.x * f - y.rA.y * g, y = y.rB.x * f - y.rB.y * g, P = w.rA.x * f - w.rA.y * g, w = w.rB.x * f - w.rB.y * g, g = t + x + r * H * H + s * y * y, f = t + x + r * P * P + s * w * w, s = t + x + r * H * P + s * y * w, g * g < 100 * (g * f - s * s) ? (e.K.col1.Set(g, s), e.K.col2.Set(s, f), e.K.GetInverse(e.normalMass)) : e.pointCount = 1)
        }
    };
    v.prototype.InitVelocityConstraints = function (a) {
        for (var b =
            0; b < this.m_constraintCount; ++b) {
            var d = this.m_constraints[b], e = d.bodyA, f = d.bodyB, g = e.m_invMass, h = e.m_invI, n = f.m_invMass, p = f.m_invI, r = d.normal.x, s = d.normal.y, t = s, K = -r, u = 0, v = 0;
            if (a.warmStarting)for (v = d.pointCount, u = 0; u < v; ++u) {
                var x = d.points[u];
                x.normalImpulse *= a.dtRatio;
                x.tangentImpulse *= a.dtRatio;
                var H = x.normalImpulse * r + x.tangentImpulse * t, w = x.normalImpulse * s + x.tangentImpulse * K;
                e.m_angularVelocity -= h * (x.rA.x * w - x.rA.y * H);
                e.m_linearVelocity.x -= g * H;
                e.m_linearVelocity.y -= g * w;
                f.m_angularVelocity += p * (x.rB.x *
                    w - x.rB.y * H);
                f.m_linearVelocity.x += n * H;
                f.m_linearVelocity.y += n * w
            } else for (v = d.pointCount, u = 0; u < v; ++u)e = d.points[u], e.normalImpulse = 0, e.tangentImpulse = 0
        }
    };
    v.prototype.SolveVelocityConstraints = function () {
        for (var a = 0, b, d = 0, e = 0, f = 0, g = e = e = d = d = 0, h = d = d = 0, n = d = f = 0, p = 0, r, s = 0; s < this.m_constraintCount; ++s) {
            var f = this.m_constraints[s], t = f.bodyA, K = f.bodyB, u = t.m_angularVelocity, v = K.m_angularVelocity, x = t.m_linearVelocity, H = K.m_linearVelocity, w = t.m_invMass, y = t.m_invI, P = K.m_invMass, A = K.m_invI, n = f.normal.x, B = p = f.normal.y;
            r = -n;
            h = f.friction;
            for (a = 0; a < f.pointCount; a++)b = f.points[a], d = H.x - v * b.rB.y - x.x + u * b.rA.y, e = H.y + v * b.rB.x - x.y - u * b.rA.x, d = d * B + e * r, d = b.tangentMass * -d, e = h * b.normalImpulse, e = I.Clamp(b.tangentImpulse + d, -e, e), d = e - b.tangentImpulse, g = d * B, d *= r, x.x -= w * g, x.y -= w * d, u -= y * (b.rA.x * d - b.rA.y * g), H.x += P * g, H.y += P * d, v += A * (b.rB.x * d - b.rB.y * g), b.tangentImpulse = e;
            parseInt(f.pointCount);
            if (1 == f.pointCount)b = f.points[0], d = H.x + -v * b.rB.y - x.x - -u * b.rA.y, e = H.y + v * b.rB.x - x.y - u * b.rA.x, f = d * n + e * p, d = -b.normalMass * (f - b.velocityBias), e = b.normalImpulse +
                d, e = 0 < e ? e : 0, d = e - b.normalImpulse, g = d * n, d *= p, x.x -= w * g, x.y -= w * d, u -= y * (b.rA.x * d - b.rA.y * g), H.x += P * g, H.y += P * d, v += A * (b.rB.x * d - b.rB.y * g), b.normalImpulse = e; else {
                b = f.points[0];
                var a = f.points[1], d = b.normalImpulse, h = a.normalImpulse, C = (H.x - v * b.rB.y - x.x + u * b.rA.y) * n + (H.y + v * b.rB.x - x.y - u * b.rA.x) * p, D = (H.x - v * a.rB.y - x.x + u * a.rA.y) * n + (H.y + v * a.rB.x - x.y - u * a.rA.x) * p, e = C - b.velocityBias, g = D - a.velocityBias;
                r = f.K;
                e -= r.col1.x * d + r.col2.x * h;
                for (g -= r.col1.y * d + r.col2.y * h; ;) {
                    r = f.normalMass;
                    B = -(r.col1.x * e + r.col2.x * g);
                    r = -(r.col1.y * e +
                    r.col2.y * g);
                    if (0 <= B && 0 <= r) {
                        d = B - d;
                        h = r - h;
                        f = d * n;
                        d *= p;
                        n *= h;
                        p *= h;
                        x.x -= w * (f + n);
                        x.y -= w * (d + p);
                        u -= y * (b.rA.x * d - b.rA.y * f + a.rA.x * p - a.rA.y * n);
                        H.x += P * (f + n);
                        H.y += P * (d + p);
                        v += A * (b.rB.x * d - b.rB.y * f + a.rB.x * p - a.rB.y * n);
                        b.normalImpulse = B;
                        a.normalImpulse = r;
                        break
                    }
                    B = -b.normalMass * e;
                    r = 0;
                    D = f.K.col1.y * B + g;
                    if (0 <= B && 0 <= D) {
                        d = B - d;
                        h = r - h;
                        f = d * n;
                        d *= p;
                        n *= h;
                        p *= h;
                        x.x -= w * (f + n);
                        x.y -= w * (d + p);
                        u -= y * (b.rA.x * d - b.rA.y * f + a.rA.x * p - a.rA.y * n);
                        H.x += P * (f + n);
                        H.y += P * (d + p);
                        v += A * (b.rB.x * d - b.rB.y * f + a.rB.x * p - a.rB.y * n);
                        b.normalImpulse = B;
                        a.normalImpulse = r;
                        break
                    }
                    B = 0;
                    r = -a.normalMass * g;
                    C = f.K.col2.x * r + e;
                    if (0 <= r && 0 <= C) {
                        d = B - d;
                        h = r - h;
                        f = d * n;
                        d *= p;
                        n *= h;
                        p *= h;
                        x.x -= w * (f + n);
                        x.y -= w * (d + p);
                        u -= y * (b.rA.x * d - b.rA.y * f + a.rA.x * p - a.rA.y * n);
                        H.x += P * (f + n);
                        H.y += P * (d + p);
                        v += A * (b.rB.x * d - b.rB.y * f + a.rB.x * p - a.rB.y * n);
                        b.normalImpulse = B;
                        a.normalImpulse = r;
                        break
                    }
                    r = B = 0;
                    C = e;
                    D = g;
                    if (0 <= C && 0 <= D) {
                        d = B - d;
                        h = r - h;
                        f = d * n;
                        d *= p;
                        n *= h;
                        p *= h;
                        x.x -= w * (f + n);
                        x.y -= w * (d + p);
                        u -= y * (b.rA.x * d - b.rA.y * f + a.rA.x * p - a.rA.y * n);
                        H.x += P * (f + n);
                        H.y += P * (d + p);
                        v += A * (b.rB.x * d - b.rB.y * f + a.rB.x * p - a.rB.y * n);
                        b.normalImpulse = B;
                        a.normalImpulse =
                            r;
                        break
                    }
                    break
                }
            }
            t.m_angularVelocity = u;
            K.m_angularVelocity = v
        }
    };
    v.prototype.FinalizeVelocityConstraints = function () {
        for (var a = 0; a < this.m_constraintCount; ++a)for (var b = this.m_constraints[a], d = b.manifold, e = 0; e < b.pointCount; ++e) {
            var f = d.m_points[e], g = b.points[e];
            f.m_normalImpulse = g.normalImpulse;
            f.m_tangentImpulse = g.tangentImpulse
        }
    };
    v.prototype.SolvePositionConstraints = function (a) {
        void 0 === a && (a = 0);
        for (var b = 0, d = 0; d < this.m_constraintCount; d++) {
            var e = this.m_constraints[d], f = e.bodyA, g = e.bodyB, h = f.m_mass * f.m_invMass,
                n = f.m_mass * f.m_invI, p = g.m_mass * g.m_invMass, r = g.m_mass * g.m_invI;
            v.s_psm.Initialize(e);
            for (var s = v.s_psm.m_normal, t = 0; t < e.pointCount; t++) {
                var u = e.points[t], K = v.s_psm.m_points[t], x = v.s_psm.m_separations[t], H = K.x - f.m_sweep.c.x, w = K.y - f.m_sweep.c.y, y = K.x - g.m_sweep.c.x, K = K.y - g.m_sweep.c.y, b = b < x ? b : x, x = I.Clamp(a * (x + C.b2_linearSlop), -C.b2_maxLinearCorrection, 0), x = -u.equalizedMass * x, u = x * s.x, x = x * s.y;
                f.m_sweep.c.x -= h * u;
                f.m_sweep.c.y -= h * x;
                f.m_sweep.a -= n * (H * x - w * u);
                f.SynchronizeTransform();
                g.m_sweep.c.x += p * u;
                g.m_sweep.c.y +=
                    p * x;
                g.m_sweep.a += r * (y * x - K * u);
                g.SynchronizeTransform()
            }
        }
        return b > -1.5 * C.b2_linearSlop
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new P;
        Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new D
    });
    Box2D.inherit(u, Box2D.Dynamics.Contacts.b2Contact);
    u.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    u.b2EdgeAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    u.Create = function (a) {
        return new u
    };
    u.Destroy = function (a,
                          b) {
    };
    u.prototype.Reset = function (a, b) {
        this.__super.Reset.call(this, a, b)
    };
    u.prototype.Evaluate = function () {
        var d = this.m_fixtureA.GetBody(), e = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof b ? this.m_fixtureA.GetShape() : null, d.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, e.m_xf)
    };
    u.prototype.b2CollideEdgeAndCircle = function (a, b, d, e, f) {
    };
    Box2D.inherit(x, Box2D.Dynamics.Contacts.b2Contact);
    x.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    x.b2NullContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    x.prototype.b2NullContact = function () {
        this.__super.b2Contact.call(this)
    };
    x.prototype.Evaluate = function () {
    };
    Box2D.inherit(w, Box2D.Dynamics.Contacts.b2Contact);
    w.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    w.b2PolyAndCircleContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    w.Create = function (a) {
        return new w
    };
    w.Destroy = function (a, b) {
    };
    w.prototype.Reset = function (a,
                                  b) {
        this.__super.Reset.call(this, a, b);
        C.b2Assert(a.GetType() == e.e_polygonShape);
        C.b2Assert(b.GetType() == e.e_circleShape)
    };
    w.prototype.Evaluate = function () {
        var b = this.m_fixtureA.m_body, e = this.m_fixtureB.m_body;
        J.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof d ? this.m_fixtureA.GetShape() : null, b.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, e.m_xf)
    };
    Box2D.inherit(y, Box2D.Dynamics.Contacts.b2Contact);
    y.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    y.b2PolyAndEdgeContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    y.Create = function (a) {
        return new y
    };
    y.Destroy = function (a, b) {
    };
    y.prototype.Reset = function (a, b) {
        this.__super.Reset.call(this, a, b);
        C.b2Assert(a.GetType() == e.e_polygonShape);
        C.b2Assert(b.GetType() == e.e_edgeShape)
    };
    y.prototype.Evaluate = function () {
        var a = this.m_fixtureA.GetBody(), e = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof d ? this.m_fixtureA.GetShape() :
            null, a.m_xf, this.m_fixtureB.GetShape() instanceof b ? this.m_fixtureB.GetShape() : null, e.m_xf)
    };
    y.prototype.b2CollidePolyAndEdge = function (a, b, d, e, f) {
    };
    Box2D.inherit(A, Box2D.Dynamics.Contacts.b2Contact);
    A.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    A.b2PolygonContact = function () {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    A.Create = function (a) {
        return new A
    };
    A.Destroy = function (a, b) {
    };
    A.prototype.Reset = function (a, b) {
        this.__super.Reset.call(this, a, b)
    };
    A.prototype.Evaluate =
        function () {
            var a = this.m_fixtureA.GetBody(), b = this.m_fixtureB.GetBody();
            J.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof d ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof d ? this.m_fixtureB.GetShape() : null, b.m_xf)
        };
    D.b2PositionSolverManifold = function () {
    };
    D.prototype.b2PositionSolverManifold = function () {
        this.m_normal = new L;
        this.m_separations = new Vector_a2j_Number(C.b2_maxManifoldPoints);
        this.m_points = new Vector(C.b2_maxManifoldPoints);
        for (var a = 0; a < C.b2_maxManifoldPoints; a++)this.m_points[a] =
            new L
    };
    D.prototype.Initialize = function (a) {
        C.b2Assert(0 < a.pointCount);
        var b = 0, d = 0, e = 0, f, g = 0, h = 0;
        switch (a.type) {
            case M.e_circles:
                f = a.bodyA.m_xf.R;
                e = a.localPoint;
                b = a.bodyA.m_xf.position.x + (f.col1.x * e.x + f.col2.x * e.y);
                d = a.bodyA.m_xf.position.y + (f.col1.y * e.x + f.col2.y * e.y);
                f = a.bodyB.m_xf.R;
                e = a.points[0].localPoint;
                g = a.bodyB.m_xf.position.x + (f.col1.x * e.x + f.col2.x * e.y);
                f = a.bodyB.m_xf.position.y + (f.col1.y * e.x + f.col2.y * e.y);
                var e = g - b, h = f - d, n = e * e + h * h;
                n > Number.MIN_VALUE * Number.MIN_VALUE ? (n = Math.sqrt(n), this.m_normal.x =
                    e / n, this.m_normal.y = h / n) : (this.m_normal.x = 1, this.m_normal.y = 0);
                this.m_points[0].x = 0.5 * (b + g);
                this.m_points[0].y = 0.5 * (d + f);
                this.m_separations[0] = e * this.m_normal.x + h * this.m_normal.y - a.radius;
                break;
            case M.e_faceA:
                f = a.bodyA.m_xf.R;
                e = a.localPlaneNormal;
                this.m_normal.x = f.col1.x * e.x + f.col2.x * e.y;
                this.m_normal.y = f.col1.y * e.x + f.col2.y * e.y;
                f = a.bodyA.m_xf.R;
                e = a.localPoint;
                g = a.bodyA.m_xf.position.x + (f.col1.x * e.x + f.col2.x * e.y);
                h = a.bodyA.m_xf.position.y + (f.col1.y * e.x + f.col2.y * e.y);
                f = a.bodyB.m_xf.R;
                for (b = 0; b < a.pointCount; ++b)e =
                    a.points[b].localPoint, d = a.bodyB.m_xf.position.x + (f.col1.x * e.x + f.col2.x * e.y), e = a.bodyB.m_xf.position.y + (f.col1.y * e.x + f.col2.y * e.y), this.m_separations[b] = (d - g) * this.m_normal.x + (e - h) * this.m_normal.y - a.radius, this.m_points[b].x = d, this.m_points[b].y = e;
                break;
            case M.e_faceB:
                f = a.bodyB.m_xf.R;
                e = a.localPlaneNormal;
                this.m_normal.x = f.col1.x * e.x + f.col2.x * e.y;
                this.m_normal.y = f.col1.y * e.x + f.col2.y * e.y;
                f = a.bodyB.m_xf.R;
                e = a.localPoint;
                g = a.bodyB.m_xf.position.x + (f.col1.x * e.x + f.col2.x * e.y);
                h = a.bodyB.m_xf.position.y +
                    (f.col1.y * e.x + f.col2.y * e.y);
                f = a.bodyA.m_xf.R;
                for (b = 0; b < a.pointCount; ++b)e = a.points[b].localPoint, d = a.bodyA.m_xf.position.x + (f.col1.x * e.x + f.col2.x * e.y), e = a.bodyA.m_xf.position.y + (f.col1.y * e.x + f.col2.y * e.y), this.m_separations[b] = (d - g) * this.m_normal.x + (e - h) * this.m_normal.y - a.radius, this.m_points[b].Set(d, e);
                this.m_normal.x *= -1;
                this.m_normal.y *= -1
        }
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new L;
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB =
            new L
    })
})();
(function () {
    var a = Box2D.Common.Math.b2Mat22, b = Box2D.Common.Math.b2Math, d = Box2D.Common.Math.b2Vec2, e = Box2D.Common.b2Color, f = Box2D.Dynamics.Controllers.b2BuoyancyController, g = Box2D.Dynamics.Controllers.b2ConstantAccelController, h = Box2D.Dynamics.Controllers.b2ConstantForceController, n = Box2D.Dynamics.Controllers.b2Controller, p = Box2D.Dynamics.Controllers.b2ControllerEdge, r = Box2D.Dynamics.Controllers.b2GravityController, s = Box2D.Dynamics.Controllers.b2TensorDampingController;
    Box2D.inherit(f, Box2D.Dynamics.Controllers.b2Controller);
    f.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    f.b2BuoyancyController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.normal = new d(0, -1);
        this.density = this.offset = 0;
        this.velocity = new d(0, 0);
        this.linearDrag = 2;
        this.angularDrag = 1;
        this.useDensity = !1;
        this.useWorldGravity = !0;
        this.gravity = null
    };
    f.prototype.Step = function (a) {
        if (this.m_bodyList)for (this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy()), a = this.m_bodyList; a; a =
            a.nextBody) {
            var b = a.body;
            if (!1 != b.IsAwake()) {
                for (var e = new d, f = new d, g = 0, h = 0, n = b.GetFixtureList(); n; n = n.GetNext()) {
                    var p = new d, r = n.GetShape().ComputeSubmergedArea(this.normal, this.offset, b.GetTransform(), p), g = g + r;
                    e.x += r * p.x;
                    e.y += r * p.y;
                    var s = 0, s = 1, h = h + r * s;
                    f.x += r * p.x * s;
                    f.y += r * p.y * s
                }
                e.x /= g;
                e.y /= g;
                f.x /= h;
                f.y /= h;
                g < Number.MIN_VALUE || (h = this.gravity.GetNegative(), h.Multiply(this.density * g), b.ApplyForce(h, f), f = b.GetLinearVelocityFromWorldPoint(e), f.Subtract(this.velocity), f.Multiply(-this.linearDrag * g), b.ApplyForce(f,
                    e), b.ApplyTorque(-b.GetInertia() / b.GetMass() * g * b.GetAngularVelocity() * this.angularDrag))
            }
        }
    };
    f.prototype.Draw = function (a) {
        var b = new d, f = new d;
        b.x = this.normal.x * this.offset + 1E3 * this.normal.y;
        b.y = this.normal.y * this.offset - 1E3 * this.normal.x;
        f.x = this.normal.x * this.offset - 1E3 * this.normal.y;
        f.y = this.normal.y * this.offset + 1E3 * this.normal.x;
        var g = new e(0, 0, 1);
        a.DrawSegment(b, f, g)
    };
    Box2D.inherit(g, Box2D.Dynamics.Controllers.b2Controller);
    g.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    g.b2ConstantAccelController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.A = new d(0, 0)
    };
    g.prototype.Step = function (a) {
        a = new d(this.A.x * a.dt, this.A.y * a.dt);
        for (var b = this.m_bodyList; b; b = b.nextBody) {
            var e = b.body;
            e.IsAwake() && e.SetLinearVelocity(new d(e.GetLinearVelocity().x + a.x, e.GetLinearVelocity().y + a.y))
        }
    };
    Box2D.inherit(h, Box2D.Dynamics.Controllers.b2Controller);
    h.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    h.b2ConstantForceController =
        function () {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
            this.F = new d(0, 0)
        };
    h.prototype.Step = function (a) {
        for (a = this.m_bodyList; a; a = a.nextBody) {
            var b = a.body;
            b.IsAwake() && b.ApplyForce(this.F, b.GetWorldCenter())
        }
    };
    n.b2Controller = function () {
    };
    n.prototype.Step = function (a) {
    };
    n.prototype.Draw = function (a) {
    };
    n.prototype.AddBody = function (a) {
        var b = new p;
        b.controller = this;
        b.body = a;
        b.nextBody = this.m_bodyList;
        b.prevBody = null;
        this.m_bodyList = b;
        b.nextBody && (b.nextBody.prevBody = b);
        this.m_bodyCount++;
        b.nextController = a.m_controllerList;
        b.prevController = null;
        a.m_controllerList = b;
        b.nextController && (b.nextController.prevController = b);
        a.m_controllerCount++
    };
    n.prototype.RemoveBody = function (a) {
        for (var b = a.m_controllerList; b && b.controller != this;)b = b.nextController;
        b.prevBody && (b.prevBody.nextBody = b.nextBody);
        b.nextBody && (b.nextBody.prevBody = b.prevBody);
        b.nextController && (b.nextController.prevController = b.prevController);
        b.prevController && (b.prevController.nextController = b.nextController);
        this.m_bodyList ==
        b && (this.m_bodyList = b.nextBody);
        a.m_controllerList == b && (a.m_controllerList = b.nextController);
        a.m_controllerCount--;
        this.m_bodyCount--
    };
    n.prototype.Clear = function () {
        for (; this.m_bodyList;)this.RemoveBody(this.m_bodyList.body)
    };
    n.prototype.GetNext = function () {
        return this.m_next
    };
    n.prototype.GetWorld = function () {
        return this.m_world
    };
    n.prototype.GetBodyList = function () {
        return this.m_bodyList
    };
    p.b2ControllerEdge = function () {
    };
    Box2D.inherit(r, Box2D.Dynamics.Controllers.b2Controller);
    r.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    r.b2GravityController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.G = 1;
        this.invSqr = !0
    };
    r.prototype.Step = function (a) {
        var b = a = null, e = null, f = 0, g = null, h = null, n = null, p = 0, r = 0, s = 0, p = null;
        if (this.invSqr)for (a = this.m_bodyList; a; a = a.nextBody)for (b = a.body, e = b.GetWorldCenter(), f = b.GetMass(), g = this.m_bodyList; g != a; g = g.nextBody)h = g.body, n = h.GetWorldCenter(), p = n.x - e.x, r = n.y - e.y, s = p * p + r * r, s < Number.MIN_VALUE || (p = new d(p, r), p.Multiply(this.G / s / Math.sqrt(s) * f * h.GetMass()),
        b.IsAwake() && b.ApplyForce(p, e), p.Multiply(-1), h.IsAwake() && h.ApplyForce(p, n)); else for (a = this.m_bodyList; a; a = a.nextBody)for (b = a.body, e = b.GetWorldCenter(), f = b.GetMass(), g = this.m_bodyList; g != a; g = g.nextBody)h = g.body, n = h.GetWorldCenter(), p = n.x - e.x, r = n.y - e.y, s = p * p + r * r, s < Number.MIN_VALUE || (p = new d(p, r), p.Multiply(this.G / s * f * h.GetMass()), b.IsAwake() && b.ApplyForce(p, e), p.Multiply(-1), h.IsAwake() && h.ApplyForce(p, n))
    };
    Box2D.inherit(s, Box2D.Dynamics.Controllers.b2Controller);
    s.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    s.b2TensorDampingController = function () {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.T = new a;
        this.maxTimestep = 0
    };
    s.prototype.SetAxisAligned = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.T.col1.x = -a;
        this.T.col1.y = 0;
        this.T.col2.x = 0;
        this.T.col2.y = -b;
        this.maxTimestep = 0 < a || 0 < b ? 1 / Math.max(a, b) : 0
    };
    s.prototype.Step = function (a) {
        a = a.dt;
        if (!(a <= Number.MIN_VALUE)) {
            a > this.maxTimestep && 0 < this.maxTimestep && (a = this.maxTimestep);
            for (var e = this.m_bodyList; e; e = e.nextBody) {
                var f =
                    e.body;
                if (f.IsAwake()) {
                    var g = f.GetWorldVector(b.MulMV(this.T, f.GetLocalVector(f.GetLinearVelocity())));
                    f.SetLinearVelocity(new d(f.GetLinearVelocity().x + g.x * a, f.GetLinearVelocity().y + g.y * a))
                }
            }
        }
    }
})();
(function () {
    var a = Box2D.Common.b2Settings, b = Box2D.Common.Math.b2Mat22, d = Box2D.Common.Math.b2Mat33, e = Box2D.Common.Math.b2Math, f = Box2D.Common.Math.b2Vec2, g = Box2D.Common.Math.b2Vec3, h = Box2D.Dynamics.Joints.b2DistanceJoint, n = Box2D.Dynamics.Joints.b2DistanceJointDef, p = Box2D.Dynamics.Joints.b2FrictionJoint, r = Box2D.Dynamics.Joints.b2FrictionJointDef, s = Box2D.Dynamics.Joints.b2GearJoint, t = Box2D.Dynamics.Joints.b2GearJointDef, v = Box2D.Dynamics.Joints.b2Jacobian, u = Box2D.Dynamics.Joints.b2Joint, x = Box2D.Dynamics.Joints.b2JointDef,
        w = Box2D.Dynamics.Joints.b2JointEdge, y = Box2D.Dynamics.Joints.b2LineJoint, A = Box2D.Dynamics.Joints.b2LineJointDef, D = Box2D.Dynamics.Joints.b2MouseJoint, G = Box2D.Dynamics.Joints.b2MouseJointDef, B = Box2D.Dynamics.Joints.b2PrismaticJoint, C = Box2D.Dynamics.Joints.b2PrismaticJointDef, E = Box2D.Dynamics.Joints.b2PulleyJoint, I = Box2D.Dynamics.Joints.b2PulleyJointDef, L = Box2D.Dynamics.Joints.b2RevoluteJoint, J = Box2D.Dynamics.Joints.b2RevoluteJointDef, Q = Box2D.Dynamics.Joints.b2WeldJoint, M = Box2D.Dynamics.Joints.b2WeldJointDef;
    Box2D.inherit(h, Box2D.Dynamics.Joints.b2Joint);
    h.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    h.b2DistanceJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new f;
        this.m_localAnchor2 = new f;
        this.m_u = new f
    };
    h.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    h.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    h.prototype.GetReactionForce = function (a) {
        void 0 === a && (a = 0);
        return new f(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)
    };
    h.prototype.GetReactionTorque = function (a) {
        return 0
    };
    h.prototype.GetLength = function () {
        return this.m_length
    };
    h.prototype.SetLength = function (a) {
        void 0 === a && (a = 0);
        this.m_length = a
    };
    h.prototype.GetFrequency = function () {
        return this.m_frequencyHz
    };
    h.prototype.SetFrequency = function (a) {
        void 0 === a && (a = 0);
        this.m_frequencyHz = a
    };
    h.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio
    };
    h.prototype.SetDampingRatio = function (a) {
        void 0 ===
        a && (a = 0);
        this.m_dampingRatio = a
    };
    h.prototype.b2DistanceJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_length = a.length;
        this.m_frequencyHz = a.frequencyHz;
        this.m_dampingRatio = a.dampingRatio;
        this.m_bias = this.m_gamma = this.m_impulse = 0
    };
    h.prototype.InitVelocityConstraints = function (b) {
        var d, e = 0, f = this.m_bodyA, g = this.m_bodyB;
        d = f.m_xf.R;
        var h = this.m_localAnchor1.x - f.m_sweep.localCenter.x, n = this.m_localAnchor1.y - f.m_sweep.localCenter.y,
            e = d.col1.x * h + d.col2.x * n, n = d.col1.y * h + d.col2.y * n, h = e;
        d = g.m_xf.R;
        var p = this.m_localAnchor2.x - g.m_sweep.localCenter.x, r = this.m_localAnchor2.y - g.m_sweep.localCenter.y, e = d.col1.x * p + d.col2.x * r, r = d.col1.y * p + d.col2.y * r, p = e;
        this.m_u.x = g.m_sweep.c.x + p - f.m_sweep.c.x - h;
        this.m_u.y = g.m_sweep.c.y + r - f.m_sweep.c.y - n;
        e = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        e > a.b2_linearSlop ? this.m_u.Multiply(1 / e) : this.m_u.SetZero();
        d = h * this.m_u.y - n * this.m_u.x;
        var s = p * this.m_u.y - r * this.m_u.x;
        d = f.m_invMass + f.m_invI *
            d * d + g.m_invMass + g.m_invI * s * s;
        this.m_mass = 0 != d ? 1 / d : 0;
        if (0 < this.m_frequencyHz) {
            var e = e - this.m_length, s = 2 * Math.PI * this.m_frequencyHz, t = this.m_mass * s * s;
            this.m_gamma = b.dt * (2 * this.m_mass * this.m_dampingRatio * s + b.dt * t);
            this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
            this.m_bias = e * b.dt * t * this.m_gamma;
            this.m_mass = d + this.m_gamma;
            this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0
        }
        b.warmStarting ? (this.m_impulse *= b.dtRatio, b = this.m_impulse * this.m_u.x, d = this.m_impulse * this.m_u.y, f.m_linearVelocity.x -= f.m_invMass * b, f.m_linearVelocity.y -=
            f.m_invMass * d, f.m_angularVelocity -= f.m_invI * (h * d - n * b), g.m_linearVelocity.x += g.m_invMass * b, g.m_linearVelocity.y += g.m_invMass * d, g.m_angularVelocity += g.m_invI * (p * d - r * b)) : this.m_impulse = 0
    };
    h.prototype.SolveVelocityConstraints = function (a) {
        var b;
        a = this.m_bodyA;
        var d = this.m_bodyB;
        b = a.m_xf.R;
        var e = this.m_localAnchor1.x - a.m_sweep.localCenter.x, f = this.m_localAnchor1.y - a.m_sweep.localCenter.y, g = b.col1.x * e + b.col2.x * f, f = b.col1.y * e + b.col2.y * f, e = g;
        b = d.m_xf.R;
        var h = this.m_localAnchor2.x - d.m_sweep.localCenter.x, n =
            this.m_localAnchor2.y - d.m_sweep.localCenter.y, g = b.col1.x * h + b.col2.x * n, n = b.col1.y * h + b.col2.y * n, h = g, g = -this.m_mass * (this.m_u.x * (d.m_linearVelocity.x + -d.m_angularVelocity * n - (a.m_linearVelocity.x + -a.m_angularVelocity * f)) + this.m_u.y * (d.m_linearVelocity.y + d.m_angularVelocity * h - (a.m_linearVelocity.y + a.m_angularVelocity * e)) + this.m_bias + this.m_gamma * this.m_impulse);
        this.m_impulse += g;
        b = g * this.m_u.x;
        g *= this.m_u.y;
        a.m_linearVelocity.x -= a.m_invMass * b;
        a.m_linearVelocity.y -= a.m_invMass * g;
        a.m_angularVelocity -= a.m_invI *
            (e * g - f * b);
        d.m_linearVelocity.x += d.m_invMass * b;
        d.m_linearVelocity.y += d.m_invMass * g;
        d.m_angularVelocity += d.m_invI * (h * g - n * b)
    };
    h.prototype.SolvePositionConstraints = function (b) {
        var d;
        if (0 < this.m_frequencyHz)return !0;
        b = this.m_bodyA;
        var f = this.m_bodyB;
        d = b.m_xf.R;
        var g = this.m_localAnchor1.x - b.m_sweep.localCenter.x, h = this.m_localAnchor1.y - b.m_sweep.localCenter.y, n = d.col1.x * g + d.col2.x * h, h = d.col1.y * g + d.col2.y * h, g = n;
        d = f.m_xf.R;
        var p = this.m_localAnchor2.x - f.m_sweep.localCenter.x, r = this.m_localAnchor2.y - f.m_sweep.localCenter.y,
            n = d.col1.x * p + d.col2.x * r, r = d.col1.y * p + d.col2.y * r, p = n, n = f.m_sweep.c.x + p - b.m_sweep.c.x - g, s = f.m_sweep.c.y + r - b.m_sweep.c.y - h;
        d = Math.sqrt(n * n + s * s);
        n /= d;
        s /= d;
        d -= this.m_length;
        d = e.Clamp(d, -a.b2_maxLinearCorrection, a.b2_maxLinearCorrection);
        var t = -this.m_mass * d;
        this.m_u.Set(n, s);
        n = t * this.m_u.x;
        s = t * this.m_u.y;
        b.m_sweep.c.x -= b.m_invMass * n;
        b.m_sweep.c.y -= b.m_invMass * s;
        b.m_sweep.a -= b.m_invI * (g * s - h * n);
        f.m_sweep.c.x += f.m_invMass * n;
        f.m_sweep.c.y += f.m_invMass * s;
        f.m_sweep.a += f.m_invI * (p * s - r * n);
        b.SynchronizeTransform();
        f.SynchronizeTransform();
        return e.Abs(d) < a.b2_linearSlop
    };
    Box2D.inherit(n, Box2D.Dynamics.Joints.b2JointDef);
    n.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    n.b2DistanceJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new f;
        this.localAnchorB = new f
    };
    n.prototype.b2DistanceJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_distanceJoint;
        this.length = 1;
        this.dampingRatio = this.frequencyHz = 0
    };
    n.prototype.Initialize = function (a,
                                       b, d, e) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(d));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(e));
        a = e.x - d.x;
        d = e.y - d.y;
        this.length = Math.sqrt(a * a + d * d);
        this.dampingRatio = this.frequencyHz = 0
    };
    Box2D.inherit(p, Box2D.Dynamics.Joints.b2Joint);
    p.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    p.b2FrictionJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new f;
        this.m_localAnchorB = new f;
        this.m_linearMass = new b;
        this.m_linearImpulse =
            new f
    };
    p.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
    };
    p.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
    };
    p.prototype.GetReactionForce = function (a) {
        void 0 === a && (a = 0);
        return new f(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)
    };
    p.prototype.GetReactionTorque = function (a) {
        void 0 === a && (a = 0);
        return a * this.m_angularImpulse
    };
    p.prototype.SetMaxForce = function (a) {
        void 0 === a && (a = 0);
        this.m_maxForce = a
    };
    p.prototype.GetMaxForce = function () {
        return this.m_maxForce
    };
    p.prototype.SetMaxTorque = function (a) {
        void 0 === a && (a = 0);
        this.m_maxTorque = a
    };
    p.prototype.GetMaxTorque = function () {
        return this.m_maxTorque
    };
    p.prototype.b2FrictionJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchorA.SetV(a.localAnchorA);
        this.m_localAnchorB.SetV(a.localAnchorB);
        this.m_linearMass.SetZero();
        this.m_angularMass = 0;
        this.m_linearImpulse.SetZero();
        this.m_angularImpulse = 0;
        this.m_maxForce = a.maxForce;
        this.m_maxTorque = a.maxTorque
    };
    p.prototype.InitVelocityConstraints = function (a) {
        var d,
            e = 0, f = this.m_bodyA, g = this.m_bodyB;
        d = f.m_xf.R;
        var h = this.m_localAnchorA.x - f.m_sweep.localCenter.x, n = this.m_localAnchorA.y - f.m_sweep.localCenter.y, e = d.col1.x * h + d.col2.x * n, n = d.col1.y * h + d.col2.y * n, h = e;
        d = g.m_xf.R;
        var p = this.m_localAnchorB.x - g.m_sweep.localCenter.x, r = this.m_localAnchorB.y - g.m_sweep.localCenter.y, e = d.col1.x * p + d.col2.x * r, r = d.col1.y * p + d.col2.y * r, p = e;
        d = f.m_invMass;
        var e = g.m_invMass, s = f.m_invI, t = g.m_invI, u = new b;
        u.col1.x = d + e;
        u.col2.x = 0;
        u.col1.y = 0;
        u.col2.y = d + e;
        u.col1.x += s * n * n;
        u.col2.x += -s * h *
            n;
        u.col1.y += -s * h * n;
        u.col2.y += s * h * h;
        u.col1.x += t * r * r;
        u.col2.x += -t * p * r;
        u.col1.y += -t * p * r;
        u.col2.y += t * p * p;
        u.GetInverse(this.m_linearMass);
        this.m_angularMass = s + t;
        0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
        a.warmStarting ? (this.m_linearImpulse.x *= a.dtRatio, this.m_linearImpulse.y *= a.dtRatio, this.m_angularImpulse *= a.dtRatio, a = this.m_linearImpulse, f.m_linearVelocity.x -= d * a.x, f.m_linearVelocity.y -= d * a.y, f.m_angularVelocity -= s * (h * a.y - n * a.x + this.m_angularImpulse), g.m_linearVelocity.x += e * a.x,
            g.m_linearVelocity.y += e * a.y, g.m_angularVelocity += t * (p * a.y - r * a.x + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0)
    };
    p.prototype.SolveVelocityConstraints = function (a) {
        var b, d = 0, g = this.m_bodyA, h = this.m_bodyB, n = g.m_linearVelocity, p = g.m_angularVelocity, r = h.m_linearVelocity, s = h.m_angularVelocity, t = g.m_invMass, u = h.m_invMass, x = g.m_invI, w = h.m_invI;
        b = g.m_xf.R;
        var v = this.m_localAnchorA.x - g.m_sweep.localCenter.x, y = this.m_localAnchorA.y - g.m_sweep.localCenter.y, d = b.col1.x * v + b.col2.x *
            y, y = b.col1.y * v + b.col2.y * y, v = d;
        b = h.m_xf.R;
        var A = this.m_localAnchorB.x - h.m_sweep.localCenter.x, B = this.m_localAnchorB.y - h.m_sweep.localCenter.y, d = b.col1.x * A + b.col2.x * B, B = b.col1.y * A + b.col2.y * B, A = d;
        b = 0;
        var d = -this.m_angularMass * (s - p), C = this.m_angularImpulse;
        b = a.dt * this.m_maxTorque;
        this.m_angularImpulse = e.Clamp(this.m_angularImpulse + d, -b, b);
        d = this.m_angularImpulse - C;
        p -= x * d;
        s += w * d;
        b = e.MulMV(this.m_linearMass, new f(-(r.x - s * B - n.x + p * y), -(r.y + s * A - n.y - p * v)));
        d = this.m_linearImpulse.Copy();
        this.m_linearImpulse.Add(b);
        b = a.dt * this.m_maxForce;
        this.m_linearImpulse.LengthSquared() > b * b && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(b));
        b = e.SubtractVV(this.m_linearImpulse, d);
        n.x -= t * b.x;
        n.y -= t * b.y;
        p -= x * (v * b.y - y * b.x);
        r.x += u * b.x;
        r.y += u * b.y;
        s += w * (A * b.y - B * b.x);
        g.m_angularVelocity = p;
        h.m_angularVelocity = s
    };
    p.prototype.SolvePositionConstraints = function (a) {
        return !0
    };
    Box2D.inherit(r, Box2D.Dynamics.Joints.b2JointDef);
    r.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    r.b2FrictionJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,
            arguments);
        this.localAnchorA = new f;
        this.localAnchorB = new f
    };
    r.prototype.b2FrictionJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_frictionJoint;
        this.maxTorque = this.maxForce = 0
    };
    r.prototype.Initialize = function (a, b, d) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(d));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(d))
    };
    Box2D.inherit(s, Box2D.Dynamics.Joints.b2Joint);
    s.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    s.b2GearJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,
            arguments);
        this.m_groundAnchor1 = new f;
        this.m_groundAnchor2 = new f;
        this.m_localAnchor1 = new f;
        this.m_localAnchor2 = new f;
        this.m_J = new v
    };
    s.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    s.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    s.prototype.GetReactionForce = function (a) {
        void 0 === a && (a = 0);
        return new f(a * this.m_impulse * this.m_J.linearB.x, a * this.m_impulse * this.m_J.linearB.y)
    };
    s.prototype.GetReactionTorque = function (a) {
        void 0 ===
        a && (a = 0);
        var b = this.m_bodyB.m_xf.R, d = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x, e = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y, f = b.col1.x * d + b.col2.x * e, e = b.col1.y * d + b.col2.y * e;
        return a * (this.m_impulse * this.m_J.angularB - f * this.m_impulse * this.m_J.linearB.y + e * this.m_impulse * this.m_J.linearB.x)
    };
    s.prototype.GetRatio = function () {
        return this.m_ratio
    };
    s.prototype.SetRatio = function (a) {
        void 0 === a && (a = 0);
        this.m_ratio = a
    };
    s.prototype.b2GearJoint = function (a) {
        this.__super.b2Joint.call(this,
            a);
        var b = parseInt(a.joint1.m_type), d = parseInt(a.joint2.m_type);
        this.m_prismatic2 = this.m_revolute2 = this.m_prismatic1 = this.m_revolute1 = null;
        var e = 0, f = 0;
        this.m_ground1 = a.joint1.GetBodyA();
        this.m_bodyA = a.joint1.GetBodyB();
        b == u.e_revoluteJoint ? (this.m_revolute1 = a.joint1 instanceof L ? a.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), e = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = a.joint1 instanceof B ? a.joint1 : null,
            this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), e = this.m_prismatic1.GetJointTranslation());
        this.m_ground2 = a.joint2.GetBodyA();
        this.m_bodyB = a.joint2.GetBodyB();
        d == u.e_revoluteJoint ? (this.m_revolute2 = a.joint2 instanceof L ? a.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), f = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = a.joint2 instanceof B ? a.joint2 :
            null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), f = this.m_prismatic2.GetJointTranslation());
        this.m_ratio = a.ratio;
        this.m_constant = e + this.m_ratio * f;
        this.m_impulse = 0
    };
    s.prototype.InitVelocityConstraints = function (a) {
        var b = this.m_ground1, d = this.m_ground2, e = this.m_bodyA, f = this.m_bodyB, g = 0, h = 0, n = 0, p = 0, r = n = 0, s = 0;
        this.m_J.SetZero();
        this.m_revolute1 ? (this.m_J.angularA = -1, s += e.m_invI) : (b = b.m_xf.R, h = this.m_prismatic1.m_localXAxis1, g = b.col1.x *
            h.x + b.col2.x * h.y, h = b.col1.y * h.x + b.col2.y * h.y, b = e.m_xf.R, n = this.m_localAnchor1.x - e.m_sweep.localCenter.x, p = this.m_localAnchor1.y - e.m_sweep.localCenter.y, r = b.col1.x * n + b.col2.x * p, p = b.col1.y * n + b.col2.y * p, n = r * h - p * g, this.m_J.linearA.Set(-g, -h), this.m_J.angularA = -n, s += e.m_invMass + e.m_invI * n * n);
        this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, s += this.m_ratio * this.m_ratio * f.m_invI) : (b = d.m_xf.R, h = this.m_prismatic2.m_localXAxis1, g = b.col1.x * h.x + b.col2.x * h.y, h = b.col1.y * h.x + b.col2.y * h.y, b = f.m_xf.R, n = this.m_localAnchor2.x -
            f.m_sweep.localCenter.x, p = this.m_localAnchor2.y - f.m_sweep.localCenter.y, r = b.col1.x * n + b.col2.x * p, p = b.col1.y * n + b.col2.y * p, n = r * h - p * g, this.m_J.linearB.Set(-this.m_ratio * g, -this.m_ratio * h), this.m_J.angularB = -this.m_ratio * n, s += this.m_ratio * this.m_ratio * (f.m_invMass + f.m_invI * n * n));
        this.m_mass = 0 < s ? 1 / s : 0;
        a.warmStarting ? (e.m_linearVelocity.x += e.m_invMass * this.m_impulse * this.m_J.linearA.x, e.m_linearVelocity.y += e.m_invMass * this.m_impulse * this.m_J.linearA.y, e.m_angularVelocity += e.m_invI * this.m_impulse * this.m_J.angularA,
            f.m_linearVelocity.x += f.m_invMass * this.m_impulse * this.m_J.linearB.x, f.m_linearVelocity.y += f.m_invMass * this.m_impulse * this.m_J.linearB.y, f.m_angularVelocity += f.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0
    };
    s.prototype.SolveVelocityConstraints = function (a) {
        a = this.m_bodyA;
        var b = this.m_bodyB, d = this.m_J.Compute(a.m_linearVelocity, a.m_angularVelocity, b.m_linearVelocity, b.m_angularVelocity), d = -this.m_mass * d;
        this.m_impulse += d;
        a.m_linearVelocity.x += a.m_invMass * d * this.m_J.linearA.x;
        a.m_linearVelocity.y +=
            a.m_invMass * d * this.m_J.linearA.y;
        a.m_angularVelocity += a.m_invI * d * this.m_J.angularA;
        b.m_linearVelocity.x += b.m_invMass * d * this.m_J.linearB.x;
        b.m_linearVelocity.y += b.m_invMass * d * this.m_J.linearB.y;
        b.m_angularVelocity += b.m_invI * d * this.m_J.angularB
    };
    s.prototype.SolvePositionConstraints = function (b) {
        b = this.m_bodyA;
        var d = this.m_bodyB, e = 0, f = 0, e = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation(), f = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation(),
            e = -this.m_mass * (this.m_constant - (e + this.m_ratio * f));
        b.m_sweep.c.x += b.m_invMass * e * this.m_J.linearA.x;
        b.m_sweep.c.y += b.m_invMass * e * this.m_J.linearA.y;
        b.m_sweep.a += b.m_invI * e * this.m_J.angularA;
        d.m_sweep.c.x += d.m_invMass * e * this.m_J.linearB.x;
        d.m_sweep.c.y += d.m_invMass * e * this.m_J.linearB.y;
        d.m_sweep.a += d.m_invI * e * this.m_J.angularB;
        b.SynchronizeTransform();
        d.SynchronizeTransform();
        return 0 < a.b2_linearSlop
    };
    Box2D.inherit(t, Box2D.Dynamics.Joints.b2JointDef);
    t.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    t.b2GearJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments)
    };
    t.prototype.b2GearJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_gearJoint;
        this.joint2 = this.joint1 = null;
        this.ratio = 1
    };
    v.b2Jacobian = function () {
        this.linearA = new f;
        this.linearB = new f
    };
    v.prototype.SetZero = function () {
        this.linearA.SetZero();
        this.angularA = 0;
        this.linearB.SetZero();
        this.angularB = 0
    };
    v.prototype.Set = function (a, b, d, e) {
        void 0 === b && (b = 0);
        void 0 === e && (e = 0);
        this.linearA.SetV(a);
        this.angularA =
            b;
        this.linearB.SetV(d);
        this.angularB = e
    };
    v.prototype.Compute = function (a, b, d, e) {
        void 0 === b && (b = 0);
        void 0 === e && (e = 0);
        return this.linearA.x * a.x + this.linearA.y * a.y + this.angularA * b + (this.linearB.x * d.x + this.linearB.y * d.y) + this.angularB * e
    };
    u.b2Joint = function () {
        this.m_edgeA = new w;
        this.m_edgeB = new w;
        this.m_localCenterA = new f;
        this.m_localCenterB = new f
    };
    u.prototype.GetType = function () {
        return this.m_type
    };
    u.prototype.GetAnchorA = function () {
        return null
    };
    u.prototype.GetAnchorB = function () {
        return null
    };
    u.prototype.GetReactionForce =
        function (a) {
            return null
        };
    u.prototype.GetReactionTorque = function (a) {
        return 0
    };
    u.prototype.GetBodyA = function () {
        return this.m_bodyA
    };
    u.prototype.GetBodyB = function () {
        return this.m_bodyB
    };
    u.prototype.GetNext = function () {
        return this.m_next
    };
    u.prototype.GetUserData = function () {
        return this.m_userData
    };
    u.prototype.SetUserData = function (a) {
        this.m_userData = a
    };
    u.prototype.IsActive = function () {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
    };
    u.Create = function (a, b) {
        var d = null;
        switch (a.type) {
            case u.e_distanceJoint:
                d =
                    new h(a instanceof n ? a : null);
                break;
            case u.e_mouseJoint:
                d = new D(a instanceof G ? a : null);
                break;
            case u.e_prismaticJoint:
                d = new B(a instanceof C ? a : null);
                break;
            case u.e_revoluteJoint:
                d = new L(a instanceof J ? a : null);
                break;
            case u.e_pulleyJoint:
                d = new E(a instanceof I ? a : null);
                break;
            case u.e_gearJoint:
                d = new s(a instanceof t ? a : null);
                break;
            case u.e_lineJoint:
                d = new y(a instanceof A ? a : null);
                break;
            case u.e_weldJoint:
                d = new Q(a instanceof M ? a : null);
                break;
            case u.e_frictionJoint:
                d = new p(a instanceof r ? a : null)
        }
        return d
    };
    u.Destroy = function (a, b) {
    };
    u.prototype.b2Joint = function (b) {
        a.b2Assert(b.bodyA != b.bodyB);
        this.m_type = b.type;
        this.m_next = this.m_prev = null;
        this.m_bodyA = b.bodyA;
        this.m_bodyB = b.bodyB;
        this.m_collideConnected = b.collideConnected;
        this.m_islandFlag = !1;
        this.m_userData = b.userData
    };
    u.prototype.InitVelocityConstraints = function (a) {
    };
    u.prototype.SolveVelocityConstraints = function (a) {
    };
    u.prototype.FinalizeVelocityConstraints = function () {
    };
    u.prototype.SolvePositionConstraints = function (a) {
        return !1
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2Joint.e_unknownJoint =
            0;
        Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
        Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
        Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
        Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
        Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
        Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
        Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
        Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
        Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
        Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
        Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit =
            1;
        Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
        Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3
    });
    x.b2JointDef = function () {
    };
    x.prototype.b2JointDef = function () {
        this.type = u.e_unknownJoint;
        this.bodyB = this.bodyA = this.userData = null;
        this.collideConnected = !1
    };
    w.b2JointEdge = function () {
    };
    Box2D.inherit(y, Box2D.Dynamics.Joints.b2Joint);
    y.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    y.b2LineJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new f;
        this.m_localAnchor2 =
            new f;
        this.m_localXAxis1 = new f;
        this.m_localYAxis1 = new f;
        this.m_axis = new f;
        this.m_perp = new f;
        this.m_K = new b;
        this.m_impulse = new f
    };
    y.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    y.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    y.prototype.GetReactionForce = function (a) {
        void 0 === a && (a = 0);
        return new f(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y +
            (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
    };
    y.prototype.GetReactionTorque = function (a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.y
    };
    y.prototype.GetJointTranslation = function () {
        var a = this.m_bodyA, b = this.m_bodyB, d = a.GetWorldPoint(this.m_localAnchor1), e = b.GetWorldPoint(this.m_localAnchor2), b = e.x - d.x, d = e.y - d.y, a = a.GetWorldVector(this.m_localXAxis1);
        return a.x * b + a.y * d
    };
    y.prototype.GetJointSpeed = function () {
        var a = this.m_bodyA, b = this.m_bodyB, d;
        d = a.m_xf.R;
        var e = this.m_localAnchor1.x - a.m_sweep.localCenter.x,
            f = this.m_localAnchor1.y - a.m_sweep.localCenter.y, g = d.col1.x * e + d.col2.x * f, f = d.col1.y * e + d.col2.y * f, e = g;
        d = b.m_xf.R;
        var h = this.m_localAnchor2.x - b.m_sweep.localCenter.x, n = this.m_localAnchor2.y - b.m_sweep.localCenter.y, g = d.col1.x * h + d.col2.x * n, n = d.col1.y * h + d.col2.y * n, h = g;
        d = b.m_sweep.c.x + h - (a.m_sweep.c.x + e);
        var g = b.m_sweep.c.y + n - (a.m_sweep.c.y + f), p = a.GetWorldVector(this.m_localXAxis1), r = a.m_linearVelocity, s = b.m_linearVelocity, a = a.m_angularVelocity, b = b.m_angularVelocity;
        return d * -a * p.y + g * a * p.x + (p.x * (s.x + -b *
            n - r.x - -a * f) + p.y * (s.y + b * h - r.y - a * e))
    };
    y.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit
    };
    y.prototype.EnableLimit = function (a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableLimit = a
    };
    y.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation
    };
    y.prototype.GetUpperLimit = function () {
        return this.m_upperTranslation
    };
    y.prototype.SetLimits = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_lowerTranslation = a;
        this.m_upperTranslation =
            b
    };
    y.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor
    };
    y.prototype.EnableMotor = function (a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableMotor = a
    };
    y.prototype.SetMotorSpeed = function (a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_motorSpeed = a
    };
    y.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed
    };
    y.prototype.SetMaxMotorForce = function (a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_maxMotorForce =
            a
    };
    y.prototype.GetMaxMotorForce = function () {
        return this.m_maxMotorForce
    };
    y.prototype.GetMotorForce = function () {
        return this.m_motorImpulse
    };
    y.prototype.b2LineJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_localXAxis1.SetV(a.localAxisA);
        this.m_localYAxis1.x = -this.m_localXAxis1.y;
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_impulse.SetZero();
        this.m_motorImpulse = this.m_motorMass = 0;
        this.m_lowerTranslation = a.lowerTranslation;
        this.m_upperTranslation = a.upperTranslation;
        this.m_maxMotorForce = a.maxMotorForce;
        this.m_motorSpeed = a.motorSpeed;
        this.m_enableLimit = a.enableLimit;
        this.m_enableMotor = a.enableMotor;
        this.m_limitState = u.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero()
    };
    y.prototype.InitVelocityConstraints = function (b) {
        var d = this.m_bodyA, f = this.m_bodyB, g, h = 0;
        this.m_localCenterA.SetV(d.GetLocalCenter());
        this.m_localCenterB.SetV(f.GetLocalCenter());
        var n = d.GetTransform();
        f.GetTransform();
        g = d.m_xf.R;
        var p = this.m_localAnchor1.x -
            this.m_localCenterA.x, r = this.m_localAnchor1.y - this.m_localCenterA.y, h = g.col1.x * p + g.col2.x * r, r = g.col1.y * p + g.col2.y * r, p = h;
        g = f.m_xf.R;
        var s = this.m_localAnchor2.x - this.m_localCenterB.x, t = this.m_localAnchor2.y - this.m_localCenterB.y, h = g.col1.x * s + g.col2.x * t, t = g.col1.y * s + g.col2.y * t, s = h;
        g = f.m_sweep.c.x + s - d.m_sweep.c.x - p;
        h = f.m_sweep.c.y + t - d.m_sweep.c.y - r;
        this.m_invMassA = d.m_invMass;
        this.m_invMassB = f.m_invMass;
        this.m_invIA = d.m_invI;
        this.m_invIB = f.m_invI;
        this.m_axis.SetV(e.MulMV(n.R, this.m_localXAxis1));
        this.m_a1 =
            (g + p) * this.m_axis.y - (h + r) * this.m_axis.x;
        this.m_a2 = s * this.m_axis.y - t * this.m_axis.x;
        this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
        this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
        this.m_perp.SetV(e.MulMV(n.R, this.m_localYAxis1));
        this.m_s1 = (g + p) * this.m_perp.y - (h + r) * this.m_perp.x;
        this.m_s2 = s * this.m_perp.y - t * this.m_perp.x;
        n = this.m_invMassA;
        p = this.m_invMassB;
        r = this.m_invIA;
        s = this.m_invIB;
        this.m_K.col1.x = n + p + r * this.m_s1 *
            this.m_s1 + s * this.m_s2 * this.m_s2;
        this.m_K.col1.y = r * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2;
        this.m_K.col2.x = this.m_K.col1.y;
        this.m_K.col2.y = n + p + r * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2;
        this.m_enableLimit ? (g = this.m_axis.x * g + this.m_axis.y * h, e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? this.m_limitState = u.e_equalLimits : g <= this.m_lowerTranslation ? this.m_limitState != u.e_atLowerLimit && (this.m_limitState = u.e_atLowerLimit, this.m_impulse.y = 0) : g >= this.m_upperTranslation ? this.m_limitState !=
        u.e_atUpperLimit && (this.m_limitState = u.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = u.e_inactiveLimit, this.m_impulse.y = 0)) : this.m_limitState = u.e_inactiveLimit;
        !1 == this.m_enableMotor && (this.m_motorImpulse = 0);
        b.warmStarting ? (this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio, b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, g = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, h = this.m_impulse.x *
            this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1, n = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2, d.m_linearVelocity.x -= this.m_invMassA * b, d.m_linearVelocity.y -= this.m_invMassA * g, d.m_angularVelocity -= this.m_invIA * h, f.m_linearVelocity.x += this.m_invMassB * b, f.m_linearVelocity.y += this.m_invMassB * g, f.m_angularVelocity += this.m_invIB * n) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
    };
    y.prototype.SolveVelocityConstraints = function (a) {
        var b = this.m_bodyA, d = this.m_bodyB,
            g = b.m_linearVelocity, h = b.m_angularVelocity, n = d.m_linearVelocity, p = d.m_angularVelocity, r = 0, s = 0, t = 0, x = 0;
        this.m_enableMotor && this.m_limitState != u.e_equalLimits && (x = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (n.x - g.x) + this.m_axis.y * (n.y - g.y) + this.m_a2 * p - this.m_a1 * h)), r = this.m_motorImpulse, s = a.dt * this.m_maxMotorForce, this.m_motorImpulse = e.Clamp(this.m_motorImpulse + x, -s, s), x = this.m_motorImpulse - r, r = x * this.m_axis.x, s = x * this.m_axis.y, t = x * this.m_a1, x *= this.m_a2, g.x -= this.m_invMassA * r, g.y -= this.m_invMassA *
            s, h -= this.m_invIA * t, n.x += this.m_invMassB * r, n.y += this.m_invMassB * s, p += this.m_invIB * x);
        s = this.m_perp.x * (n.x - g.x) + this.m_perp.y * (n.y - g.y) + this.m_s2 * p - this.m_s1 * h;
        this.m_enableLimit && this.m_limitState != u.e_inactiveLimit ? (t = this.m_axis.x * (n.x - g.x) + this.m_axis.y * (n.y - g.y) + this.m_a2 * p - this.m_a1 * h, r = this.m_impulse.Copy(), a = this.m_K.Solve(new f, -s, -t), this.m_impulse.Add(a), this.m_limitState == u.e_atLowerLimit ? this.m_impulse.y = e.Max(this.m_impulse.y, 0) : this.m_limitState == u.e_atUpperLimit && (this.m_impulse.y =
            e.Min(this.m_impulse.y, 0)), s = -s - (this.m_impulse.y - r.y) * this.m_K.col2.x, t = 0, t = 0 != this.m_K.col1.x ? s / this.m_K.col1.x + r.x : r.x, this.m_impulse.x = t, a.x = this.m_impulse.x - r.x, a.y = this.m_impulse.y - r.y, r = a.x * this.m_perp.x + a.y * this.m_axis.x, s = a.x * this.m_perp.y + a.y * this.m_axis.y, t = a.x * this.m_s1 + a.y * this.m_a1, x = a.x * this.m_s2 + a.y * this.m_a2) : (a = 0, a = 0 != this.m_K.col1.x ? -s / this.m_K.col1.x : 0, this.m_impulse.x += a, r = a * this.m_perp.x, s = a * this.m_perp.y, t = a * this.m_s1, x = a * this.m_s2);
        g.x -= this.m_invMassA * r;
        g.y -= this.m_invMassA *
            s;
        h -= this.m_invIA * t;
        n.x += this.m_invMassB * r;
        n.y += this.m_invMassB * s;
        p += this.m_invIB * x;
        b.m_linearVelocity.SetV(g);
        b.m_angularVelocity = h;
        d.m_linearVelocity.SetV(n);
        d.m_angularVelocity = p
    };
    y.prototype.SolvePositionConstraints = function (d) {
        d = this.m_bodyA;
        var g = this.m_bodyB, h = d.m_sweep.c, n = d.m_sweep.a, p = g.m_sweep.c, r = g.m_sweep.a, s, t = 0, u = 0, x = 0, w = 0, v = s = 0, y = 0, u = !1, A = 0, B = b.FromAngle(n), x = b.FromAngle(r);
        s = B;
        var y = this.m_localAnchor1.x - this.m_localCenterA.x, C = this.m_localAnchor1.y - this.m_localCenterA.y, t = s.col1.x *
            y + s.col2.x * C, C = s.col1.y * y + s.col2.y * C, y = t;
        s = x;
        x = this.m_localAnchor2.x - this.m_localCenterB.x;
        w = this.m_localAnchor2.y - this.m_localCenterB.y;
        t = s.col1.x * x + s.col2.x * w;
        w = s.col1.y * x + s.col2.y * w;
        x = t;
        s = p.x + x - h.x - y;
        t = p.y + w - h.y - C;
        if (this.m_enableLimit) {
            this.m_axis = e.MulMV(B, this.m_localXAxis1);
            this.m_a1 = (s + y) * this.m_axis.y - (t + C) * this.m_axis.x;
            this.m_a2 = x * this.m_axis.y - w * this.m_axis.x;
            var E = this.m_axis.x * s + this.m_axis.y * t;
            e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? (A = e.Clamp(E, -a.b2_maxLinearCorrection,
                a.b2_maxLinearCorrection), v = e.Abs(E), u = !0) : E <= this.m_lowerTranslation ? (A = e.Clamp(E - this.m_lowerTranslation + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), v = this.m_lowerTranslation - E, u = !0) : E >= this.m_upperTranslation && (A = e.Clamp(E - this.m_upperTranslation + a.b2_linearSlop, 0, a.b2_maxLinearCorrection), v = E - this.m_upperTranslation, u = !0)
        }
        this.m_perp = e.MulMV(B, this.m_localYAxis1);
        this.m_s1 = (s + y) * this.m_perp.y - (t + C) * this.m_perp.x;
        this.m_s2 = x * this.m_perp.y - w * this.m_perp.x;
        B = new f;
        C = this.m_perp.x * s + this.m_perp.y *
            t;
        v = e.Max(v, e.Abs(C));
        y = 0;
        u ? (u = this.m_invMassA, x = this.m_invMassB, w = this.m_invIA, s = this.m_invIB, this.m_K.col1.x = u + x + w * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2, this.m_K.col1.y = w * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = u + x + w * this.m_a1 * this.m_a1 + s * this.m_a2 * this.m_a2, this.m_K.Solve(B, -C, -A)) : (u = this.m_invMassA, x = this.m_invMassB, w = this.m_invIA, s = this.m_invIB, A = u + x + w * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2, B.x = 0 != A ? -C / A : 0, B.y = 0);
        A = B.x * this.m_perp.x + B.y *
            this.m_axis.x;
        u = B.x * this.m_perp.y + B.y * this.m_axis.y;
        C = B.x * this.m_s1 + B.y * this.m_a1;
        B = B.x * this.m_s2 + B.y * this.m_a2;
        h.x -= this.m_invMassA * A;
        h.y -= this.m_invMassA * u;
        n -= this.m_invIA * C;
        p.x += this.m_invMassB * A;
        p.y += this.m_invMassB * u;
        r += this.m_invIB * B;
        d.m_sweep.a = n;
        g.m_sweep.a = r;
        d.SynchronizeTransform();
        g.SynchronizeTransform();
        return v <= a.b2_linearSlop && y <= a.b2_angularSlop
    };
    Box2D.inherit(A, Box2D.Dynamics.Joints.b2JointDef);
    A.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    A.b2LineJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,
            arguments);
        this.localAnchorA = new f;
        this.localAnchorB = new f;
        this.localAxisA = new f
    };
    A.prototype.b2LineJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_lineJoint;
        this.localAxisA.Set(1, 0);
        this.enableLimit = !1;
        this.upperTranslation = this.lowerTranslation = 0;
        this.enableMotor = !1;
        this.motorSpeed = this.maxMotorForce = 0
    };
    A.prototype.Initialize = function (a, b, d, e) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA = this.bodyA.GetLocalPoint(d);
        this.localAnchorB = this.bodyB.GetLocalPoint(d);
        this.localAxisA =
            this.bodyA.GetLocalVector(e)
    };
    Box2D.inherit(D, Box2D.Dynamics.Joints.b2Joint);
    D.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    D.b2MouseJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b;
        this.K1 = new b;
        this.K2 = new b;
        this.m_localAnchor = new f;
        this.m_target = new f;
        this.m_impulse = new f;
        this.m_mass = new b;
        this.m_C = new f
    };
    D.prototype.GetAnchorA = function () {
        return this.m_target
    };
    D.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
    };
    D.prototype.GetReactionForce = function (a) {
        void 0 === a && (a = 0);
        return new f(a * this.m_impulse.x, a * this.m_impulse.y)
    };
    D.prototype.GetReactionTorque = function (a) {
        return 0
    };
    D.prototype.GetTarget = function () {
        return this.m_target
    };
    D.prototype.SetTarget = function (a) {
        !1 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0);
        this.m_target = a
    };
    D.prototype.GetMaxForce = function () {
        return this.m_maxForce
    };
    D.prototype.SetMaxForce = function (a) {
        void 0 === a && (a = 0);
        this.m_maxForce = a
    };
    D.prototype.GetFrequency = function () {
        return this.m_frequencyHz
    };
    D.prototype.SetFrequency = function (a) {
        void 0 === a && (a = 0);
        this.m_frequencyHz = a
    };
    D.prototype.GetDampingRatio = function () {
        return this.m_dampingRatio
    };
    D.prototype.SetDampingRatio = function (a) {
        void 0 === a && (a = 0);
        this.m_dampingRatio = a
    };
    D.prototype.b2MouseJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_target.SetV(a.target);
        var b = this.m_target.x - this.m_bodyB.m_xf.position.x, d = this.m_target.y - this.m_bodyB.m_xf.position.y, e = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = b * e.col1.x + d * e.col1.y;
        this.m_localAnchor.y =
            b * e.col2.x + d * e.col2.y;
        this.m_maxForce = a.maxForce;
        this.m_impulse.SetZero();
        this.m_frequencyHz = a.frequencyHz;
        this.m_dampingRatio = a.dampingRatio;
        this.m_gamma = this.m_beta = 0
    };
    D.prototype.InitVelocityConstraints = function (a) {
        var b = this.m_bodyB, d = b.GetMass(), e = 2 * Math.PI * this.m_frequencyHz, f = d * e * e;
        this.m_gamma = a.dt * (2 * d * this.m_dampingRatio * e + a.dt * f);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
        this.m_beta = a.dt * f * this.m_gamma;
        var f = b.m_xf.R, d = this.m_localAnchor.x - b.m_sweep.localCenter.x, e = this.m_localAnchor.y -
            b.m_sweep.localCenter.y, g = f.col1.x * d + f.col2.x * e, e = f.col1.y * d + f.col2.y * e, d = g, f = b.m_invMass, g = b.m_invI;
        this.K1.col1.x = f;
        this.K1.col2.x = 0;
        this.K1.col1.y = 0;
        this.K1.col2.y = f;
        this.K2.col1.x = g * e * e;
        this.K2.col2.x = -g * d * e;
        this.K2.col1.y = -g * d * e;
        this.K2.col2.y = g * d * d;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.col1.x += this.m_gamma;
        this.K.col2.y += this.m_gamma;
        this.K.GetInverse(this.m_mass);
        this.m_C.x = b.m_sweep.c.x + d - this.m_target.x;
        this.m_C.y = b.m_sweep.c.y + e - this.m_target.y;
        b.m_angularVelocity *= 0.98;
        this.m_impulse.x *=
            a.dtRatio;
        this.m_impulse.y *= a.dtRatio;
        b.m_linearVelocity.x += f * this.m_impulse.x;
        b.m_linearVelocity.y += f * this.m_impulse.y;
        b.m_angularVelocity += g * (d * this.m_impulse.y - e * this.m_impulse.x)
    };
    D.prototype.SolveVelocityConstraints = function (a) {
        var b = this.m_bodyB, d, e = 0, f = 0;
        d = b.m_xf.R;
        var g = this.m_localAnchor.x - b.m_sweep.localCenter.x, h = this.m_localAnchor.y - b.m_sweep.localCenter.y, e = d.col1.x * g + d.col2.x * h, h = d.col1.y * g + d.col2.y * h, g = e, e = b.m_linearVelocity.x + -b.m_angularVelocity * h, n = b.m_linearVelocity.y + b.m_angularVelocity *
            g;
        d = this.m_mass;
        e = e + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
        f = n + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        n = -(d.col1.x * e + d.col2.x * f);
        f = -(d.col1.y * e + d.col2.y * f);
        d = this.m_impulse.x;
        e = this.m_impulse.y;
        this.m_impulse.x += n;
        this.m_impulse.y += f;
        a = a.dt * this.m_maxForce;
        this.m_impulse.LengthSquared() > a * a && this.m_impulse.Multiply(a / this.m_impulse.Length());
        n = this.m_impulse.x - d;
        f = this.m_impulse.y - e;
        b.m_linearVelocity.x += b.m_invMass * n;
        b.m_linearVelocity.y += b.m_invMass * f;
        b.m_angularVelocity +=
            b.m_invI * (g * f - h * n)
    };
    D.prototype.SolvePositionConstraints = function (a) {
        return !0
    };
    Box2D.inherit(G, Box2D.Dynamics.Joints.b2JointDef);
    G.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    G.b2MouseJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.target = new f
    };
    G.prototype.b2MouseJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_mouseJoint;
        this.maxForce = 0;
        this.frequencyHz = 5;
        this.dampingRatio = 0.7
    };
    Box2D.inherit(B, Box2D.Dynamics.Joints.b2Joint);
    B.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    B.b2PrismaticJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new f;
        this.m_localAnchor2 = new f;
        this.m_localXAxis1 = new f;
        this.m_localYAxis1 = new f;
        this.m_axis = new f;
        this.m_perp = new f;
        this.m_K = new d;
        this.m_impulse = new g
    };
    B.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    B.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    B.prototype.GetReactionForce = function (a) {
        void 0 === a && (a = 0);
        return new f(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
    };
    B.prototype.GetReactionTorque = function (a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.y
    };
    B.prototype.GetJointTranslation = function () {
        var a = this.m_bodyA, b = this.m_bodyB, d = a.GetWorldPoint(this.m_localAnchor1), e = b.GetWorldPoint(this.m_localAnchor2), b = e.x - d.x,
            d = e.y - d.y, a = a.GetWorldVector(this.m_localXAxis1);
        return a.x * b + a.y * d
    };
    B.prototype.GetJointSpeed = function () {
        var a = this.m_bodyA, b = this.m_bodyB, d;
        d = a.m_xf.R;
        var e = this.m_localAnchor1.x - a.m_sweep.localCenter.x, f = this.m_localAnchor1.y - a.m_sweep.localCenter.y, g = d.col1.x * e + d.col2.x * f, f = d.col1.y * e + d.col2.y * f, e = g;
        d = b.m_xf.R;
        var h = this.m_localAnchor2.x - b.m_sweep.localCenter.x, n = this.m_localAnchor2.y - b.m_sweep.localCenter.y, g = d.col1.x * h + d.col2.x * n, n = d.col1.y * h + d.col2.y * n, h = g;
        d = b.m_sweep.c.x + h - (a.m_sweep.c.x +
            e);
        var g = b.m_sweep.c.y + n - (a.m_sweep.c.y + f), p = a.GetWorldVector(this.m_localXAxis1), r = a.m_linearVelocity, s = b.m_linearVelocity, a = a.m_angularVelocity, b = b.m_angularVelocity;
        return d * -a * p.y + g * a * p.x + (p.x * (s.x + -b * n - r.x - -a * f) + p.y * (s.y + b * h - r.y - a * e))
    };
    B.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit
    };
    B.prototype.EnableLimit = function (a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableLimit = a
    };
    B.prototype.GetLowerLimit = function () {
        return this.m_lowerTranslation
    };
    B.prototype.GetUpperLimit =
        function () {
            return this.m_upperTranslation
        };
    B.prototype.SetLimits = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_lowerTranslation = a;
        this.m_upperTranslation = b
    };
    B.prototype.IsMotorEnabled = function () {
        return this.m_enableMotor
    };
    B.prototype.EnableMotor = function (a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableMotor = a
    };
    B.prototype.SetMotorSpeed = function (a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_motorSpeed = a
    };
    B.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed
    };
    B.prototype.SetMaxMotorForce = function (a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_maxMotorForce = a
    };
    B.prototype.GetMotorForce = function () {
        return this.m_motorImpulse
    };
    B.prototype.b2PrismaticJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_localXAxis1.SetV(a.localAxisA);
        this.m_localYAxis1.x = -this.m_localXAxis1.y;
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_refAngle = a.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorImpulse = this.m_motorMass = 0;
        this.m_lowerTranslation = a.lowerTranslation;
        this.m_upperTranslation = a.upperTranslation;
        this.m_maxMotorForce = a.maxMotorForce;
        this.m_motorSpeed = a.motorSpeed;
        this.m_enableLimit = a.enableLimit;
        this.m_enableMotor = a.enableMotor;
        this.m_limitState = u.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero()
    };
    B.prototype.InitVelocityConstraints = function (b) {
        var d = this.m_bodyA,
            f = this.m_bodyB, g, h = 0;
        this.m_localCenterA.SetV(d.GetLocalCenter());
        this.m_localCenterB.SetV(f.GetLocalCenter());
        var n = d.GetTransform();
        f.GetTransform();
        g = d.m_xf.R;
        var p = this.m_localAnchor1.x - this.m_localCenterA.x, r = this.m_localAnchor1.y - this.m_localCenterA.y, h = g.col1.x * p + g.col2.x * r, r = g.col1.y * p + g.col2.y * r, p = h;
        g = f.m_xf.R;
        var s = this.m_localAnchor2.x - this.m_localCenterB.x, t = this.m_localAnchor2.y - this.m_localCenterB.y, h = g.col1.x * s + g.col2.x * t, t = g.col1.y * s + g.col2.y * t, s = h;
        g = f.m_sweep.c.x + s - d.m_sweep.c.x -
            p;
        h = f.m_sweep.c.y + t - d.m_sweep.c.y - r;
        this.m_invMassA = d.m_invMass;
        this.m_invMassB = f.m_invMass;
        this.m_invIA = d.m_invI;
        this.m_invIB = f.m_invI;
        this.m_axis.SetV(e.MulMV(n.R, this.m_localXAxis1));
        this.m_a1 = (g + p) * this.m_axis.y - (h + r) * this.m_axis.x;
        this.m_a2 = s * this.m_axis.y - t * this.m_axis.x;
        this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
        this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass);
        this.m_perp.SetV(e.MulMV(n.R, this.m_localYAxis1));
        this.m_s1 = (g + p) * this.m_perp.y - (h + r) * this.m_perp.x;
        this.m_s2 = s * this.m_perp.y - t * this.m_perp.x;
        n = this.m_invMassA;
        p = this.m_invMassB;
        r = this.m_invIA;
        s = this.m_invIB;
        this.m_K.col1.x = n + p + r * this.m_s1 * this.m_s1 + s * this.m_s2 * this.m_s2;
        this.m_K.col1.y = r * this.m_s1 + s * this.m_s2;
        this.m_K.col1.z = r * this.m_s1 * this.m_a1 + s * this.m_s2 * this.m_a2;
        this.m_K.col2.x = this.m_K.col1.y;
        this.m_K.col2.y = r + s;
        this.m_K.col2.z = r * this.m_a1 + s * this.m_a2;
        this.m_K.col3.x = this.m_K.col1.z;
        this.m_K.col3.y = this.m_K.col2.z;
        this.m_K.col3.z = n + p + r * this.m_a1 *
            this.m_a1 + s * this.m_a2 * this.m_a2;
        this.m_enableLimit ? (g = this.m_axis.x * g + this.m_axis.y * h, e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? this.m_limitState = u.e_equalLimits : g <= this.m_lowerTranslation ? this.m_limitState != u.e_atLowerLimit && (this.m_limitState = u.e_atLowerLimit, this.m_impulse.z = 0) : g >= this.m_upperTranslation ? this.m_limitState != u.e_atUpperLimit && (this.m_limitState = u.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = u.e_inactiveLimit, this.m_impulse.z = 0)) : this.m_limitState =
            u.e_inactiveLimit;
        !1 == this.m_enableMotor && (this.m_motorImpulse = 0);
        b.warmStarting ? (this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio, b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, g = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, h = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, n = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse +
            this.m_impulse.z) * this.m_a2, d.m_linearVelocity.x -= this.m_invMassA * b, d.m_linearVelocity.y -= this.m_invMassA * g, d.m_angularVelocity -= this.m_invIA * h, f.m_linearVelocity.x += this.m_invMassB * b, f.m_linearVelocity.y += this.m_invMassB * g, f.m_angularVelocity += this.m_invIB * n) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
    };
    B.prototype.SolveVelocityConstraints = function (a) {
        var b = this.m_bodyA, d = this.m_bodyB, h = b.m_linearVelocity, n = b.m_angularVelocity, p = d.m_linearVelocity, r = d.m_angularVelocity, s = 0, t = 0, x = 0, w = 0;
        this.m_enableMotor &&
        this.m_limitState != u.e_equalLimits && (w = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (p.x - h.x) + this.m_axis.y * (p.y - h.y) + this.m_a2 * r - this.m_a1 * n)), s = this.m_motorImpulse, a = a.dt * this.m_maxMotorForce, this.m_motorImpulse = e.Clamp(this.m_motorImpulse + w, -a, a), w = this.m_motorImpulse - s, s = w * this.m_axis.x, t = w * this.m_axis.y, x = w * this.m_a1, w *= this.m_a2, h.x -= this.m_invMassA * s, h.y -= this.m_invMassA * t, n -= this.m_invIA * x, p.x += this.m_invMassB * s, p.y += this.m_invMassB * t, r += this.m_invIB * w);
        x = this.m_perp.x * (p.x - h.x) + this.m_perp.y *
            (p.y - h.y) + this.m_s2 * r - this.m_s1 * n;
        t = r - n;
        this.m_enableLimit && this.m_limitState != u.e_inactiveLimit ? (a = this.m_axis.x * (p.x - h.x) + this.m_axis.y * (p.y - h.y) + this.m_a2 * r - this.m_a1 * n, s = this.m_impulse.Copy(), a = this.m_K.Solve33(new g, -x, -t, -a), this.m_impulse.Add(a), this.m_limitState == u.e_atLowerLimit ? this.m_impulse.z = e.Max(this.m_impulse.z, 0) : this.m_limitState == u.e_atUpperLimit && (this.m_impulse.z = e.Min(this.m_impulse.z, 0)), x = -x - (this.m_impulse.z - s.z) * this.m_K.col3.x, t = -t - (this.m_impulse.z - s.z) * this.m_K.col3.y,
            t = this.m_K.Solve22(new f, x, t), t.x += s.x, t.y += s.y, this.m_impulse.x = t.x, this.m_impulse.y = t.y, a.x = this.m_impulse.x - s.x, a.y = this.m_impulse.y - s.y, a.z = this.m_impulse.z - s.z, s = a.x * this.m_perp.x + a.z * this.m_axis.x, t = a.x * this.m_perp.y + a.z * this.m_axis.y, x = a.x * this.m_s1 + a.y + a.z * this.m_a1, w = a.x * this.m_s2 + a.y + a.z * this.m_a2) : (a = this.m_K.Solve22(new f, -x, -t), this.m_impulse.x += a.x, this.m_impulse.y += a.y, s = a.x * this.m_perp.x, t = a.x * this.m_perp.y, x = a.x * this.m_s1 + a.y, w = a.x * this.m_s2 + a.y);
        h.x -= this.m_invMassA * s;
        h.y -= this.m_invMassA *
            t;
        n -= this.m_invIA * x;
        p.x += this.m_invMassB * s;
        p.y += this.m_invMassB * t;
        r += this.m_invIB * w;
        b.m_linearVelocity.SetV(h);
        b.m_angularVelocity = n;
        d.m_linearVelocity.SetV(p);
        d.m_angularVelocity = r
    };
    B.prototype.SolvePositionConstraints = function (d) {
        d = this.m_bodyA;
        var h = this.m_bodyB, n = d.m_sweep.c, p = d.m_sweep.a, r = h.m_sweep.c, s = h.m_sweep.a, t, u = 0, x = 0, w = 0, v = u = t = 0, y = 0, x = !1, A = 0, B = b.FromAngle(p), C = b.FromAngle(s);
        t = B;
        var y = this.m_localAnchor1.x - this.m_localCenterA.x, E = this.m_localAnchor1.y - this.m_localCenterA.y, u = t.col1.x *
            y + t.col2.x * E, E = t.col1.y * y + t.col2.y * E, y = u;
        t = C;
        C = this.m_localAnchor2.x - this.m_localCenterB.x;
        w = this.m_localAnchor2.y - this.m_localCenterB.y;
        u = t.col1.x * C + t.col2.x * w;
        w = t.col1.y * C + t.col2.y * w;
        C = u;
        t = r.x + C - n.x - y;
        u = r.y + w - n.y - E;
        if (this.m_enableLimit) {
            this.m_axis = e.MulMV(B, this.m_localXAxis1);
            this.m_a1 = (t + y) * this.m_axis.y - (u + E) * this.m_axis.x;
            this.m_a2 = C * this.m_axis.y - w * this.m_axis.x;
            var D = this.m_axis.x * t + this.m_axis.y * u;
            e.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? (A = e.Clamp(D, -a.b2_maxLinearCorrection,
                a.b2_maxLinearCorrection), v = e.Abs(D), x = !0) : D <= this.m_lowerTranslation ? (A = e.Clamp(D - this.m_lowerTranslation + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), v = this.m_lowerTranslation - D, x = !0) : D >= this.m_upperTranslation && (A = e.Clamp(D - this.m_upperTranslation + a.b2_linearSlop, 0, a.b2_maxLinearCorrection), v = D - this.m_upperTranslation, x = !0)
        }
        this.m_perp = e.MulMV(B, this.m_localYAxis1);
        this.m_s1 = (t + y) * this.m_perp.y - (u + E) * this.m_perp.x;
        this.m_s2 = C * this.m_perp.y - w * this.m_perp.x;
        B = new g;
        E = this.m_perp.x * t + this.m_perp.y *
            u;
        C = s - p - this.m_refAngle;
        v = e.Max(v, e.Abs(E));
        y = e.Abs(C);
        x ? (x = this.m_invMassA, w = this.m_invMassB, t = this.m_invIA, u = this.m_invIB, this.m_K.col1.x = x + w + t * this.m_s1 * this.m_s1 + u * this.m_s2 * this.m_s2, this.m_K.col1.y = t * this.m_s1 + u * this.m_s2, this.m_K.col1.z = t * this.m_s1 * this.m_a1 + u * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = t + u, this.m_K.col2.z = t * this.m_a1 + u * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = x + w + t * this.m_a1 * this.m_a1 + u * this.m_a2 * this.m_a2,
            this.m_K.Solve33(B, -E, -C, -A)) : (x = this.m_invMassA, w = this.m_invMassB, t = this.m_invIA, u = this.m_invIB, A = t * this.m_s1 + u * this.m_s2, D = t + u, this.m_K.col1.Set(x + w + t * this.m_s1 * this.m_s1 + u * this.m_s2 * this.m_s2, A, 0), this.m_K.col2.Set(A, D, 0), A = this.m_K.Solve22(new f, -E, -C), B.x = A.x, B.y = A.y, B.z = 0);
        A = B.x * this.m_perp.x + B.z * this.m_axis.x;
        x = B.x * this.m_perp.y + B.z * this.m_axis.y;
        E = B.x * this.m_s1 + B.y + B.z * this.m_a1;
        B = B.x * this.m_s2 + B.y + B.z * this.m_a2;
        n.x -= this.m_invMassA * A;
        n.y -= this.m_invMassA * x;
        p -= this.m_invIA * E;
        r.x += this.m_invMassB *
            A;
        r.y += this.m_invMassB * x;
        s += this.m_invIB * B;
        d.m_sweep.a = p;
        h.m_sweep.a = s;
        d.SynchronizeTransform();
        h.SynchronizeTransform();
        return v <= a.b2_linearSlop && y <= a.b2_angularSlop
    };
    Box2D.inherit(C, Box2D.Dynamics.Joints.b2JointDef);
    C.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    C.b2PrismaticJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new f;
        this.localAnchorB = new f;
        this.localAxisA = new f
    };
    C.prototype.b2PrismaticJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_prismaticJoint;
        this.localAxisA.Set(1, 0);
        this.referenceAngle = 0;
        this.enableLimit = !1;
        this.upperTranslation = this.lowerTranslation = 0;
        this.enableMotor = !1;
        this.motorSpeed = this.maxMotorForce = 0
    };
    C.prototype.Initialize = function (a, b, d, e) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA = this.bodyA.GetLocalPoint(d);
        this.localAnchorB = this.bodyB.GetLocalPoint(d);
        this.localAxisA = this.bodyA.GetLocalVector(e);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    };
    Box2D.inherit(E, Box2D.Dynamics.Joints.b2Joint);
    E.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    E.b2PulleyJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new f;
        this.m_groundAnchor2 = new f;
        this.m_localAnchor1 = new f;
        this.m_localAnchor2 = new f;
        this.m_u1 = new f;
        this.m_u2 = new f
    };
    E.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    E.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    E.prototype.GetReactionForce = function (a) {
        void 0 ===
        a && (a = 0);
        return new f(a * this.m_impulse * this.m_u2.x, a * this.m_impulse * this.m_u2.y)
    };
    E.prototype.GetReactionTorque = function (a) {
        return 0
    };
    E.prototype.GetGroundAnchorA = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor1);
        return a
    };
    E.prototype.GetGroundAnchorB = function () {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor2);
        return a
    };
    E.prototype.GetLength1 = function () {
        var a = this.m_bodyA.GetWorldPoint(this.m_localAnchor1), b = a.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x),
            a = a.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y);
        return Math.sqrt(b * b + a * a)
    };
    E.prototype.GetLength2 = function () {
        var a = this.m_bodyB.GetWorldPoint(this.m_localAnchor2), b = a.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor2.x), a = a.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor2.y);
        return Math.sqrt(b * b + a * a)
    };
    E.prototype.GetRatio = function () {
        return this.m_ratio
    };
    E.prototype.b2PulleyJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_ground = this.m_bodyA.m_world.m_groundBody;
        this.m_groundAnchor1.x =
            a.groundAnchorA.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor1.y = a.groundAnchorA.y - this.m_ground.m_xf.position.y;
        this.m_groundAnchor2.x = a.groundAnchorB.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor2.y = a.groundAnchorB.y - this.m_ground.m_xf.position.y;
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_ratio = a.ratio;
        this.m_constant = a.lengthA + this.m_ratio * a.lengthB;
        this.m_maxLength1 = e.Min(a.maxLengthA, this.m_constant - this.m_ratio * E.b2_minPulleyLength);
        this.m_maxLength2 = e.Min(a.maxLengthB, (this.m_constant - E.b2_minPulleyLength) / this.m_ratio);
        this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0
    };
    E.prototype.InitVelocityConstraints = function (b) {
        var d = this.m_bodyA, e = this.m_bodyB, f;
        f = d.m_xf.R;
        var g = this.m_localAnchor1.x - d.m_sweep.localCenter.x, h = this.m_localAnchor1.y - d.m_sweep.localCenter.y, n = f.col1.x * g + f.col2.x * h, h = f.col1.y * g + f.col2.y * h, g = n;
        f = e.m_xf.R;
        var p = this.m_localAnchor2.x - e.m_sweep.localCenter.x, r = this.m_localAnchor2.y - e.m_sweep.localCenter.y,
            n = f.col1.x * p + f.col2.x * r, r = f.col1.y * p + f.col2.y * r, p = n;
        f = e.m_sweep.c.x + p;
        var n = e.m_sweep.c.y + r, s = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, t = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(d.m_sweep.c.x + g - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x), d.m_sweep.c.y + h - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y));
        this.m_u2.Set(f - s, n - t);
        f = this.m_u1.Length();
        n = this.m_u2.Length();
        f > a.b2_linearSlop ? this.m_u1.Multiply(1 / f) : this.m_u1.SetZero();
        n > a.b2_linearSlop ?
            this.m_u2.Multiply(1 / n) : this.m_u2.SetZero();
        0 < this.m_constant - f - this.m_ratio * n ? (this.m_state = u.e_inactiveLimit, this.m_impulse = 0) : this.m_state = u.e_atUpperLimit;
        f < this.m_maxLength1 ? (this.m_limitState1 = u.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = u.e_atUpperLimit;
        n < this.m_maxLength2 ? (this.m_limitState2 = u.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = u.e_atUpperLimit;
        f = g * this.m_u1.y - h * this.m_u1.x;
        n = p * this.m_u2.y - r * this.m_u2.x;
        this.m_limitMass1 = d.m_invMass + d.m_invI * f * f;
        this.m_limitMass2 =
            e.m_invMass + e.m_invI * n * n;
        this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
        this.m_limitMass1 = 1 / this.m_limitMass1;
        this.m_limitMass2 = 1 / this.m_limitMass2;
        this.m_pulleyMass = 1 / this.m_pulleyMass;
        b.warmStarting ? (this.m_impulse *= b.dtRatio, this.m_limitImpulse1 *= b.dtRatio, this.m_limitImpulse2 *= b.dtRatio, b = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, f = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y, n = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, s = (-this.m_ratio *
            this.m_impulse - this.m_limitImpulse2) * this.m_u2.y, d.m_linearVelocity.x += d.m_invMass * b, d.m_linearVelocity.y += d.m_invMass * f, d.m_angularVelocity += d.m_invI * (g * f - h * b), e.m_linearVelocity.x += e.m_invMass * n, e.m_linearVelocity.y += e.m_invMass * s, e.m_angularVelocity += e.m_invI * (p * s - r * n)) : this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0
    };
    E.prototype.SolveVelocityConstraints = function (a) {
        a = this.m_bodyA;
        var b = this.m_bodyB, d;
        d = a.m_xf.R;
        var f = this.m_localAnchor1.x - a.m_sweep.localCenter.x, g = this.m_localAnchor1.y -
            a.m_sweep.localCenter.y, h = d.col1.x * f + d.col2.x * g, g = d.col1.y * f + d.col2.y * g, f = h;
        d = b.m_xf.R;
        var n = this.m_localAnchor2.x - b.m_sweep.localCenter.x, p = this.m_localAnchor2.y - b.m_sweep.localCenter.y, h = d.col1.x * n + d.col2.x * p, p = d.col1.y * n + d.col2.y * p, n = h, r = h = d = 0, s = 0;
        d = s = d = s = r = h = d = 0;
        this.m_state == u.e_atUpperLimit && (d = a.m_linearVelocity.x + -a.m_angularVelocity * g, h = a.m_linearVelocity.y + a.m_angularVelocity * f, r = b.m_linearVelocity.x + -b.m_angularVelocity * p, s = b.m_linearVelocity.y + b.m_angularVelocity * n, d = -(this.m_u1.x * d + this.m_u1.y *
            h) - this.m_ratio * (this.m_u2.x * r + this.m_u2.y * s), s = this.m_pulleyMass * -d, d = this.m_impulse, this.m_impulse = e.Max(0, this.m_impulse + s), s = this.m_impulse - d, d = -s * this.m_u1.x, h = -s * this.m_u1.y, r = -this.m_ratio * s * this.m_u2.x, s = -this.m_ratio * s * this.m_u2.y, a.m_linearVelocity.x += a.m_invMass * d, a.m_linearVelocity.y += a.m_invMass * h, a.m_angularVelocity += a.m_invI * (f * h - g * d), b.m_linearVelocity.x += b.m_invMass * r, b.m_linearVelocity.y += b.m_invMass * s, b.m_angularVelocity += b.m_invI * (n * s - p * r));
        this.m_limitState1 == u.e_atUpperLimit &&
        (d = a.m_linearVelocity.x + -a.m_angularVelocity * g, h = a.m_linearVelocity.y + a.m_angularVelocity * f, d = -(this.m_u1.x * d + this.m_u1.y * h), s = -this.m_limitMass1 * d, d = this.m_limitImpulse1, this.m_limitImpulse1 = e.Max(0, this.m_limitImpulse1 + s), s = this.m_limitImpulse1 - d, d = -s * this.m_u1.x, h = -s * this.m_u1.y, a.m_linearVelocity.x += a.m_invMass * d, a.m_linearVelocity.y += a.m_invMass * h, a.m_angularVelocity += a.m_invI * (f * h - g * d));
        this.m_limitState2 == u.e_atUpperLimit && (r = b.m_linearVelocity.x + -b.m_angularVelocity * p, s = b.m_linearVelocity.y +
            b.m_angularVelocity * n, d = -(this.m_u2.x * r + this.m_u2.y * s), s = -this.m_limitMass2 * d, d = this.m_limitImpulse2, this.m_limitImpulse2 = e.Max(0, this.m_limitImpulse2 + s), s = this.m_limitImpulse2 - d, r = -s * this.m_u2.x, s = -s * this.m_u2.y, b.m_linearVelocity.x += b.m_invMass * r, b.m_linearVelocity.y += b.m_invMass * s, b.m_angularVelocity += b.m_invI * (n * s - p * r))
    };
    E.prototype.SolvePositionConstraints = function (b) {
        b = this.m_bodyA;
        var d = this.m_bodyB, f, g = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x, h = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
            n = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x, p = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y, r = 0, s = 0, t = 0, x = 0, w = f = 0, v = 0, y = 0, A = w = y = f = w = f = 0;
        this.m_state == u.e_atUpperLimit && (f = b.m_xf.R, r = this.m_localAnchor1.x - b.m_sweep.localCenter.x, s = this.m_localAnchor1.y - b.m_sweep.localCenter.y, w = f.col1.x * r + f.col2.x * s, s = f.col1.y * r + f.col2.y * s, r = w, f = d.m_xf.R, t = this.m_localAnchor2.x - d.m_sweep.localCenter.x, x = this.m_localAnchor2.y - d.m_sweep.localCenter.y, w = f.col1.x * t + f.col2.x * x, x = f.col1.y * t + f.col2.y * x,
            t = w, f = b.m_sweep.c.x + r, w = b.m_sweep.c.y + s, v = d.m_sweep.c.x + t, y = d.m_sweep.c.y + x, this.m_u1.Set(f - g, w - h), this.m_u2.Set(v - n, y - p), f = this.m_u1.Length(), w = this.m_u2.Length(), f > a.b2_linearSlop ? this.m_u1.Multiply(1 / f) : this.m_u1.SetZero(), w > a.b2_linearSlop ? this.m_u2.Multiply(1 / w) : this.m_u2.SetZero(), f = this.m_constant - f - this.m_ratio * w, A = e.Max(A, -f), f = e.Clamp(f + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), y = -this.m_pulleyMass * f, f = -y * this.m_u1.x, w = -y * this.m_u1.y, v = -this.m_ratio * y * this.m_u2.x, y = -this.m_ratio * y * this.m_u2.y,
            b.m_sweep.c.x += b.m_invMass * f, b.m_sweep.c.y += b.m_invMass * w, b.m_sweep.a += b.m_invI * (r * w - s * f), d.m_sweep.c.x += d.m_invMass * v, d.m_sweep.c.y += d.m_invMass * y, d.m_sweep.a += d.m_invI * (t * y - x * v), b.SynchronizeTransform(), d.SynchronizeTransform());
        this.m_limitState1 == u.e_atUpperLimit && (f = b.m_xf.R, r = this.m_localAnchor1.x - b.m_sweep.localCenter.x, s = this.m_localAnchor1.y - b.m_sweep.localCenter.y, w = f.col1.x * r + f.col2.x * s, s = f.col1.y * r + f.col2.y * s, r = w, f = b.m_sweep.c.x + r, w = b.m_sweep.c.y + s, this.m_u1.Set(f - g, w - h), f = this.m_u1.Length(),
            f > a.b2_linearSlop ? (this.m_u1.x *= 1 / f, this.m_u1.y *= 1 / f) : this.m_u1.SetZero(), f = this.m_maxLength1 - f, A = e.Max(A, -f), f = e.Clamp(f + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), y = -this.m_limitMass1 * f, f = -y * this.m_u1.x, w = -y * this.m_u1.y, b.m_sweep.c.x += b.m_invMass * f, b.m_sweep.c.y += b.m_invMass * w, b.m_sweep.a += b.m_invI * (r * w - s * f), b.SynchronizeTransform());
        this.m_limitState2 == u.e_atUpperLimit && (f = d.m_xf.R, t = this.m_localAnchor2.x - d.m_sweep.localCenter.x, x = this.m_localAnchor2.y - d.m_sweep.localCenter.y, w = f.col1.x * t + f.col2.x *
            x, x = f.col1.y * t + f.col2.y * x, t = w, v = d.m_sweep.c.x + t, y = d.m_sweep.c.y + x, this.m_u2.Set(v - n, y - p), w = this.m_u2.Length(), w > a.b2_linearSlop ? (this.m_u2.x *= 1 / w, this.m_u2.y *= 1 / w) : this.m_u2.SetZero(), f = this.m_maxLength2 - w, A = e.Max(A, -f), f = e.Clamp(f + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), y = -this.m_limitMass2 * f, v = -y * this.m_u2.x, y = -y * this.m_u2.y, d.m_sweep.c.x += d.m_invMass * v, d.m_sweep.c.y += d.m_invMass * y, d.m_sweep.a += d.m_invI * (t * y - x * v), d.SynchronizeTransform());
        return A < a.b2_linearSlop
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength =
            2
    });
    Box2D.inherit(I, Box2D.Dynamics.Joints.b2JointDef);
    I.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    I.b2PulleyJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.groundAnchorA = new f;
        this.groundAnchorB = new f;
        this.localAnchorA = new f;
        this.localAnchorB = new f
    };
    I.prototype.b2PulleyJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_pulleyJoint;
        this.groundAnchorA.Set(-1, 1);
        this.groundAnchorB.Set(1, 1);
        this.localAnchorA.Set(-1, 0);
        this.localAnchorB.Set(1,
            0);
        this.maxLengthB = this.lengthB = this.maxLengthA = this.lengthA = 0;
        this.ratio = 1;
        this.collideConnected = !0
    };
    I.prototype.Initialize = function (a, b, d, e, f, g, h) {
        void 0 === h && (h = 0);
        this.bodyA = a;
        this.bodyB = b;
        this.groundAnchorA.SetV(d);
        this.groundAnchorB.SetV(e);
        this.localAnchorA = this.bodyA.GetLocalPoint(f);
        this.localAnchorB = this.bodyB.GetLocalPoint(g);
        a = f.x - d.x;
        d = f.y - d.y;
        this.lengthA = Math.sqrt(a * a + d * d);
        d = g.x - e.x;
        e = g.y - e.y;
        this.lengthB = Math.sqrt(d * d + e * e);
        this.ratio = h;
        h = this.lengthA + this.ratio * this.lengthB;
        this.maxLengthA =
            h - this.ratio * E.b2_minPulleyLength;
        this.maxLengthB = (h - E.b2_minPulleyLength) / this.ratio
    };
    Box2D.inherit(L, Box2D.Dynamics.Joints.b2Joint);
    L.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    L.b2RevoluteJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new b;
        this.K1 = new b;
        this.K2 = new b;
        this.K3 = new b;
        this.impulse3 = new g;
        this.impulse2 = new f;
        this.reduced = new f;
        this.m_localAnchor1 = new f;
        this.m_localAnchor2 = new f;
        this.m_impulse = new g;
        this.m_mass = new d
    };
    L.prototype.GetAnchorA =
        function () {
            return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
        };
    L.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    L.prototype.GetReactionForce = function (a) {
        void 0 === a && (a = 0);
        return new f(a * this.m_impulse.x, a * this.m_impulse.y)
    };
    L.prototype.GetReactionTorque = function (a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.z
    };
    L.prototype.GetJointAngle = function () {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
    };
    L.prototype.GetJointSpeed = function () {
        return this.m_bodyB.m_angularVelocity -
            this.m_bodyA.m_angularVelocity
    };
    L.prototype.IsLimitEnabled = function () {
        return this.m_enableLimit
    };
    L.prototype.EnableLimit = function (a) {
        this.m_enableLimit = a
    };
    L.prototype.GetLowerLimit = function () {
        return this.m_lowerAngle
    };
    L.prototype.GetUpperLimit = function () {
        return this.m_upperAngle
    };
    L.prototype.SetLimits = function (a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_lowerAngle = a;
        this.m_upperAngle = b
    };
    L.prototype.IsMotorEnabled = function () {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        return this.m_enableMotor
    };
    L.prototype.EnableMotor = function (a) {
        this.m_enableMotor = a
    };
    L.prototype.SetMotorSpeed = function (a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_motorSpeed = a
    };
    L.prototype.GetMotorSpeed = function () {
        return this.m_motorSpeed
    };
    L.prototype.SetMaxMotorTorque = function (a) {
        void 0 === a && (a = 0);
        this.m_maxMotorTorque = a
    };
    L.prototype.GetMotorTorque = function () {
        return this.m_maxMotorTorque
    };
    L.prototype.b2RevoluteJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_referenceAngle = a.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorImpulse = 0;
        this.m_lowerAngle = a.lowerAngle;
        this.m_upperAngle = a.upperAngle;
        this.m_maxMotorTorque = a.maxMotorTorque;
        this.m_motorSpeed = a.motorSpeed;
        this.m_enableLimit = a.enableLimit;
        this.m_enableMotor = a.enableMotor;
        this.m_limitState = u.e_inactiveLimit
    };
    L.prototype.InitVelocityConstraints = function (b) {
        var d = this.m_bodyA, f = this.m_bodyB, g, h = 0;
        g = d.m_xf.R;
        var n = this.m_localAnchor1.x - d.m_sweep.localCenter.x,
            p = this.m_localAnchor1.y - d.m_sweep.localCenter.y, h = g.col1.x * n + g.col2.x * p, p = g.col1.y * n + g.col2.y * p, n = h;
        g = f.m_xf.R;
        var r = this.m_localAnchor2.x - f.m_sweep.localCenter.x, s = this.m_localAnchor2.y - f.m_sweep.localCenter.y, h = g.col1.x * r + g.col2.x * s, s = g.col1.y * r + g.col2.y * s, r = h;
        g = d.m_invMass;
        var h = f.m_invMass, t = d.m_invI, x = f.m_invI;
        this.m_mass.col1.x = g + h + p * p * t + s * s * x;
        this.m_mass.col2.x = -p * n * t - s * r * x;
        this.m_mass.col3.x = -p * t - s * x;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = g + h + n * n * t + r * r * x;
        this.m_mass.col3.y =
            n * t + r * x;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = t + x;
        this.m_motorMass = 1 / (t + x);
        !1 == this.m_enableMotor && (this.m_motorImpulse = 0);
        if (this.m_enableLimit) {
            var w = f.m_sweep.a - d.m_sweep.a - this.m_referenceAngle;
            e.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * a.b2_angularSlop ? this.m_limitState = u.e_equalLimits : w <= this.m_lowerAngle ? (this.m_limitState != u.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = u.e_atLowerLimit) : w >= this.m_upperAngle ? (this.m_limitState !=
            u.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = u.e_atUpperLimit) : (this.m_limitState = u.e_inactiveLimit, this.m_impulse.z = 0)
        } else this.m_limitState = u.e_inactiveLimit;
        b.warmStarting ? (this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio, b = this.m_impulse.x, w = this.m_impulse.y, d.m_linearVelocity.x -= g * b, d.m_linearVelocity.y -= g * w, d.m_angularVelocity -= t * (n * w - p * b + this.m_motorImpulse + this.m_impulse.z), f.m_linearVelocity.x += h * b, f.m_linearVelocity.y += h * w, f.m_angularVelocity +=
            x * (r * w - s * b + this.m_motorImpulse + this.m_impulse.z)) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
    };
    L.prototype.SolveVelocityConstraints = function (a) {
        var b = this.m_bodyA, d = this.m_bodyB, f = 0, g = f = 0, h = 0, n = 0, p = 0, r = b.m_linearVelocity, s = b.m_angularVelocity, t = d.m_linearVelocity, x = d.m_angularVelocity, w = b.m_invMass, v = d.m_invMass, y = b.m_invI, A = d.m_invI;
        this.m_enableMotor && this.m_limitState != u.e_equalLimits && (g = this.m_motorMass * -(x - s - this.m_motorSpeed), h = this.m_motorImpulse, n = a.dt * this.m_maxMotorTorque, this.m_motorImpulse =
            e.Clamp(this.m_motorImpulse + g, -n, n), g = this.m_motorImpulse - h, s -= y * g, x += A * g);
        if (this.m_enableLimit && this.m_limitState != u.e_inactiveLimit) {
            a = b.m_xf.R;
            g = this.m_localAnchor1.x - b.m_sweep.localCenter.x;
            h = this.m_localAnchor1.y - b.m_sweep.localCenter.y;
            f = a.col1.x * g + a.col2.x * h;
            h = a.col1.y * g + a.col2.y * h;
            g = f;
            a = d.m_xf.R;
            n = this.m_localAnchor2.x - d.m_sweep.localCenter.x;
            p = this.m_localAnchor2.y - d.m_sweep.localCenter.y;
            f = a.col1.x * n + a.col2.x * p;
            p = a.col1.y * n + a.col2.y * p;
            n = f;
            a = t.x + -x * p - r.x - -s * h;
            var B = t.y + x * n - r.y - s * g;
            this.m_mass.Solve33(this.impulse3,
                -a, -B, -(x - s));
            this.m_limitState == u.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == u.e_atLowerLimit ? (f = this.m_impulse.z + this.impulse3.z, 0 > f && (this.m_mass.Solve22(this.reduced, -a, -B), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)) : this.m_limitState == u.e_atUpperLimit && (f = this.m_impulse.z + this.impulse3.z, 0 < f && (this.m_mass.Solve22(this.reduced, -a, -B),
                this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0));
            r.x -= w * this.impulse3.x;
            r.y -= w * this.impulse3.y;
            s -= y * (g * this.impulse3.y - h * this.impulse3.x + this.impulse3.z);
            t.x += v * this.impulse3.x;
            t.y += v * this.impulse3.y;
            x += A * (n * this.impulse3.y - p * this.impulse3.x + this.impulse3.z)
        } else a = b.m_xf.R, g = this.m_localAnchor1.x - b.m_sweep.localCenter.x, h = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
            f = a.col1.x * g + a.col2.x * h, h = a.col1.y * g + a.col2.y * h, g = f, a = d.m_xf.R, n = this.m_localAnchor2.x - d.m_sweep.localCenter.x, p = this.m_localAnchor2.y - d.m_sweep.localCenter.y, f = a.col1.x * n + a.col2.x * p, p = a.col1.y * n + a.col2.y * p, n = f, this.m_mass.Solve22(this.impulse2, -(t.x + -x * p - r.x - -s * h), -(t.y + x * n - r.y - s * g)), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, r.x -= w * this.impulse2.x, r.y -= w * this.impulse2.y, s -= y * (g * this.impulse2.y - h * this.impulse2.x), t.x += v * this.impulse2.x, t.y += v * this.impulse2.y, x += A * (n * this.impulse2.y -
            p * this.impulse2.x);
        b.m_linearVelocity.SetV(r);
        b.m_angularVelocity = s;
        d.m_linearVelocity.SetV(t);
        d.m_angularVelocity = x
    };
    L.prototype.SolvePositionConstraints = function (b) {
        var d = 0, f;
        b = this.m_bodyA;
        var g = this.m_bodyB, h = 0, n = f = 0, p = 0, r = 0;
        if (this.m_enableLimit && this.m_limitState != u.e_inactiveLimit) {
            var d = g.m_sweep.a - b.m_sweep.a - this.m_referenceAngle, s = 0;
            this.m_limitState == u.e_equalLimits ? (d = e.Clamp(d - this.m_lowerAngle, -a.b2_maxAngularCorrection, a.b2_maxAngularCorrection), s = -this.m_motorMass * d, h = e.Abs(d)) : this.m_limitState ==
            u.e_atLowerLimit ? (d -= this.m_lowerAngle, h = -d, d = e.Clamp(d + a.b2_angularSlop, -a.b2_maxAngularCorrection, 0), s = -this.m_motorMass * d) : this.m_limitState == u.e_atUpperLimit && (h = d -= this.m_upperAngle, d = e.Clamp(d - a.b2_angularSlop, 0, a.b2_maxAngularCorrection), s = -this.m_motorMass * d);
            b.m_sweep.a -= b.m_invI * s;
            g.m_sweep.a += g.m_invI * s;
            b.SynchronizeTransform();
            g.SynchronizeTransform()
        }
        f = b.m_xf.R;
        s = this.m_localAnchor1.x - b.m_sweep.localCenter.x;
        d = this.m_localAnchor1.y - b.m_sweep.localCenter.y;
        n = f.col1.x * s + f.col2.x * d;
        d = f.col1.y *
            s + f.col2.y * d;
        s = n;
        f = g.m_xf.R;
        var t = this.m_localAnchor2.x - g.m_sweep.localCenter.x, x = this.m_localAnchor2.y - g.m_sweep.localCenter.y, n = f.col1.x * t + f.col2.x * x, x = f.col1.y * t + f.col2.y * x, t = n, p = g.m_sweep.c.x + t - b.m_sweep.c.x - s, r = g.m_sweep.c.y + x - b.m_sweep.c.y - d, w = p * p + r * r;
        f = Math.sqrt(w);
        var n = b.m_invMass, v = g.m_invMass, y = b.m_invI, A = g.m_invI, B = 10 * a.b2_linearSlop;
        w > B * B && (w = 1 / (n + v), p = w * -p, r = w * -r, b.m_sweep.c.x -= 0.5 * n * p, b.m_sweep.c.y -= 0.5 * n * r, g.m_sweep.c.x += 0.5 * v * p, g.m_sweep.c.y += 0.5 * v * r, p = g.m_sweep.c.x + t - b.m_sweep.c.x -
            s, r = g.m_sweep.c.y + x - b.m_sweep.c.y - d);
        this.K1.col1.x = n + v;
        this.K1.col2.x = 0;
        this.K1.col1.y = 0;
        this.K1.col2.y = n + v;
        this.K2.col1.x = y * d * d;
        this.K2.col2.x = -y * s * d;
        this.K2.col1.y = -y * s * d;
        this.K2.col2.y = y * s * s;
        this.K3.col1.x = A * x * x;
        this.K3.col2.x = -A * t * x;
        this.K3.col1.y = -A * t * x;
        this.K3.col2.y = A * t * t;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.AddM(this.K3);
        this.K.Solve(L.tImpulse, -p, -r);
        p = L.tImpulse.x;
        r = L.tImpulse.y;
        b.m_sweep.c.x -= b.m_invMass * p;
        b.m_sweep.c.y -= b.m_invMass * r;
        b.m_sweep.a -= b.m_invI * (s * r - d * p);
        g.m_sweep.c.x +=
            g.m_invMass * p;
        g.m_sweep.c.y += g.m_invMass * r;
        g.m_sweep.a += g.m_invI * (t * r - x * p);
        b.SynchronizeTransform();
        g.SynchronizeTransform();
        return f <= a.b2_linearSlop && h <= a.b2_angularSlop
    };
    Box2D.postDefs.push(function () {
        Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new f
    });
    Box2D.inherit(J, Box2D.Dynamics.Joints.b2JointDef);
    J.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    J.b2RevoluteJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new f;
        this.localAnchorB =
            new f
    };
    J.prototype.b2RevoluteJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_revoluteJoint;
        this.localAnchorA.Set(0, 0);
        this.localAnchorB.Set(0, 0);
        this.motorSpeed = this.maxMotorTorque = this.upperAngle = this.lowerAngle = this.referenceAngle = 0;
        this.enableMotor = this.enableLimit = !1
    };
    J.prototype.Initialize = function (a, b, d) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA = this.bodyA.GetLocalPoint(d);
        this.localAnchorB = this.bodyB.GetLocalPoint(d);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    };
    Box2D.inherit(Q, Box2D.Dynamics.Joints.b2Joint);
    Q.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    Q.b2WeldJoint = function () {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new f;
        this.m_localAnchorB = new f;
        this.m_impulse = new g;
        this.m_mass = new d
    };
    Q.prototype.GetAnchorA = function () {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
    };
    Q.prototype.GetAnchorB = function () {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
    };
    Q.prototype.GetReactionForce = function (a) {
        void 0 ===
        a && (a = 0);
        return new f(a * this.m_impulse.x, a * this.m_impulse.y)
    };
    Q.prototype.GetReactionTorque = function (a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.z
    };
    Q.prototype.b2WeldJoint = function (a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchorA.SetV(a.localAnchorA);
        this.m_localAnchorB.SetV(a.localAnchorB);
        this.m_referenceAngle = a.referenceAngle;
        this.m_impulse.SetZero();
        this.m_mass = new d
    };
    Q.prototype.InitVelocityConstraints = function (a) {
        var b, d = 0, e = this.m_bodyA, f = this.m_bodyB;
        b = e.m_xf.R;
        var g = this.m_localAnchorA.x -
            e.m_sweep.localCenter.x, h = this.m_localAnchorA.y - e.m_sweep.localCenter.y, d = b.col1.x * g + b.col2.x * h, h = b.col1.y * g + b.col2.y * h, g = d;
        b = f.m_xf.R;
        var n = this.m_localAnchorB.x - f.m_sweep.localCenter.x, p = this.m_localAnchorB.y - f.m_sweep.localCenter.y, d = b.col1.x * n + b.col2.x * p, p = b.col1.y * n + b.col2.y * p, n = d;
        b = e.m_invMass;
        var d = f.m_invMass, r = e.m_invI, s = f.m_invI;
        this.m_mass.col1.x = b + d + h * h * r + p * p * s;
        this.m_mass.col2.x = -h * g * r - p * n * s;
        this.m_mass.col3.x = -h * r - p * s;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = b + d + g * g *
            r + n * n * s;
        this.m_mass.col3.y = g * r + n * s;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = r + s;
        a.warmStarting ? (this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_impulse.z *= a.dtRatio, e.m_linearVelocity.x -= b * this.m_impulse.x, e.m_linearVelocity.y -= b * this.m_impulse.y, e.m_angularVelocity -= r * (g * this.m_impulse.y - h * this.m_impulse.x + this.m_impulse.z), f.m_linearVelocity.x += d * this.m_impulse.x, f.m_linearVelocity.y += d * this.m_impulse.y, f.m_angularVelocity += s *
            (n * this.m_impulse.y - p * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero()
    };
    Q.prototype.SolveVelocityConstraints = function (a) {
        var b, d = 0;
        a = this.m_bodyA;
        var e = this.m_bodyB, f = a.m_linearVelocity, h = a.m_angularVelocity, n = e.m_linearVelocity, p = e.m_angularVelocity, r = a.m_invMass, s = e.m_invMass, t = a.m_invI, u = e.m_invI;
        b = a.m_xf.R;
        var x = this.m_localAnchorA.x - a.m_sweep.localCenter.x, w = this.m_localAnchorA.y - a.m_sweep.localCenter.y, d = b.col1.x * x + b.col2.x * w, w = b.col1.y * x + b.col2.y * w, x = d;
        b = e.m_xf.R;
        var v = this.m_localAnchorB.x -
            e.m_sweep.localCenter.x, y = this.m_localAnchorB.y - e.m_sweep.localCenter.y, d = b.col1.x * v + b.col2.x * y, y = b.col1.y * v + b.col2.y * y, v = d;
        b = n.x - p * y - f.x + h * w;
        var d = n.y + p * v - f.y - h * x, A = p - h, B = new g;
        this.m_mass.Solve33(B, -b, -d, -A);
        this.m_impulse.Add(B);
        f.x -= r * B.x;
        f.y -= r * B.y;
        h -= t * (x * B.y - w * B.x + B.z);
        n.x += s * B.x;
        n.y += s * B.y;
        p += u * (v * B.y - y * B.x + B.z);
        a.m_angularVelocity = h;
        e.m_angularVelocity = p
    };
    Q.prototype.SolvePositionConstraints = function (b) {
        var d, f = 0;
        b = this.m_bodyA;
        var h = this.m_bodyB;
        d = b.m_xf.R;
        var n = this.m_localAnchorA.x - b.m_sweep.localCenter.x,
            p = this.m_localAnchorA.y - b.m_sweep.localCenter.y, f = d.col1.x * n + d.col2.x * p, p = d.col1.y * n + d.col2.y * p, n = f;
        d = h.m_xf.R;
        var r = this.m_localAnchorB.x - h.m_sweep.localCenter.x, s = this.m_localAnchorB.y - h.m_sweep.localCenter.y, f = d.col1.x * r + d.col2.x * s, s = d.col1.y * r + d.col2.y * s, r = f;
        d = b.m_invMass;
        var f = h.m_invMass, t = b.m_invI, u = h.m_invI, x = h.m_sweep.c.x + r - b.m_sweep.c.x - n, w = h.m_sweep.c.y + s - b.m_sweep.c.y - p, v = h.m_sweep.a - b.m_sweep.a - this.m_referenceAngle, y = 10 * a.b2_linearSlop, A = Math.sqrt(x * x + w * w), B = e.Abs(v);
        A > y && (t *= 1, u *= 1);
        this.m_mass.col1.x = d + f + p * p * t + s * s * u;
        this.m_mass.col2.x = -p * n * t - s * r * u;
        this.m_mass.col3.x = -p * t - s * u;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = d + f + n * n * t + r * r * u;
        this.m_mass.col3.y = n * t + r * u;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = t + u;
        y = new g;
        this.m_mass.Solve33(y, -x, -w, -v);
        b.m_sweep.c.x -= d * y.x;
        b.m_sweep.c.y -= d * y.y;
        b.m_sweep.a -= t * (n * y.y - p * y.x + y.z);
        h.m_sweep.c.x += f * y.x;
        h.m_sweep.c.y += f * y.y;
        h.m_sweep.a += u * (r * y.y - s * y.x + y.z);
        b.SynchronizeTransform();
        h.SynchronizeTransform();
        return A <= a.b2_linearSlop && B <= a.b2_angularSlop
    };
    Box2D.inherit(M, Box2D.Dynamics.Joints.b2JointDef);
    M.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    M.b2WeldJointDef = function () {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new f;
        this.localAnchorB = new f
    };
    M.prototype.b2WeldJointDef = function () {
        this.__super.b2JointDef.call(this);
        this.type = u.e_weldJoint;
        this.referenceAngle = 0
    };
    M.prototype.Initialize = function (a, b, d) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(d));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(d));
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    }
})();
(function () {
    var a = Box2D.Dynamics.b2DebugDraw;
    a.b2DebugDraw = function () {
        this.m_xformScale = this.m_fillAlpha = this.m_alpha = this.m_lineThickness = this.m_drawScale = 1;
        var a = this;
        this.m_sprite = {
            graphics: {
                clear: function () {
                    a.m_ctx.clearRect(0, 0, a.m_ctx.canvas.width, a.m_ctx.canvas.height)
                }
            }
        }
    };
    a.prototype._color = function (a, d) {
        return "rgba(" + ((a & 16711680) >> 16) + "," + ((a & 65280) >> 8) + "," + (a & 255) + "," + d + ")"
    };
    a.prototype.b2DebugDraw = function () {
        this.m_drawFlags = 0
    };
    a.prototype.SetFlags = function (a) {
        void 0 === a && (a = 0);
        this.m_drawFlags =
            a
    };
    a.prototype.GetFlags = function () {
        return this.m_drawFlags
    };
    a.prototype.AppendFlags = function (a) {
        void 0 === a && (a = 0);
        this.m_drawFlags |= a
    };
    a.prototype.ClearFlags = function (a) {
        void 0 === a && (a = 0);
        this.m_drawFlags &= ~a
    };
    a.prototype.SetSprite = function (a) {
        this.m_ctx = a
    };
    a.prototype.GetSprite = function () {
        return this.m_ctx
    };
    a.prototype.SetDrawScale = function (a) {
        void 0 === a && (a = 0);
        this.m_drawScale = a
    };
    a.prototype.GetDrawScale = function () {
        return this.m_drawScale
    };
    a.prototype.SetLineThickness = function (a) {
        void 0 === a && (a =
            0);
        this.m_lineThickness = a;
        this.m_ctx.strokeWidth = a
    };
    a.prototype.GetLineThickness = function () {
        return this.m_lineThickness
    };
    a.prototype.SetAlpha = function (a) {
        void 0 === a && (a = 0);
        this.m_alpha = a
    };
    a.prototype.GetAlpha = function () {
        return this.m_alpha
    };
    a.prototype.SetFillAlpha = function (a) {
        void 0 === a && (a = 0);
        this.m_fillAlpha = a
    };
    a.prototype.GetFillAlpha = function () {
        return this.m_fillAlpha
    };
    a.prototype.SetXFormScale = function (a) {
        void 0 === a && (a = 0);
        this.m_xformScale = a
    };
    a.prototype.GetXFormScale = function () {
        return this.m_xformScale
    };
    a.prototype.DrawPolygon = function (a, d, e) {
        if (d) {
            var f = this.m_ctx, g = this.m_drawScale;
            f.beginPath();
            f.strokeStyle = this._color(e.color, this.m_alpha);
            f.moveTo(a[0].x * g, a[0].y * g);
            for (e = 1; e < d; e++)f.lineTo(a[e].x * g, a[e].y * g);
            f.lineTo(a[0].x * g, a[0].y * g);
            f.closePath();
            f.stroke()
        }
    };
    a.prototype.DrawSolidPolygon = function (a, d, e) {
        if (d) {
            var f = this.m_ctx, g = this.m_drawScale;
            f.beginPath();
            f.strokeStyle = this._color(e.color, this.m_alpha);
            f.fillStyle = this._color(e.color, this.m_fillAlpha);
            f.moveTo(a[0].x * g, a[0].y * g);
            for (e =
                     1; e < d; e++)f.lineTo(a[e].x * g, a[e].y * g);
            f.lineTo(a[0].x * g, a[0].y * g);
            f.closePath();
            f.fill();
            f.stroke()
        }
    };
    a.prototype.DrawCircle = function (a, d, e) {
        if (d) {
            var f = this.m_ctx, g = this.m_drawScale;
            f.beginPath();
            f.strokeStyle = this._color(e.color, this.m_alpha);
            f.arc(a.x * g, a.y * g, d * g, 0, 2 * Math.PI, !0);
            f.closePath();
            f.stroke()
        }
    };
    a.prototype.DrawSolidCircle = function (a, d, e, f) {
        if (d) {
            var g = this.m_ctx, h = this.m_drawScale, n = a.x * h, p = a.y * h;
            g.moveTo(0, 0);
            g.beginPath();
            g.strokeStyle = this._color(f.color, this.m_alpha);
            g.fillStyle =
                this._color(f.color, this.m_fillAlpha);
            g.arc(n, p, d * h, 0, 2 * Math.PI, !0);
            g.moveTo(n, p);
            g.lineTo((a.x + e.x * d) * h, (a.y + e.y * d) * h);
            g.closePath();
            g.fill();
            g.stroke()
        }
    };
    a.prototype.DrawSegment = function (a, d, e) {
        var f = this.m_ctx, g = this.m_drawScale;
        f.strokeStyle = this._color(e.color, this.m_alpha);
        f.beginPath();
        f.moveTo(a.x * g, a.y * g);
        f.lineTo(d.x * g, d.y * g);
        f.closePath();
        f.stroke()
    };
    a.prototype.DrawTransform = function (a) {
        var d = this.m_ctx, e = this.m_drawScale;
        d.beginPath();
        d.strokeStyle = this._color(16711680, this.m_alpha);
        d.moveTo(a.position.x * e, a.position.y * e);
        d.lineTo((a.position.x + this.m_xformScale * a.R.col1.x) * e, (a.position.y + this.m_xformScale * a.R.col1.y) * e);
        d.strokeStyle = this._color(65280, this.m_alpha);
        d.moveTo(a.position.x * e, a.position.y * e);
        d.lineTo((a.position.x + this.m_xformScale * a.R.col2.x) * e, (a.position.y + this.m_xformScale * a.R.col2.y) * e);
        d.closePath();
        d.stroke()
    }
})();
var i;
for (i = 0; i < Box2D.postDefs.length; ++i)Box2D.postDefs[i]();
delete Box2D.postDefs;
"undefined" !== typeof require && "undefined" !== typeof module && (module.exports = Box2D);
(function () {
    Object.create = Object.create || function (a) {
            function b() {
            }

            b.prototype = a;
            return new b
        };
    var a;
    "undefined" === typeof exports ? (a = {}, "object" === typeof window && (window.cp = a)) : a = exports;
    var b = function (a, b) {
        if (!a)throw Error("Assertion failed: " + b);
    }, d = function (a, b) {
        !a && console && console.warn && (console.warn("ASSERTION FAILED: " + b), console.trace && console.trace())
    }, e = function (a, b) {
        return a < b ? a : b
    }, f = function (a, b) {
        return a > b ? a : b
    }, g, h;
    "object" === typeof window && -1 < window.navigator.userAgent.indexOf("Firefox") ?
        (g = Math.min, h = Math.max) : (g = e, h = f);
    var n = function (a, b) {
        return a < b ? a + " " + b : b + " " + a
    }, p = function (a, b) {
        for (var d = 0; d < a.length; d++)if (a[d] === b) {
            a[d] = a[a.length - 1];
            a.length--;
            break
        }
    };
    a.momentForCircle = function (a, b, d, e) {
        return a * (0.5 * (b * b + d * d) + H(e))
    };
    a.areaForCircle = function (a, b) {
        return Math.PI * Math.abs(a * a - b * b)
    };
    a.momentForSegment = function (a, b, d) {
        var e = I(B(b, d), 0.5);
        return a * (N(d, b) / 12 + H(e))
    };
    a.areaForSegment = function (a, b, d) {
        return d * (Math.PI * d + 2 * F(a, b))
    };
    a.momentForPoly = function (a, b, d) {
        for (var e = 0, f = 0,
                 g = b.length, h = 0; h < g; h += 2)var n = b[h] + d.x, p = b[h + 1] + d.y, r = b[(h + 2) % g] + d.x, s = b[(h + 3) % g] + d.y, t = r * p - s * n, e = e + t * (n * n + p * p + (n * r + p * s) + (r * r + s * s)), f = f + t;
        return a * e / (6 * f)
    };
    a.areaForPoly = function (a) {
        for (var b = 0, d = 0, e = a.length; d < e; d += 2)b += L(new w(a[d], a[d + 1]), new w(a[(d + 2) % e], a[(d + 3) % e]));
        return -b / 2
    };
    a.centroidForPoly = function (a) {
        for (var b = 0, d = new w(0, 0), e = 0, f = a.length; e < f; e += 2)var g = new w(a[e], a[e + 1]), h = new w(a[(e + 2) % f], a[(e + 3) % f]), n = L(g, h), b = b + n, d = B(d, I(B(g, h), n));
        return I(d, 1 / (3 * b))
    };
    a.recenterPoly = function (b) {
        for (var d =
            a.centroidForPoly(b), e = 0; e < b.length; e += 2)b[e] -= d.x, b[e + 1] -= d.y
    };
    a.momentForBox = function (a, b, d) {
        return a * (b * b + d * d) / 12
    };
    a.momentForBox2 = function (b, d) {
        var e = d.r - d.l, f = d.t - d.b, g = I([d.l + d.r, d.b + d.t], 0.5);
        return a.momentForBox(b, e, f) + b * H(g)
    };
    var r = a.loopIndexes = function (a) {
        var b = 0, d = 0, e, f, g, h;
        e = g = a[0];
        f = h = a[1];
        for (var n = a.length >> 1, p = 1; p < n; p++) {
            var r = a[2 * p], s = a[2 * p + 1];
            if (r < e || r == e && s < f)e = r, f = s, b = p; else if (r > g || r == g && s > h)g = r, h = s, d = p
        }
        return [b, d]
    }, s = function (a, b, d) {
        var e = a[2 * b];
        a[2 * b] = a[2 * d];
        a[2 * d] = e;
        e = a[2 *
        b + 1];
        a[2 * b + 1] = a[2 * d + 1];
        a[2 * d + 1] = e
    }, t = function (a, b, d, e, f, g) {
        if (0 === d)return 0;
        var h = 0, n = b;
        f = C(f, e);
        g *= D(f);
        var p = b;
        for (d = b + d - 1; p <= d;) {
            var r = new w(a[2 * p], a[2 * p + 1]), r = L(f, C(r, e));
            r > g ? (r > h && (h = r, n = p), p++) : (s(a, p, d), d--)
        }
        n != b && s(a, b, n);
        return p - b
    }, v = function (a, b, d, e, f, g, h, n) {
        if (0 > e)return 0;
        if (0 == e)return b[2 * n] = g.x, b[2 * n + 1] = g.y, 1;
        var p = t(b, d, e, f, g, a), r = new w(b[2 * d], b[2 * d + 1]);
        f = v(a, b, d + 1, p - 1, f, r, g, n);
        r = n + f++;
        b[2 * r] = g.x;
        b[2 * r + 1] = g.y;
        e = t(b, d + p, e - p, g, h, a);
        r = new w(b[2 * (d + p)], b[2 * (d + p) + 1]);
        return f + v(a, b, d +
                p + 1, e - 1, g, r, h, n + f)
    };
    a.convexHull = function (a, b, e) {
        if (b)for (var f = 0; f < a.length; f++)b[f] = a[f]; else b = a;
        var g = r(a), f = g[0], g = g[1];
        if (f == g)return b.length = 2, b;
        s(b, 0, f);
        s(b, 1, 0 == g ? f : g);
        f = new w(b[0], b[1]);
        g = new w(b[2], b[3]);
        a = v(e, b, 2, (a.length >> 1) - 2, f, g, f, 1) + 1;
        b.length = 2 * a;
        d(Da(b), "Internal error: cpConvexHull() and cpPolyValidate() did not agree.Please report this error with as much info as you can.");
        return b
    };
    var u = function (a, b, d) {
        return g(h(a, b), d)
    }, x = function (a) {
        return h(0, g(a, 1))
    }, w = a.Vect = function (a,
                              b) {
        this.x = a;
        this.y = b
    };
    a.v = function (a, b) {
        return new w(a, b)
    };
    var y = a.vzero = new w(0, 0), A = a.v.dot = function (a, b) {
        return a.x * b.x + a.y * b.y
    }, D = a.v.len = function (a) {
        return Math.sqrt(A(a, a))
    }, G = a.v.len2 = function (a, b) {
        return Math.sqrt(a * a + b * b)
    };
    a.v.eql = function (a, b) {
        return a.x === b.x && a.y === b.y
    };
    var B = a.v.add = function (a, b) {
        return new w(a.x + b.x, a.y + b.y)
    };
    w.prototype.add = function (a) {
        this.x += a.x;
        this.y += a.y;
        return this
    };
    var C = a.v.sub = function (a, b) {
        return new w(a.x - b.x, a.y - b.y)
    };
    w.prototype.sub = function (a) {
        this.x -=
            a.x;
        this.y -= a.y;
        return this
    };
    var E = a.v.neg = function (a) {
        return new w(-a.x, -a.y)
    };
    w.prototype.neg = function () {
        this.x = -this.x;
        this.y = -this.y;
        return this
    };
    var I = a.v.mult = function (a, b) {
        return new w(a.x * b, a.y * b)
    };
    w.prototype.mult = function (a) {
        this.x *= a;
        this.y *= a;
        return this
    };
    var L = a.v.cross = function (a, b) {
        return a.x * b.y - a.y * b.x
    }, J = a.v.perp = function (a) {
        return new w(-a.y, a.x)
    };
    a.v.pvrperp = function (a) {
        return new w(a.y, -a.x)
    };
    var Q = a.v.project = function (a, b) {
        return I(b, A(a, b) / H(b))
    };
    w.prototype.project = function (a) {
        this.mult(A(this,
                a) / H(a));
        return this
    };
    var M = a.v.rotate = function (a, b) {
        return new w(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
    };
    w.prototype.rotate = function (a) {
        this.x = this.x * a.x - this.y * a.y;
        this.y = this.x * a.y + this.y * a.x;
        return this
    };
    var K = a.v.unrotate = function (a, b) {
        return new w(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
    }, H = a.v.lengthsq = function (a) {
        return A(a, a)
    }, P = a.v.lengthsq2 = function (a, b) {
        return a * a + b * b
    }, U = a.v.lerp = function (a, b, d) {
        return B(I(a, 1 - d), I(b, d))
    }, O = a.v.normalize = function (a) {
        return I(a, 1 / D(a))
    }, Y = a.v.normalize_safe = function (a) {
        return 0 ===
        a.x && 0 === a.y ? y : O(a)
    }, V = a.v.clamp = function (a, b) {
        return A(a, a) > b * b ? I(O(a), b) : a
    };
    a.v.lerpconst = function (a, b, d) {
        return B(a, V(C(b, a), d))
    };
    var F = a.v.dist = function (a, b) {
        return D(C(a, b))
    }, N = a.v.distsq = function (a, b) {
        return H(C(a, b))
    };
    a.v.near = function (a, b, d) {
        return N(a, b) < d * d
    };
    var W = a.v.slerp = function (a, b, d) {
        var e = Math.acos(A(a, b));
        if (e) {
            var f = 1 / Math.sin(e);
            return B(I(a, Math.sin((1 - d) * e) * f), I(b, Math.sin(d * e) * f))
        }
        return a
    };
    a.v.slerpconst = function (a, b, d) {
        var e = Math.acos(A(a, b));
        return W(a, b, g(d, e) / e)
    };
    a.v.forangle =
        function (a) {
            return new w(Math.cos(a), Math.sin(a))
        };
    a.v.toangle = function (a) {
        return Math.atan2(a.y, a.x)
    };
    a.v.str = function (a) {
        return "(" + a.x.toFixed(3) + ", " + a.y.toFixed(3) + ")"
    };
    var R = 0, X = a.BB = function (a, b, d, e) {
        this.l = a;
        this.b = b;
        this.r = d;
        this.t = e;
        R++
    };
    a.bb = function (a, b, d, e) {
        return new X(a, b, d, e)
    };
    var fa = function (a, b) {
        return new X(a.x - b, a.y - b, a.x + b, a.y + b)
    }, sa = 0;
    a.NO_GROUP = 0;
    var ma = a.ALL_LAYERS = -1;
    a.ALL_CATEGORIES = -1;
    a.resetShapeIdCounter = function () {
        sa = 0
    };
    var ba = a.Shape = function (a) {
        this.body = a;
        this.bb_l =
            this.bb_b = this.bb_r = this.bb_t = 0;
        this.hashid = sa++;
        this.sensor = !1;
        this.u = this.e = 0;
        this.surface_v = y;
        this.group = this.collision_type = 0;
        this.layers = ma;
        this.space = null;
        this.collisionCode = this.collisionCode
    };
    ba.prototype.setElasticity = function (a) {
        this.e = a
    };
    ba.prototype.setFriction = function (a) {
        this.body.activate();
        this.u = a
    };
    ba.prototype.setLayers = function (a) {
        this.body.activate();
        this.layers = a
    };
    ba.prototype.setSensor = function (a) {
        this.body.activate();
        this.sensor = a
    };
    ba.prototype.setCollisionType = function (a) {
        this.body.activate();
        this.collision_type = a
    };
    ba.prototype.getBody = function () {
        return this.body
    };
    ba.prototype.active = function () {
        return this.body && -1 !== this.body.shapeList.indexOf(this)
    };
    ba.prototype.setBody = function (a) {
        b(!this.active(), "You cannot change the body on an active shape. You must remove the shape from the space before changing the body.");
        this.body = a
    };
    ba.prototype.cacheBB = function () {
        return this.update(this.body.p, this.body.rot)
    };
    ba.prototype.update = function (a, d) {
        b(!isNaN(d.x), "Rotation is NaN");
        b(!isNaN(a.x),
            "Position is NaN");
        this.cacheData(a, d)
    };
    ba.prototype.pointQuery = function (a) {
        a = this.nearestPointQuery(a);
        if (0 > a.d)return a
    };
    ba.prototype.getBB = function () {
        return new X(this.bb_l, this.bb_b, this.bb_r, this.bb_t)
    };
    var ua = function (a, b, d) {
        this.shape = a;
        this.p = b;
        this.d = d
    }, oa = function (a, b, d) {
        this.shape = a;
        this.t = b;
        this.n = d
    };
    oa.prototype.hitPoint = function (a, b) {
        return U(a, b, this.t)
    };
    oa.prototype.hitDist = function (a, b) {
        return F(a, b) * this.t
    };
    var pa = a.CircleShape = function (a, b, d) {
        this.c = this.tc = d;
        this.r = b;
        this.type =
            "circle";
        ba.call(this, a)
    };
    pa.prototype = Object.create(ba.prototype);
    pa.prototype.cacheData = function (a, b) {
        var d = this.tc = M(this.c, b).add(a), e = this.r;
        this.bb_l = d.x - e;
        this.bb_b = d.y - e;
        this.bb_r = d.x + e;
        this.bb_t = d.y + e
    };
    pa.prototype.nearestPointQuery = function (a) {
        var b = a.x - this.tc.x, d = a.y - this.tc.y;
        a = G(b, d);
        var e = this.r, b = new w(this.tc.x + b * e / a, this.tc.y + d * e / a);
        return new ua(this, b, a - e)
    };
    var Ca = function (a, b, d, e, f, g) {
        e = C(e, b);
        f = C(f, b);
        b = A(e, e) - 2 * A(e, f) + A(f, f);
        g = -2 * A(e, e) + 2 * A(e, f);
        d = A(e, e) - d * d;
        d = g * g - 4 * b * d;
        if (0 <=
            d && (d = (-g - Math.sqrt(d)) / (2 * b), 0 <= d && 1 >= d))return new oa(a, d, O(U(e, f, d)))
    };
    pa.prototype.segmentQuery = function (a, b) {
        return Ca(this, this.tc, this.r, a, b)
    };
    var la = a.SegmentShape = function (a, b, d, e) {
        this.a = b;
        this.b = d;
        this.n = J(O(C(d, b)));
        this.ta = this.tb = this.tn = null;
        this.r = e;
        this.b_tangent = this.a_tangent = y;
        this.type = "segment";
        ba.call(this, a)
    };
    la.prototype = Object.create(ba.prototype);
    la.prototype.cacheData = function (a, b) {
        this.ta = B(a, M(this.a, b));
        this.tb = B(a, M(this.b, b));
        this.tn = M(this.n, b);
        var d, e, f, g;
        this.ta.x <
        this.tb.x ? (d = this.ta.x, e = this.tb.x) : (d = this.tb.x, e = this.ta.x);
        this.ta.y < this.tb.y ? (f = this.ta.y, g = this.tb.y) : (f = this.tb.y, g = this.ta.y);
        var h = this.r;
        this.bb_l = d - h;
        this.bb_b = f - h;
        this.bb_r = e + h;
        this.bb_t = g + h
    };
    la.prototype.nearestPointQuery = function (a) {
        var b;
        b = this.tb;
        var d = C(this.ta, b), e = x(A(d, C(a, b)) / H(d));
        b = B(b, I(d, e));
        var d = a.x - b.x, f = a.y - b.y;
        a = G(d, f);
        e = this.r;
        b = a ? B(b, I(new w(d, f), e / a)) : b;
        return new ua(this, b, a - e)
    };
    la.prototype.segmentQuery = function (a, b) {
        var d = this.tn, e = A(C(this.ta, a), d), f = this.r, g =
            0 < e ? E(d) : d, h = C(I(g, f), a), n = B(this.ta, h), p = B(this.tb, h), h = C(b, a);
        if (0 >= L(h, n) * L(h, p)) {
            if (f = e + (0 < e ? -f : f), e = -f, d = A(h, d) - f, 0 > e * d)return new oa(this, e / (e - d), g)
        } else if (0 !== f)return g = Ca(this, this.ta, this.r, a, b), d = Ca(this, this.tb, this.r, a, b), g ? d && d.t < g.t ? d : g : d
    };
    la.prototype.setNeighbors = function (a, b) {
        this.a_tangent = C(a, this.a);
        this.b_tangent = C(b, this.b)
    };
    la.prototype.setEndpoints = function (a, b) {
        this.a = a;
        this.b = b;
        this.n = J(O(C(b, a)))
    };
    var Da = function (a) {
        for (var b = a.length, d = 0; d < b; d += 2) {
            var e = a[(d + 2) % b], f =
                a[(d + 3) % b];
            if (0 < (e - a[d]) * (a[(d + 5) % b] - f) - (f - a[d + 1]) * (a[(d + 4) % b] - e))return !1
        }
        return !0
    }, ca = a.PolyShape = function (a, b, d) {
        this.setVerts(b, d);
        this.type = "poly";
        ba.call(this, a)
    };
    ca.prototype = Object.create(ba.prototype);
    var Ea = function (a, b) {
        this.n = a;
        this.d = b
    };
    Ea.prototype.compare = function (a) {
        return A(this.n, a) - this.d
    };
    ca.prototype.setVerts = function (a, d) {
        b(4 <= a.length, "Polygons require some verts");
        b("number" === typeof a[0], "Polygon verticies should be specified in a flattened list (eg [x1,y1,x2,y2,x3,y3,...])");
        b(Da(a), "Polygon is concave or has a reversed winding. Consider using cpConvexHull()");
        var e = a.length, f = e >> 1;
        this.verts = Array(e);
        this.tVerts = Array(e);
        this.planes = Array(f);
        this.tPlanes = Array(f);
        for (f = 0; f < e; f += 2) {
            var g = a[f] + d.x, h = a[f + 1] + d.y, n = O(J(new w(a[(f + 2) % e] + d.x - g, a[(f + 3) % e] + d.y - h)));
            this.verts[f] = g;
            this.verts[f + 1] = h;
            this.planes[f >> 1] = new Ea(n, n.x * g + n.y * h);
            this.tPlanes[f >> 1] = new Ea(new w(0, 0), 0)
        }
    };
    a.BoxShape = function (a, b, d) {
        b /= 2;
        d /= 2;
        return ob(a, new X(-b, -d, b, d))
    };
    var ob = a.BoxShape2 = function (a,
                                     b) {
        return new ca(a, [b.l, b.b, b.l, b.t, b.r, b.t, b.r, b.b], y)
    };
    ca.prototype.transformVerts = function (a, b) {
        for (var d = this.verts, e = this.tVerts, f = Infinity, n = -Infinity, p = Infinity, r = -Infinity, s = 0; s < d.length; s += 2) {
            var t = d[s], u = d[s + 1], x = a.x + t * b.x - u * b.y, t = a.y + t * b.y + u * b.x;
            e[s] = x;
            e[s + 1] = t;
            f = g(f, x);
            n = h(n, x);
            p = g(p, t);
            r = h(r, t)
        }
        this.bb_l = f;
        this.bb_b = p;
        this.bb_r = n;
        this.bb_t = r
    };
    ca.prototype.transformAxes = function (a, b) {
        for (var d = this.planes, e = this.tPlanes, f = 0; f < d.length; f++) {
            var g = M(d[f].n, b);
            e[f].n = g;
            e[f].d = A(a, g) + d[f].d
        }
    };
    ca.prototype.cacheData = function (a, b) {
        this.transformAxes(a, b);
        this.transformVerts(a, b)
    };
    ca.prototype.nearestPointQuery = function (a) {
        for (var b = this.tPlanes, d = this.tVerts, e = d[d.length - 2], f = d[d.length - 1], g = Infinity, h = y, n = !1, p = 0; p < b.length; p++) {
            0 < b[p].compare(a) && (n = !0);
            var r = d[2 * p], s = d[2 * p + 1], t;
            t = r;
            var u = s, e = e - t, f = f - u, v = x((e * (a.x - t) + f * (a.y - u)) / P(e, f));
            t = new w(t + e * v, u + f * v);
            u = F(a, t);
            u < g && (g = u, h = t);
            e = r;
            f = s
        }
        return new ua(this, h, n ? g : -g)
    };
    ca.prototype.segmentQuery = function (a, b) {
        for (var d = this.tPlanes, e = this.tVerts,
                 f = d.length, g = 2 * f, h = 0; h < f; h++) {
            var n = d[h].n, p = A(a, n);
            if (!(d[h].d > p)) {
                var r = A(b, n), p = (d[h].d - p) / (r - p);
                if (!(0 > p || 1 < p)) {
                    var r = U(a, b, p), r = -L(n, r), s = -(n.x * e[(2 * h + 3) % g] - n.y * e[(2 * h + 2) % g]);
                    if (-(n.x * e[2 * h + 1] - n.y * e[2 * h]) <= r && r <= s)return new oa(this, p, n)
                }
            }
        }
    };
    ca.prototype.valueOnAxis = function (a, b) {
        for (var d = this.tVerts, e = a.x * d[0] + a.y * d[1], f = 2; f < d.length; f += 2)e = g(e, a.x * d[f] + a.y * d[f + 1]);
        return e - b
    };
    ca.prototype.containsVert = function (a, b) {
        for (var d = this.tPlanes, e = 0; e < d.length; e++) {
            var f = d[e].n;
            if (0 < f.x * a + f.y * b - d[e].d)return !1
        }
        return !0
    };
    ca.prototype.containsVertPartial = function (a, b, d) {
        for (var e = this.tPlanes, f = 0; f < e.length; f++) {
            var g = e[f].n;
            if (!(0 > A(g, d)) && 0 < g.x * a + g.y * b - e[f].d)return !1
        }
        return !0
    };
    ca.prototype.getNumVerts = function () {
        return this.verts.length / 2
    };
    ca.prototype.getCount = ca.prototype.getNumVerts;
    ca.prototype.getVert = function (a) {
        return new w(this.verts[2 * a], this.verts[2 * a + 1])
    };
    var S = a.Body = function (a, b) {
        this.p = new w(0, 0);
        this.vx = this.vy = 0;
        this.f = new w(0, 0);
        this.t = this.w = 0;
        this.w_limit = this.v_limit = Infinity;
        this.w_bias = this.v_biasx =
            this.v_biasy = 0;
        this.space = null;
        this.shapeList = [];
        this.nodeNext = this.nodeRoot = this.constraintList = this.arbiterList = null;
        this.nodeIdleTime = 0;
        this.setMass(a);
        this.setMoment(b);
        this.rot = new w(0, 0);
        this.setAngle(0)
    };
    a.StaticBody = function () {
        var a = new S(Infinity, Infinity);
        a.nodeIdleTime = Infinity;
        return a
    };
    if ("undefined" !== typeof DEBUG && DEBUG) {
        var va = function (a, d) {
            b(a.x == a.x && a.y == a.y, d)
        }, wa = function (a, d) {
            b(Infinity !== Math.abs(a.x) && Infinity !== Math.abs(a.y), d)
        };
        S.prototype.sanityCheck = function () {
            b(this.m ===
                this.m && this.m_inv === this.m_inv, "Body's mass is invalid.");
            b(this.i === this.i && this.i_inv === this.i_inv, "Body's moment is invalid.");
            var a = this.p;
            va(a, "Body's position is invalid.");
            wa(a, "Body's position is invalid.");
            a = this.f;
            va(a, "Body's force is invalid.");
            wa(a, "Body's force is invalid.");
            b(this.vx === this.vx && Infinity !== Math.abs(this.vx), "Body's velocity is invalid.");
            b(this.vy === this.vy && Infinity !== Math.abs(this.vy), "Body's velocity is invalid.");
            b(this.a === this.a && Infinity !== Math.abs(this.a), "Body's angle is invalid.");
            b(this.w === this.w && Infinity !== Math.abs(this.w), "Body's angular velocity is invalid.");
            b(this.t === this.t && Infinity !== Math.abs(this.t), "Body's torque is invalid.");
            a = this.rot;
            va(a, "Body's rotation vector is invalid.");
            wa(a, "Body's rotation vector is invalid.");
            b(this.v_limit === this.v_limit, "Body's velocity limit is invalid.");
            b(this.w_limit === this.w_limit, "Body's angular velocity limit is invalid.")
        }
    } else S.prototype.sanityCheck = function () {
    };
    S.prototype.getPos = function () {
        return this.p
    };
    S.prototype.getVel =
        function () {
            return new w(this.vx, this.vy)
        };
    S.prototype.getAngVel = function () {
        return this.w
    };
    S.prototype.getPosition = S.prototype.getPos;
    S.prototype.getVelocity = S.prototype.getVel;
    S.prototype.getAngularVelocity = S.prototype.getAngVel;
    S.prototype.getCenterOfGravity = function () {
        return this.p
    };
    S.prototype.isSleeping = function () {
        return null !== this.nodeRoot
    };
    S.prototype.isStatic = function () {
        return Infinity === this.nodeIdleTime
    };
    S.prototype.isRogue = function () {
        return null === this.space
    };
    S.prototype.setMass = function (a) {
        b(0 <
            a, "Mass must be positive and non-zero.");
        this.activate();
        this.m = a;
        this.m_inv = 1 / a
    };
    S.prototype.setMoment = function (a) {
        b(0 < a, "Moment of Inertia must be positive and non-zero.");
        this.activate();
        this.i = a;
        this.i_inv = 1 / a
    };
    S.prototype.addShape = function (a) {
        this.shapeList.push(a)
    };
    S.prototype.removeShape = function (a) {
        p(this.shapeList, a)
    };
    var Ia = function (a, b, d) {
        if (a === d)return a.next(b);
        a.a === b ? a.next_a = Ia(a.next_a, b, d) : a.next_b = Ia(a.next_b, b, d);
        return a
    };
    S.prototype.removeConstraint = function (a) {
        this.constraintList =
            Ia(this.constraintList, this, a)
    };
    S.prototype.setPos = function (b) {
        this.activate();
        this.sanityCheck();
        b === y && (b = a.v(0, 0));
        this.p = b
    };
    S.prototype.setVel = function (a) {
        this.activate();
        this.vx = a.x;
        this.vy = a.y
    };
    S.prototype.setAngVel = function (a) {
        this.activate();
        this.w = a
    };
    S.prototype.setAngleInternal = function (a) {
        b(!isNaN(a), "Internal Error: Attempting to set body's angle to NaN");
        this.a = a;
        this.rot.x = Math.cos(a);
        this.rot.y = Math.sin(a)
    };
    S.prototype.setAngle = function (a) {
        this.activate();
        this.sanityCheck();
        this.setAngleInternal(a)
    };
    S.prototype.velocity_func = function (a, b, d) {
        var e = this.vx * b + (a.x + this.f.x * this.m_inv) * d;
        a = this.vy * b + (a.y + this.f.y * this.m_inv) * d;
        var f = this.v_limit, g = e * e + a * a, f = g > f * f ? f / Math.sqrt(g) : 1;
        this.vx = e * f;
        this.vy = a * f;
        e = this.w_limit;
        this.w = u(this.w * b + this.t * this.i_inv * d, -e, e);
        this.sanityCheck()
    };
    S.prototype.position_func = function (a) {
        this.p.x += (this.vx + this.v_biasx) * a;
        this.p.y += (this.vy + this.v_biasy) * a;
        this.setAngleInternal(this.a + (this.w + this.w_bias) * a);
        this.w_bias = this.v_biasx = this.v_biasy = 0;
        this.sanityCheck()
    };
    S.prototype.resetForces = function () {
        this.activate();
        this.f = new w(0, 0);
        this.t = 0
    };
    S.prototype.applyForce = function (a, b) {
        this.activate();
        this.f = B(this.f, a);
        this.t += L(b, a)
    };
    S.prototype.applyImpulse = function (a, b) {
        this.activate();
        rb(this, a.x, a.y, b)
    };
    S.prototype.getVelAtPoint = function (a) {
        return B(new w(this.vx, this.vy), I(J(a), this.w))
    };
    S.prototype.getVelAtWorldPoint = function (a) {
        return this.getVelAtPoint(C(a, this.p))
    };
    S.prototype.getVelAtLocalPoint = function (a) {
        return this.getVelAtPoint(M(a, this.rot))
    };
    S.prototype.eachShape =
        function (a) {
            for (var b = 0, d = this.shapeList.length; b < d; b++)a(this.shapeList[b])
        };
    S.prototype.eachConstraint = function (a) {
        for (var b = this.constraintList; b;) {
            var d = b.next(this);
            a(b);
            b = d
        }
    };
    S.prototype.eachArbiter = function (a) {
        for (var b = this.arbiterList; b;) {
            var d = b.next(this);
            b.swappedColl = this === b.body_b;
            a(b);
            b = d
        }
    };
    S.prototype.local2World = function (a) {
        return B(this.p, M(a, this.rot))
    };
    S.prototype.world2Local = function (a) {
        return K(C(a, this.p), this.rot)
    };
    S.prototype.localToWorld = S.prototype.local2World;
    S.prototype.worldToLocal =
        S.prototype.world2Local;
    S.prototype.kineticEnergy = function () {
        var a = this.vx * this.vx + this.vy * this.vy, b = this.w * this.w;
        return (a ? a * this.m : 0) + (b ? b * this.i : 0)
    };
    var xa = a.SpatialIndex = function (a) {
        if (this.staticIndex = a) {
            if (a.dynamicIndex)throw Error("This static index is already associated with a dynamic index.");
            a.dynamicIndex = this
        }
    };
    xa.prototype.collideStatic = function (a, b) {
        if (0 < a.count) {
            var d = a.query;
            this.each(function (a) {
                d(a, new X(a.bb_l, a.bb_b, a.bb_r, a.bb_t), b)
            })
        }
    };
    var $ = a.BBTree = function (a) {
        xa.call(this,
            a);
        this.velocityFunc = null;
        this.leaves = {};
        this.count = 0;
        this.pooledPairs = this.pooledNodes = this.root = null;
        this.stamp = 0
    };
    $.prototype = Object.create(xa.prototype);
    var Xa = 0, ea = function (a, b, d) {
        this.obj = null;
        this.bb_l = g(b.bb_l, d.bb_l);
        this.bb_b = g(b.bb_b, d.bb_b);
        this.bb_r = h(b.bb_r, d.bb_r);
        this.bb_t = h(b.bb_t, d.bb_t);
        this.parent = null;
        this.setA(b);
        this.setB(d)
    };
    $.prototype.makeNode = function (a, b) {
        var d = this.pooledNodes;
        if (d)return this.pooledNodes = d.parent, d.constructor(this, a, b), d;
        Xa++;
        return new ea(this, a, b)
    };
    var pb = 0, ha = function (a, b) {
        this.obj = b;
        a.getBB(b, this);
        this.parent = null;
        this.stamp = 1;
        this.pairs = null;
        pb++
    };
    $.prototype.getBB = function (a, b) {
        var d = this.velocityFunc;
        if (d) {
            var e = 0.1 * (a.bb_r - a.bb_l), f = 0.1 * (a.bb_t - a.bb_b), d = I(d(a), 0.1);
            b.bb_l = a.bb_l + g(-e, d.x);
            b.bb_b = a.bb_b + g(-f, d.y);
            b.bb_r = a.bb_r + h(e, d.x);
            b.bb_t = a.bb_t + h(f, d.y)
        } else b.bb_l = a.bb_l, b.bb_b = a.bb_b, b.bb_r = a.bb_r, b.bb_t = a.bb_t
    };
    $.prototype.getStamp = function () {
        var a = this.dynamicIndex;
        return a && a.stamp ? a.stamp : this.stamp
    };
    $.prototype.incrementStamp =
        function () {
            this.dynamicIndex && this.dynamicIndex.stamp ? this.dynamicIndex.stamp++ : this.stamp++
        };
    var Ya = 0, Za = function (a, b, d, e) {
        this.prevA = null;
        this.leafA = a;
        this.nextA = b;
        this.prevB = null;
        this.leafB = d;
        this.nextB = e
    };
    $.prototype.makePair = function (a, b, d, e) {
        var f = this.pooledPairs;
        if (f)return this.pooledPairs = f.prevA, f.prevA = null, f.leafA = a, f.nextA = b, f.prevB = null, f.leafB = d, f.nextB = e, f;
        Ya++;
        return new Za(a, b, d, e)
    };
    Za.prototype.recycle = function (a) {
        this.prevA = a.pooledPairs;
        a.pooledPairs = this
    };
    var Ua = function (a,
                       b, d) {
        d && (d.leafA === b ? d.prevA = a : d.prevB = a);
        a ? a.leafA === b ? a.nextA = d : a.nextB = d : b.pairs = d
    };
    ha.prototype.clearPairs = function (a) {
        var b = this.pairs, d;
        for (this.pairs = null; b;)b.leafA === this ? (d = b.nextA, Ua(b.prevB, b.leafB, b.nextB)) : (d = b.nextB, Ua(b.prevA, b.leafA, b.nextA)), b.recycle(a), b = d
    };
    var Fa = function (a, b, d) {
        var e = a.pairs, f = b.pairs;
        d = d.makePair(a, e, b, f);
        a.pairs = b.pairs = d;
        e && (e.leafA === a ? e.prevA = d : e.prevB = d);
        f && (f.leafA === b ? f.prevA = d : f.prevB = d)
    };
    ea.prototype.recycle = function (a) {
        this.parent = a.pooledNodes;
        a.pooledNodes =
            this
    };
    ha.prototype.recycle = function (a) {
    };
    ea.prototype.setA = function (a) {
        this.A = a;
        a.parent = this
    };
    ea.prototype.setB = function (a) {
        this.B = a;
        a.parent = this
    };
    ha.prototype.isLeaf = !0;
    ea.prototype.isLeaf = !1;
    ea.prototype.otherChild = function (a) {
        return this.A == a ? this.B : this.A
    };
    ea.prototype.replaceChild = function (a, b, e) {
        d(a == this.A || a == this.B, "Node is not a child of parent.");
        this.A == a ? (this.A.recycle(e), this.setA(b)) : (this.B.recycle(e), this.setB(b));
        for (a = this; a; a = a.parent)b = a.A, e = a.B, a.bb_l = g(b.bb_l, e.bb_l), a.bb_b =
            g(b.bb_b, e.bb_b), a.bb_r = h(b.bb_r, e.bb_r), a.bb_t = h(b.bb_t, e.bb_t)
    };
    ea.prototype.bbArea = ha.prototype.bbArea = function () {
        return (this.bb_r - this.bb_l) * (this.bb_t - this.bb_b)
    };
    var Va = function (a, b) {
        return (h(a.bb_r, b.bb_r) - g(a.bb_l, b.bb_l)) * (h(a.bb_t, b.bb_t) - g(a.bb_b, b.bb_b))
    }, Ga = function (a, b) {
        return Math.abs(a.bb_l + a.bb_r - b.bb_l - b.bb_r) + Math.abs(a.bb_b + a.bb_t - b.bb_b - b.bb_t)
    }, ra = function (a, b, d) {
        if (null == a)return b;
        if (a.isLeaf)return d.makeNode(b, a);
        var e = a.B.bbArea() + Va(a.A, b), f = a.A.bbArea() + Va(a.B, b);
        e ===
        f && (e = Ga(a.A, b), f = Ga(a.B, b));
        f < e ? a.setB(ra(a.B, b, d)) : a.setA(ra(a.A, b, d));
        a.bb_l = g(a.bb_l, b.bb_l);
        a.bb_b = g(a.bb_b, b.bb_b);
        a.bb_r = h(a.bb_r, b.bb_r);
        a.bb_t = h(a.bb_t, b.bb_t);
        return a
    };
    ea.prototype.intersectsBB = ha.prototype.intersectsBB = function (a) {
        return this.bb_l <= a.r && a.l <= this.bb_r && this.bb_b <= a.t && a.b <= this.bb_t
    };
    var Ha = function (a, b, d) {
        a.intersectsBB(b) && (a.isLeaf ? d(a.obj) : (Ha(a.A, b, d), Ha(a.B, b, d)))
    }, Wa = function (a, b, d) {
        var e = 1 / (d.x - b.x), f = a.bb_l == b.x ? -Infinity : (a.bb_l - b.x) * e, n = a.bb_r == b.x ? Infinity :
        (a.bb_r - b.x) * e, e = g(f, n), f = h(f, n), n = 1 / (d.y - b.y);
        d = a.bb_b == b.y ? -Infinity : (a.bb_b - b.y) * n;
        b = a.bb_t == b.y ? Infinity : (a.bb_t - b.y) * n;
        a = g(d, b);
        b = h(d, b);
        return a <= f && e <= b && (e = h(e, a), 0 <= g(f, b) && 1 >= e) ? h(e, 0) : Infinity
    }, qa = function (a, b, d, e, f) {
        if (a.isLeaf)return f(a.obj);
        var h = Wa(a.A, b, d), n = Wa(a.B, b, d);
        h < n ? (h < e && (e = g(e, qa(a.A, b, d, e, f))), n < e && (e = g(e, qa(a.B, b, d, e, f)))) : (n < e && (e = g(e, qa(a.B, b, d, e, f))), h < e && (e = g(e, qa(a.A, b, d, e, f))));
        return e
    };
    $.prototype.subtreeRecycle = function (a) {
        a.isLeaf && (this.subtreeRecycle(a.A),
            this.subtreeRecycle(a.B), a.recycle(this))
    };
    var $a = function (a, b, d) {
        if (b == a)return null;
        var e = b.parent;
        if (e == a)return b = a.otherChild(b), b.parent = a.parent, a.recycle(d), b;
        e.parent.replaceChild(e, e.otherChild(b), d);
        return a
    }, ab = function (a, b) {
        return a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t
    };
    ha.prototype.markLeafQuery = function (a, b, d, e) {
        ab(a, this) && (b ? Fa(a, this, d) : (this.stamp < a.stamp && Fa(this, a, d), e && e(a.obj, this.obj)))
    };
    ea.prototype.markLeafQuery = function (a, b, d, e) {
        ab(a, this) && (this.A.markLeafQuery(a,
            b, d, e), this.B.markLeafQuery(a, b, d, e))
    };
    ha.prototype.markSubtree = function (a, b, d) {
        if (this.stamp == a.getStamp())for (b && b.markLeafQuery(this, !1, a, d), b = this; b.parent; b = b.parent)b == b.parent.A ? b.parent.B.markLeafQuery(this, !0, a, d) : b.parent.A.markLeafQuery(this, !1, a, d); else for (a = this.pairs; a;)this === a.leafB ? (d && d(a.leafA.obj, this.obj), a = a.nextB) : a = a.nextA
    };
    ea.prototype.markSubtree = function (a, b, d) {
        this.A.markSubtree(a, b, d);
        this.B.markSubtree(a, b, d)
    };
    ha.prototype.containsObj = function (a) {
        return this.bb_l <= a.bb_l &&
            this.bb_r >= a.bb_r && this.bb_b <= a.bb_b && this.bb_t >= a.bb_t
    };
    ha.prototype.update = function (a) {
        var b = a.root;
        return this.containsObj(this.obj) ? !1 : (a.getBB(this.obj, this), b = $a(b, this, a), a.root = ra(b, this, a), this.clearPairs(a), this.stamp = a.getStamp(), !0)
    };
    ha.prototype.addPairs = function (a) {
        var b = a.dynamicIndex;
        b ? (a = b.root) && a.markLeafQuery(this, !0, b, null) : this.markSubtree(a, a.staticIndex.root, null)
    };
    $.prototype.insert = function (a, b) {
        var d = new ha(this, a);
        this.leaves[b] = d;
        this.root = ra(this.root, d, this);
        this.count++;
        d.stamp = this.getStamp();
        d.addPairs(this);
        this.incrementStamp()
    };
    $.prototype.remove = function (a, b) {
        var d = this.leaves[b];
        delete this.leaves[b];
        this.root = $a(this.root, d, this);
        this.count--;
        d.clearPairs(this);
        d.recycle(this)
    };
    $.prototype.contains = function (a, b) {
        return null != this.leaves[b]
    };
    var qb = function (a, b) {
    };
    $.prototype.reindexQuery = function (a) {
        if (this.root) {
            var b, d = this.leaves;
            for (b in d)d[b].update(this);
            d = (b = this.staticIndex) && b.root;
            this.root.markSubtree(this, d, a);
            b && !d && this.collideStatic(this,
                b, a);
            this.incrementStamp()
        }
    };
    $.prototype.reindex = function () {
        this.reindexQuery(qb)
    };
    $.prototype.reindexObject = function (a, b) {
        var d = this.leaves[b];
        d && (d.update(this) && d.addPairs(this), this.incrementStamp())
    };
    $.prototype.pointQuery = function (a, b) {
        this.query(new X(a.x, a.y, a.x, a.y), b)
    };
    $.prototype.segmentQuery = function (a, b, d, e) {
        this.root && qa(this.root, a, b, d, e)
    };
    $.prototype.query = function (a, b) {
        this.root && Ha(this.root, a, b)
    };
    $.prototype.count = function () {
        return this.count
    };
    $.prototype.each = function (a) {
        for (var b in this.leaves)a(this.leaves[b].obj)
    };
    var bb = function (a, b, d, e, f) {
        return (h(a.bb_r, e) - g(a.bb_l, b)) * (h(a.bb_t, f) - g(a.bb_b, d))
    }, Ja = function (a, b, d, e) {
        if (1 == e)return b[d];
        if (2 == e)return a.makeNode(b[d], b[d + 1]);
        for (var f = b[d], n = f.bb_l, p = f.bb_b, r = f.bb_r, s = f.bb_t, t = d + e, u = d + 1; u < t; u++)f = b[u], n = g(n, f.bb_l), p = g(p, f.bb_b), r = h(r, f.bb_r), s = h(s, f.bb_t);
        var f = r - n > s - p, x = Array(2 * e);
        if (f)for (u = d; u < t; u++)x[2 * u + 0] = b[u].bb_l, x[2 * u + 1] = b[u].bb_r; else for (u = d; u < t; u++)x[2 * u + 0] = b[u].bb_b, x[2 * u + 1] = b[u].bb_t;
        x.sort(function (a, b) {
            return a - b
        });
        var w = 0.5 * (x[e - 1] + x[e]),
            u = n, x = p, v = r, y = s;
        f ? v = n = w : y = p = w;
        for (var w = t, A = d; A < w;)f = b[A], bb(f, n, p, r, s) < bb(f, u, x, v, y) ? (w--, b[A] = b[w], b[w] = f) : A++;
        if (w == e) {
            f = null;
            for (u = d; u < t; u++)f = ra(f, b[u], a);
            return f
        }
        return NodeNew(a, Ja(a, b, d, w - d), Ja(a, b, w, t - w))
    };
    $.prototype.optimize = function () {
        var a = Array(this.count), b = 0, d;
        for (d in this.leaves)a[b++] = this.nodes[d];
        tree.subtreeRecycle(root);
        this.root = Ja(tree, a, a.length)
    };
    var Ka = function (a, b) {
        !a.isLeaf && 10 >= b && (Ka(a.A, b + 1), Ka(a.B, b + 1));
        for (var d = "", e = 0; e < b; e++)d += " ";
        console.log(d + a.bb_b + " " + a.bb_t)
    };
    $.prototype.log = function () {
        this.root && Ka(this.root, 0)
    };
    var na = a.CollisionHandler = function () {
        this.a = this.b = 0
    };
    na.prototype.begin = function (a, b) {
        return !0
    };
    na.prototype.preSolve = function (a, b) {
        return !0
    };
    na.prototype.postSolve = function (a, b) {
    };
    na.prototype.separate = function (a, b) {
    };
    var aa = function (a, b) {
        this.u = this.e = 0;
        this.surface_vr = y;
        this.a = a;
        this.body_a = a.body;
        this.b = b;
        this.body_b = b.body;
        this.contacts = this.thread_b_next = this.thread_b_prev = this.thread_a_next = this.thread_a_prev = null;
        this.stamp = 0;
        this.handler =
            null;
        this.swappedColl = !1;
        this.state = "first coll"
    };
    aa.prototype.getShapes = function () {
        return this.swappedColl ? [this.b, this.a] : [this.a, this.b]
    };
    aa.prototype.totalImpulse = function () {
        for (var a = this.contacts, b = new w(0, 0), d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            b.add(I(f.n, f.jnAcc))
        }
        return this.swappedColl ? b : b.neg()
    };
    aa.prototype.totalImpulseWithFriction = function () {
        for (var a = this.contacts, b = new w(0, 0), d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            b.add((new w(f.jnAcc, f.jtAcc)).rotate(f.n))
        }
        return this.swappedColl ? b : b.neg()
    };
    aa.prototype.totalKE = function () {
        for (var a = (1 - this.e) / (1 + this.e), b = 0, d = this.contacts, e = 0, f = d.length; e < f; e++)var g = d[e], h = g.jnAcc, n = g.jtAcc, b = b + (a * h * h / g.nMass + n * n / g.tMass);
        return b
    };
    aa.prototype.ignore = function () {
        this.state = "ignore"
    };
    aa.prototype.getA = function () {
        return this.swappedColl ? this.b : this.a
    };
    aa.prototype.getB = function () {
        return this.swappedColl ? this.a : this.b
    };
    aa.prototype.isFirstContact = function () {
        return "first coll" === this.state
    };
    var La = function (a, b, d) {
        this.point = a;
        this.normal = b;
        this.dist = d
    };
    aa.prototype.getContactPointSet = function () {
        var a = Array(this.contacts.length), b;
        for (b = 0; b < a.length; b++)a[b] = new La(this.contacts[b].p, this.contacts[b].n, this.contacts[b].dist);
        return a
    };
    aa.prototype.getNormal = function (a) {
        a = this.contacts[a].n;
        return this.swappedColl ? E(a) : a
    };
    aa.prototype.getPoint = function (a) {
        return this.contacts[a].p
    };
    aa.prototype.getDepth = function (a) {
        return this.contacts[a].dist
    };
    var Ma = function (a, b, d, e) {
        d ? d.body_a === b ? d.thread_a_next = e : d.thread_b_next = e : b.arbiterList = e;
        e && (e.body_a ===
        b ? e.thread_a_prev = d : e.thread_b_prev = d)
    };
    aa.prototype.unthread = function () {
        Ma(this, this.body_a, this.thread_a_prev, this.thread_a_next);
        Ma(this, this.body_b, this.thread_b_prev, this.thread_b_next);
        this.thread_b_prev = this.thread_b_next = this.thread_a_prev = this.thread_a_next = null
    };
    aa.prototype.update = function (a, b, d, e) {
        if (this.contacts)for (var f = 0; f < this.contacts.length; f++)for (var g = this.contacts[f], h = 0; h < a.length; h++) {
            var n = a[h];
            n.hash === g.hash && (n.jnAcc = g.jnAcc, n.jtAcc = g.jtAcc)
        }
        this.contacts = a;
        this.handler =
            b;
        this.swappedColl = d.collision_type !== b.a;
        this.e = d.e * e.e;
        this.u = d.u * e.u;
        this.surface_vr = C(d.surface_v, e.surface_v);
        this.a = d;
        this.body_a = d.body;
        this.b = e;
        this.body_b = e.body;
        "cached" == this.state && (this.state = "first coll")
    };
    aa.prototype.preStep = function (a, b, d) {
        for (var e = this.body_a, f = this.body_b, h = 0; h < this.contacts.length; h++) {
            var n = this.contacts[h];
            n.r1 = C(n.p, e.p);
            n.r2 = C(n.p, f.p);
            n.nMass = 1 / gb(e, f, n.r1, n.r2, n.n);
            n.tMass = 1 / gb(e, f, n.r1, n.r2, J(n.n));
            n.bias = -d * g(0, n.dist + b) / a;
            n.jBias = 0;
            n.bounce = Ba(e, f, n.r1,
                    n.r2, n.n) * this.e
        }
    };
    aa.prototype.applyCachedImpulse = function (a) {
        if (!this.isFirstContact())for (var b = this.body_a, d = this.body_b, e = 0; e < this.contacts.length; e++) {
            var f = this.contacts[e], g = f.n.x, h = f.n.y;
            ka(b, d, f.r1, f.r2, (g * f.jnAcc - h * f.jtAcc) * a, (g * f.jtAcc + h * f.jnAcc) * a)
        }
    };
    var cb = 0, db = 0;
    aa.prototype.applyImpulse = function () {
        cb++;
        for (var a = this.body_a, b = this.body_b, d = this.surface_vr, e = this.u, f = 0; f < this.contacts.length; f++) {
            db++;
            var g = this.contacts[f], n = g.nMass, p = g.n, r = g.r1, s = g.r2, t = b.vx - s.y * b.w - (a.vx - r.y * a.w),
                x = b.vy + s.x * b.w - (a.vy + r.x * a.w), w = t * p.x + x * p.y, v = (t + d.x) * -p.y + (x + d.y) * p.x, x = g.jBias;
            g.jBias = h(x + (g.bias - (p.x * (b.v_biasx - s.y * b.w_bias - a.v_biasx + r.y * a.w_bias) + p.y * (s.x * b.w_bias + b.v_biasy - r.x * a.w_bias - a.v_biasy))) * n, 0);
            t = g.jnAcc;
            g.jnAcc = h(t + -(g.bounce + w) * n, 0);
            w = e * g.jnAcc;
            n = g.jtAcc;
            g.jtAcc = u(n + -v * g.tMass, -w, w);
            w = p.x * (g.jBias - x);
            x = p.y * (g.jBias - x);
            tb(a, -w, -x, r);
            tb(b, w, x, s);
            t = g.jnAcc - t;
            g = g.jtAcc - n;
            ka(a, b, r, s, p.x * t - p.y * g, p.x * g + p.y * t)
        }
    };
    aa.prototype.callSeparate = function (a) {
        a.lookupHandler(this.a.collision_type,
            this.b.collision_type).separate(this, a)
    };
    aa.prototype.next = function (a) {
        return this.body_a == a ? this.thread_a_next : this.thread_b_next
    };
    var eb = 0, ia = function (a, b, d, e) {
        this.p = a;
        this.n = b;
        this.dist = d;
        this.r1 = this.r2 = y;
        this.jnAcc = this.jtAcc = this.jBias = this.nMass = this.tMass = this.bounce = this.bias = 0;
        this.hash = e;
        eb++
    }, da = [], ja = function (a, b, d, e) {
        e = d + e;
        b = C(b, a);
        var f = H(b);
        if (!(f >= e * e))return f = Math.sqrt(f), new ia(B(a, I(b, 0.5 + (d - 0.5 * e) / (f ? f : Infinity))), f ? I(b, 1 / f) : new w(1, 0), f - e, 0)
    }, Na = 0, Oa = function (a, b) {
        var d = 0,
            e = a.valueOnAxis(b[0].n, b[0].d);
        if (0 < e)return -1;
        for (var f = 1; f < b.length; f++) {
            var g = a.valueOnAxis(b[f].n, b[f].d);
            if (0 < g)return -1;
            g > e && (e = g, d = f)
        }
        Na = e;
        return d
    }, Pa = function (a, b, d, e) {
        for (var f = [], g = a.tVerts, h = 0; h < g.length; h += 2) {
            var p = g[h], r = g[h + 1];
            b.containsVert(p, r) && f.push(new ia(new w(p, r), d, e, n(a.hashid, h >> 1)))
        }
        g = b.tVerts;
        for (h = 0; h < g.length; h += 2)p = g[h], r = g[h + 1], a.containsVert(p, r) && f.push(new ia(new w(p, r), d, e, n(b.hashid, h >> 1)));
        if (!f.length) {
            f = [];
            g = a.tVerts;
            for (h = 0; h < g.length; h += 2)p = g[h], r = g[h + 1],
            b.containsVertPartial(p, r, E(d)) && f.push(new ia(new w(p, r), d, e, n(a.hashid, h)));
            g = b.tVerts;
            for (h = 0; h < g.length; h += 2)p = g[h], r = g[h + 1], a.containsVertPartial(p, r, d) && f.push(new ia(new w(p, r), d, e, n(b.hashid, h)))
        }
        return a = f
    }, Qa = function (a, b, d) {
        var e = A(b, a.ta) - a.r;
        a = A(b, a.tb) - a.r;
        return g(e, a) - d
    }, Ra = function (a, b, d, e, f) {
        for (var g = L(b.tn, b.ta), h = L(b.tn, b.tb), p = I(b.tn, f), r = d.tVerts, s = 0; s < r.length; s += 2) {
            var t = r[s], u = r[s + 1];
            if (t * p.x + u * p.y < A(b.tn, b.ta) * f + b.r) {
                var x = b.tn.x * u - b.tn.y * t;
                g >= x && x >= h && a.push(new ia(new w(t,
                    u), p, e, n(d.hashid, s)))
            }
        }
    };
    pa.prototype.collisionCode = 0;
    la.prototype.collisionCode = 1;
    ca.prototype.collisionCode = 2;
    pa.prototype.collisionTable = [function (a, b) {
        var d = ja(a.tc, b.tc, a.r, b.r);
        return d ? [d] : da
    }, function (a, b) {
        var d = b.ta, e = a.tc, f = C(b.tb, d), g = x(A(f, C(e, d)) / H(f)), d = B(d, I(f, g));
        return (e = ja(e, d, a.r, b.r)) ? (d = e.n, 0 === g && 0 > A(d, b.a_tangent) || 1 === g && 0 > A(d, b.b_tangent) ? da : [e]) : da
    }, function (a, b) {
        for (var d = b.tPlanes, e = 0, f = A(d[0].n, a.tc) - d[0].d - a.r, g = 0; g < d.length; g++) {
            var h = A(d[g].n, a.tc) - d[g].d - a.r;
            if (0 <
                h)return da;
            h > f && (f = h, e = g)
        }
        var d = d[e].n, n = b.tVerts, p = n.length, r = e << 1, e = n[r], g = n[r + 1], h = n[(r + 2) % p], n = n[(r + 3) % p], p = d.x * g - d.y * e, r = d.x * n - d.y * h, s = L(d, a.tc);
        if (s < r) {
            var t = ja(a.tc, new w(h, n), a.r, 0, t);
            return t ? [t] : da
        }
        return s < p ? [new ia(C(a.tc, I(d, a.r + f / 2)), E(d), f, 0)] : (t = ja(a.tc, new w(e, g), a.r, 0, t)) ? [t] : da
    }];
    la.prototype.collisionTable = [null, function (a, b) {
        return da
    }, function (a, b) {
        var d = [], e = b.tPlanes, f = e.length, g = A(a.tn, a.ta), h = b.valueOnAxis(a.tn, g) - a.r, g = b.valueOnAxis(E(a.tn), -g) - a.r;
        if (0 < g || 0 < h)return da;
        var p = 0, r = Qa(a, e[0].n, e[0].d);
        if (0 < r)return da;
        for (var s = 0; s < f; s++) {
            var t = Qa(a, e[s].n, e[s].d);
            if (0 < t)return da;
            t > r && (r = t, p = s)
        }
        e = E(e[p].n);
        s = B(a.ta, I(e, a.r));
        t = B(a.tb, I(e, a.r));
        b.containsVert(s.x, s.y) && d.push(new ia(s, e, r, n(a.hashid, 0)));
        b.containsVert(t.x, t.y) && d.push(new ia(t, e, r, n(a.hashid, 1)));
        if (h >= r || g >= r)h > g ? Ra(d, a, b, h, 1) : Ra(d, a, b, g, -1);
        if (0 === d.length) {
            h = 2 * p;
            g = b.tVerts;
            r = new w(g[h], g[h + 1]);
            if ((p = ja(a.ta, r, a.r, 0, d)) || (p = ja(a.tb, r, a.r, 0, d)))return [p];
            f *= 2;
            f = new w(g[(h + 2) % f], g[(h + 3) % f]);
            if ((p =
                    ja(a.ta, f, a.r, 0, d)) || (p = ja(a.tb, f, a.r, 0, d)))return [p]
        }
        return d
    }];
    ca.prototype.collisionTable = [null, null, function (a, b) {
        var d = Oa(b, a.tPlanes);
        if (-1 == d)return da;
        var e = Na, f = Oa(a, b.tPlanes);
        if (-1 == f)return da;
        var g = Na;
        return e > g ? Pa(a, b, a.tPlanes[d].n, e) : Pa(a, b, E(b.tPlanes[f].n), g)
    }];
    var ya = a.collideShapes = function (a, d) {
        b(a.collisionCode <= d.collisionCode, "Collided shapes must be sorted by type");
        return a.collisionTable[d.collisionCode](a, d)
    }, Sa = new na, T = a.Space = function () {
        this.curr_dt = this.stamp = 0;
        this.bodies =
            [];
        this.rousedBodies = [];
        this.sleepingComponents = [];
        this.staticShapes = new $(null);
        this.activeShapes = new $(this.staticShapes);
        this.arbiters = [];
        this.contactBuffersHead = null;
        this.cachedArbiters = {};
        this.constraints = [];
        this.locked = 0;
        this.collisionHandlers = {};
        this.defaultHandler = Sa;
        this.postStepCallbacks = [];
        this.iterations = 10;
        this.gravity = y;
        this.damping = 1;
        this.idleSpeedThreshold = 0;
        this.sleepTimeThreshold = Infinity;
        this.collisionSlop = 0.1;
        this.collisionBias = Math.pow(0.9, 60);
        this.collisionPersistence = 3;
        this.enableContactGraph = !1;
        this.staticBody = new S(Infinity, Infinity);
        this.staticBody.nodeIdleTime = Infinity;
        this.collideShapes = this.makeCollideShapes()
    };
    T.prototype.getCurrentTimeStep = function () {
        return this.curr_dt
    };
    T.prototype.setIterations = function (a) {
        this.iterations = a
    };
    T.prototype.isLocked = function () {
        return this.locked
    };
    var ga = function (a) {
        b(!a.locked, "This addition/removal cannot be done safely during a call to cpSpaceStep()  or during a query. Put these calls into a post-step callback.")
    };
    T.prototype.addCollisionHandler =
        function (a, b, d, e, f, g) {
            ga(this);
            this.removeCollisionHandler(a, b);
            var h = new na;
            h.a = a;
            h.b = b;
            d && (h.begin = d);
            e && (h.preSolve = e);
            f && (h.postSolve = f);
            g && (h.separate = g);
            this.collisionHandlers[n(a, b)] = h
        };
    T.prototype.removeCollisionHandler = function (a, b) {
        ga(this);
        delete this.collisionHandlers[n(a, b)]
    };
    T.prototype.setDefaultCollisionHandler = function (a, b, d, e) {
        ga(this);
        var f = new na;
        a && (f.begin = a);
        b && (f.preSolve = b);
        d && (f.postSolve = d);
        e && (f.separate = e);
        this.defaultHandler = f
    };
    T.prototype.lookupHandler = function (a, b) {
        return this.collisionHandlers[n(a,
                b)] || this.defaultHandler
    };
    T.prototype.addShape = function (a) {
        var d = a.body;
        if (d.isStatic())return this.addStaticShape(a);
        b(!a.space, "This shape is already added to a space and cannot be added to another.");
        ga(this);
        d.activate();
        d.addShape(a);
        a.update(d.p, d.rot);
        this.activeShapes.insert(a, a.hashid);
        a.space = this;
        return a
    };
    T.prototype.addStaticShape = function (a) {
        b(!a.space, "This shape is already added to a space and cannot be added to another.");
        ga(this);
        var d = a.body;
        d.addShape(a);
        a.update(d.p, d.rot);
        this.staticShapes.insert(a,
            a.hashid);
        a.space = this;
        return a
    };
    T.prototype.addBody = function (a) {
        b(!a.isStatic(), "Static bodies cannot be added to a space as they are not meant to be simulated.");
        b(!a.space, "This body is already added to a space and cannot be added to another.");
        ga(this);
        this.bodies.push(a);
        a.space = this;
        return a
    };
    T.prototype.addConstraint = function (a) {
        b(!a.space, "This shape is already added to a space and cannot be added to another.");
        ga(this);
        var d = a.a, e = a.b;
        d.activate();
        e.activate();
        this.constraints.push(a);
        a.next_a =
            d.constraintList;
        d.constraintList = a;
        a.next_b = e.constraintList;
        e.constraintList = a;
        a.space = this;
        return a
    };
    T.prototype.filterArbiters = function (a, b) {
        for (var d in this.cachedArbiters) {
            var e = this.cachedArbiters[d];
            if (a === e.body_a && (b === e.a || null === b) || a === e.body_b && (b === e.b || null === b))b && "cached" !== e.state && e.callSeparate(this), e.unthread(), p(this.arbiters, e), delete this.cachedArbiters[d]
        }
    };
    T.prototype.removeShape = function (a) {
        var d = a.body;
        d.isStatic() ? this.removeStaticShape(a) : (b(this.containsShape(a),
            "Cannot remove a shape that was not added to the space. (Removed twice maybe?)"), ga(this), d.activate(), d.removeShape(a), this.filterArbiters(d, a), this.activeShapes.remove(a, a.hashid), a.space = null)
    };
    T.prototype.removeStaticShape = function (a) {
        b(this.containsShape(a), "Cannot remove a static or sleeping shape that was not added to the space. (Removed twice maybe?)");
        ga(this);
        var d = a.body;
        d.isStatic() && d.activateStatic(a);
        d.removeShape(a);
        this.filterArbiters(d, a);
        this.staticShapes.remove(a, a.hashid);
        a.space =
            null
    };
    T.prototype.removeBody = function (a) {
        b(this.containsBody(a), "Cannot remove a body that was not added to the space. (Removed twice maybe?)");
        ga(this);
        a.activate();
        p(this.bodies, a);
        a.space = null
    };
    T.prototype.removeConstraint = function (a) {
        b(this.containsConstraint(a), "Cannot remove a constraint that was not added to the space. (Removed twice maybe?)");
        ga(this);
        a.a.activate();
        a.b.activate();
        p(this.constraints, a);
        a.a.removeConstraint(a);
        a.b.removeConstraint(a);
        a.space = null
    };
    T.prototype.containsShape =
        function (a) {
            return a.space === this
        };
    T.prototype.containsBody = function (a) {
        return a.space == this
    };
    T.prototype.containsConstraint = function (a) {
        return a.space == this
    };
    T.prototype.uncacheArbiter = function (a) {
        delete this.cachedArbiters[n(a.a.hashid, a.b.hashid)];
        p(this.arbiters, a)
    };
    T.prototype.eachBody = function (a) {
        this.lock();
        for (var b = this.bodies, d = 0; d < b.length; d++)a(b[d]);
        b = this.sleepingComponents;
        for (d = 0; d < b.length; d++)for (var e = b[d]; e;) {
            var f = e.nodeNext;
            a(e);
            e = f
        }
        this.unlock(!0)
    };
    T.prototype.eachShape = function (a) {
        this.lock();
        this.activeShapes.each(a);
        this.staticShapes.each(a);
        this.unlock(!0)
    };
    T.prototype.eachConstraint = function (a) {
        this.lock();
        for (var b = this.constraints, d = 0; d < b.length; d++)a(b[d]);
        this.unlock(!0)
    };
    T.prototype.reindexStatic = function () {
        b(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
        this.staticShapes.each(function (a) {
            var b = a.body;
            a.update(b.p, b.rot)
        });
        this.staticShapes.reindex()
    };
    T.prototype.reindexShape = function (a) {
        b(!this.locked,
            "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
        var d = a.body;
        a.update(d.p, d.rot);
        this.activeShapes.reindexObject(a, a.hashid);
        this.staticShapes.reindexObject(a, a.hashid)
    };
    T.prototype.reindexShapesForBody = function (a) {
        for (a = a.shapeList; a; a = a.next)this.reindexShape(a)
    };
    T.prototype.useSpatialHash = function (a, b) {
        throw Error("Spatial Hash not implemented.");
    };
    T.prototype.activateBody = function (a) {
        b(!a.isRogue(), "Internal error: Attempting to activate a rogue body.");
        if (this.locked)-1 === this.rousedBodies.indexOf(a) && this.rousedBodies.push(a); else {
            this.bodies.push(a);
            for (var d = 0; d < a.shapeList.length; d++) {
                var e = a.shapeList[d];
                this.staticShapes.remove(e, e.hashid);
                this.activeShapes.insert(e, e.hashid)
            }
            for (d = a.arbiterList; d; d = d.next(a))if (e = d.body_a, a === e || e.isStatic()) {
                var e = d.a, f = d.b;
                this.cachedArbiters[n(e.hashid, f.hashid)] = d;
                d.stamp = this.stamp;
                d.handler = this.lookupHandler(e.collision_type, f.collision_type);
                this.arbiters.push(d)
            }
            for (d = a.constraintList; d; d = d.nodeNext)e =
                d.a, (a === e || e.isStatic()) && this.constraints.push(d)
        }
    };
    T.prototype.deactivateBody = function (a) {
        b(!a.isRogue(), "Internal error: Attempting to deactivate a rogue body.");
        p(this.bodies, a);
        for (var d = 0; d < a.shapeList.length; d++) {
            var e = a.shapeList[d];
            this.activeShapes.remove(e, e.hashid);
            this.staticShapes.insert(e, e.hashid)
        }
        for (e = a.arbiterList; e; e = e.next(a))d = e.body_a, (a === d || d.isStatic()) && this.uncacheArbiter(e);
        for (e = a.constraintList; e; e = e.nodeNext)d = e.a, (a === d || d.isStatic()) && p(this.constraints, e)
    };
    S.prototype.activate =
        function () {
            if (!this.isRogue()) {
                this.nodeIdleTime = 0;
                var a = this ? this.nodeRoot : null;
                if (a && a.isSleeping(a)) {
                    b(!a.isRogue(), "Internal Error: componentActivate() called on a rogue body.");
                    for (var d = a.space, e = a; e;) {
                        var f = e.nodeNext;
                        e.nodeIdleTime = 0;
                        e.nodeRoot = null;
                        e.nodeNext = null;
                        d.activateBody(e);
                        e = f
                    }
                    p(d.sleepingComponents, a)
                }
            }
        };
    S.prototype.activateStatic = function (a) {
        b(this.isStatic(), "Body.activateStatic() called on a non-static body.");
        for (var d = this.arbiterList; d; d = d.next(this))a && a != d.a && a != d.b || (d.body_a ==
        this ? d.body_b : d.body_a).activate()
    };
    S.prototype.pushArbiter = function (a) {
        d(null === (a.body_a === this ? a.thread_a_next : a.thread_b_next), "Internal Error: Dangling contact graph pointers detected. (A)");
        d(null === (a.body_a === this ? a.thread_a_prev : a.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (B)");
        var b = this.arbiterList;
        d(null === b || null === (b.body_a === this ? b.thread_a_prev : b.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (C)");
        a.body_a === this ? a.thread_a_next =
            b : a.thread_b_next = b;
        b && (b.body_a === this ? b.thread_a_prev = a : b.thread_b_prev = a);
        this.arbiterList = a
    };
    var za = function (a, b) {
        if (!b.isRogue()) {
            var e = b ? b.nodeRoot : null;
            if (null == e) {
                b.nodeRoot = a;
                b !== a && (b.nodeNext = a.nodeNext, a.nodeNext = b);
                for (e = b.arbiterList; e; e = e.next(b))za(a, b == e.body_a ? e.body_b : e.body_a);
                for (e = b.constraintList; e; e = e.next(b))za(a, b == e.a ? e.b : e.a)
            } else d(e === a, "Internal Error: Inconsistency detected in the contact graph.")
        }
    };
    T.prototype.processComponents = function (a) {
        for (var b = Infinity !== this.sleepTimeThreshold,
                 e = this.bodies, f = 0; f < e.length; f++) {
            var g = e[f];
            d(null === g.nodeNext, "Internal Error: Dangling next pointer detected in contact graph.");
            d(null === g.nodeRoot, "Internal Error: Dangling root pointer detected in contact graph.")
        }
        if (b)for (var h = (f = this.idleSpeedThreshold) ? f * f : H(this.gravity) * a * a, f = 0; f < e.length; f++) {
            var g = e[f], n = h ? g.m * h : 0;
            g.nodeIdleTime = g.kineticEnergy() > n ? 0 : g.nodeIdleTime + a
        }
        h = this.arbiters;
        f = 0;
        for (n = h.length; f < n; f++) {
            var p = h[f], g = p.body_a;
            a = p.body_b;
            b && ((a.isRogue() && !a.isStatic() || g.isSleeping()) &&
            g.activate(), (g.isRogue() && !g.isStatic() || a.isSleeping()) && a.activate());
            g.pushArbiter(p);
            a.pushArbiter(p)
        }
        if (b) {
            b = this.constraints;
            for (f = 0; f < b.length; f++)a = b[f], g = a.a, a = a.b, a.isRogue() && !a.isStatic() && g.activate(), g.isRogue() && !g.isStatic() && a.activate();
            for (f = 0; f < e.length;) {
                g = e[f];
                if (null === (g ? g.nodeRoot : null)) {
                    za(g, g);
                    a:{
                        for (b = g; b; b = b.nodeNext)if (b.nodeIdleTime < this.sleepTimeThreshold) {
                            b = !0;
                            break a
                        }
                        b = !1
                    }
                    if (!b) {
                        this.sleepingComponents.push(g);
                        for (b = g; b; b = b.nodeNext)this.deactivateBody(b);
                        continue
                    }
                }
                f++;
                g.nodeRoot = null;
                g.nodeNext = null
            }
        }
    };
    S.prototype.sleep = function () {
        this.sleepWithGroup(null)
    };
    S.prototype.sleepWithGroup = function (a) {
        b(!this.isStatic() && !this.isRogue(), "Rogue and static bodies cannot be put to sleep.");
        var d = this.space;
        b(d, "Cannot put a rogue body to sleep.");
        b(!d.locked, "Bodies cannot be put to sleep during a query or a call to cpSpaceStep(). Put these calls into a post-step callback.");
        b(null === a || a.isSleeping(), "Cannot use a non-sleeping body as a group identifier.");
        if (this.isSleeping())b((this ?
                this.nodeRoot : null) === (a ? a.nodeRoot : null), "The body is already sleeping and it's group cannot be reassigned."); else {
            for (var e = 0; e < this.shapeList.length; e++)this.shapeList[e].update(this.p, this.rot);
            d.deactivateBody(this);
            a ? (this.nodeRoot = a = a ? a.nodeRoot : null, this.nodeNext = a.nodeNext, this.nodeIdleTime = 0, a.nodeNext = this) : (this.nodeRoot = this, this.nodeNext = null, this.nodeIdleTime = 0, d.sleepingComponents.push(this));
            p(d.bodies, this)
        }
    };
    T.prototype.activateShapesTouchingShape = function (a) {
        Infinity !== this.sleepTimeThreshold &&
        this.shapeQuery(a, function (a, b) {
            a.body.activate()
        })
    };
    T.prototype.pointQuery = function (a, b, d, e) {
        var f = function (f) {
            (!f.group || d !== f.group) && b & f.layers && f.pointQuery(a) && e(f)
        }, g = new X(a.x, a.y, a.x, a.y);
        this.lock();
        this.activeShapes.query(g, f);
        this.staticShapes.query(g, f);
        this.unlock(!0)
    };
    T.prototype.pointQueryFirst = function (a, b, d) {
        var e = null;
        this.pointQuery(a, b, d, function (a) {
            a.sensor || (e = a)
        });
        return e
    };
    T.prototype.nearestPointQuery = function (a, b, d, e, f) {
        var g = function (g) {
            if ((!g.group || e !== g.group) && d & g.layers) {
                var h =
                    g.nearestPointQuery(a);
                h.d < b && f(g, h.d, h.p)
            }
        }, h = fa(a, b);
        this.lock();
        this.activeShapes.query(h, g);
        this.staticShapes.query(h, g);
        this.unlock(!0)
    };
    T.prototype.nearestPointQueryNearest = function (a, b, d, e) {
        var f, g = function (g) {
            g.group && e === g.group || !(d & g.layers) || g.sensor || (g = g.nearestPointQuery(a), g.d < b && (!f || g.d < f.d) && (f = g))
        }, h = fa(a, b);
        this.activeShapes.query(h, g);
        this.staticShapes.query(h, g);
        return f
    };
    a.SHAPE_FILTER_ALL = {group: a.NO_GROUP, categories: a.ALL_CATEGORIES, mask: a.ALL_CATEGORIES};
    T.prototype.pointQueryNearest =
        function (a, b, d) {
            a = this.nearestPointQueryNearest(a, b, d.mask, d.group);
            "undefined" != typeof a && (a.distance = a.d, a.point = a.p);
            return a
        };
    T.prototype.segmentQuery = function (a, b, d, e, f) {
        var g = function (g) {
            var h;
            (!g.group || e !== g.group) && d & g.layers && (h = g.segmentQuery(a, b)) && f(g, h.t, h.n);
            return 1
        };
        this.lock();
        this.staticShapes.segmentQuery(a, b, 1, g);
        this.activeShapes.segmentQuery(a, b, 1, g);
        this.unlock(!0)
    };
    T.prototype.segmentQueryFirst = function (b, d, e, f) {
        var g = null, h = function (a) {
            var h;
            (!a.group || f !== a.group) && e & a.layers && !a.sensor && (h = a.segmentQuery(b, d)) && (null === g || h.t < g.t) && (g = h);
            return g ? g.t : 1
        };
        this.staticShapes.segmentQuery(b, d, 1, h);
        this.activeShapes.segmentQuery(b, d, g ? g.t : 1, h);
        g && "null" !== g && "undefined" !== g && (g.normal = g.n, g.alpha = g.t, g.p = g.point = a.v.lerp(b, d, g.t));
        return g
    };
    T.prototype.bbQuery = function (a, b, d, e) {
        var f = function (f) {
            (!f.group || d !== f.group) && b & f.layers && a.l <= f.bb_r && f.bb_l <= a.r && a.b <= f.bb_t && f.bb_b <= a.t && e(f)
        };
        this.lock();
        this.activeShapes.query(a, f);
        this.staticShapes.query(a, f);
        this.unlock(!0)
    };
    T.prototype.shapeQuery = function (a, b) {
        var d = a.body;
        d && a.update(d.p, d.rot);
        var d = new X(a.bb_l, a.bb_b, a.bb_r, a.bb_t), e = !1, f = function (d) {
            if ((!a.group || a.group !== d.group) && a.layers & d.layers && a !== d) {
                var f;
                if (a.collisionCode <= d.collisionCode)f = ya(a, d); else {
                    f = ya(d, a);
                    for (var g = 0; g < f.length; g++)f[g].n = E(f[g].n)
                }
                if (f.length && (e = !(a.sensor || d.sensor), b)) {
                    for (var h = Array(f.length), g = 0; g < f.length; g++)h[g] = new La(f[g].p, f[g].n, f[g].dist);
                    b(d, h)
                }
            }
        };
        this.lock();
        this.activeShapes.query(d, f);
        this.staticShapes.query(d,
            f);
        this.unlock(!0);
        return e
    };
    T.prototype.addPostStepCallback = function (a) {
        d(this.locked, "Adding a post-step callback when the space is not locked is unnecessary. Post-step callbacks will not called until the end of the next call to cpSpaceStep() or the next query.");
        this.postStepCallbacks.push(a)
    };
    T.prototype.runPostStepCallbacks = function () {
        for (var a = 0; a < this.postStepCallbacks.length; a++)this.postStepCallbacks[a]();
        this.postStepCallbacks = []
    };
    T.prototype.lock = function () {
        this.locked++
    };
    T.prototype.unlock =
        function (a) {
            this.locked--;
            b(0 <= this.locked, "Internal Error: Space lock underflow.");
            if (0 === this.locked && a) {
                a = this.rousedBodies;
                for (var d = 0; d < a.length; d++)this.activateBody(a[d]);
                a.length = 0;
                this.runPostStepCallbacks()
            }
        };
    T.prototype.makeCollideShapes = function () {
        var a = this;
        return function (b, d) {
            if (b.bb_l <= d.bb_r && d.bb_l <= b.bb_r && b.bb_b <= d.bb_t && d.bb_b <= b.bb_t && b.body !== d.body && (!b.group || b.group !== d.group) && b.layers & d.layers) {
                var e = a.lookupHandler(b.collision_type, d.collision_type), f = b.sensor || d.sensor;
                if (!f || e !== Sa) {
                    if (b.collisionCode > d.collisionCode) {
                        var g = b;
                        b = d;
                        d = g
                    }
                    g = ya(b, d);
                    if (0 !== g.length) {
                        var h = n(b.hashid, d.hashid), p = a.cachedArbiters[h];
                        p || (p = a.cachedArbiters[h] = new aa(b, d));
                        p.update(g, e, b, d);
                        "first coll" != p.state || e.begin(p, a) || p.ignore();
                        "ignore" !== p.state && e.preSolve(p, a) && !f ? a.arbiters.push(p) : (p.contacts = null, "ignore" !== p.state && (p.state = "normal"));
                        p.stamp = a.stamp
                    }
                }
            }
        }
    };
    T.prototype.arbiterSetFilter = function (a) {
        var b = this.stamp - a.stamp, d = a.body_a, e = a.body_b;
        if ((d.isStatic() || d.isSleeping()) &&
            (e.isStatic() || e.isSleeping()))return !0;
        1 <= b && "cached" != a.state && (a.callSeparate(this), a.state = "cached");
        return b >= this.collisionPersistence ? (a.contacts = null, !1) : !0
    };
    var fb = function (a) {
        var b = a.body;
        a.update(b.p, b.rot)
    };
    T.prototype.step = function (a) {
        if (0 !== a) {
            b(0 === y.x && 0 === y.y, "vzero is invalid");
            this.stamp++;
            var d = this.curr_dt;
            this.curr_dt = a;
            var e, f, g = this.bodies, h = this.constraints, n = this.arbiters;
            for (e = 0; e < n.length; e++) {
                var p = n[e];
                p.state = "normal";
                p.body_a.isSleeping() || p.body_b.isSleeping() || p.unthread()
            }
            n.length =
                0;
            this.lock();
            for (e = 0; e < g.length; e++)g[e].position_func(a);
            this.activeShapes.each(fb);
            this.activeShapes.reindexQuery(this.collideShapes);
            this.unlock(!1);
            this.processComponents(a);
            this.lock();
            for (f in this.cachedArbiters)this.arbiterSetFilter(this.cachedArbiters[f]) || delete this.cachedArbiters[f];
            f = this.collisionSlop;
            p = 1 - Math.pow(this.collisionBias, a);
            for (e = 0; e < n.length; e++)n[e].preStep(a, f, p);
            for (e = 0; e < h.length; e++)f = h[e], f.preSolve(this), f.preStep(a);
            f = Math.pow(this.damping, a);
            p = this.gravity;
            for (e =
                     0; e < g.length; e++)g[e].velocity_func(p, f, a);
            a = 0 === d ? 0 : a / d;
            for (e = 0; e < n.length; e++)n[e].applyCachedImpulse(a);
            for (e = 0; e < h.length; e++)h[e].applyCachedImpulse(a);
            for (e = 0; e < this.iterations; e++) {
                for (a = 0; a < n.length; a++)n[a].applyImpulse();
                for (a = 0; a < h.length; a++)h[a].applyImpulse()
            }
            for (e = 0; e < h.length; e++)h[e].postSolve(this);
            for (e = 0; e < n.length; e++)n[e].handler.postSolve(n[e], this);
            this.unlock(!0)
        }
    };
    var Aa = function (a, b, d, e) {
        return new w(b.vx + -e.y * b.w - (a.vx + -d.y * a.w), b.vy + e.x * b.w - (a.vy + d.x * a.w))
    }, Ba = function (a,
                      b, d, e, f) {
        return (b.vx + -e.y * b.w - (a.vx + -d.y * a.w)) * f.x + (b.vy + e.x * b.w - (a.vy + d.x * a.w)) * f.y
    }, rb = function (a, b, d, e) {
        a.vx += b * a.m_inv;
        a.vy += d * a.m_inv;
        a.w += a.i_inv * (e.x * d - e.y * b)
    }, ka = function (a, b, d, e, f, g) {
        rb(a, -f, -g, d);
        rb(b, f, g, e)
    }, tb = function (a, b, d, e) {
        a.v_biasx += b * a.m_inv;
        a.v_biasy += d * a.m_inv;
        a.w_bias += a.i_inv * (e.x * d - e.y * b)
    }, ub = function (a, b, d) {
        b = L(b, d);
        return a.m_inv + a.i_inv * b * b
    }, gb = function (a, b, e, f, g) {
        a = ub(a, e, g) + ub(b, f, g);
        d(0 !== a, "Unsolvable collision or constraint.");
        return a
    }, vb = function (a, b, e, f, g, h) {
        var n;
        n = a.m_inv + b.m_inv;
        var p = a.i_inv, r = e.x * e.x * p;
        a = -e.x * e.y * p;
        e = n + e.y * e.y * p;
        n += r;
        p = b.i_inv;
        b = f.x * f.x * p;
        r = -f.x * f.y * p;
        e += f.y * f.y * p;
        f = 0 + a + r;
        a = 0 + a + r;
        n += b;
        b = e * n - f * a;
        d(0 !== b, "Unsolvable constraint.");
        b = 1 / b;
        g.x = n * b;
        g.y = -f * b;
        h.x = -a * b;
        h.y = e * b
    }, Z = a.Constraint = function (a, b) {
        this.a = a;
        this.b = b;
        this.next_b = this.next_a = this.space = null;
        this.maxForce = Infinity;
        this.errorBias = Math.pow(0.9, 60);
        this.maxBias = Infinity
    };
    Z.prototype.activateBodies = function () {
        this.a && this.a.activate();
        this.b && this.b.activate()
    };
    Z.prototype.preStep =
        function (a) {
        };
    Z.prototype.applyCachedImpulse = function (a) {
    };
    Z.prototype.applyImpulse = function () {
    };
    Z.prototype.getImpulse = function () {
        return 0
    };
    Z.prototype.preSolve = function (a) {
    };
    Z.prototype.postSolve = function (a) {
    };
    Z.prototype.next = function (a) {
        return this.a === a ? this.next_a : this.next_b
    };
    var hb = a.PinJoint = function (a, b, e, f) {
        Z.call(this, a, b);
        this.anchr1 = e;
        this.anchr2 = f;
        a = a ? B(a.p, M(e, a.rot)) : e;
        b = b ? B(b.p, M(f, b.rot)) : f;
        this.dist = D(C(b, a));
        d(0 < this.dist, "You created a 0 length pin joint. A pivot joint will be much more stable.");
        this.n = this.r1 = this.r2 = null;
        this.bias = this.jnAcc = this.jnMax = this.nMass = 0
    };
    hb.prototype = Object.create(Z.prototype);
    hb.prototype.preStep = function (a) {
        var b = this.a, d = this.b;
        this.r1 = M(this.anchr1, b.rot);
        this.r2 = M(this.anchr2, d.rot);
        var e = C(B(d.p, this.r2), B(b.p, this.r1)), f = D(e);
        this.n = I(e, 1 / (f ? f : Infinity));
        this.nMass = 1 / gb(b, d, this.r1, this.r2, this.n);
        b = this.maxBias;
        this.bias = u(-(1 - Math.pow(this.errorBias, a)) * (f - this.dist) / a, -b, b);
        this.jnMax = this.maxForce * a
    };
    hb.prototype.applyCachedImpulse = function (a) {
        a =
            I(this.n, this.jnAcc * a);
        ka(this.a, this.b, this.r1, this.r2, a.x, a.y)
    };
    hb.prototype.applyImpulse = function () {
        var a = this.a, b = this.b, d = this.n, e = Ba(a, b, this.r1, this.r2, d), e = (this.bias - e) * this.nMass, f = this.jnAcc;
        this.jnAcc = u(f + e, -this.jnMax, this.jnMax);
        e = this.jnAcc - f;
        ka(a, b, this.r1, this.r2, d.x * e, d.y * e)
    };
    hb.prototype.getImpulse = function () {
        return Math.abs(this.jnAcc)
    };
    var ib = a.SlideJoint = function (a, b, d, e, f, g) {
        Z.call(this, a, b);
        this.anchr1 = d;
        this.anchr2 = e;
        this.min = f;
        this.max = g;
        this.r1 = this.r2 = this.n = null;
        this.bias =
            this.jnAcc = this.jnMax = this.nMass = 0
    };
    ib.prototype = Object.create(Z.prototype);
    ib.prototype.preStep = function (a) {
        var b = this.a, d = this.b;
        this.r1 = M(this.anchr1, b.rot);
        this.r2 = M(this.anchr2, d.rot);
        var e = C(B(d.p, this.r2), B(b.p, this.r1)), f = D(e), g = 0;
        f > this.max ? (g = f - this.max, this.n = Y(e)) : f < this.min ? (g = this.min - f, this.n = E(Y(e))) : (this.n = y, this.jnAcc = 0);
        this.nMass = 1 / gb(b, d, this.r1, this.r2, this.n);
        b = this.maxBias;
        this.bias = u(-(1 - Math.pow(this.errorBias, a)) * g / a, -b, b);
        this.jnMax = this.maxForce * a
    };
    ib.prototype.applyCachedImpulse =
        function (a) {
            a *= this.jnAcc;
            ka(this.a, this.b, this.r1, this.r2, this.n.x * a, this.n.y * a)
        };
    ib.prototype.applyImpulse = function () {
        if (0 !== this.n.x || 0 !== this.n.y) {
            var a = this.a, b = this.b, d = this.n, e = Aa(a, b, this.r1, this.r2), e = A(e, d), e = (this.bias - e) * this.nMass, f = this.jnAcc;
            this.jnAcc = u(f + e, -this.jnMax, 0);
            e = this.jnAcc - f;
            ka(a, b, this.r1, this.r2, d.x * e, d.y * e)
        }
    };
    ib.prototype.getImpulse = function () {
        return Math.abs(this.jnAcc)
    };
    var jb = a.PivotJoint = function (a, b, d, e) {
        Z.call(this, a, b);
        "undefined" === typeof e && (e = d, d = a ? a.world2Local(e) :
            e, e = b ? b.world2Local(e) : e);
        this.anchr1 = d;
        this.anchr2 = e;
        this.r1 = this.r2 = y;
        this.k1 = new w(0, 0);
        this.k2 = new w(0, 0);
        this.jAcc = y;
        this.jMaxLen = 0;
        this.bias = y
    };
    jb.prototype = Object.create(Z.prototype);
    jb.prototype.preStep = function (a) {
        var b = this.a, d = this.b;
        this.r1 = M(this.anchr1, b.rot);
        this.r2 = M(this.anchr2, d.rot);
        vb(b, d, this.r1, this.r2, this.k1, this.k2);
        this.jMaxLen = this.maxForce * a;
        b = C(B(d.p, this.r2), B(b.p, this.r1));
        this.bias = V(I(b, -(1 - Math.pow(this.errorBias, a)) / a), this.maxBias)
    };
    jb.prototype.applyCachedImpulse =
        function (a) {
            ka(this.a, this.b, this.r1, this.r2, this.jAcc.x * a, this.jAcc.y * a)
        };
    jb.prototype.applyImpulse = function () {
        var a = this.a, b = this.b, d = Aa(a, b, this.r1, this.r2), d = C(this.bias, d), e = this.k2, d = new w(A(d, this.k1), A(d, e)), e = this.jAcc;
        this.jAcc = V(B(this.jAcc, d), this.jMaxLen);
        ka(a, b, this.r1, this.r2, this.jAcc.x - e.x, this.jAcc.y - e.y)
    };
    jb.prototype.getImpulse = function () {
        return D(this.jAcc)
    };
    var ta = a.GrooveJoint = function (a, b, d, e, f) {
        Z.call(this, a, b);
        this.grv_a = d;
        this.grv_b = e;
        this.grv_n = J(O(C(e, d)));
        this.anchr2 =
            f;
        this.grv_tn = null;
        this.clamp = 0;
        this.r1 = this.r2 = null;
        this.k1 = new w(0, 0);
        this.k2 = new w(0, 0);
        this.jAcc = y;
        this.jMaxLen = 0;
        this.bias = null
    };
    ta.prototype = Object.create(Z.prototype);
    ta.prototype.preStep = function (a) {
        var b = this.a, d = this.b, e = b.local2World(this.grv_a), f = b.local2World(this.grv_b), g = M(this.grv_n, b.rot), h = A(e, g);
        this.grv_tn = g;
        this.r2 = M(this.anchr2, d.rot);
        var n = L(B(d.p, this.r2), g);
        n <= L(e, g) ? (this.clamp = 1, this.r1 = C(e, b.p)) : n >= L(f, g) ? (this.clamp = -1, this.r1 = C(f, b.p)) : (this.clamp = 0, this.r1 = C(B(I(J(g),
            -n), I(g, h)), b.p));
        vb(b, d, this.r1, this.r2, this.k1, this.k2);
        this.jMaxLen = this.maxForce * a;
        b = C(B(d.p, this.r2), B(b.p, this.r1));
        this.bias = V(I(b, -(1 - Math.pow(this.errorBias, a)) / a), this.maxBias)
    };
    ta.prototype.applyCachedImpulse = function (a) {
        ka(this.a, this.b, this.r1, this.r2, this.jAcc.x * a, this.jAcc.y * a)
    };
    ta.prototype.grooveConstrain = function (a) {
        var b = this.grv_tn;
        a = 0 < this.clamp * L(a, b) ? a : Q(a, b);
        return V(a, this.jMaxLen)
    };
    ta.prototype.applyImpulse = function () {
        var a = this.a, b = this.b, d = Aa(a, b, this.r1, this.r2), d = C(this.bias,
            d), e = this.k2, d = new w(A(d, this.k1), A(d, e)), e = this.jAcc;
        this.jAcc = this.grooveConstrain(B(e, d));
        ka(a, b, this.r1, this.r2, this.jAcc.x - e.x, this.jAcc.y - e.y)
    };
    ta.prototype.getImpulse = function () {
        return D(this.jAcc)
    };
    ta.prototype.setGrooveA = function (a) {
        this.grv_a = a;
        this.grv_n = J(O(C(this.grv_b, a)));
        this.activateBodies()
    };
    ta.prototype.setGrooveB = function (a) {
        this.grv_b = a;
        this.grv_n = J(O(C(a, this.grv_a)));
        this.activateBodies()
    };
    var wb = function (a, b) {
        return (a.restLength - b) * a.stiffness
    }, kb = a.DampedSpring = function (a,
                                       b, d, e, f, g, h) {
        Z.call(this, a, b);
        this.anchr1 = d;
        this.anchr2 = e;
        this.restLength = f;
        this.stiffness = g;
        this.damping = h;
        this.springForceFunc = wb;
        this.target_vrn = this.v_coef = 0;
        this.r1 = this.r2 = null;
        this.nMass = 0;
        this.n = null
    };
    kb.prototype = Object.create(Z.prototype);
    kb.prototype.preStep = function (a) {
        var b = this.a, e = this.b;
        this.r1 = M(this.anchr1, b.rot);
        this.r2 = M(this.anchr2, e.rot);
        var f = C(B(e.p, this.r2), B(b.p, this.r1)), g = D(f);
        this.n = I(f, 1 / (g ? g : Infinity));
        f = gb(b, e, this.r1, this.r2, this.n);
        d(0 !== f, "Unsolvable this.");
        this.nMass =
            1 / f;
        this.target_vrn = 0;
        this.v_coef = 1 - Math.exp(-this.damping * a * f);
        g = this.springForceFunc(this, g);
        ka(b, e, this.r1, this.r2, this.n.x * g * a, this.n.y * g * a)
    };
    kb.prototype.applyCachedImpulse = function (a) {
    };
    kb.prototype.applyImpulse = function () {
        var a = this.a, b = this.b, d = Ba(a, b, this.r1, this.r2, this.n), e = (this.target_vrn - d) * this.v_coef;
        this.target_vrn = d + e;
        e *= this.nMass;
        ka(a, b, this.r1, this.r2, this.n.x * e, this.n.y * e)
    };
    kb.prototype.getImpulse = function () {
        return 0
    };
    var xb = function (a, b) {
        return (b - a.restAngle) * a.stiffness
    }, sb =
        a.DampedRotarySpring = function (a, b, d, e, f) {
            Z.call(this, a, b);
            this.restAngle = d;
            this.stiffness = e;
            this.damping = f;
            this.springTorqueFunc = xb;
            this.iSum = this.w_coef = this.target_wrn = 0
        };
    sb.prototype = Object.create(Z.prototype);
    sb.prototype.preStep = function (a) {
        var b = this.a, e = this.b, f = b.i_inv + e.i_inv;
        d(0 !== f, "Unsolvable spring.");
        this.iSum = 1 / f;
        this.w_coef = 1 - Math.exp(-this.damping * a * f);
        this.target_wrn = 0;
        a *= this.springTorqueFunc(this, b.a - e.a);
        b.w -= a * b.i_inv;
        e.w += a * e.i_inv
    };
    sb.prototype.applyImpulse = function () {
        var a =
            this.a, b = this.b, d = a.w - b.w, e = (this.target_wrn - d) * this.w_coef;
        this.target_wrn = d + e;
        d = e * this.iSum;
        a.w += d * a.i_inv;
        b.w -= d * b.i_inv
    };
    var lb = a.RotaryLimitJoint = function (a, b, d, e) {
        Z.call(this, a, b);
        this.min = d;
        this.max = e;
        this.iSum = this.bias = this.jMax = this.jAcc = 0
    };
    lb.prototype = Object.create(Z.prototype);
    lb.prototype.preStep = function (a) {
        var b = this.a, d = this.b, e = d.a - b.a, f = 0;
        e > this.max ? f = this.max - e : e < this.min && (f = this.min - e);
        this.iSum = 1 / (1 / b.i + 1 / d.i);
        b = this.maxBias;
        this.bias = u(-(1 - Math.pow(this.errorBias, a)) * f / a, -b,
            b);
        this.jMax = this.maxForce * a;
        this.bias || (this.jAcc = 0)
    };
    lb.prototype.applyCachedImpulse = function (a) {
        var b = this.a, d = this.b;
        a *= this.jAcc;
        b.w -= a * b.i_inv;
        d.w += a * d.i_inv
    };
    lb.prototype.applyImpulse = function () {
        if (this.bias) {
            var a = this.a, b = this.b, d = -(this.bias + (b.w - a.w)) * this.iSum, e = this.jAcc;
            this.jAcc = 0 > this.bias ? u(e + d, 0, this.jMax) : u(e + d, -this.jMax, 0);
            d = this.jAcc - e;
            a.w -= d * a.i_inv;
            b.w += d * b.i_inv
        }
    };
    lb.prototype.getImpulse = function () {
        return Math.abs(joint.jAcc)
    };
    var mb = a.RatchetJoint = function (a, b, d, e) {
        Z.call(this,
            a, b);
        this.angle = 0;
        this.phase = d;
        this.ratchet = e;
        this.angle = (b ? b.a : 0) - (a ? a.a : 0);
        this.iSum = this.bias = this.jAcc = this.jMax = 0
    };
    mb.prototype = Object.create(Z.prototype);
    mb.prototype.preStep = function (a) {
        var b = this.a, d = this.b, e = this.phase, f = this.ratchet, g = d.a - b.a, h = this.angle - g, n = 0;
        0 < h * f ? n = h : this.angle = Math.floor((g - e) / f) * f + e;
        this.iSum = 1 / (b.i_inv + d.i_inv);
        b = this.maxBias;
        this.bias = u(-(1 - Math.pow(this.errorBias, a)) * n / a, -b, b);
        this.jMax = this.maxForce * a;
        this.bias || (this.jAcc = 0)
    };
    mb.prototype.applyCachedImpulse = function (a) {
        var b =
            this.a, d = this.b;
        a *= this.jAcc;
        b.w -= a * b.i_inv;
        d.w += a * d.i_inv
    };
    mb.prototype.applyImpulse = function () {
        if (this.bias) {
            var a = this.a, b = this.b, d = this.ratchet, e = -(this.bias + (b.w - a.w)) * this.iSum, f = this.jAcc;
            this.jAcc = u((f + e) * d, 0, this.jMax * Math.abs(d)) / d;
            e = this.jAcc - f;
            a.w -= e * a.i_inv;
            b.w += e * b.i_inv
        }
    };
    mb.prototype.getImpulse = function (a) {
        return Math.abs(a.jAcc)
    };
    var Ta = a.GearJoint = function (a, b, d, e) {
        Z.call(this, a, b);
        this.phase = d;
        this.ratio = e;
        this.ratio_inv = 1 / e;
        this.iSum = this.bias = this.jMax = this.jAcc = 0
    };
    Ta.prototype =
        Object.create(Z.prototype);
    Ta.prototype.preStep = function (a) {
        var b = this.a, d = this.b;
        this.iSum = 1 / (b.i_inv * this.ratio_inv + this.ratio * d.i_inv);
        var e = this.maxBias;
        this.bias = u(-(1 - Math.pow(this.errorBias, a)) * (d.a * this.ratio - b.a - this.phase) / a, -e, e);
        this.jMax = this.maxForce * a
    };
    Ta.prototype.applyCachedImpulse = function (a) {
        var b = this.a, d = this.b;
        a *= this.jAcc;
        b.w -= a * b.i_inv * this.ratio_inv;
        d.w += a * d.i_inv
    };
    Ta.prototype.applyImpulse = function () {
        var a = this.a, b = this.b, d = (this.bias - (b.w * this.ratio - a.w)) * this.iSum, e = this.jAcc;
        this.jAcc = u(e + d, -this.jMax, this.jMax);
        d = this.jAcc - e;
        a.w -= d * a.i_inv * this.ratio_inv;
        b.w += d * b.i_inv
    };
    Ta.prototype.getImpulse = function () {
        return Math.abs(this.jAcc)
    };
    Ta.prototype.setRatio = function (a) {
        this.ratio = a;
        this.ratio_inv = 1 / a;
        this.activateBodies()
    };
    var nb = a.SimpleMotor = function (a, b, d) {
        Z.call(this, a, b);
        this.rate = d;
        this.iSum = this.jMax = this.jAcc = 0
    };
    nb.prototype = Object.create(Z.prototype);
    nb.prototype.preStep = function (a) {
        this.iSum = 1 / (this.a.i_inv + this.b.i_inv);
        this.jMax = this.maxForce * a
    };
    nb.prototype.applyCachedImpulse =
        function (a) {
            var b = this.a, d = this.b;
            a *= this.jAcc;
            b.w -= a * b.i_inv;
            d.w += a * d.i_inv
        };
    nb.prototype.applyImpulse = function () {
        var a = this.a, b = this.b, d = -(b.w - a.w + this.rate) * this.iSum, e = this.jAcc;
        this.jAcc = u(e + d, -this.jMax, this.jMax);
        d = this.jAcc - e;
        a.w -= d * a.i_inv;
        b.w += d * b.i_inv
    };
    nb.prototype.getImpulse = function () {
        return Math.abs(this.jAcc)
    }
})();
!function (a) {
    if ("object" == typeof exports && "undefined" != typeof module)module.exports = a(); else if ("function" == typeof define && define.amd)define([], a); else {
        var b;
        "undefined" != typeof window ? b = window : "undefined" != typeof global ? b = global : "undefined" != typeof self && (b = self);
        b.io = a()
    }
}(function () {
    return function b(d, e, f) {
        function g(n, r) {
            if (!e[n]) {
                if (!d[n]) {
                    var s = "function" == typeof require && require;
                    if (!r && s)return s(n, !0);
                    if (h)return h(n, !0);
                    throw Error("Cannot find module '" + n + "'");
                }
                s = e[n] = {exports: {}};
                d[n][0].call(s.exports,
                    function (b) {
                        var e = d[n][1][b];
                        return g(e ? e : b)
                    }, s, s.exports, b, d, e, f)
            }
            return e[n].exports
        }

        for (var h = "function" == typeof require && require, n = 0; n < f.length; n++)g(f[n]);
        return g
    }({
        1: [function (b, d, e) {
            d.exports = b("./lib/")
        }, {"./lib/": 2}],
        2: [function (b, d, e) {
            function f(b, d) {
                "object" == typeof b && (d = b, b = void 0);
                d = d || {};
                var e = g(b), f = e.source, h = e.id;
                d.forceNew || d["force new connection"] || !1 === d.multiplex ? (p("ignoring socket cache for %s", f), f = n(f, d)) : (r[h] || (p("new io instance for %s", f), r[h] = n(f, d)), f = r[h]);
                return f.socket(e.path)
            }

            var g = b("./url"), h = b("socket.io-parser"), n = b("./manager"), p = b("debug")("socket.io-client");
            d.exports = e = f;
            var r = e.managers = {};
            e.protocol = h.protocol;
            e.connect = f;
            e.Manager = b("./manager");
            e.Socket = b("./socket")
        }, {"./manager": 3, "./socket": 5, "./url": 6, debug: 10, "socket.io-parser": 46}],
        3: [function (b, d, e) {
            function f(b, d) {
                if (!(this instanceof f))return new f(b, d);
                b && "object" == typeof b && (d = b, b = void 0);
                d = d || {};
                d.path = d.path || "/socket.io";
                this.nsps = {};
                this.subs = [];
                this.opts = d;
                this.reconnection(!1 !== d.reconnection);
                this.reconnectionAttempts(d.reconnectionAttempts || Infinity);
                this.reconnectionDelay(d.reconnectionDelay || 1E3);
                this.reconnectionDelayMax(d.reconnectionDelayMax || 5E3);
                this.randomizationFactor(d.randomizationFactor || 0.5);
                this.backoff = new v({
                    min: this.reconnectionDelay(),
                    max: this.reconnectionDelayMax(),
                    jitter: this.randomizationFactor()
                });
                this.timeout(null == d.timeout ? 2E4 : d.timeout);
                this.readyState = "closed";
                this.uri = b;
                this.connected = [];
                this.encoding = !1;
                this.packetBuffer = [];
                this.encoder = new n.Encoder;
                this.decoder =
                    new n.Decoder;
                (this.autoConnect = !1 !== d.autoConnect) && this.open()
            }

            b("./url");
            var g = b("engine.io-client"), h = b("./socket");
            e = b("component-emitter");
            var n = b("socket.io-parser"), p = b("./on"), r = b("component-bind");
            b("object-component");
            var s = b("debug")("socket.io-client:manager"), t = b("indexof"), v = b("backo2");
            d.exports = f;
            f.prototype.emitAll = function () {
                this.emit.apply(this, arguments);
                for (var b in this.nsps)this.nsps[b].emit.apply(this.nsps[b], arguments)
            };
            f.prototype.updateSocketIds = function () {
                for (var b in this.nsps)this.nsps[b].id =
                    this.engine.id
            };
            e(f.prototype);
            f.prototype.reconnection = function (b) {
                if (!arguments.length)return this._reconnection;
                this._reconnection = !!b;
                return this
            };
            f.prototype.reconnectionAttempts = function (b) {
                if (!arguments.length)return this._reconnectionAttempts;
                this._reconnectionAttempts = b;
                return this
            };
            f.prototype.reconnectionDelay = function (b) {
                if (!arguments.length)return this._reconnectionDelay;
                this._reconnectionDelay = b;
                this.backoff && this.backoff.setMin(b);
                return this
            };
            f.prototype.randomizationFactor = function (b) {
                if (!arguments.length)return this._randomizationFactor;
                this._randomizationFactor = b;
                this.backoff && this.backoff.setJitter(b);
                return this
            };
            f.prototype.reconnectionDelayMax = function (b) {
                if (!arguments.length)return this._reconnectionDelayMax;
                this._reconnectionDelayMax = b;
                this.backoff && this.backoff.setMax(b);
                return this
            };
            f.prototype.timeout = function (b) {
                if (!arguments.length)return this._timeout;
                this._timeout = b;
                return this
            };
            f.prototype.maybeReconnectOnOpen = function () {
                !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
            };
            f.prototype.open =
                f.prototype.connect = function (b) {
                    s("readyState %s", this.readyState);
                    if (~this.readyState.indexOf("open"))return this;
                    s("opening %s", this.uri);
                    var d = this.engine = g(this.uri, this.opts), e = this;
                    this.readyState = "opening";
                    this.skipReconnect = !1;
                    var f = p(d, "open", function () {
                        e.onopen();
                        b && b()
                    }), h = p(d, "error", function (d) {
                        s("connect_error");
                        e.cleanup();
                        e.readyState = "closed";
                        e.emitAll("connect_error", d);
                        if (b) {
                            var f = Error("Connection error");
                            f.data = d;
                            b(f)
                        } else e.maybeReconnectOnOpen()
                    });
                    if (!1 !== this._timeout) {
                        var n =
                            this._timeout;
                        s("connect attempt will timeout after %d", n);
                        var r = setTimeout(function () {
                            s("connect attempt timed out after %d", n);
                            f.destroy();
                            d.close();
                            d.emit("error", "timeout");
                            e.emitAll("connect_timeout", n)
                        }, n);
                        this.subs.push({
                            destroy: function () {
                                clearTimeout(r)
                            }
                        })
                    }
                    this.subs.push(f);
                    this.subs.push(h);
                    return this
                };
            f.prototype.onopen = function () {
                s("open");
                this.cleanup();
                this.readyState = "open";
                this.emit("open");
                var b = this.engine;
                this.subs.push(p(b, "data", r(this, "ondata")));
                this.subs.push(p(this.decoder,
                    "decoded", r(this, "ondecoded")));
                this.subs.push(p(b, "error", r(this, "onerror")));
                this.subs.push(p(b, "close", r(this, "onclose")))
            };
            f.prototype.ondata = function (b) {
                this.decoder.add(b)
            };
            f.prototype.ondecoded = function (b) {
                this.emit("packet", b)
            };
            f.prototype.onerror = function (b) {
                s("error", b);
                this.emitAll("error", b)
            };
            f.prototype.socket = function (b) {
                var d = this.nsps[b];
                if (!d) {
                    d = new h(this, b);
                    this.nsps[b] = d;
                    var e = this;
                    d.on("connect", function () {
                        d.id = e.engine.id;
                        ~t(e.connected, d) || e.connected.push(d)
                    })
                }
                return d
            };
            f.prototype.destroy =
                function (b) {
                    b = t(this.connected, b);
                    ~b && this.connected.splice(b, 1);
                    this.connected.length || this.close()
                };
            f.prototype.packet = function (b) {
                s("writing packet %j", b);
                var d = this;
                d.encoding ? d.packetBuffer.push(b) : (d.encoding = !0, this.encoder.encode(b, function (b) {
                    for (var e = 0; e < b.length; e++)d.engine.write(b[e]);
                    d.encoding = !1;
                    d.processPacketQueue()
                }))
            };
            f.prototype.processPacketQueue = function () {
                if (0 < this.packetBuffer.length && !this.encoding) {
                    var b = this.packetBuffer.shift();
                    this.packet(b)
                }
            };
            f.prototype.cleanup = function () {
                for (var b; b =
                    this.subs.shift();)b.destroy();
                this.packetBuffer = [];
                this.encoding = !1;
                this.decoder.destroy()
            };
            f.prototype.close = f.prototype.disconnect = function () {
                this.skipReconnect = !0;
                this.backoff.reset();
                this.readyState = "closed";
                this.engine && this.engine.close()
            };
            f.prototype.onclose = function (b) {
                s("close");
                this.cleanup();
                this.backoff.reset();
                this.readyState = "closed";
                this.emit("close", b);
                this._reconnection && !this.skipReconnect && this.reconnect()
            };
            f.prototype.reconnect = function () {
                if (this.reconnecting || this.skipReconnect)return this;
                var b = this;
                if (this.backoff.attempts >= this._reconnectionAttempts)s("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1; else {
                    var d = this.backoff.duration();
                    s("will wait %dms before reconnect attempt", d);
                    this.reconnecting = !0;
                    var e = setTimeout(function () {
                        b.skipReconnect || (s("attempting reconnect"), b.emitAll("reconnect_attempt", b.backoff.attempts), b.emitAll("reconnecting", b.backoff.attempts), b.skipReconnect || b.open(function (d) {
                            d ? (s("reconnect attempt error"), b.reconnecting = !1, b.reconnect(), b.emitAll("reconnect_error", d.data)) : (s("reconnect success"), b.onreconnect())
                        }))
                    }, d);
                    this.subs.push({
                        destroy: function () {
                            clearTimeout(e)
                        }
                    })
                }
            };
            f.prototype.onreconnect = function () {
                var b = this.backoff.attempts;
                this.reconnecting = !1;
                this.backoff.reset();
                this.updateSocketIds();
                this.emitAll("reconnect", b)
            }
        }, {
            "./on": 4,
            "./socket": 5,
            "./url": 6,
            backo2: 7,
            "component-bind": 8,
            "component-emitter": 9,
            debug: 10,
            "engine.io-client": 11,
            indexof: 42,
            "object-component": 43,
            "socket.io-parser": 46
        }],
        4: [function (b,
                      d, e) {
            d.exports = function (b, d, e) {
                b.on(d, e);
                return {
                    destroy: function () {
                        b.removeListener(d, e)
                    }
                }
            }
        }, {}],
        5: [function (b, d, e) {
            function f(b, d) {
                this.io = b;
                this.nsp = d;
                this.json = this;
                this.ids = 0;
                this.acks = {};
                this.io.autoConnect && this.open();
                this.receiveBuffer = [];
                this.sendBuffer = [];
                this.connected = !1;
                this.disconnected = !0
            }

            var g = b("socket.io-parser");
            e = b("component-emitter");
            var h = b("to-array"), n = b("./on"), p = b("component-bind"), r = b("debug")("socket.io-client:socket"), s = b("has-binary");
            d.exports = f;
            var t = {
                connect: 1,
                connect_error: 1,
                connect_timeout: 1,
                disconnect: 1,
                error: 1,
                reconnect: 1,
                reconnect_attempt: 1,
                reconnect_failed: 1,
                reconnect_error: 1,
                reconnecting: 1
            }, v = e.prototype.emit;
            e(f.prototype);
            f.prototype.subEvents = function () {
                if (!this.subs) {
                    var b = this.io;
                    this.subs = [n(b, "open", p(this, "onopen")), n(b, "packet", p(this, "onpacket")), n(b, "close", p(this, "onclose"))]
                }
            };
            f.prototype.open = f.prototype.connect = function () {
                if (this.connected)return this;
                this.subEvents();
                this.io.open();
                if ("open" == this.io.readyState)this.onopen();
                return this
            };
            f.prototype.send =
                function () {
                    var b = h(arguments);
                    b.unshift("message");
                    this.emit.apply(this, b);
                    return this
                };
            f.prototype.emit = function (b) {
                if (t.hasOwnProperty(b))return v.apply(this, arguments), this;
                var d = h(arguments), e = g.EVENT;
                s(d) && (e = g.BINARY_EVENT);
                e = {type: e, data: d};
                "function" == typeof d[d.length - 1] && (r("emitting packet with ack id %d", this.ids), this.acks[this.ids] = d.pop(), e.id = this.ids++);
                this.connected ? this.packet(e) : this.sendBuffer.push(e);
                return this
            };
            f.prototype.packet = function (b) {
                b.nsp = this.nsp;
                this.io.packet(b)
            };
            f.prototype.onopen = function () {
                r("transport is open - connecting");
                "/" != this.nsp && this.packet({type: g.CONNECT})
            };
            f.prototype.onclose = function (b) {
                r("close (%s)", b);
                this.connected = !1;
                this.disconnected = !0;
                delete this.id;
                this.emit("disconnect", b)
            };
            f.prototype.onpacket = function (b) {
                if (b.nsp == this.nsp)switch (b.type) {
                    case g.CONNECT:
                        this.onconnect();
                        break;
                    case g.EVENT:
                        this.onevent(b);
                        break;
                    case g.BINARY_EVENT:
                        this.onevent(b);
                        break;
                    case g.ACK:
                        this.onack(b);
                        break;
                    case g.BINARY_ACK:
                        this.onack(b);
                        break;
                    case g.DISCONNECT:
                        this.ondisconnect();
                        break;
                    case g.ERROR:
                        this.emit("error", b.data)
                }
            };
            f.prototype.onevent = function (b) {
                var d = b.data || [];
                r("emitting event %j", d);
                null != b.id && (r("attaching ack callback to event"), d.push(this.ack(b.id)));
                this.connected ? v.apply(this, d) : this.receiveBuffer.push(d)
            };
            f.prototype.ack = function (b) {
                var d = this, e = !1;
                return function () {
                    if (!e) {
                        e = !0;
                        var f = h(arguments);
                        r("sending ack %j", f);
                        var n = s(f) ? g.BINARY_ACK : g.ACK;
                        d.packet({type: n, id: b, data: f})
                    }
                }
            };
            f.prototype.onack = function (b) {
                r("calling ack %s with %j", b.id, b.data);
                this.acks[b.id].apply(this, b.data);
                delete this.acks[b.id]
            };
            f.prototype.onconnect = function () {
                this.connected = !0;
                this.disconnected = !1;
                this.emit("connect");
                this.emitBuffered()
            };
            f.prototype.emitBuffered = function () {
                var b;
                for (b = 0; b < this.receiveBuffer.length; b++)v.apply(this, this.receiveBuffer[b]);
                this.receiveBuffer = [];
                for (b = 0; b < this.sendBuffer.length; b++)this.packet(this.sendBuffer[b]);
                this.sendBuffer = []
            };
            f.prototype.ondisconnect = function () {
                r("server disconnect (%s)", this.nsp);
                this.destroy();
                this.onclose("io server disconnect")
            };
            f.prototype.destroy = function () {
                if (this.subs) {
                    for (var b = 0; b < this.subs.length; b++)this.subs[b].destroy();
                    this.subs = null
                }
                this.io.destroy(this)
            };
            f.prototype.close = f.prototype.disconnect = function () {
                this.connected && (r("performing disconnect (%s)", this.nsp), this.packet({type: g.DISCONNECT}));
                this.destroy();
                if (this.connected)this.onclose("io client disconnect");
                return this
            }
        }, {
            "./on": 4,
            "component-bind": 8,
            "component-emitter": 9,
            debug: 10,
            "has-binary": 38,
            "socket.io-parser": 46,
            "to-array": 50
        }],
        6: [function (b, d, e) {
            (function (e) {
                var g =
                    b("parseuri"), h = b("debug")("socket.io-client:url");
                d.exports = function (b, d) {
                    var r = b;
                    d = d || e.location;
                    null == b && (b = d.protocol + "//" + d.host);
                    "string" == typeof b && ("/" == b.charAt(0) && (b = "/" == b.charAt(1) ? d.protocol + b : d.hostname + b), /^(https?|wss?):\/\//.test(b) || (h("protocol-less url %s", b), b = "undefined" != typeof d ? d.protocol + "//" + b : "https://" + b), h("parse %s", b), r = g(b));
                    r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443"));
                    r.path = r.path || "/";
                    r.id = r.protocol + "://" +
                        r.host + ":" + r.port;
                    r.href = r.protocol + "://" + r.host + (d && d.port == r.port ? "" : ":" + r.port);
                    return r
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {debug: 10, parseuri: 44}],
        7: [function (b, d, e) {
            function f(b) {
                b = b || {};
                this.ms = b.min || 100;
                this.max = b.max || 1E4;
                this.factor = b.factor || 2;
                this.jitter = 0 < b.jitter && 1 >= b.jitter ? b.jitter : 0;
                this.attempts = 0
            }

            d.exports = f;
            f.prototype.duration = function () {
                var b = this.ms * Math.pow(this.factor, this.attempts++);
                if (this.jitter)var d = Math.random(), e = Math.floor(d *
                    this.jitter * b), b = 0 == (Math.floor(10 * d) & 1) ? b - e : b + e;
                return Math.min(b, this.max) | 0
            };
            f.prototype.reset = function () {
                this.attempts = 0
            };
            f.prototype.setMin = function (b) {
                this.ms = b
            };
            f.prototype.setMax = function (b) {
                this.max = b
            };
            f.prototype.setJitter = function (b) {
                this.jitter = b
            }
        }, {}],
        8: [function (b, d, e) {
            var f = [].slice;
            d.exports = function (b, d) {
                "string" == typeof d && (d = b[d]);
                if ("function" != typeof d)throw Error("bind() requires a function");
                var e = f.call(arguments, 2);
                return function () {
                    return d.apply(b, e.concat(f.call(arguments)))
                }
            }
        },
            {}],
        9: [function (b, d, e) {
            function f(b) {
                if (b) {
                    for (var d in f.prototype)b[d] = f.prototype[d];
                    return b
                }
            }

            d.exports = f;
            f.prototype.on = f.prototype.addEventListener = function (b, d) {
                this._callbacks = this._callbacks || {};
                (this._callbacks[b] = this._callbacks[b] || []).push(d);
                return this
            };
            f.prototype.once = function (b, d) {
                function e() {
                    f.off(b, e);
                    d.apply(this, arguments)
                }

                var f = this;
                this._callbacks = this._callbacks || {};
                e.fn = d;
                this.on(b, e);
                return this
            };
            f.prototype.off = f.prototype.removeListener = f.prototype.removeAllListeners =
                f.prototype.removeEventListener = function (b, d) {
                    this._callbacks = this._callbacks || {};
                    if (0 == arguments.length)return this._callbacks = {}, this;
                    var e = this._callbacks[b];
                    if (!e)return this;
                    if (1 == arguments.length)return delete this._callbacks[b], this;
                    for (var f, r = 0; r < e.length; r++)if (f = e[r], f === d || f.fn === d) {
                        e.splice(r, 1);
                        break
                    }
                    return this
                };
            f.prototype.emit = function (b) {
                this._callbacks = this._callbacks || {};
                var d = [].slice.call(arguments, 1), e = this._callbacks[b];
                if (e)for (var e = e.slice(0), f = 0, r = e.length; f < r; ++f)e[f].apply(this,
                    d);
                return this
            };
            f.prototype.listeners = function (b) {
                this._callbacks = this._callbacks || {};
                return this._callbacks[b] || []
            };
            f.prototype.hasListeners = function (b) {
                return !!this.listeners(b).length
            }
        }, {}],
        10: [function (b, d, e) {
            function f(b) {
                return f.enabled(b) ? function (d) {
                    d instanceof Error && (d = d.stack || d.message);
                    var e = new Date, g = e - (f[b] || e);
                    f[b] = e;
                    d = b + " " + d + " +" + f.humanize(g);
                    window.console && console.log && Function.prototype.apply.call(console.log, console, arguments)
                } : function () {
                }
            }

            d.exports = f;
            f.names = [];
            f.skips =
                [];
            f.enable = function (b) {
                try {
                    localStorage.debug = b
                } catch (d) {
                }
                for (var e = (b || "").split(/[\s,]+/), g = e.length, s = 0; s < g; s++)b = e[s].replace("*", ".*?"), "-" === b[0] ? f.skips.push(RegExp("^" + b.substr(1) + "$")) : f.names.push(RegExp("^" + b + "$"))
            };
            f.disable = function () {
                f.enable("")
            };
            f.humanize = function (b) {
                return 36E5 <= b ? (b / 36E5).toFixed(1) + "h" : 6E4 <= b ? (b / 6E4).toFixed(1) + "m" : 1E3 <= b ? (b / 1E3 | 0) + "s" : b + "ms"
            };
            f.enabled = function (b) {
                for (var d = 0, e = f.skips.length; d < e; d++)if (f.skips[d].test(b))return !1;
                d = 0;
                for (e = f.names.length; d <
                e; d++)if (f.names[d].test(b))return !0;
                return !1
            };
            try {
                window.localStorage && f.enable(localStorage.debug)
            } catch (g) {
            }
        }, {}],
        11: [function (b, d, e) {
            d.exports = b("./lib/")
        }, {"./lib/": 12}],
        12: [function (b, d, e) {
            d.exports = b("./socket");
            d.exports.parser = b("engine.io-parser")
        }, {"./socket": 13, "engine.io-parser": 25}],
        13: [function (b, d, e) {
            (function (e) {
                function g(b, d) {
                    if (!(this instanceof g))return new g(b, d);
                    d = d || {};
                    b && "object" == typeof b && (d = b, b = null);
                    b && (b = t(b), d.host = b.host, d.secure = "https" == b.protocol || "wss" == b.protocol,
                        d.port = b.port, b.query && (d.query = b.query));
                    this.secure = null != d.secure ? d.secure : e.location && "https:" == location.protocol;
                    if (d.host) {
                        var h = d.host.split(":");
                        d.hostname = h.shift();
                        h.length ? d.port = h.pop() : d.port || (d.port = this.secure ? "443" : "80")
                    }
                    this.agent = d.agent || !1;
                    this.hostname = d.hostname || (e.location ? location.hostname : "localhost");
                    this.port = d.port || (e.location && location.port ? location.port : this.secure ? 443 : 80);
                    this.query = d.query || {};
                    "string" == typeof this.query && (this.query = u.decode(this.query));
                    this.upgrade =
                        !1 !== d.upgrade;
                    this.path = (d.path || "/engine.io").replace(/\/$/, "") + "/";
                    this.forceJSONP = !!d.forceJSONP;
                    this.jsonp = !1 !== d.jsonp;
                    this.forceBase64 = !!d.forceBase64;
                    this.enablesXDR = !!d.enablesXDR;
                    this.timestampParam = d.timestampParam || "t";
                    this.timestampRequests = d.timestampRequests;
                    this.transports = d.transports || ["polling", "websocket"];
                    this.readyState = "";
                    this.writeBuffer = [];
                    this.callbackBuffer = [];
                    this.policyPort = d.policyPort || 843;
                    this.rememberUpgrade = d.rememberUpgrade || !1;
                    this.binaryType = null;
                    this.onlyBinaryUpgrades =
                        d.onlyBinaryUpgrades;
                    this.pfx = d.pfx || null;
                    this.key = d.key || null;
                    this.passphrase = d.passphrase || null;
                    this.cert = d.cert || null;
                    this.ca = d.ca || null;
                    this.ciphers = d.ciphers || null;
                    this.rejectUnauthorized = d.rejectUnauthorized || null;
                    this.open()
                }

                var h = b("./transports"), n = b("component-emitter"), p = b("debug")("engine.io-client:socket"), r = b("indexof"), s = b("engine.io-parser"), t = b("parseuri"), v = b("parsejson"), u = b("parseqs");
                d.exports = g;
                g.priorWebsocketSuccess = !1;
                n(g.prototype);
                g.protocol = s.protocol;
                g.Socket = g;
                g.Transport =
                    b("./transport");
                g.transports = b("./transports");
                g.parser = b("engine.io-parser");
                g.prototype.createTransport = function (b) {
                    p('creating transport "%s"', b);
                    var d = this.query, e = {}, f;
                    for (f in d)d.hasOwnProperty(f) && (e[f] = d[f]);
                    e.EIO = s.protocol;
                    e.transport = b;
                    this.id && (e.sid = this.id);
                    return new h[b]({
                        agent: this.agent,
                        hostname: this.hostname,
                        port: this.port,
                        secure: this.secure,
                        path: this.path,
                        query: e,
                        forceJSONP: this.forceJSONP,
                        jsonp: this.jsonp,
                        forceBase64: this.forceBase64,
                        enablesXDR: this.enablesXDR,
                        timestampRequests: this.timestampRequests,
                        timestampParam: this.timestampParam,
                        policyPort: this.policyPort,
                        socket: this,
                        pfx: this.pfx,
                        key: this.key,
                        passphrase: this.passphrase,
                        cert: this.cert,
                        ca: this.ca,
                        ciphers: this.ciphers,
                        rejectUnauthorized: this.rejectUnauthorized
                    })
                };
                g.prototype.open = function () {
                    var b;
                    if (this.rememberUpgrade && g.priorWebsocketSuccess && -1 != this.transports.indexOf("websocket"))b = "websocket"; else {
                        if (0 == this.transports.length) {
                            var d = this;
                            setTimeout(function () {
                                d.emit("error", "No transports available")
                            }, 0);
                            return
                        }
                        b = this.transports[0]
                    }
                    this.readyState =
                        "opening";
                    try {
                        b = this.createTransport(b)
                    } catch (e) {
                        this.transports.shift();
                        this.open();
                        return
                    }
                    b.open();
                    this.setTransport(b)
                };
                g.prototype.setTransport = function (b) {
                    p("setting transport %s", b.name);
                    var d = this;
                    this.transport && (p("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners());
                    this.transport = b;
                    b.on("drain", function () {
                        d.onDrain()
                    }).on("packet", function (b) {
                        d.onPacket(b)
                    }).on("error", function (b) {
                        d.onError(b)
                    }).on("close", function () {
                        d.onClose("transport close")
                    })
                };
                g.prototype.probe = function (b) {
                    function d() {
                        if (v.onlyBinaryUpgrades) {
                            var e = !this.supportsBinary && v.transport.supportsBinary;
                            u = u || e
                        }
                        u || (p('probe transport "%s" opened', b), t.send([{
                            type: "ping",
                            data: "probe"
                        }]), t.once("packet", function (d) {
                            u || ("pong" == d.type && "probe" == d.data ? (p('probe transport "%s" pong', b), v.upgrading = !0, v.emit("upgrading", t), t && (g.priorWebsocketSuccess = "websocket" == t.name, p('pausing current transport "%s"', v.transport.name), v.transport.pause(function () {
                                u || "closed" == v.readyState || (p("changing transport and sending upgrade packet"),
                                    s(), v.setTransport(t), t.send([{type: "upgrade"}]), v.emit("upgrade", t), t = null, v.upgrading = !1, v.flush())
                            }))) : (p('probe transport "%s" failed', b), d = Error("probe error"), d.transport = t.name, v.emit("upgradeError", d)))
                        }))
                    }

                    function e() {
                        u || (u = !0, s(), t.close(), t = null)
                    }

                    function f(d) {
                        var g = Error("probe error: " + d);
                        g.transport = t.name;
                        e();
                        p('probe transport "%s" failed because of error: %s', b, d);
                        v.emit("upgradeError", g)
                    }

                    function h() {
                        f("transport closed")
                    }

                    function n() {
                        f("socket closed")
                    }

                    function r(b) {
                        t && b.name !=
                        t.name && (p('"%s" works - aborting "%s"', b.name, t.name), e())
                    }

                    function s() {
                        t.removeListener("open", d);
                        t.removeListener("error", f);
                        t.removeListener("close", h);
                        v.removeListener("close", n);
                        v.removeListener("upgrading", r)
                    }

                    p('probing transport "%s"', b);
                    var t = this.createTransport(b, {probe: 1}), u = !1, v = this;
                    g.priorWebsocketSuccess = !1;
                    t.once("open", d);
                    t.once("error", f);
                    t.once("close", h);
                    this.once("close", n);
                    this.once("upgrading", r);
                    t.open()
                };
                g.prototype.onOpen = function () {
                    p("socket open");
                    this.readyState = "open";
                    g.priorWebsocketSuccess = "websocket" == this.transport.name;
                    this.emit("open");
                    this.flush();
                    if ("open" == this.readyState && this.upgrade && this.transport.pause) {
                        p("starting upgrade probes");
                        for (var b = 0, d = this.upgrades.length; b < d; b++)this.probe(this.upgrades[b])
                    }
                };
                g.prototype.onPacket = function (b) {
                    if ("opening" == this.readyState || "open" == this.readyState)switch (p('socket receive: type "%s", data "%s"', b.type, b.data), this.emit("packet", b), this.emit("heartbeat"), b.type) {
                        case "open":
                            this.onHandshake(v(b.data));
                            break;
                        case "pong":
                            this.setPing();
                            break;
                        case "error":
                            var d = Error("server error");
                            d.code = b.data;
                            this.emit("error", d);
                            break;
                        case "message":
                            this.emit("data", b.data), this.emit("message", b.data)
                    } else p('packet received with socket readyState "%s"', this.readyState)
                };
                g.prototype.onHandshake = function (b) {
                    this.emit("handshake", b);
                    this.id = b.sid;
                    this.transport.query.sid = b.sid;
                    this.upgrades = this.filterUpgrades(b.upgrades);
                    this.pingInterval = b.pingInterval;
                    this.pingTimeout = b.pingTimeout;
                    this.onOpen();
                    "closed" != this.readyState &&
                    (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat))
                };
                g.prototype.onHeartbeat = function (b) {
                    clearTimeout(this.pingTimeoutTimer);
                    var d = this;
                    d.pingTimeoutTimer = setTimeout(function () {
                        if ("closed" != d.readyState)d.onClose("ping timeout")
                    }, b || d.pingInterval + d.pingTimeout)
                };
                g.prototype.setPing = function () {
                    var b = this;
                    clearTimeout(b.pingIntervalTimer);
                    b.pingIntervalTimer = setTimeout(function () {
                        p("writing ping packet - expecting pong within %sms", b.pingTimeout);
                        b.ping();
                        b.onHeartbeat(b.pingTimeout)
                    }, b.pingInterval)
                };
                g.prototype.ping = function () {
                    this.sendPacket("ping")
                };
                g.prototype.onDrain = function () {
                    for (var b = 0; b < this.prevBufferLen; b++)if (this.callbackBuffer[b])this.callbackBuffer[b]();
                    this.writeBuffer.splice(0, this.prevBufferLen);
                    this.callbackBuffer.splice(0, this.prevBufferLen);
                    this.prevBufferLen = 0;
                    0 == this.writeBuffer.length ? this.emit("drain") : this.flush()
                };
                g.prototype.flush = function () {
                    "closed" != this.readyState && this.transport.writable && !this.upgrading &&
                    this.writeBuffer.length && (p("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"))
                };
                g.prototype.write = g.prototype.send = function (b, d) {
                    this.sendPacket("message", b, d);
                    return this
                };
                g.prototype.sendPacket = function (b, d, e) {
                    "closing" != this.readyState && "closed" != this.readyState && (b = {
                        type: b,
                        data: d
                    }, this.emit("packetCreate", b), this.writeBuffer.push(b), this.callbackBuffer.push(e), this.flush())
                };
                g.prototype.close =
                    function () {
                        if ("opening" == this.readyState || "open" == this.readyState) {
                            this.readyState = "closing";
                            var b = this, d = function () {
                                b.onClose("forced close");
                                p("socket closing - telling transport to close");
                                b.transport.close()
                            }, e = function () {
                                b.removeListener("upgrade", e);
                                b.removeListener("upgradeError", e);
                                d()
                            }, f = function () {
                                b.once("upgrade", e);
                                b.once("upgradeError", e)
                            };
                            if (this.writeBuffer.length)this.once("drain", function () {
                                this.upgrading ? f() : d()
                            }); else this.upgrading ? f() : d()
                        }
                        return this
                    };
                g.prototype.onError = function (b) {
                    p("socket error %j",
                        b);
                    g.priorWebsocketSuccess = !1;
                    this.emit("error", b);
                    this.onClose("transport error", b)
                };
                g.prototype.onClose = function (b, d) {
                    if ("opening" == this.readyState || "open" == this.readyState || "closing" == this.readyState) {
                        p('socket close with reason: "%s"', b);
                        var e = this;
                        clearTimeout(this.pingIntervalTimer);
                        clearTimeout(this.pingTimeoutTimer);
                        setTimeout(function () {
                            e.writeBuffer = [];
                            e.callbackBuffer = [];
                            e.prevBufferLen = 0
                        }, 0);
                        this.transport.removeAllListeners("close");
                        this.transport.close();
                        this.transport.removeAllListeners();
                        this.readyState = "closed";
                        this.id = null;
                        this.emit("close", b, d)
                    }
                };
                g.prototype.filterUpgrades = function (b) {
                    for (var d = [], e = 0, f = b.length; e < f; e++)~r(this.transports, b[e]) && d.push(b[e]);
                    return d
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {
            "./transport": 14,
            "./transports": 15,
            "component-emitter": 9,
            debug: 22,
            "engine.io-parser": 25,
            indexof: 42,
            parsejson: 34,
            parseqs: 35,
            parseuri: 36
        }],
        14: [function (b, d, e) {
            function f(b) {
                this.path = b.path;
                this.hostname = b.hostname;
                this.port = b.port;
                this.secure = b.secure;
                this.query = b.query;
                this.timestampParam = b.timestampParam;
                this.timestampRequests = b.timestampRequests;
                this.readyState = "";
                this.agent = b.agent || !1;
                this.socket = b.socket;
                this.enablesXDR = b.enablesXDR;
                this.pfx = b.pfx;
                this.key = b.key;
                this.passphrase = b.passphrase;
                this.cert = b.cert;
                this.ca = b.ca;
                this.ciphers = b.ciphers;
                this.rejectUnauthorized = b.rejectUnauthorized
            }

            var g = b("engine.io-parser");
            b = b("component-emitter");
            d.exports = f;
            b(f.prototype);
            f.timestamps = 0;
            f.prototype.onError = function (b, d) {
                var e =
                    Error(b);
                e.type = "TransportError";
                e.description = d;
                this.emit("error", e);
                return this
            };
            f.prototype.open = function () {
                if ("closed" == this.readyState || "" == this.readyState)this.readyState = "opening", this.doOpen();
                return this
            };
            f.prototype.close = function () {
                if ("opening" == this.readyState || "open" == this.readyState)this.doClose(), this.onClose();
                return this
            };
            f.prototype.send = function (b) {
                if ("open" == this.readyState)this.write(b); else throw Error("Transport not open");
            };
            f.prototype.onOpen = function () {
                this.readyState = "open";
                this.writable = !0;
                this.emit("open")
            };
            f.prototype.onData = function (b) {
                b = g.decodePacket(b, this.socket.binaryType);
                this.onPacket(b)
            };
            f.prototype.onPacket = function (b) {
                this.emit("packet", b)
            };
            f.prototype.onClose = function () {
                this.readyState = "closed";
                this.emit("close")
            }
        }, {"component-emitter": 9, "engine.io-parser": 25}],
        15: [function (b, d, e) {
            (function (d) {
                var g = b("xmlhttprequest"), h = b("./polling-xhr"), n = b("./polling-jsonp"), p = b("./websocket");
                e.polling = function (b) {
                    var e = !1, p = !1, v = !1 !== b.jsonp;
                    d.location && (p = "https:" ==
                        location.protocol, (e = location.port) || (e = p ? 443 : 80), e = b.hostname != location.hostname || e != b.port, p = b.secure != p);
                    b.xdomain = e;
                    b.xscheme = p;
                    if ("open" in new g(b) && !b.forceJSONP)return new h(b);
                    if (!v)throw Error("JSONP disabled");
                    return new n(b)
                };
                e.websocket = p
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {"./polling-jsonp": 16, "./polling-xhr": 17, "./websocket": 19, xmlhttprequest: 20}],
        16: [function (b, d, e) {
            (function (e) {
                function g() {
                }

                function h(b) {
                    n.call(this, b);
                    this.query = this.query ||
                        {};
                    t || (e.___eio || (e.___eio = []), t = e.___eio);
                    this.index = t.length;
                    var d = this;
                    t.push(function (b) {
                        d.onData(b)
                    });
                    this.query.j = this.index;
                    e.document && e.addEventListener && e.addEventListener("beforeunload", function () {
                        d.script && (d.script.onerror = g)
                    }, !1)
                }

                var n = b("./polling"), p = b("component-inherit");
                d.exports = h;
                var r = /\n/g, s = /\\n/g, t;
                p(h, n);
                h.prototype.supportsBinary = !1;
                h.prototype.doClose = function () {
                    this.script && (this.script.parentNode.removeChild(this.script), this.script = null);
                    this.form && (this.form.parentNode.removeChild(this.form),
                        this.iframe = this.form = null);
                    n.prototype.doClose.call(this)
                };
                h.prototype.doPoll = function () {
                    var b = this, d = document.createElement("script");
                    this.script && (this.script.parentNode.removeChild(this.script), this.script = null);
                    d.async = !0;
                    d.src = this.uri();
                    d.onerror = function (d) {
                        b.onError("jsonp poll error", d)
                    };
                    var e = document.getElementsByTagName("script")[0];
                    e.parentNode.insertBefore(d, e);
                    this.script = d;
                    "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent) && setTimeout(function () {
                        var b = document.createElement("iframe");
                        document.body.appendChild(b);
                        document.body.removeChild(b)
                    }, 100)
                };
                h.prototype.doWrite = function (b, d) {
                    function e() {
                        f();
                        d()
                    }

                    function f() {
                        if (g.iframe)try {
                            g.form.removeChild(g.iframe)
                        } catch (b) {
                            g.onError("jsonp polling iframe removal error", b)
                        }
                        try {
                            t = document.createElement('\x3ciframe src\x3d"javascript:0" name\x3d"' + g.iframeId + '"\x3e')
                        } catch (d) {
                            t = document.createElement("iframe"), t.name = g.iframeId, t.src = "javascript:0"
                        }
                        t.id = g.iframeId;
                        g.form.appendChild(t);
                        g.iframe = t
                    }

                    var g = this;
                    if (!this.form) {
                        var h = document.createElement("form"),
                            n = document.createElement("textarea"), p = this.iframeId = "eio_iframe_" + this.index, t;
                        h.className = "socketio";
                        h.style.position = "absolute";
                        h.style.top = "-1000px";
                        h.style.left = "-1000px";
                        h.target = p;
                        h.method = "POST";
                        h.setAttribute("accept-charset", "utf-8");
                        n.name = "d";
                        h.appendChild(n);
                        document.body.appendChild(h);
                        this.form = h;
                        this.area = n
                    }
                    this.form.action = this.uri();
                    f();
                    b = b.replace(s, "\\\n");
                    this.area.value = b.replace(r, "\\n");
                    try {
                        this.form.submit()
                    } catch (C) {
                    }
                    this.iframe.attachEvent ? this.iframe.onreadystatechange =
                        function () {
                            "complete" == g.iframe.readyState && e()
                        } : this.iframe.onload = e
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {"./polling": 18, "component-inherit": 21}],
        17: [function (b, d, e) {
            (function (e) {
                function g() {
                }

                function h(b) {
                    s.call(this, b);
                    if (e.location) {
                        var d = "https:" == location.protocol, g = location.port;
                        g || (g = d ? 443 : 80);
                        this.xd = b.hostname != e.location.hostname || g != b.port;
                        this.xs = b.secure != d
                    }
                }

                function n(b) {
                    this.method = b.method || "GET";
                    this.uri = b.uri;
                    this.xd = !!b.xd;
                    this.xs = !!b.xs;
                    this.async = !1 !== b.async;
                    this.data = void 0 != b.data ? b.data : null;
                    this.agent = b.agent;
                    this.isBinary = b.isBinary;
                    this.supportsBinary = b.supportsBinary;
                    this.enablesXDR = b.enablesXDR;
                    this.pfx = b.pfx;
                    this.key = b.key;
                    this.passphrase = b.passphrase;
                    this.cert = b.cert;
                    this.ca = b.ca;
                    this.ciphers = b.ciphers;
                    this.rejectUnauthorized = b.rejectUnauthorized;
                    this.create()
                }

                function p() {
                    for (var b in n.requests)n.requests.hasOwnProperty(b) && n.requests[b].abort()
                }

                var r = b("xmlhttprequest"), s = b("./polling"), t = b("component-emitter"),
                    v = b("component-inherit"), u = b("debug")("engine.io-client:polling-xhr");
                d.exports = h;
                d.exports.Request = n;
                v(h, s);
                h.prototype.supportsBinary = !0;
                h.prototype.request = function (b) {
                    b = b || {};
                    b.uri = this.uri();
                    b.xd = this.xd;
                    b.xs = this.xs;
                    b.agent = this.agent || !1;
                    b.supportsBinary = this.supportsBinary;
                    b.enablesXDR = this.enablesXDR;
                    b.pfx = this.pfx;
                    b.key = this.key;
                    b.passphrase = this.passphrase;
                    b.cert = this.cert;
                    b.ca = this.ca;
                    b.ciphers = this.ciphers;
                    b.rejectUnauthorized = this.rejectUnauthorized;
                    return new n(b)
                };
                h.prototype.doWrite =
                    function (b, d) {
                        var e = this.request({
                            method: "POST",
                            data: b,
                            isBinary: "string" !== typeof b && void 0 !== b
                        }), f = this;
                        e.on("success", d);
                        e.on("error", function (b) {
                            f.onError("xhr post error", b)
                        });
                        this.sendXhr = e
                    };
                h.prototype.doPoll = function () {
                    u("xhr poll");
                    var b = this.request(), d = this;
                    b.on("data", function (b) {
                        d.onData(b)
                    });
                    b.on("error", function (b) {
                        d.onError("xhr poll error", b)
                    });
                    this.pollXhr = b
                };
                t(n.prototype);
                n.prototype.create = function () {
                    var b = {agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR};
                    b.pfx = this.pfx;
                    b.key = this.key;
                    b.passphrase = this.passphrase;
                    b.cert = this.cert;
                    b.ca = this.ca;
                    b.ciphers = this.ciphers;
                    b.rejectUnauthorized = this.rejectUnauthorized;
                    var d = this.xhr = new r(b), g = this;
                    try {
                        u("xhr open %s: %s", this.method, this.uri);
                        d.open(this.method, this.uri, this.async);
                        this.supportsBinary && (d.responseType = "arraybuffer");
                        if ("POST" == this.method)try {
                            this.isBinary ? d.setRequestHeader("Content-type", "application/octet-stream") : d.setRequestHeader("Content-type", "text/plain;charset\x3dUTF-8")
                        } catch (h) {
                        }
                        "withCredentials" in
                        d && (d.withCredentials = !0);
                        this.hasXDR() ? (d.onload = function () {
                            g.onLoad()
                        }, d.onerror = function () {
                            g.onError(d.responseText)
                        }) : d.onreadystatechange = function () {
                            if (4 == d.readyState)if (200 == d.status || 1223 == d.status)g.onLoad(); else setTimeout(function () {
                                g.onError(d.status)
                            }, 0)
                        };
                        u("xhr data %s", this.data);
                        d.send(this.data)
                    } catch (p) {
                        setTimeout(function () {
                            g.onError(p)
                        }, 0);
                        return
                    }
                    e.document && (this.index = n.requestsCount++, n.requests[this.index] = this)
                };
                n.prototype.onSuccess = function () {
                    this.emit("success");
                    this.cleanup()
                };
                n.prototype.onData = function (b) {
                    this.emit("data", b);
                    this.onSuccess()
                };
                n.prototype.onError = function (b) {
                    this.emit("error", b);
                    this.cleanup(!0)
                };
                n.prototype.cleanup = function (b) {
                    if ("undefined" != typeof this.xhr && null !== this.xhr) {
                        this.hasXDR() ? this.xhr.onload = this.xhr.onerror = g : this.xhr.onreadystatechange = g;
                        if (b)try {
                            this.xhr.abort()
                        } catch (d) {
                        }
                        e.document && delete n.requests[this.index];
                        this.xhr = null
                    }
                };
                n.prototype.onLoad = function () {
                    var b;
                    try {
                        var d;
                        try {
                            d = this.xhr.getResponseHeader("Content-Type").split(";")[0]
                        } catch (e) {
                        }
                        b =
                            "application/octet-stream" === d ? this.xhr.response : this.supportsBinary ? "ok" : this.xhr.responseText
                    } catch (f) {
                        this.onError(f)
                    }
                    if (null != b)this.onData(b)
                };
                n.prototype.hasXDR = function () {
                    return "undefined" !== typeof e.XDomainRequest && !this.xs && this.enablesXDR
                };
                n.prototype.abort = function () {
                    this.cleanup()
                };
                e.document && (n.requestsCount = 0, n.requests = {}, e.attachEvent ? e.attachEvent("onunload", p) : e.addEventListener && e.addEventListener("beforeunload", p, !1))
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ?
                window : {})
        }, {"./polling": 18, "component-emitter": 9, "component-inherit": 21, debug: 22, xmlhttprequest: 20}],
        18: [function (b, d, e) {
            function f(b) {
                var d = b && b.forceBase64;
                if (!r || d)this.supportsBinary = !1;
                g.call(this, b)
            }

            var g = b("../transport"), h = b("parseqs"), n = b("engine.io-parser");
            e = b("component-inherit");
            var p = b("debug")("engine.io-client:polling");
            d.exports = f;
            var r = null != (new (b("xmlhttprequest"))({xdomain: !1})).responseType;
            e(f, g);
            f.prototype.name = "polling";
            f.prototype.doOpen = function () {
                this.poll()
            };
            f.prototype.pause =
                function (b) {
                    function d() {
                        p("paused");
                        e.readyState = "paused";
                        b()
                    }

                    var e = this;
                    this.readyState = "pausing";
                    if (this.polling || !this.writable) {
                        var f = 0;
                        this.polling && (p("we are currently polling - waiting to pause"), f++, this.once("pollComplete", function () {
                            p("pre-pause polling complete");
                            --f || d()
                        }));
                        this.writable || (p("we are currently writing - waiting to pause"), f++, this.once("drain", function () {
                            p("pre-pause writing complete");
                            --f || d()
                        }))
                    } else d()
                };
            f.prototype.poll = function () {
                p("polling");
                this.polling = !0;
                this.doPoll();
                this.emit("poll")
            };
            f.prototype.onData = function (b) {
                var d = this;
                p("polling got data %s", b);
                n.decodePayload(b, this.socket.binaryType, function (b, e, f) {
                    if ("opening" == d.readyState)d.onOpen();
                    if ("close" == b.type)return d.onClose(), !1;
                    d.onPacket(b)
                });
                "closed" != this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" == this.readyState ? this.poll() : p('ignoring poll - transport state "%s"', this.readyState))
            };
            f.prototype.doClose = function () {
                function b() {
                    p("writing close packet");
                    d.write([{type: "close"}])
                }

                var d = this;
                "open" == this.readyState ? (p("transport open - closing"), b()) : (p("transport not open - deferring close"), this.once("open", b))
            };
            f.prototype.write = function (b) {
                var d = this;
                this.writable = !1;
                var e = function () {
                    d.writable = !0;
                    d.emit("drain")
                }, d = this;
                n.encodePayload(b, this.supportsBinary, function (b) {
                    d.doWrite(b, e)
                })
            };
            f.prototype.uri = function () {
                var b = this.query || {}, d = this.secure ? "https" : "http", e = "";
                !1 !== this.timestampRequests && (b[this.timestampParam] = +new Date + "-" + g.timestamps++);
                this.supportsBinary ||
                b.sid || (b.b64 = 1);
                b = h.encode(b);
                this.port && ("https" == d && 443 != this.port || "http" == d && 80 != this.port) && (e = ":" + this.port);
                b.length && (b = "?" + b);
                return d + "://" + this.hostname + e + this.path + b
            }
        }, {
            "../transport": 14,
            "component-inherit": 21,
            debug: 22,
            "engine.io-parser": 25,
            parseqs: 35,
            xmlhttprequest: 20
        }],
        19: [function (b, d, e) {
            function f(b) {
                b && b.forceBase64 && (this.supportsBinary = !1);
                g.call(this, b)
            }

            var g = b("../transport"), h = b("engine.io-parser"), n = b("parseqs");
            e = b("component-inherit");
            var p = b("debug")("engine.io-client:websocket"),
                r = b("ws");
            d.exports = f;
            e(f, g);
            f.prototype.name = "websocket";
            f.prototype.supportsBinary = !0;
            f.prototype.doOpen = function () {
                if (this.check()) {
                    var b = this.uri(), d = {agent: this.agent};
                    d.pfx = this.pfx;
                    d.key = this.key;
                    d.passphrase = this.passphrase;
                    d.cert = this.cert;
                    d.ca = this.ca;
                    d.ciphers = this.ciphers;
                    d.rejectUnauthorized = this.rejectUnauthorized;
                    this.ws = new r(b, void 0, d);
                    void 0 === this.ws.binaryType && (this.supportsBinary = !1);
                    this.ws.binaryType = "arraybuffer";
                    this.addEventListeners()
                }
            };
            f.prototype.addEventListeners = function () {
                var b =
                    this;
                this.ws.onopen = function () {
                    b.onOpen()
                };
                this.ws.onclose = function () {
                    b.onClose()
                };
                this.ws.onmessage = function (d) {
                    b.onData(d.data)
                };
                this.ws.onerror = function (d) {
                    b.onError("websocket error", d)
                }
            };
            "undefined" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent) && (f.prototype.onData = function (b) {
                var d = this;
                setTimeout(function () {
                    g.prototype.onData.call(d, b)
                }, 0)
            });
            f.prototype.write = function (b) {
                var d = this;
                this.writable = !1;
                for (var e = 0, f = b.length; e < f; e++)h.encodePacket(b[e], this.supportsBinary, function (b) {
                    try {
                        d.ws.send(b)
                    } catch (e) {
                        p("websocket closed before onclose event")
                    }
                });
                setTimeout(function () {
                    d.writable = !0;
                    d.emit("drain")
                }, 0)
            };
            f.prototype.onClose = function () {
                g.prototype.onClose.call(this)
            };
            f.prototype.doClose = function () {
                "undefined" !== typeof this.ws && this.ws.close()
            };
            f.prototype.uri = function () {
                var b = this.query || {}, d = this.secure ? "wss" : "ws", e = "";
                this.port && ("wss" == d && 443 != this.port || "ws" == d && 80 != this.port) && (e = ":" + this.port);
                this.timestampRequests && (b[this.timestampParam] = +new Date);
                this.supportsBinary || (b.b64 = 1);
                b = n.encode(b);
                b.length && (b = "?" + b);
                return d + "://" + this.hostname +
                    e + this.path + b
            };
            f.prototype.check = function () {
                return !!r && !("__initialize" in r && this.name === f.prototype.name)
            }
        }, {"../transport": 14, "component-inherit": 21, debug: 22, "engine.io-parser": 25, parseqs: 35, ws: 37}],
        20: [function (b, d, e) {
            var f = b("has-cors");
            d.exports = function (b) {
                var d = b.xdomain, e = b.xscheme;
                b = b.enablesXDR;
                try {
                    if ("undefined" != typeof XMLHttpRequest && (!d || f))return new XMLHttpRequest
                } catch (p) {
                }
                try {
                    if ("undefined" != typeof XDomainRequest && !e && b)return new XDomainRequest
                } catch (r) {
                }
                if (!d)try {
                    return new ActiveXObject("Microsoft.XMLHTTP")
                } catch (s) {
                }
            }
        },
            {"has-cors": 40}],
        21: [function (b, d, e) {
            d.exports = function (b, d) {
                var e = function () {
                };
                e.prototype = d.prototype;
                b.prototype = new e;
                b.prototype.constructor = b
            }
        }, {}],
        22: [function (b, d, e) {
            function f() {
                var b;
                try {
                    b = localStorage.debug
                } catch (d) {
                }
                return b
            }

            e = d.exports = b("./debug");
            e.log = function () {
                return "object" == typeof console && "function" == typeof console.log && Function.prototype.apply.call(console.log, console, arguments)
            };
            e.formatArgs = function () {
                var b = arguments, d = this.useColors;
                b[0] = (d ? "%c" : "") + this.namespace + (d ? " %c" :
                        " ") + b[0] + (d ? "%c " : " ") + "+" + e.humanize(this.diff);
                if (!d)return b;
                var d = "color: " + this.color, b = [b[0], d, "color: inherit"].concat(Array.prototype.slice.call(b, 1)), f = 0, p = 0;
                b[0].replace(/%[a-z%]/g, function (b) {
                    "%" !== b && (f++, "%c" === b && (p = f))
                });
                b.splice(p, 0, d);
                return b
            };
            e.save = function (b) {
                try {
                    null == b ? localStorage.removeItem("debug") : localStorage.debug = b
                } catch (d) {
                }
            };
            e.load = f;
            e.useColors = function () {
                return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception &&
                    console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10)
            };
            e.colors = "lightseagreen forestgreen goldenrod dodgerblue darkorchid crimson".split(" ");
            e.formatters.j = function (b) {
                return JSON.stringify(b)
            };
            e.enable(f())
        }, {"./debug": 23}],
        23: [function (b, d, e) {
            e = d.exports = function (b) {
                function d() {
                }

                function p() {
                    var b = p, d = +new Date;
                    b.diff = d - (g || d);
                    b.prev = g;
                    g = b.curr = d;
                    null == b.useColors && (b.useColors = e.useColors());
                    null == b.color && b.useColors && (b.color = e.colors[f++ % e.colors.length]);
                    var h = Array.prototype.slice.call(arguments);
                    h[0] = e.coerce(h[0]);
                    "string" !== typeof h[0] && (h = ["%o"].concat(h));
                    var n = 0;
                    h[0] = h[0].replace(/%([a-z%])/g, function (d, f) {
                        if ("%" === d)return d;
                        n++;
                        var g = e.formatters[f];
                        "function" === typeof g && (d = g.call(b, h[n]), h.splice(n, 1), n--);
                        return d
                    });
                    "function" === typeof e.formatArgs && (h = e.formatArgs.apply(b, h));
                    (p.log || e.log || console.log.bind(console)).apply(b, h)
                }

                d.enabled = !1;
                p.enabled = !0;
                var r = e.enabled(b) ? p : d;
                r.namespace = b;
                return r
            };
            e.coerce = function (b) {
                return b instanceof Error ? b.stack || b.message : b
            };
            e.disable = function () {
                e.enable("")
            };
            e.enable = function (b) {
                e.save(b);
                for (var d = (b || "").split(/[\s,]+/), f = d.length, g = 0; g < f; g++)d[g] && (b = d[g].replace(/\*/g, ".*?"), "-" === b[0] ? e.skips.push(RegExp("^" + b.substr(1) + "$")) : e.names.push(RegExp("^" + b + "$")))
            };
            e.enabled = function (b) {
                var d, f;
                d = 0;
                for (f = e.skips.length; d < f; d++)if (e.skips[d].test(b))return !1;
                d = 0;
                for (f = e.names.length; d < f; d++)if (e.names[d].test(b))return !0;
                return !1
            };
            e.humanize = b("ms");
            e.names = [];
            e.skips = [];
            e.formatters = {};
            var f =
                0, g
        }, {ms: 24}],
        24: [function (b, d, e) {
            function f(b) {
                if (b = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(b)) {
                    var d = parseFloat(b[1]);
                    switch ((b[2] || "ms").toLowerCase()) {
                        case "years":
                        case "year":
                        case "y":
                            return d * s;
                        case "days":
                        case "day":
                        case "d":
                            return d * r;
                        case "hours":
                        case "hour":
                        case "h":
                            return d * p;
                        case "minutes":
                        case "minute":
                        case "m":
                            return d * n;
                        case "seconds":
                        case "second":
                        case "s":
                            return d * h;
                        case "ms":
                            return d
                    }
                }
            }

            function g(b, d, e) {
                if (!(b < d))return b < 1.5 * d ? Math.floor(b /
                    d) + " " + e : Math.ceil(b / d) + " " + e + "s"
            }

            var h = 1E3, n = 60 * h, p = 60 * n, r = 24 * p, s = 365.25 * r;
            d.exports = function (b, d) {
                d = d || {};
                return "string" == typeof b ? f(b) : d.long ? g(b, r, "day") || g(b, p, "hour") || g(b, n, "minute") || g(b, h, "second") || b + " ms" : b >= r ? Math.round(b / r) + "d" : b >= p ? Math.round(b / p) + "h" : b >= n ? Math.round(b / n) + "m" : b >= h ? Math.round(b / h) + "s" : b + "ms"
            }
        }, {}],
        25: [function (b, d, e) {
            (function (d) {
                function g(b, d, f) {
                    if (!d)return e.encodeBase64Packet(b, f);
                    var g = new FileReader;
                    g.onload = function () {
                        b.data = g.result;
                        e.encodePacket(b, d, !0, f)
                    };
                    return g.readAsArrayBuffer(b.data)
                }

                function h(b, d, e) {
                    var f = Array(b.length);
                    e = t(b.length, e);
                    for (var g = function (b, e, g) {
                        d(e, function (d, e) {
                            f[b] = e;
                            g(d, f)
                        })
                    }, h = 0; h < b.length; h++)g(h, b[h], e)
                }

                var n = b("./keys"), p = b("has-binary"), r = b("arraybuffer.slice"), s = b("base64-arraybuffer"), t = b("after"), v = b("utf8"), u = navigator.userAgent.match(/Android/i), x = /PhantomJS/i.test(navigator.userAgent), w = u || x;
                e.protocol = 3;
                var y = e.packets = {
                        open: 0,
                        close: 1,
                        ping: 2,
                        pong: 3,
                        message: 4,
                        upgrade: 5,
                        noop: 6
                    }, A = n(y), D = {type: "error", data: "parser error"},
                    G = b("blob");
                e.encodePacket = function (b, h, n, p) {
                    "function" == typeof h && (p = h, h = !1);
                    "function" == typeof n && (p = n, n = null);
                    var r = void 0 === b.data ? void 0 : b.data.buffer || b.data;
                    if (d.ArrayBuffer && r instanceof ArrayBuffer) {
                        if (h) {
                            n = b.data;
                            h = new Uint8Array(n);
                            n = new Uint8Array(1 + n.byteLength);
                            n[0] = y[b.type];
                            for (b = 0; b < h.length; b++)n[b + 1] = h[b];
                            b = p(n.buffer)
                        } else b = e.encodeBase64Packet(b, p);
                        return b
                    }
                    if (G && r instanceof d.Blob)return h ? w ? b = g(b, h, p) : (h = new Uint8Array(1), h[0] = y[b.type], b = new G([h.buffer, b.data]), b = p(b)) :
                        b = e.encodeBase64Packet(b, p), b;
                    if (r && r.base64)return p("b" + e.packets[b.type] + b.data.data);
                    h = y[b.type];
                    void 0 !== b.data && (h += n ? v.encode(String(b.data)) : String(b.data));
                    return p("" + h)
                };
                e.encodeBase64Packet = function (b, g) {
                    var h = "b" + e.packets[b.type];
                    if (G && b.data instanceof G) {
                        var n = new FileReader;
                        n.onload = function () {
                            var b = n.result.split(",")[1];
                            g(h + b)
                        };
                        return n.readAsDataURL(b.data)
                    }
                    var p;
                    try {
                        p = String.fromCharCode.apply(null, new Uint8Array(b.data))
                    } catch (r) {
                        p = new Uint8Array(b.data);
                        for (var s = Array(p.length),
                                 t = 0; t < p.length; t++)s[t] = p[t];
                        p = String.fromCharCode.apply(null, s)
                    }
                    h += d.btoa(p);
                    return g(h)
                };
                e.decodePacket = function (b, d, f) {
                    if ("string" == typeof b || void 0 === b) {
                        if ("b" == b.charAt(0))return e.decodeBase64Packet(b.substr(1), d);
                        if (f)try {
                            b = v.decode(b)
                        } catch (g) {
                            return D
                        }
                        f = b.charAt(0);
                        return Number(f) == f && A[f] ? 1 < b.length ? {
                            type: A[f],
                            data: b.substring(1)
                        } : {type: A[f]} : D
                    }
                    f = (new Uint8Array(b))[0];
                    b = r(b, 1);
                    G && "blob" === d && (b = new G([b]));
                    return {type: A[f], data: b}
                };
                e.decodeBase64Packet = function (b, e) {
                    var g = A[b.charAt(0)];
                    if (!d.ArrayBuffer)return {type: g, data: {base64: !0, data: b.substr(1)}};
                    var h = s.decode(b.substr(1));
                    "blob" === e && G && (h = new G([h]));
                    return {type: g, data: h}
                };
                e.encodePayload = function (b, d, f) {
                    "function" == typeof d && (f = d, d = null);
                    var g = p(b);
                    if (d && g)return G && !w ? e.encodePayloadAsBlob(b, f) : e.encodePayloadAsArrayBuffer(b, f);
                    if (!b.length)return f("0:");
                    h(b, function (b, f) {
                        e.encodePacket(b, g ? d : !1, !0, function (b) {
                            f(null, b.length + ":" + b)
                        })
                    }, function (b, d) {
                        return f(d.join(""))
                    })
                };
                e.decodePayload = function (b, d, f) {
                    if ("string" != typeof b)return e.decodePayloadAsBinary(b, d, f);
                    "function" === typeof d && (f = d, d = null);
                    var g;
                    if ("" == b)return f(D, 0, 1);
                    g = "";
                    for (var h, n, p = 0, r = b.length; p < r; p++)if (n = b.charAt(p), ":" != n)g += n; else {
                        if ("" == g || g != (h = Number(g)))return f(D, 0, 1);
                        n = b.substr(p + 1, h);
                        if (g != n.length)return f(D, 0, 1);
                        if (n.length) {
                            g = e.decodePacket(n, d, !0);
                            if (D.type == g.type && D.data == g.data)return f(D, 0, 1);
                            if (!1 === f(g, p + h, r))return
                        }
                        p += h;
                        g = ""
                    }
                    if ("" != g)return f(D, 0, 1)
                };
                e.encodePayloadAsArrayBuffer = function (b, d) {
                    if (!b.length)return d(new ArrayBuffer(0));
                    h(b, function (b, d) {
                        e.encodePacket(b, !0, !0, function (b) {
                            return d(null, b)
                        })
                    }, function (b, e) {
                        var f = e.reduce(function (b, d) {
                            var e;
                            e = "string" === typeof d ? d.length : d.byteLength;
                            return b + e.toString().length + e + 2
                        }, 0), g = new Uint8Array(f), h = 0;
                        e.forEach(function (b) {
                            var d = "string" === typeof b, e = b;
                            if (d) {
                                for (var e = new Uint8Array(b.length), f = 0; f < b.length; f++)e[f] = b.charCodeAt(f);
                                e = e.buffer
                            }
                            d ? g[h++] = 0 : g[h++] = 1;
                            b = e.byteLength.toString();
                            for (f = 0; f < b.length; f++)g[h++] = parseInt(b[f]);
                            g[h++] = 255;
                            e = new Uint8Array(e);
                            for (f = 0; f <
                            e.length; f++)g[h++] = e[f]
                        });
                        return d(g.buffer)
                    })
                };
                e.encodePayloadAsBlob = function (b, d) {
                    h(b, function (b, d) {
                        e.encodePacket(b, !0, !0, function (b) {
                            var e = new Uint8Array(1);
                            e[0] = 1;
                            if ("string" === typeof b) {
                                for (var f = new Uint8Array(b.length), g = 0; g < b.length; g++)f[g] = b.charCodeAt(g);
                                b = f.buffer;
                                e[0] = 0
                            }
                            for (var f = (b instanceof ArrayBuffer ? b.byteLength : b.size).toString(), h = new Uint8Array(f.length + 1), g = 0; g < f.length; g++)h[g] = parseInt(f[g]);
                            h[f.length] = 255;
                            G && (b = new G([e.buffer, h.buffer, b]), d(null, b))
                        })
                    }, function (b, e) {
                        return d(new G(e))
                    })
                };
                e.decodePayloadAsBinary = function (b, d, f) {
                    "function" === typeof d && (f = d, d = null);
                    for (var g = [], h = !1; 0 < b.byteLength;) {
                        for (var n = new Uint8Array(b), p = 0 === n[0], s = "", t = 1; 255 != n[t]; t++) {
                            if (310 < s.length) {
                                h = !0;
                                break
                            }
                            s += n[t]
                        }
                        if (h)return f(D, 0, 1);
                        b = r(b, 2 + s.length);
                        s = parseInt(s);
                        n = r(b, 0, s);
                        if (p)try {
                            n = String.fromCharCode.apply(null, new Uint8Array(n))
                        } catch (u) {
                            for (p = new Uint8Array(n), n = "", t = 0; t < p.length; t++)n += String.fromCharCode(p[t])
                        }
                        g.push(n);
                        b = r(b, s)
                    }
                    var v = g.length;
                    g.forEach(function (b, g) {
                        f(e.decodePacket(b, d, !0),
                            g, v)
                    })
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {
            "./keys": 26,
            after: 27,
            "arraybuffer.slice": 28,
            "base64-arraybuffer": 29,
            blob: 30,
            "has-binary": 31,
            utf8: 33
        }],
        26: [function (b, d, e) {
            d.exports = Object.keys || function (b) {
                    var d = [], e = Object.prototype.hasOwnProperty, n;
                    for (n in b)e.call(b, n) && d.push(n);
                    return d
                }
        }, {}],
        27: [function (b, d, e) {
            function f() {
            }

            d.exports = function (b, d, e) {
                function p(b, f) {
                    if (0 >= p.count)throw Error("after called too many times");
                    --p.count;
                    b ? (r = !0, d(b), d =
                        e) : 0 !== p.count || r || d(null, f)
                }

                var r = !1;
                e = e || f;
                p.count = b;
                return 0 === b ? d() : p
            }
        }, {}],
        28: [function (b, d, e) {
            d.exports = function (b, d, e) {
                var n = b.byteLength;
                d = d || 0;
                e = e || n;
                if (b.slice)return b.slice(d, e);
                0 > d && (d += n);
                0 > e && (e += n);
                e > n && (e = n);
                if (d >= n || d >= e || 0 === n)return new ArrayBuffer(0);
                b = new Uint8Array(b);
                for (var n = new Uint8Array(e - d), p = 0; d < e; d++, p++)n[p] = b[d];
                return n.buffer
            }
        }, {}],
        29: [function (b, d, e) {
            (function (b) {
                e.encode = function (d) {
                    d = new Uint8Array(d);
                    var e, n = d.length, p = "";
                    for (e = 0; e < n; e += 3)p += b[d[e] >> 2], p += b[(d[e] &
                    3) << 4 | d[e + 1] >> 4], p += b[(d[e + 1] & 15) << 2 | d[e + 2] >> 6], p += b[d[e + 2] & 63];
                    2 === n % 3 ? p = p.substring(0, p.length - 1) + "\x3d" : 1 === n % 3 && (p = p.substring(0, p.length - 2) + "\x3d\x3d");
                    return p
                };
                e.decode = function (d) {
                    var e = 0.75 * d.length, n = d.length, p = 0, r, s, t, v;
                    "\x3d" === d[d.length - 1] && (e--, "\x3d" === d[d.length - 2] && e--);
                    for (var u = new ArrayBuffer(e), x = new Uint8Array(u), e = 0; e < n; e += 4)r = b.indexOf(d[e]), s = b.indexOf(d[e + 1]), t = b.indexOf(d[e + 2]), v = b.indexOf(d[e + 3]), x[p++] = r << 2 | s >> 4, x[p++] = (s & 15) << 4 | t >> 2, x[p++] = (t & 3) << 6 | v & 63;
                    return u
                }
            })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
        },
            {}],
        30: [function (b, d, e) {
            (function (b) {
                function e(b, d) {
                    d = d || {};
                    for (var f = new h, g = 0; g < b.length; g++)f.append(b[g]);
                    return d.type ? f.getBlob(d.type) : f.getBlob()
                }

                var h = b.BlobBuilder || b.WebKitBlobBuilder || b.MSBlobBuilder || b.MozBlobBuilder, n;
                try {
                    n = 2 == (new Blob(["hi"])).size
                } catch (p) {
                    n = !1
                }
                var r = h && h.prototype.append && h.prototype.getBlob;
                b = n ? b.Blob : r ? e : void 0;
                d.exports = b
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {}],
        31: [function (b, d, e) {
            (function (e) {
                var g = b("isarray");
                d.exports = function (b) {
                    function d(b) {
                        if (!b)return !1;
                        if (e.Buffer && e.Buffer.isBuffer(b) || e.ArrayBuffer && b instanceof ArrayBuffer || e.Blob && b instanceof Blob || e.File && b instanceof File)return !0;
                        if (g(b))for (var h = 0; h < b.length; h++) {
                            if (d(b[h]))return !0
                        } else if (b && "object" == typeof b)for (h in b.toJSON && (b = b.toJSON()), b)if (b.hasOwnProperty(h) && d(b[h]))return !0;
                        return !1
                    }

                    return d(b)
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {isarray: 32}],
        32: [function (b, d, e) {
            d.exports =
                Array.isArray || function (b) {
                    return "[object Array]" == Object.prototype.toString.call(b)
                }
        }, {}],
        33: [function (b, d, e) {
            (function (b) {
                (function (g) {
                    function h(b) {
                        for (var d = [], e = 0, f = b.length, g, h; e < f;)g = b.charCodeAt(e++), 55296 <= g && 56319 >= g && e < f ? (h = b.charCodeAt(e++), 56320 == (h & 64512) ? d.push(((g & 1023) << 10) + (h & 1023) + 65536) : (d.push(g), e--)) : d.push(g);
                        return d
                    }

                    function n() {
                        if (w >= x)throw Error("Invalid byte index");
                        var b = u[w] & 255;
                        w++;
                        if (128 == (b & 192))return b & 63;
                        throw Error("Invalid continuation byte");
                    }

                    function p() {
                        var b,
                            d, e, f;
                        if (w > x)throw Error("Invalid byte index");
                        if (w == x)return !1;
                        b = u[w] & 255;
                        w++;
                        if (0 == (b & 128))return b;
                        if (192 == (b & 224)) {
                            d = n();
                            b = (b & 31) << 6 | d;
                            if (128 <= b)return b;
                            throw Error("Invalid continuation byte");
                        }
                        if (224 == (b & 240)) {
                            d = n();
                            e = n();
                            b = (b & 15) << 12 | d << 6 | e;
                            if (2048 <= b)return b;
                            throw Error("Invalid continuation byte");
                        }
                        if (240 == (b & 248) && (d = n(), e = n(), f = n(), b = (b & 15) << 18 | d << 12 | e << 6 | f, 65536 <= b && 1114111 >= b))return b;
                        throw Error("Invalid UTF-8 detected");
                    }

                    var r = "object" == typeof e && e, s = "object" == typeof d && d && d.exports ==
                        r && d, t = "object" == typeof b && b;
                    if (t.global === t || t.window === t)g = t;
                    var v = String.fromCharCode, u, x, w, t = {
                        version: "2.0.0", encode: function (b) {
                            b = h(b);
                            for (var d = b.length, e = -1, f, g = ""; ++e < d;) {
                                f = b[e];
                                if (0 == (f & 4294967168))f = v(f); else {
                                    var n = "";
                                    0 == (f & 4294965248) ? n = v(f >> 6 & 31 | 192) : 0 == (f & 4294901760) ? (n = v(f >> 12 & 15 | 224), n += v(f >> 6 & 63 | 128)) : 0 == (f & 4292870144) && (n = v(f >> 18 & 7 | 240), n += v(f >> 12 & 63 | 128), n += v(f >> 6 & 63 | 128));
                                    f = n += v(f & 63 | 128)
                                }
                                g += f
                            }
                            return g
                        }, decode: function (b) {
                            u = h(b);
                            x = u.length;
                            w = 0;
                            b = [];
                            for (var d; !1 !== (d = p());)b.push(d);
                            d = b.length;
                            for (var e = -1, f, g = ""; ++e < d;)f = b[e], 65535 < f && (f -= 65536, g += v(f >>> 10 & 1023 | 55296), f = 56320 | f & 1023), g += v(f);
                            return g
                        }
                    };
                    if (r && !r.nodeType)if (s)s.exports = t; else {
                        g = {}.hasOwnProperty;
                        for (var y in t)g.call(t, y) && (r[y] = t[y])
                    } else g.utf8 = t
                })(this)
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {}],
        34: [function (b, d, e) {
            (function (b) {
                var e = /^[\],:{}\s]*$/, h = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, n = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, p = /(?:^|:|,)(?:\s*\[)+/g,
                    r = /^\s+/, s = /\s+$/;
                d.exports = function (d) {
                    if ("string" != typeof d || !d)return null;
                    d = d.replace(r, "").replace(s, "");
                    if (b.JSON && JSON.parse)return JSON.parse(d);
                    if (e.test(d.replace(h, "@").replace(n, "]").replace(p, "")))return (new Function("return " + d))()
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {}],
        35: [function (b, d, e) {
            e.encode = function (b) {
                var d = "", e;
                for (e in b)b.hasOwnProperty(e) && (d.length && (d += "\x26"), d += encodeURIComponent(e) + "\x3d" + encodeURIComponent(b[e]));
                return d
            };
            e.decode = function (b) {
                var d = {};
                b = b.split("\x26");
                for (var e = 0, n = b.length; e < n; e++) {
                    var p = b[e].split("\x3d");
                    d[decodeURIComponent(p[0])] = decodeURIComponent(p[1])
                }
                return d
            }
        }, {}],
        36: [function (b, d, e) {
            var f = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, g = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
            d.exports = function (b) {
                var d = b, e = b.indexOf("["), r = b.indexOf("]");
                -1 != e && -1 != r && (b = b.substring(0, e) + b.substring(e, r).replace(/:/g, ";") + b.substring(r, b.length));
                b = f.exec(b || "");
                for (var s = {}, t = 14; t--;)s[g[t]] = b[t] || "";
                -1 != e && -1 != r && (s.source = d, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0);
                return s
            }
        }, {}],
        37: [function (b, d, e) {
            function f(b, d, e) {
                return d ? new g(b, d) : new g(b)
            }

            b = function () {
                return this
            }();
            var g =
                b.WebSocket || b.MozWebSocket;
            d.exports = g ? f : null;
            g && (f.prototype = g.prototype)
        }, {}],
        38: [function (b, d, e) {
            (function (e) {
                var g = b("isarray");
                d.exports = function (b) {
                    function d(b) {
                        if (!b)return !1;
                        if (e.Buffer && e.Buffer.isBuffer(b) || e.ArrayBuffer && b instanceof ArrayBuffer || e.Blob && b instanceof Blob || e.File && b instanceof File)return !0;
                        if (g(b))for (var h = 0; h < b.length; h++) {
                            if (d(b[h]))return !0
                        } else if (b && "object" == typeof b)for (h in b.toJSON && (b = b.toJSON()), b)if (Object.prototype.hasOwnProperty.call(b, h) && d(b[h]))return !0;
                        return !1
                    }

                    return d(b)
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {isarray: 39}],
        39: [function (b, d, e) {
            d.exports = b(32)
        }, {}],
        40: [function (b, d, e) {
            b = b("global");
            try {
                d.exports = "XMLHttpRequest" in b && "withCredentials" in new b.XMLHttpRequest
            } catch (f) {
                d.exports = !1
            }
        }, {global: 41}],
        41: [function (b, d, e) {
            d.exports = function () {
                return this
            }()
        }, {}],
        42: [function (b, d, e) {
            var f = [].indexOf;
            d.exports = function (b, d) {
                if (f)return b.indexOf(d);
                for (var e = 0; e < b.length; ++e)if (b[e] === d)return e;
                return -1
            }
        }, {}],
        43: [function (b, d, e) {
            var f = Object.prototype.hasOwnProperty;
            e.keys = Object.keys || function (b) {
                    var d = [], e;
                    for (e in b)f.call(b, e) && d.push(e);
                    return d
                };
            e.values = function (b) {
                var d = [], e;
                for (e in b)f.call(b, e) && d.push(b[e]);
                return d
            };
            e.merge = function (b, d) {
                for (var e in d)f.call(d, e) && (b[e] = d[e]);
                return b
            };
            e.length = function (b) {
                return e.keys(b).length
            };
            e.isEmpty = function (b) {
                return 0 == e.length(b)
            }
        }, {}],
        44: [function (b, d, e) {
            var f = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
                g = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
            d.exports = function (b) {
                b = f.exec(b || "");
                for (var d = {}, e = 14; e--;)d[g[e]] = b[e] || "";
                return d
            }
        }, {}],
        45: [function (b, d, e) {
            (function (d) {
                var g = b("isarray"), h = b("./is-buffer");
                e.deconstructPacket = function (b) {
                    function d(b) {
                        if (!b)return b;
                        if (h(b)) {
                            var f = {_placeholder: !0, num: e.length};
                            e.push(b);
                            return f
                        }
                        if (g(b)) {
                            for (var f = Array(b.length), n = 0; n < b.length; n++)f[n] = d(b[n]);
                            return f
                        }
                        if ("object" == typeof b && !(b instanceof Date)) {
                            f = {};
                            for (n in b)f[n] = d(b[n]);
                            return f
                        }
                        return b
                    }

                    var e = [];
                    b.data = d(b.data);
                    b.attachments = e.length;
                    return {packet: b, buffers: e}
                };
                e.reconstructPacket = function (b, d) {
                    function e(b) {
                        if (b && b._placeholder)return d[b.num];
                        if (g(b))for (var f = 0; f < b.length; f++)b[f] = e(b[f]); else if (b && "object" == typeof b)for (f in b)b[f] = e(b[f]);
                        return b
                    }

                    b.data = e(b.data);
                    b.attachments = void 0;
                    return b
                };
                e.removeBlobs = function (b, e) {
                    function r(b, n, x) {
                        if (!b)return b;
                        if (d.Blob && b instanceof Blob || d.File && b instanceof File) {
                            s++;
                            var w = new FileReader;
                            w.onload = function () {
                                x ? x[n] = this.result : t = this.result;
                                --s || e(t)
                            };
                            w.readAsArrayBuffer(b)
                        } else if (g(b))for (w = 0; w < b.length; w++)r(b[w], w, b); else if (b && "object" == typeof b && !h(b))for (w in b)r(b[w], w, b)
                    }

                    var s = 0, t = b;
                    r(t);
                    s || e(t)
                }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {"./is-buffer": 47, isarray: 48}],
        46: [function (b, d, e) {
            function f() {
            }

            function g(b) {
                var d, f = !1;
                d = "" + b.type;
                if (e.BINARY_EVENT == b.type || e.BINARY_ACK == b.type)d += b.attachments,
                    d += "-";
                b.nsp && "/" != b.nsp && (f = !0, d += b.nsp);
                null != b.id && (f && (d += ",", f = !1), d += b.id);
                null != b.data && (f && (d += ","), d += s.stringify(b.data));
                r("encoded %j as %s", b, d);
                return d
            }

            function h(b, d) {
                t.removeBlobs(b, function (b) {
                    var e = t.deconstructPacket(b);
                    b = g(e.packet);
                    e = e.buffers;
                    e.unshift(b);
                    d(e)
                })
            }

            function n() {
                this.reconstructor = null
            }

            function p(b) {
                this.reconPack = b;
                this.buffers = []
            }

            var r = b("debug")("socket.io-parser"), s = b("json3");
            b("isarray");
            d = b("component-emitter");
            var t = b("./binary"), v = b("./is-buffer");
            e.protocol =
                4;
            e.types = "CONNECT DISCONNECT EVENT BINARY_EVENT ACK BINARY_ACK ERROR".split(" ");
            e.CONNECT = 0;
            e.DISCONNECT = 1;
            e.EVENT = 2;
            e.ACK = 3;
            e.ERROR = 4;
            e.BINARY_EVENT = 5;
            e.BINARY_ACK = 6;
            e.Encoder = f;
            e.Decoder = n;
            f.prototype.encode = function (b, d) {
                r("encoding packet %j", b);
                if (e.BINARY_EVENT == b.type || e.BINARY_ACK == b.type)h(b, d); else {
                    var f = g(b);
                    d([f])
                }
            };
            d(n.prototype);
            n.prototype.add = function (b) {
                if ("string" == typeof b) {
                    a:{
                        var d = {}, f = 0;
                        d.type = Number(b.charAt(0));
                        if (null == e.types[d.type])b = {type: e.ERROR, data: "parser error"};
                        else {
                            if (e.BINARY_EVENT == d.type || e.BINARY_ACK == d.type) {
                                for (var g = ""; "-" != b.charAt(++f) && (g += b.charAt(f), f != b.length););
                                if (g != Number(g) || "-" != b.charAt(f))throw Error("Illegal attachments");
                                d.attachments = Number(g)
                            }
                            if ("/" == b.charAt(f + 1))for (d.nsp = ""; ++f;) {
                                g = b.charAt(f);
                                if ("," == g)break;
                                d.nsp += g;
                                if (f == b.length)break
                            } else d.nsp = "/";
                            g = b.charAt(f + 1);
                            if ("" !== g && Number(g) == g) {
                                for (d.id = ""; ++f;) {
                                    g = b.charAt(f);
                                    if (null == g || Number(g) != g) {
                                        --f;
                                        break
                                    }
                                    d.id += b.charAt(f);
                                    if (f == b.length)break
                                }
                                d.id = Number(d.id)
                            }
                            if (b.charAt(++f))try {
                                d.data =
                                    s.parse(b.substr(f))
                            } catch (h) {
                                b = {type: e.ERROR, data: "parser error"};
                                break a
                            }
                            r("decoded %s as %j", b, d);
                            b = d
                        }
                    }
                    e.BINARY_EVENT == b.type || e.BINARY_ACK == b.type ? (this.reconstructor = new p(b), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", b)) : this.emit("decoded", b)
                } else if (v(b) || b.base64)if (this.reconstructor) {
                    if (b = this.reconstructor.takeBinaryData(b))this.reconstructor = null, this.emit("decoded", b)
                } else throw Error("got binary data when not reconstructing a packet"); else throw Error("Unknown type: " +
                    b);
            };
            n.prototype.destroy = function () {
                this.reconstructor && this.reconstructor.finishedReconstruction()
            };
            p.prototype.takeBinaryData = function (b) {
                this.buffers.push(b);
                return this.buffers.length == this.reconPack.attachments ? (b = t.reconstructPacket(this.reconPack, this.buffers), this.finishedReconstruction(), b) : null
            };
            p.prototype.finishedReconstruction = function () {
                this.reconPack = null;
                this.buffers = []
            }
        }, {"./binary": 45, "./is-buffer": 47, "component-emitter": 9, debug: 10, isarray: 48, json3: 49}],
        47: [function (b, d, e) {
            (function (b) {
                d.exports =
                    function (d) {
                        return b.Buffer && b.Buffer.isBuffer(d) || b.ArrayBuffer && d instanceof ArrayBuffer
                    }
            }).call(this, "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
        }, {}],
        48: [function (b, d, e) {
            d.exports = b(32)
        }, {}],
        49: [function (b, d, e) {
            (function (b) {
                function d(b) {
                    if (d[b] !== r)return d[b];
                    var e;
                    if ("bug-string-char-index" == b)e = "a" != "a"[0]; else if ("json" == b)e = d("json-stringify") && d("json-parse"); else {
                        var f;
                        if ("json-stringify" == b) {
                            e = t.stringify;
                            var n = "function" == typeof e && v;
                            if (n) {
                                (f = function () {
                                    return 1
                                }).toJSON =
                                    f;
                                try {
                                    n = "0" === e(0) && "0" === e(new Number) && '""' == e(new String) && e(h) === r && e(r) === r && e() === r && "1" === e(f) && "[1]" == e([f]) && "[null]" == e([r]) && "null" == e(null) && "[null,null,null]" == e([r, h, null]) && '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}' == e({a: [f, !0, !1, null, "\x00\b\n\f\r\t"]}) && "1" === e(null, f) && "[\n 1,\n 2\n]" == e([1, 2], null, 1) && '"-271821-04-20T00:00:00.000Z"' == e(new Date(-864E13)) && '"+275760-09-13T00:00:00.000Z"' == e(new Date(864E13)) && '"-000001-01-01T00:00:00.000Z"' == e(new Date(-621987552E5)) &&
                                        '"1969-12-31T23:59:59.999Z"' == e(new Date(-1))
                                } catch (p) {
                                    n = !1
                                }
                            }
                            e = n
                        }
                        if ("json-parse" == b) {
                            e = t.parse;
                            if ("function" == typeof e)try {
                                if (0 === e("0") && !e(!1)) {
                                    f = e('{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}');
                                    var s = 5 == f.a.length && 1 === f.a[0];
                                    if (s) {
                                        try {
                                            s = !e('"\t"')
                                        } catch (u) {
                                        }
                                        if (s)try {
                                            s = 1 !== e("01")
                                        } catch (w) {
                                        }
                                        if (s)try {
                                            s = 1 !== e("1.")
                                        } catch (x) {
                                        }
                                    }
                                }
                            } catch (y) {
                                s = !1
                            }
                            e = s
                        }
                    }
                    return d[b] = !!e
                }

                var h = {}.toString, n, p, r, s = "object" == typeof JSON && JSON, t = "object" == typeof e && e && !e.nodeType && e;
                t && s ? (t.stringify = s.stringify, t.parse =
                    s.parse) : t = b.JSON = s || {};
                var v = new Date(-0xc782b5b800cec);
                try {
                    v = -109252 == v.getUTCFullYear() && 0 === v.getUTCMonth() && 1 === v.getUTCDate() && 10 == v.getUTCHours() && 37 == v.getUTCMinutes() && 6 == v.getUTCSeconds() && 708 == v.getUTCMilliseconds()
                } catch (u) {
                }
                if (!d("json")) {
                    var x = d("bug-string-char-index");
                    if (!v)var w = Math.floor, y = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], A = function (b, d) {
                        return y[d] + 365 * (b - 1970) + w((b - 1969 + (d = +(1 < d))) / 4) - w((b - 1901 + d) / 100) + w((b - 1601 + d) / 400)
                    };
                    (n = {}.hasOwnProperty) || (n = function (b) {
                        var d =
                        {}, e;
                        (d.__proto__ = null, d.__proto__ = {toString: 1}, d).toString != h ? n = function (b) {
                            var d = this.__proto__;
                            b = b in (this.__proto__ = null, this);
                            this.__proto__ = d;
                            return b
                        } : (e = d.constructor, n = function (b) {
                            var d = (this.constructor || e).prototype;
                            return b in this && !(b in d && this[b] === d[b])
                        });
                        d = null;
                        return n.call(this, b)
                    });
                    var D = {"boolean": 1, number: 1, string: 1, undefined: 1};
                    p = function (b, d) {
                        var e = 0, f, g, r;
                        (f = function () {
                            this.valueOf = 0
                        }).prototype.valueOf = 0;
                        g = new f;
                        for (r in g)n.call(g, r) && e++;
                        f = g = null;
                        e ? p = 2 == e ? function (b, d) {
                            var e =
                            {}, f = "[object Function]" == h.call(b), g;
                            for (g in b)f && "prototype" == g || n.call(e, g) || !(e[g] = 1) || !n.call(b, g) || d(g)
                        } : function (b, d) {
                            var e = "[object Function]" == h.call(b), f, g;
                            for (f in b)e && "prototype" == f || !n.call(b, f) || (g = "constructor" === f) || d(f);
                            (g || n.call(b, f = "constructor")) && d(f)
                        } : (g = "valueOf toString toLocaleString propertyIsEnumerable isPrototypeOf hasOwnProperty constructor".split(" "), p = function (b, d) {
                            var e = "[object Function]" == h.call(b), f, p;
                            if (p = !e)if (p = "function" != typeof b.constructor)p = typeof b.hasOwnProperty,
                                p = "object" == p ? !!b.hasOwnProperty : !D[p];
                            p = p ? b.hasOwnProperty : n;
                            for (f in b)e && "prototype" == f || !p.call(b, f) || d(f);
                            for (e = g.length; f = g[--e]; p.call(b, f) && d(f));
                        });
                        return p(b, d)
                    };
                    if (!d("json-stringify")) {
                        var G = {
                            92: "\\\\",
                            34: '\\"',
                            8: "\\b",
                            12: "\\f",
                            10: "\\n",
                            13: "\\r",
                            9: "\\t"
                        }, B = function (b, d) {
                            return ("000000" + (d || 0)).slice(-b)
                        }, C = function (b) {
                            var d = '"', e = 0, f = b.length, g = 10 < f && x, h;
                            for (g && (h = b.split("")); e < f; e++) {
                                var n = b.charCodeAt(e);
                                switch (n) {
                                    case 8:
                                    case 9:
                                    case 10:
                                    case 12:
                                    case 13:
                                    case 34:
                                    case 92:
                                        d += G[n];
                                        break;
                                    default:
                                        if (32 > n) {
                                            d += "\\u00" + B(2, n.toString(16));
                                            break
                                        }
                                        d += g ? h[e] : x ? b.charAt(e) : b[e]
                                }
                            }
                            return d + '"'
                        }, E = function (b, d, e, f, g, s, t) {
                            var u, v, x, y, D, G, H, I, J;
                            try {
                                u = d[b]
                            } catch (K) {
                            }
                            if ("object" == typeof u && u)if (v = h.call(u), "[object Date]" != v || n.call(u, "toJSON"))"function" == typeof u.toJSON && ("[object Number]" != v && "[object String]" != v && "[object Array]" != v || n.call(u, "toJSON")) && (u = u.toJSON(b)); else if (u > -1 / 0 && u < 1 / 0) {
                                if (A) {
                                    y = w(u / 864E5);
                                    for (v = w(y / 365.2425) + 1970 - 1; A(v + 1, 0) <= y; v++);
                                    for (x = w((y - A(v, 0)) / 30.42); A(v, x + 1) <= y; x++);
                                    y = 1 + y - A(v, x);
                                    D = (u % 864E5 + 864E5) % 864E5;
                                    G = w(D / 36E5) % 24;
                                    H = w(D / 6E4) % 60;
                                    I = w(D / 1E3) % 60;
                                    D %= 1E3
                                } else v = u.getUTCFullYear(), x = u.getUTCMonth(), y = u.getUTCDate(), G = u.getUTCHours(), H = u.getUTCMinutes(), I = u.getUTCSeconds(), D = u.getUTCMilliseconds();
                                u = (0 >= v || 1E4 <= v ? (0 > v ? "-" : "+") + B(6, 0 > v ? -v : v) : B(4, v)) + "-" + B(2, x + 1) + "-" + B(2, y) + "T" + B(2, G) + ":" + B(2, H) + ":" + B(2, I) + "." + B(3, D) + "Z"
                            } else u = null;
                            e && (u = e.call(d, b, u));
                            if (null === u)return "null";
                            v = h.call(u);
                            if ("[object Boolean]" == v)return "" + u;
                            if ("[object Number]" == v)return u > -1 / 0 && u <
                            1 / 0 ? "" + u : "null";
                            if ("[object String]" == v)return C("" + u);
                            if ("object" == typeof u) {
                                for (b = t.length; b--;)if (t[b] === u)throw TypeError();
                                t.push(u);
                                J = [];
                                d = s;
                                s += g;
                                if ("[object Array]" == v) {
                                    x = 0;
                                    for (b = u.length; x < b; x++)v = E(x, u, e, f, g, s, t), J.push(v === r ? "null" : v);
                                    b = J.length ? g ? "[\n" + s + J.join(",\n" + s) + "\n" + d + "]" : "[" + J.join(",") + "]" : "[]"
                                } else p(f || u, function (b) {
                                    var d = E(b, u, e, f, g, s, t);
                                    d !== r && J.push(C(b) + ":" + (g ? " " : "") + d)
                                }), b = J.length ? g ? "{\n" + s + J.join(",\n" + s) + "\n" + d + "}" : "{" + J.join(",") + "}" : "{}";
                                t.pop();
                                return b
                            }
                        };
                        t.stringify =
                            function (b, d, e) {
                                var f, g, n, p;
                                if ("function" == typeof d || "object" == typeof d && d)if ("[object Function]" == (p = h.call(d)))g = d; else if ("[object Array]" == p) {
                                    n = {};
                                    for (var r = 0, s = d.length, t; r < s; t = d[r++], (p = h.call(t), "[object String]" == p || "[object Number]" == p) && (n[t] = 1));
                                }
                                if (e)if ("[object Number]" == (p = h.call(e))) {
                                    if (0 < (e -= e % 1))for (f = "", 10 < e && (e = 10); f.length < e; f += " ");
                                } else"[object String]" == p && (f = 10 >= e.length ? e : e.slice(0, 10));
                                return E("", (t = {}, t[""] = b, t), g, n, f, "", [])
                            }
                    }
                    if (!d("json-parse")) {
                        var I = String.fromCharCode,
                            L = {
                                92: "\\",
                                34: '"',
                                47: "/",
                                98: "\b",
                                116: "\t",
                                110: "\n",
                                102: "\f",
                                114: "\r"
                            }, J, Q, M = function () {
                                J = Q = null;
                                throw SyntaxError();
                            }, K = function () {
                                for (var b = Q, d = b.length, e, f, g, h, n; J < d;)switch (n = b.charCodeAt(J), n) {
                                    case 9:
                                    case 10:
                                    case 13:
                                    case 32:
                                        J++;
                                        break;
                                    case 123:
                                    case 125:
                                    case 91:
                                    case 93:
                                    case 58:
                                    case 44:
                                        return e = x ? b.charAt(J) : b[J], J++, e;
                                    case 34:
                                        e = "@";
                                        for (J++; J < d;)if (n = b.charCodeAt(J), 32 > n)M(); else if (92 == n)switch (n = b.charCodeAt(++J), n) {
                                            case 92:
                                            case 34:
                                            case 47:
                                            case 98:
                                            case 116:
                                            case 110:
                                            case 102:
                                            case 114:
                                                e += L[n];
                                                J++;
                                                break;
                                            case 117:
                                                f = ++J;
                                                for (g = J + 4; J < g; J++)n = b.charCodeAt(J), 48 <= n && 57 >= n || 97 <= n && 102 >= n || 65 <= n && 70 >= n || M();
                                                e += I("0x" + b.slice(f, J));
                                                break;
                                            default:
                                                M()
                                        } else {
                                            if (34 == n)break;
                                            n = b.charCodeAt(J);
                                            for (f = J; 32 <= n && 92 != n && 34 != n;)n = b.charCodeAt(++J);
                                            e += b.slice(f, J)
                                        }
                                        if (34 == b.charCodeAt(J))return J++, e;
                                        M();
                                    default:
                                        f = J;
                                        45 == n && (h = !0, n = b.charCodeAt(++J));
                                        if (48 <= n && 57 >= n) {
                                            for (48 == n && (n = b.charCodeAt(J + 1), 48 <= n && 57 >= n) && M(); J < d && (n = b.charCodeAt(J), 48 <= n && 57 >= n); J++);
                                            if (46 == b.charCodeAt(J)) {
                                                for (g = ++J; g < d && (n = b.charCodeAt(g),
                                                48 <= n && 57 >= n); g++);
                                                g == J && M();
                                                J = g
                                            }
                                            n = b.charCodeAt(J);
                                            if (101 == n || 69 == n) {
                                                n = b.charCodeAt(++J);
                                                43 != n && 45 != n || J++;
                                                for (g = J; g < d && (n = b.charCodeAt(g), 48 <= n && 57 >= n); g++);
                                                g == J && M();
                                                J = g
                                            }
                                            return +b.slice(f, J)
                                        }
                                        h && M();
                                        if ("true" == b.slice(J, J + 4))return J += 4, !0;
                                        if ("false" == b.slice(J, J + 5))return J += 5, !1;
                                        if ("null" == b.slice(J, J + 4))return J += 4, null;
                                        M()
                                }
                                return "$"
                            }, H = function (b) {
                                var d, e;
                                "$" == b && M();
                                if ("string" == typeof b) {
                                    if ("@" == (x ? b.charAt(0) : b[0]))return b.slice(1);
                                    if ("[" == b) {
                                        for (d = []; ; e || (e = !0)) {
                                            b = K();
                                            if ("]" == b)break;
                                            e &&
                                            ("," == b ? (b = K(), "]" == b && M()) : M());
                                            "," == b && M();
                                            d.push(H(b))
                                        }
                                        return d
                                    }
                                    if ("{" == b) {
                                        for (d = {}; ; e || (e = !0)) {
                                            b = K();
                                            if ("}" == b)break;
                                            e && ("," == b ? (b = K(), "}" == b && M()) : M());
                                            "," != b && "string" == typeof b && "@" == (x ? b.charAt(0) : b[0]) && ":" == K() || M();
                                            d[b.slice(1)] = H(K())
                                        }
                                        return d
                                    }
                                    M()
                                }
                                return b
                            }, P = function (b, d, e) {
                                e = U(b, d, e);
                                e === r ? delete b[d] : b[d] = e
                            }, U = function (b, d, e) {
                                var f = b[d], g;
                                if ("object" == typeof f && f)if ("[object Array]" == h.call(f))for (g = f.length; g--;)P(f, g, e); else p(f, function (b) {
                                    P(f, b, e)
                                });
                                return e.call(b, d, f)
                            };
                        t.parse =
                            function (b, d) {
                                var e, f;
                                J = 0;
                                Q = "" + b;
                                e = H(K());
                                "$" != K() && M();
                                J = Q = null;
                                return d && "[object Function]" == h.call(d) ? U((f = {}, f[""] = e, f), "", d) : e
                            }
                    }
                }
            })(this)
        }, {}],
        50: [function (b, d, e) {
            d.exports = function (b, d) {
                for (var e = [], n = (d = d || 0) || 0; n < b.length; n++)e[n - d] = b[n];
                return e
            }
        }, {}]
    }, {}, [1])(1)
});
(function () {
    if (void 0 !== cc) {
        var a = function () {
        };
        a.prototype = {
            constructor: a, getInstance: function () {
                return this
            }, loadPlugin: function (a) {
            }, unloadPlugin: function (a) {
            }
        };
        var b = function () {
        };
        b.prototype = {
            constructor: b, setDebugMode: function (a) {
            }, startSession: function (a) {
            }, setCaptureUncaughtException: function (a) {
            }, callFuncWithParam: function (a) {
                if ("function" === typeof this[a])return this[a].apply(this, Array.prototype.splice.call(arguments, 1));
                cc.log("function is not define")
            }, callStringFuncWithParam: function (a) {
                this.callFuncWithParam.apply(arguments)
            },
            getPluginName: function () {
                return this._name
            }, getPluginVersion: function () {
                return this._version
            }
        };
        b.extend = function (a, d) {
            var e, n = {};
            for (e in b.prototype)n[e] = b.prototype[e];
            for (e in d)n[e] = d[e];
            e = eval("(function " + a + "Plugin(){})");
            n.constructor = e;
            e.prototype = n;
            return e
        };
        var d = function (a, b) {
            var d = plugin.PluginParam.ParamType;
            switch (a) {
                case d.TypeInt:
                    d = parseInt(b);
                    break;
                case d.TypeFloat:
                    d = parseFloat(b);
                    break;
                case d.TypeBool:
                    d = Boolean(b);
                    break;
                case d.TypeString:
                    d = String(b);
                    break;
                case d.TypeStringMap:
                    d =
                        b;
                    break;
                default:
                    d = b
            }
            return d
        };
        d.ParamType = {TypeInt: 1, TypeFloat: 2, TypeBool: 3, TypeString: 4, TypeStringMap: 5};
        d.AdsResultCode = {
            AdsReceived: 0,
            FullScreenViewShown: 1,
            FullScreenViewDismissed: 2,
            PointsSpendSucceed: 3,
            PointsSpendFailed: 4,
            NetworkError: 5,
            UnknownError: 6
        };
        d.PayResultCode = {PaySuccess: 0, PayFail: 1, PayCancel: 2, PayTimeOut: 3};
        d.ShareResultCode = {ShareSuccess: 0, ShareFail: 1, ShareCancel: 2, ShareTimeOut: 3};
        var e = {}, a = {
            extend: function (a, d) {
                var h = cc.game.config && cc.game.config.plugin || {};
                e[a] = new (b.extend(a,
                    d));
                "function" === typeof e[a].ctor && e[a].ctor(h[a])
            }, PluginList: e, PluginParam: d, PluginManager: new a
        };
        window.plugin = a
    }
})();
var gaf = gaf || {};
gaf.COMPRESSION_NONE = 4669766;
gaf.COMPRESSION_ZIP = 4669763;
gaf.IDNONE = 4294967295;
gaf.FIRST_FRAME_INDEX = 0;
gaf.EFFECT_DROP_SHADOW = 0;
gaf.EFFECT_BLUR = 1;
gaf.EFFECT_GLOW = 2;
gaf.EFFECT_COLOR_MATRIX = 6;
gaf.ACTION_STOP = 0;
gaf.ACTION_PLAY = 1;
gaf.ACTION_GO_TO_AND_STOP = 2;
gaf.ACTION_GO_TO_AND_PLAY = 3;
gaf.ACTION_DISPATCH_EVENT = 4;
gaf.PI_FRAME = 0;
gaf.PI_EVENT_TYPE = 0;
gaf.TYPE_TEXTURE = 0;
gaf.TYPE_TEXT_FIELD = 1;
gaf.TYPE_TIME_LINE = 2;
gaf.UNIFORM_BLUR_TEXEL_OFFSET = "u_step";
gaf.UNIFORM_GLOW_TEXEL_OFFSET = "u_step";
gaf.UNIFORM_GLOW_COLOR = "u_glowColor";
gaf.UNIFORM_ALPHA_TINT_MULT = "colorTransformMult";
gaf.UNIFORM_ALPHA_TINT_OFFSET = "colorTransformOffsets";
gaf.UNIFORM_ALPHA_COLOR_MATRIX_BODY = "colorMatrix";
gaf.UNIFORM_ALPHA_COLOR_MATRIX_APPENDIX = "colorMatrix2";
gaf = gaf || {};
gaf._tmp = gaf._tmp || {};
gaf._initialized = !1;
gaf.CCGAFLoader = function () {
    this.load = function (a, b, d, e) {
        gaf._initialized || gaf._setup();
        (new gaf.Loader).LoadFile(a, function (a) {
            e(null, a)
        })
    }
};
gaf._setup = function () {
    gaf._setupShaders();
    gaf._initialized = !0
};
cc.loader.register(".gaf", new gaf.CCGAFLoader);
gaf.CGAffineTransformCocosFormatFromFlashFormat = function (a) {
    var b = {};
    b.a = a.a;
    b.b = -a.b;
    b.c = -a.c;
    b.d = a.d;
    b.tx = a.tx;
    b.ty = -a.ty;
    return b
};
gaf._AssetPreload = function () {
    this["0"] = this.End;
    this["1"] = this.Atlases;
    this["2"] = this.AnimationMasks;
    this["3"] = this.AnimationObjects;
    this["4"] = this.AnimationFrames;
    this["5"] = this.NamedParts;
    this["6"] = this.Sequences;
    this["7"] = this.TextFields;
    this["8"] = this.Atlases;
    this["9"] = this.Stage;
    this["10"] = this.AnimationObjects;
    this["11"] = this.AnimationMasks;
    this["12"] = this.AnimationFrames;
    this["13"] = this.TimeLine
};
gaf._AssetPreload.prototype.End = function (a, b, d) {
    d && (d.getFps = function () {
        return a.getSceneFps()
    })
};
gaf._AssetPreload.prototype.Tag = function (a, b, d) {
    this[b.tagId].call(this, a, b.content, d)
};
gaf._AssetPreload.prototype.Tags = function (a, b, d) {
    var e = this;
    b.forEach(function (b) {
        e.Tag(a, b, d)
    })
};
gaf._AssetPreload.prototype.AtlasCreateFrames = function (a, b, d) {
    a.forEach(function (a) {
        var f = b._atlases[a.atlasId], g = cc.rect(a.origin.x, a.origin.y, a.size.x, a.size.y), f = new cc.SpriteFrame(f, g);
        f._gafAnchor = {x: 0 - (0 - a.pivot.x / a.size.x), y: 0 + (1 - a.pivot.y / a.size.y)};
        d[a.elementAtlasId] = f
    })
};
gaf._AssetPreload.prototype.Atlases = function (a, b, d) {
    var e = a._atlasScales[b.scale] = a._atlasScales[b.scale] || [], f = cc.Director._getInstance().getContentScaleFactor();
    b.atlases.forEach(function (d) {
        var h = d.id, n = function () {
            gaf._AssetPreload.AtlasCreateFrames(b.elements, a, e)
        }, p = "";
        d.sources.forEach(function (a) {
            a.csf === f && (p = a.source)
        });
        cc.assert(p, "GAF Error. Texture for current CSF not found. Reconvert animation with correct parameters.");
        a._textureLoadDelegate && (p = a._textureLoadDelegate(p));
        var r = !1;
        d =
            a._getSearchPaths(p);
        for (var s = 0, t = d.length; s < t; ++s) {
            var v = cc.textureCache.getTextureForKey(d[s]);
            if (v && v.isLoaded()) {
                v.handleLoadedTexture(!0);
                r = !0;
                a._atlases[h] = v;
                n();
                break
            }
        }
        r || (r = function (b) {
            b.handleLoadedTexture(!0);
            a._onAtlasLoaded(h, b)
        }, s = function () {
            cc.log("GAF Error. Couldn't find `" + p + "` required by `" + a.getGAFFileName() + "`")
        }, a._atlasesToLoad.hasOwnProperty(h) || (gaf._AtlasLoader.loadArray(d, r, s), a._atlasesToLoad[h] = {}), a._onLoadTasks.push(n))
    })
};
gaf._AssetPreload.prototype.AnimationObjects = function (a, b, d) {
    b.forEach(function (b) {
        b.type = void 0 === b.type ? gaf.TYPE_TEXTURE : b.type;
        d._objects.push(b.objectId);
        a._objects[b.objectId] = b
    })
};
gaf._AssetPreload.prototype.convertTint = function (a, b) {
    return a ? {
        mult: {r: 255 * a.redMultiplier, g: 255 * a.greenMultiplier, b: 255 * a.blueMultiplier, a: 255 * b},
        offset: {r: 255 * a.redOffset, g: 255 * a.greenOffset, b: 255 * a.blueOffset, a: 255 * a.alphaOffset}
    } : null
};
gaf._AssetPreload.prototype.convertState = function (a) {
    return {
        hasColorTransform: a.hasColorTransform,
        hasMask: a.hasMask,
        hasEffect: a.hasEffect,
        objectIdRef: a.objectIdRef,
        depth: a.depth,
        alpha: 255 * a.alpha,
        matrix: gaf.CGAffineTransformCocosFormatFromFlashFormat(a.matrix),
        colorTransform: this.convertTint(a.colorTransform, a.alpha),
        effect: a.effect,
        maskObjectIdRef: a.maskObjectIdRef
    }
};
gaf._AssetPreload.prototype.AnimationFrames = function (a, b, d) {
    var e = this;
    cc.assert(d, "Error. Time Line should not be null.");
    var f = {}, g = [];
    a = 0;
    for (var h = b.length; a < h; ++a) {
        var n = b[a];
        n.state && n.state.forEach(function (a) {
            f[a.objectIdRef] = 0 !== a.alpha ? e.convertState(a) : null
        });
        var p = [], r;
        for (r in f)f.hasOwnProperty(r) && f[r] && p.push(f[r]);
        g[n.frame - 1] = {states: p, actions: n.actions || null}
    }
    d.getFrames = function () {
        return g
    }
};
gaf._AssetPreload.prototype.NamedParts = function (a, b, d) {
    var e = {};
    b.forEach(function (a) {
        e[a.name] = a.objectId
    });
    d.getNamedParts = function () {
        return e
    }
};
gaf._AssetPreload.prototype.Sequences = function (a, b, d) {
    var e = {};
    b.forEach(function (a) {
        e[a.id] = {start: a.start - 1, end: a.end}
    });
    d.getSequences = function () {
        return e
    }
};
gaf._AssetPreload.prototype.TextFields = function (a, b, d) {
    debugger
};
gaf._AssetPreload.prototype.Stage = function (a, b, d) {
    a._sceneFps = b.fps;
    a._sceneColor = b.color;
    a._sceneWidth = b.width;
    a._sceneHeight = b.height
};
gaf._AssetPreload.prototype.AnimationMasks = function (a, b, d) {
    b.forEach(function (b) {
        b.type = void 0 === b.type ? gaf.TYPE_TEXTURE : b.type;
        d._objects.push(b.objectId);
        a._masks[b.objectId] = b
    })
};
gaf._AssetPreload.prototype.TimeLine = function (a, b, d) {
    d = new gaf._TimeLineProto(a, b.animationFrameCount, b.boundingBox, b.pivotPoint, b.id, b.linkageName);
    a._pushTimeLine(d);
    this.Tags(a, b.tags, d)
};
gaf._AssetPreload = new gaf._AssetPreload;
gaf = gaf || {};
gaf.Asset = cc.Class.extend({
    _className: "GAFAsset",
    _header: null,
    _timeLines: null,
    _textFields: null,
    _protos: null,
    _objects: null,
    _masks: null,
    _rootTimeLine: null,
    _textureLoadDelegate: null,
    _sceneFps: 60,
    _sceneWidth: 0,
    _sceneHeight: 0,
    _sceneColor: 0,
    _gafData: null,
    _desiredAtlasScale: 1,
    _usedAtlasScale: 0,
    _atlases: null,
    _onLoadTasks: null,
    _atlasScales: null,
    _textureLoaded: !1,
    _atlasesToLoad: null,
    _gafName: null,
    initWithGAFFile: function (a, b) {
        var d = this;
        this._textureLoadDelegate = b;
        this._gafName = a;
        var e = cc.loader.getRes(a);
        if (e)return this._init(e);
        cc.loader.load(a, function (a, b) {
            a || d._init(b[0])
        });
        return !1
    },
    initWithGAFBundle: function (a, b, d) {
        cc.assert(!1, "initWithGAFBundle is not yet implemented");
        return !1
    },
    setRootTimelineWithName: function (a) {
        for (var b = 0, d = this._timeLines.length; b < d; ++b) {
            var e = this._timeLines[b];
            if (e && e.getLinkageName() === a) {
                this._setRootTimeline(e);
                break
            }
        }
    },
    isAssetVersionPlayable: function () {
        return !0
    },
    desiredAtlasScale: function () {
        return this._desiredAtlasScale
    },
    setDesiredAtlasScale: function (a) {
        this._desiredAtlasScale = a;
        for (var b in this._atlasScales)this._atlasScales.hasOwnProperty(b) &&
        (0 === this._usedAtlasScale || Math.abs(this._usedAtlasScale - a) > Math.abs(b - a)) && (this._usedAtlasScale = b)
    },
    createObject: function () {
        return this._instantiateGaf(this._gafData)
    },
    createObjectAndRun: function (a) {
        cc.assert(1 === arguments.length, "GAFAsset::createObjectAndRun should have one param");
        var b = this._instantiateGaf(this._gafData);
        b.setLooped(a, !0);
        b.start();
        return b
    },
    setTextureLoadDelegate: function (a) {
        debugger
    },
    getSceneFps: function () {
        return this._sceneFps
    },
    getSceneWidth: function () {
        debugger
    },
    getSceneHeight: function () {
        debugger
    },
    getSceneColor: function () {
        debugger
    },
    setSceneFps: function (a) {
        this._sceneFps = a
    },
    setSceneWidth: function (a) {
        debugger
    },
    setSceneHeight: function (a) {
        debugger
    },
    setSceneColor: function (a) {
        debugger
    },
    getHeader: function () {
        return this._header
    },
    getGAFFileName: function () {
        return this._gafName
    },
    ctor: function () {
        this._header = {};
        this._timeLines = [];
        this._textFields = [];
        this._objects = [];
        this._masks = [];
        this._protos = [];
        this._atlases = {};
        this._onLoadTasks = [];
        this._atlasScales = {};
        this._atlasesToLoad = {};
        0 < arguments.length && this.initWithGAFFile.apply(this,
            arguments)
    },
    _getProtos: function () {
        return this._protos
    },
    _setRootTimeline: function (a) {
        this._rootTimeLine = a;
        this._header.pivot = a.getPivot();
        this._header.frameSize = a.getRect()
    },
    _setHeader: function (a) {
        for (var b in a)a.hasOwnProperty(b) && (this._header[b] = a[b])
    },
    _getMajorVerison: function () {
        return this._header.versionMajor
    },
    _init: function (a) {
        var b = this;
        this._gafData = a;
        this._setHeader(a.header);
        this._timeLinesToLink = [];
        4 > this._getMajorVerison() && this._pushTimeLine(new gaf._TimeLineProto(this, this._header.framesCount,
            this._header.frameSize, this._header.pivot));
        gaf._AssetPreload.Tags(this, a.tags, this._rootTimeLine);
        this._objects.forEach(function (a) {
            switch (a.type) {
                case gaf.TYPE_TEXTURE:
                    b._protos[a.objectId] || (b._protos[a.objectId] = new gaf._SpriteProto(b, b._atlasScales, a.elementAtlasIdRef));
                    break;
                case gaf.TYPE_TIME_LINE:
                    b._protos[a.objectId] = b._timeLines[a.elementAtlasIdRef];
                    break;
                case gaf.TYPE_TEXT_FIELD:
                    b._protos[a.objectId] = b._textFields[a.elementAtlasIdRef];
                    break;
                default:
                    cc.log("Unknown object type: " + a.type)
            }
        });
        this._masks.forEach(function (a) {
            if (!b._protos[a.objectId]) {
                var e = null;
                switch (a.type) {
                    case gaf.TYPE_TEXTURE:
                        e = new gaf._SpriteProto(b, b._atlasScales, a.elementAtlasIdRef);
                        break;
                    case gaf.TYPE_TIME_LINE:
                        e = b._timeLines[a.elementAtlasIdRef];
                        break;
                    case gaf.TYPE_TEXT_FIELD:
                        e = b._textFields[a.elementAtlasIdRef]
                }
                b._protos[a.objectId] = new gaf._MaskProto(b, e, a.elementAtlasIdRef)
            }
        });
        this.setDesiredAtlasScale(this._desiredAtlasScale);
        0 === Object.keys(this._atlasesToLoad).length && (this._textureLoaded = !0, this.dispatchEvent("load"))
    },
    _pushTimeLine: function (a) {
        this._timeLines[a.getId()] = a;
        0 === a.getId() && this._setRootTimeline(a)
    },
    _instantiateGaf: function () {
        var a = null;
        return a = this._rootTimeLine._gafConstruct()
    },
    _onAtlasLoaded: function (a, b) {
        this._atlases[a] = b;
        delete this._atlasesToLoad[a];
        0 === Object.keys(this._atlasesToLoad).length && (this._onLoadTasks.forEach(function (a) {
            a()
        }), this._onLoadTasks.length = 0, this._textureLoaded = !0, this.dispatchEvent("load"))
    },
    isLoaded: function () {
        return this._textureLoaded
    },
    _getSearchPaths: function (a) {
        var b =
            this.getGAFFileName().split("/");
        b[b.length - 1] = a;
        b = b.join("/");
        return [a, b]
    }
});
gaf.Asset.create = function (a, b) {
    return new gaf.Asset(a, b)
};
gaf.Asset.createWithBundle = function (a, b, d) {
    var e = new gaf.Asset;
    e.initWithGAFBundle(a, b, d);
    return e
};
cc.EventHelper.prototype.apply(gaf.Asset.prototype);
gaf = gaf || {};
gaf._stateHasCtx = function (a) {
    if (a.hasColorTransform && (0 < a.colorTransform.offset.r || 0 < a.colorTransform.offset.g || 0 < a.colorTransform.offset.b || 0 < a.colorTransform.offset.a))return !0;
    if (a.hasEffect)for (var b = 0, d = a.effect.length; b < d; ++b)if (a.effect[b].type === gaf.EFFECT_COLOR_MATRIX)return !0;
    return !1
};
gaf.Object = cc.Node.extend({
    _asset: null,
    _className: "GAFObject",
    _id: gaf.IDNONE,
    _gafproto: null,
    _parentTimeLine: null,
    _lastVisibleInFrame: 0,
    _filterStack: null,
    _cascadeColorMult: null,
    _cascadeColorOffset: null,
    _needsCtx: !1,
    _usedAtlasScale: 1,
    ctor: function (a) {
        1 == arguments.length && (this._usedAtlasScale = a);
        this._super();
        this._cascadeColorMult = cc.color(255, 255, 255, 255);
        this._cascadeColorOffset = cc.color(0, 0, 0, 0);
        this._filterStack = []
    },
    setAnimationStartedNextLoopDelegate: function (a) {
    },
    setAnimationFinishedPlayDelegate: function (a) {
    },
    setLooped: function (a) {
    },
    getBoundingBoxForCurrentFrame: function () {
        return null
    },
    setFps: function (a) {
    },
    getObjectByName: function (a) {
        return null
    },
    clearSequence: function () {
    },
    getIsAnimationRunning: function () {
        return !1
    },
    getSequences: function () {
        return []
    },
    gotoAndStop: function (a) {
    },
    getStartFrame: function (a) {
        return gaf.IDNONE
    },
    setFramePlayedDelegate: function (a) {
    },
    getCurrentFrameIndex: function () {
        return gaf.IDNONE
    },
    getTotalFrameCount: function () {
        return 0
    },
    start: function () {
    },
    stop: function () {
    },
    isVisibleInCurrentFrame: function () {
        return !(this._parentTimeLine &&
        this._parentTimeLine.getCurrentFrameIndex() + 1 != this._lastVisibleInFrame)
    },
    isDone: function () {
        return !0
    },
    playSequence: function (a, b, d) {
        return !1
    },
    isReversed: function () {
        return !1
    },
    setSequenceDelegate: function (a) {
    },
    setFrame: function (a) {
        return !1
    },
    setControlDelegate: function (a) {
    },
    getEndFrame: function (a) {
        return gaf.IDNONE
    },
    pauseAnimation: function () {
    },
    gotoAndPlay: function (a) {
    },
    isLooped: function () {
        return !1
    },
    resumeAnimation: function () {
    },
    setReversed: function (a) {
    },
    hasSequences: function () {
        return !1
    },
    getFps: function () {
        return 60
    },
    setLocator: function (a) {
    },
    setExternalTransform: function (a) {
        cc.affineTransformEqualToTransform(this._additionalTransform, a) || this.setAdditionalTransform(a)
    },
    getExternalTransform: function () {
        return this._additionalTransform
    },
    setAnimationRunning: function () {
    },
    _enableTick: function (a) {
    },
    _resetState: function () {
    },
    _updateVisibility: function (a, b) {
        this.setOpacity(a.alpha + (a.hasColorTransform ? a.colorTransform.offset.a : 0))
    },
    isVisible: function () {
        return 0 < this.getOpacity()
    },
    visit: function (a) {
        this.isVisibleInCurrentFrame() &&
        this._super(a)
    },
    _getFilters: function () {
        return null
    },
    _processAnimation: function () {
    },
    _applyState: function (a, b) {
        this._applyStateSuper(a, b)
    },
    _applyStateSuper: function (a, b) {
        this._needsCtx = b._needsCtx;
        this._filterStack.length = 0;
        this._parentTimeLine = b;
        if (1 != this._usedAtlasScale) {
            var d = cc.clone(a.matrix);
            d.tx *= this._usedAtlasScale;
            d.ty *= this._usedAtlasScale;
            this.setExternalTransform(d)
        } else this.setExternalTransform(a.matrix);
        a.hasEffect && (this._filterStack = this._filterStack.concat(a.effect), this._needsCtx = !0);
        b._filterStack && 0 < b._filterStack.length && (this._filterStack = this._filterStack.concat(b._filterStack));
        0 < this._filterStack.length && this._filterStack[0].type === gaf.EFFECT_COLOR_MATRIX && (this._needsCtx = !0);
        a.hasColorTransform ? (this._cascadeColorMult.r = a.colorTransform.mult.r * b._cascadeColorMult.r / 255, this._cascadeColorMult.g = a.colorTransform.mult.g * b._cascadeColorMult.g / 255, this._cascadeColorMult.b = a.colorTransform.mult.b * b._cascadeColorMult.b / 255, this._cascadeColorMult.a = a.colorTransform.mult.a *
            b._cascadeColorMult.a / 255, this._cascadeColorOffset.r = a.colorTransform.offset.r + b._cascadeColorOffset.r, this._cascadeColorOffset.g = a.colorTransform.offset.g + b._cascadeColorOffset.g, this._cascadeColorOffset.b = a.colorTransform.offset.b + b._cascadeColorOffset.b, this._cascadeColorOffset.a = a.colorTransform.offset.a + b._cascadeColorOffset.a) : (this._cascadeColorMult.r = b._cascadeColorMult.r, this._cascadeColorMult.g = b._cascadeColorMult.g, this._cascadeColorMult.b = b._cascadeColorMult.b, this._cascadeColorMult.a =
            b._cascadeColorMult.a / 255 * a.alpha, this._cascadeColorOffset.r = b._cascadeColorOffset.r, this._cascadeColorOffset.g = b._cascadeColorOffset.g, this._cascadeColorOffset.b = b._cascadeColorOffset.b, this._cascadeColorOffset.a = b._cascadeColorOffset.a);
        if (0 < this._cascadeColorOffset.r || 0 < this._cascadeColorOffset.g || 0 < this._cascadeColorOffset.b || 0 < this._cascadeColorOffset.a)this._needsCtx = !0
    },
    _initRendererCmd: function () {
        this._renderCmd = cc.renderer.getRenderCmd(this);
        this._renderCmd._visit = this._renderCmd.visit;
        var a =
            this;
        this._renderCmd.visit = function (b) {
            a.isVisibleInCurrentFrame() && this._visit(b)
        }
    },
    _getNode: function () {
        return this
    },
    setAnchorPoint: function (a, b) {
        void 0 === b ? this._super(a.x, a.y - 1) : this._super(a, b - 1)
    }
});
gaf.Object._createNullObject = function () {
    var a = new gaf.Object;
    a.isVisible = function () {
        return !0
    };
    return a
};
gaf.TimeLine = gaf.Object.extend({
    _className: "GAFTimeLine",
    _objects: null,
    _container: null,
    _animationStartedNextLoopDelegate: null,
    _animationFinishedPlayDelegate: null,
    _framePlayedDelegate: null,
    _sequenceDelegate: null,
    _fps: 60,
    _frameTime: 1 / 60,
    _currentSequenceStart: gaf.FIRST_FRAME_INDEX,
    _currentSequenceEnd: gaf.FIRST_FRAME_INDEX,
    _totalFrameCount: 0,
    _isRunning: !1,
    _isLooped: !1,
    _isReversed: !1,
    _timeDelta: 0,
    _animationsSelectorScheduled: !1,
    _currentFrame: gaf.FIRST_FRAME_INDEX,
    setAnimationStartedNextLoopDelegate: function (a) {
        this._animationStartedNextLoopDelegate =
            a
    },
    setAnimationFinishedPlayDelegate: function (a) {
        this._animationFinishedPlayDelegate = a
    },
    setLooped: function (a, b) {
        this._isLooped = a;
        b && this._objects.forEach(function (d) {
            d.setLooped(a, b)
        })
    },
    getBoundingBoxForCurrentFrame: function () {
        var a = null, b = !0;
        this._objects.forEach(function (d) {
            if (d.isVisibleInCurrentFrame() && d.isVisible()) {
                var e = d.getBoundingBoxForCurrentFrame();
                e || (e = d.getBoundingBox());
                b ? (b = !1, a = e) : a = cc.rectUnion(a, e)
            }
        });
        return cc._rectApplyAffineTransformIn(a, this._container.getNodeToParentTransform())
    },
    setFps: function (a) {
        cc.assert(0 !== a, "Error! Fps is set to zero.");
        this._fps = a;
        this._frameTime = 1 / a
    },
    getObjectByName: function (a) {
        var b = a.split("."), d = null, e = -1, f = this, g = {};
        try {
            b.forEach(function (a) {
                var b = f._gafproto.getNamedParts();
                if (b.hasOwnProperty(a))e = b[a]; else throw g.lastElement = a, g;
                f = d = f._objects[e]
            })
        } catch (h) {
            if (h !== g)throw h;
            cc.log("Sequence incorrect: `" + a + "` At: `" + g.lastElement + "`");
            return null
        }
        return d
    },
    clearSequence: function () {
        this._currentSequenceStart = gaf.FIRST_FRAME_INDEX;
        this._currentSequenceEnd =
            this._gafproto.getTotalFrames()
    },
    getIsAnimationRunning: function () {
        return this._isRunning
    },
    gotoAndStop: function (a) {
        var b = 0, b = "string" === typeof a ? this.getStartFrame(a) : a;
        return this.setFrame(b) ? (this.setAnimationRunning(!1, !1), !0) : !1
    },
    gotoAndPlay: function (a) {
        var b = 0, b = "string" === typeof a ? this.getStartFrame(a) : a;
        return this.setFrame(b) ? (this.setAnimationRunning(!0, !1), !0) : !1
    },
    getStartFrame: function (a) {
        return (a = this._gafproto.getSequences()[a]) ? a.start : gaf.IDNONE
    },
    getEndFrame: function (a) {
        return (a = this._gafproto.getSequences()[a]) ?
            a.end : gaf.IDNONE
    },
    setFramePlayedDelegate: function (a) {
        this._framePlayedDelegate = a
    },
    getCurrentFrameIndex: function () {
        return this._showingFrame
    },
    getTotalFrameCount: function () {
        return this._gafproto.getTotalFrames()
    },
    start: function () {
        this._enableTick(!0);
        this._isRunning || (this._currentFrame = gaf.FIRST_FRAME_INDEX, this.setAnimationRunning(!0, !0))
    },
    stop: function () {
        this._enableTick(!1);
        this._isRunning && (this._currentFrame = gaf.FIRST_FRAME_INDEX, this.setAnimationRunning(!1, !0))
    },
    isDone: function () {
        return this._isLooped ?
            !1 : this._isReversed ? this._currentFrame < gaf.FIRST_FRAME_INDEX - 1 : this._currentFrame > this._totalFrameCount
    },
    getSequences: function () {
        return this._gafproto.getSequences()
    },
    playSequence: function (a, b) {
        var d = this.getStartFrame(a), e = this.getEndFrame(a);
        if (gaf.IDNONE === d || gaf.IDNONE === e)return !1;
        this._currentSequenceStart = d;
        this._currentSequenceEnd = e;
        this._currentFrame = this._currentSequenceStart;
        this.setLooped(b, !1);
        this.resumeAnimation();
        return !0
    },
    isReversed: function () {
        return this._isReversed
    },
    setSequenceDelegate: function (a) {
        this._sequenceDelegate =
            a
    },
    setFrame: function (a) {
        return a >= gaf.FIRST_FRAME_INDEX && a < this._totalFrameCount ? (this._currentFrame = this._showingFrame = a, this._processAnimation(), !0) : !1
    },
    pauseAnimation: function () {
        this._isRunning && this.setAnimationRunning(!1, !1)
    },
    isLooped: function () {
        return this._isLooped
    },
    resumeAnimation: function () {
        this._isRunning || this.setAnimationRunning(!0, !1)
    },
    setReversed: function (a) {
        this._isReversed = a
    },
    hasSequences: function () {
        return 0 < this._gafproto.getSequences().length
    },
    getFps: function () {
        return this._fps
    },
    ctor: function (a, b) {
        this._super(b);
        this._objects = [];
        cc.assert(a, "Error! Missing mandatory parameter.");
        this._gafproto = a
    },
    setExternalTransform: function (a) {
        cc.affineTransformEqualToTransform(this._container._additionalTransform, a) || this._container.setAdditionalTransform(a)
    },
    _init: function () {
        this.setContentSize(this._gafproto.getBoundingBox());
        this._totalFrameCount = this._currentSequenceEnd = this._gafproto.getTotalFrames();
        this.setFps(this._gafproto.getFps());
        this._container = new cc.Node;
        this.addChild(this._container);
        var a = this, b = this._gafproto.getAsset();
        this._gafproto.getObjects().forEach(function (d) {
            var e = b._getProtos()[d];
            cc.assert(e, "Error. GAF proto for type: " + d.type + " and reference id: " + d + " not found.");
            a._objects[d] = e._gafConstruct()
        })
    },
    _enableTick: function (a) {
        !this._animationsSelectorScheduled && a ? (this.schedule(this._processAnimations), this._animationsSelectorScheduled = !0) : this._animationsSelectorScheduled && !a && (this.unschedule(this._processAnimations), this._animationsSelectorScheduled = !1)
    },
    _processAnimations: function (a) {
        for (this._timeDelta +=
                 a; this._timeDelta >= this._frameTime;)this._timeDelta -= this._frameTime, this._step()
    },
    _step: function () {
        this._showingFrame = this._currentFrame;
        if (this.getIsAnimationRunning()) {
            if (this._sequenceDelegate) {
                var a;
                (a = this._isReversed ? this._getSequenceByFirstFrame(this._currentFrame + 1) : this._getSequenceByLastFrame(this._currentFrame)) && this._sequenceDelegate(this, a)
            }
            this._isCurrentFrameLastInSequence() && (this._isLooped ? this._animationStartedNextLoopDelegate && this._animationStartedNextLoopDelegate(this) : (this.setAnimationRunning(!1,
                !1), this._animationFinishedPlayDelegate && this._animationFinishedPlayDelegate(this)));
            this._processAnimation();
            this._currentFrame = this._nextFrame()
        } else this._processAnimation()
    },
    _isCurrentFrameLastInSequence: function () {
        return this._isReversed ? this._currentFrame == this._currentSequenceStart : this._currentFrame == this._currentSequenceEnd - 1
    },
    _nextFrame: function () {
        return this._isCurrentFrameLastInSequence() ? this._isLooped ? this._isReversed ? this._currentSequenceEnd - 1 : this._currentSequenceStart : this._currentFrame :
        this._currentFrame + (this._isReversed ? -1 : 1)
    },
    _processAnimation: function () {
        this._realizeFrame(this._container, this._currentFrame);
        this._framePlayedDelegate && this._framePlayedDelegate(this, this._currentFrame)
    },
    _realizeFrame: function (a, b) {
        var d = this._objects, e = this._gafproto.getFrames();
        if (!(b > e.length) && (e = e[b]))for (var e = e.states, f = 0, g = e.length; f < g; ++f) {
            var h = e[f], n = d[h.objectIdRef];
            if (!n)break;
            0 > h.alpha && n._resetState();
            n._updateVisibility(h, this);
            if (n.isVisible()) {
                n._applyState(h, this);
                var p = a;
                h.hasMask &&
                (p = d[h.maskObjectIdRef]._getNode(), cc.assert(p, "Error! Mask not found."));
                n._lastVisibleInFrame = 1 + b;
                gaf.TimeLine.rearrangeSubobject(p, n, h.depth);
                n._step && n._step()
            }
        }
    },
    setAnimationRunning: function (a, b) {
        this._isRunning = a;
        b && this._objects.forEach(function (d) {
            d && d.setAnimationRunning && d.setAnimationRunning(a, b)
        })
    },
    _getSequenceByLastFrame: function () {
        var a = this._gafproto.getSequences(), b;
        for (b in a)if (a.hasOwnProperty(b) && a[b].end === frame + 1)return b;
        return ""
    },
    _resetState: function () {
        this._super();
        this._currentFrame =
            this._currentSequenceStart
    },
    _getSequenceByFirstFrame: function () {
        var a = this._gafproto.getSequences(), b;
        for (b in a)if (a.hasOwnProperty(b) && a[b].start === frame)return b;
        return ""
    }
});
gaf.TimeLine.rearrangeSubobject = function (a, b, d) {
    b.getParent() !== a ? (b.removeFromParent(!1), a.addChild(b, d)) : b.setLocalZOrder(d)
};
gaf.TextField = gaf.Object.extend({_className: "GAFTextField"});
gaf.Sprite = gaf.Object.extend({
    _className: "GAFSprite", _hasCtx: !1, _hasFilter: !1, ctor: function (a, b) {
        this._super(b);
        cc.assert(a, "Error! Missing mandatory parameter.");
        this._gafproto = a
    }, _init: function () {
        var a = this._gafproto.getFrame();
        cc.assert(a instanceof cc.SpriteFrame, "Error. Wrong object type.");
        this._sprite = new cc.Sprite;
        this._sprite._renderCmd = this._gafCreateRenderCmd(this._sprite);
        this._sprite.initWithSpriteFrame(a);
        this._sprite.setAnchorPoint(this._gafproto.getAnchor());
        this.addChild(this._sprite);
        this._sprite.setOpacityModifyRGB(!0);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._sprite.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
    }, _applyState: function (a, b) {
        this._applyStateSuper(a, b);
        this._needsCtx ? (this._hasCtx || (this._enableCtx(), this._hasCtx = !0), this._applyCtxState(a)) : (this._hasCtx && (this._disableCtx(), this._hasCtx = !1), cc.colorEqual(this._sprite._realColor, this._cascadeColorMult) || this._sprite.setColor(this._cascadeColorMult), this._sprite.getOpacity() != this._cascadeColorMult.a && this._sprite.setOpacity(this._cascadeColorMult.a))
    },
    _enableCtx: function () {
        this._sprite._renderCmd._enableCtx()
    }, _disableCtx: function () {
        this._sprite._renderCmd._disableCtx()
    }, _applyCtxState: function (a) {
        this._sprite._renderCmd._applyCtxState(this)
    }, getBoundingBoxForCurrentFrame: function () {
        var a = this._sprite.getBoundingBox();
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    }, _gafCreateRenderCmd: function (a) {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new gaf.Sprite.CanvasRenderCmd(a) : new gaf.Sprite.WebGLRenderCmd(a)
    }
});
gaf.Mask = gaf.Object.extend({
    _className: "GAFMask", _clippingNode: null, ctor: function (a) {
        this._super();
        cc.assert(a, "Error! Missing mandatory parameter.");
        this._gafproto = a
    }, _init: function () {
        var a = this._gafproto.getMaskNodeProto();
        cc.assert(a, "Error. Mask node for id ref " + this._gafproto.getIdRef() + " not found.");
        this._maskNode = a._gafConstruct();
        this._clippingNode = cc.ClippingNode.create(this._maskNode);
        this._clippingNode.setAlphaThreshold(0.5);
        this.addChild(this._clippingNode)
    }, setExternalTransform: function (a) {
        cc.affineTransformEqualToTransform(this._maskNode._additionalTransform,
            a) || this._maskNode.setAdditionalTransform(a)
    }, _getNode: function () {
        return this._clippingNode
    }
});
(function () {
    gaf.Sprite.CanvasRenderCmd = function (a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        this._hasCtx = this._hasTintOffset = this._hasTintMult = !1;
        this._tintMult = cc.color(255, 255, 255, 255);
        this._tintOffset = cc.color(0, 0, 0, 0);
        this._textureDirty = !1
    };
    var a = gaf.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    a.constructor = gaf.Sprite.CanvasRenderCmd;
    a._disableCtx = function () {
        this._hasCtx = this._hasTintOffset = !1;
        this._textureDirty = !0;
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        this._tintMult = cc.color(255, 255, 255, 255);
        this._tintOffset = cc.color(0, 0, 0, 0)
    };
    a._enableCtx = function () {
    };
    a._applyCtxState = function (a) {
        var d = a._cascadeColorMult, e = a._cascadeColorOffset, f = d.a;
        this._node.getOpacity() != f && this._node.setOpacity(f);
        if (f = !cc.colorEqual(this._tintMult, d))this._node.setColor(d), this._tintMult = d, this._hasTintMult = 255 !== d.r || 255 !== d.g || 255 !== d.b;
        if (d = this._tintOffset.r != e.r || this._tintOffset.g != e.g || this._tintOffset.b != e.b || this._tintOffset.a != e.a)this._tintOffset = e, this._hasTintOffset =
            0 !== e.r || 0 !== e.g || 0 !== e.b || 0 !== e.a;
        (this._textureDirty = f || d) && this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        this._hasCtx = 0 < a._filterStack.length && a._filterStack[0].type === gaf.EFFECT_COLOR_MATRIX
    };
    a.rendering = function (a, d, e) {
        var f = this._node, g = this._textureCoord, h = this._displayedOpacity / 255;
        if ((!f._texture || 0 !== g.width && 0 !== g.height && f._texture._textureLoaded) && 0 !== h) {
            a = a || cc._renderContext;
            var n = a.getContext(), p = f._offsetPosition.x, r = f._rect.height, s = f._rect.width, t = -f._offsetPosition.y - r;
            a.setTransform(this._worldTransform,
                d, e);
            a.setCompositeOperation(this._blendFuncStr);
            a.setGlobalAlpha(h);
            (f._flippedX || f._flippedY) && a.save();
            f._flippedX && (p = -p - s, n.scale(-1, 1));
            f._flippedY && (t = f._offsetPosition.y, n.scale(1, -1));
            h = f._texture._htmlElementObj;
            this._colorized ? n.drawImage(h, 0, 0, g.width, g.height, p * d, t * e, s * d, r * e) : n.drawImage(h, g.renderX, g.renderY, g.width, g.height, p * d, t * e, s * d, r * e);
            (f._flippedX || f._flippedY) && a.restore();
            cc.g_NumberOfDraws++
        }
    };
    cc.sys._supportCanvasNewBlendModes && (a._updateColor = function () {
        var a = this._displayedColor,
            d = this._node;
        this._hasTintMult |= 255 !== a.r || 255 !== a.g || 255 !== a.b;
        if (this._textureDirty) {
            this._textureDirty = !1;
            this._colorized && (this._colorized = !1, d.texture = this._originalTexture);
            var e, f = d._texture, g = this._textureCoord;
            if (this._hasTintMult && f && g.validRect && this._originalTexture) {
                e = f.getHtmlElementObj();
                if (!e)return;
                this._colorized = !0;
                if (this._hasTintOffset || this._hasCtx)a = this._tintMult;
                e = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, a, g);
                f = new cc.Texture2D;
                f.initWithElement(e);
                f.handleLoadedTexture();
                d.texture = f
            }
            f = d._texture;
            this._hasTintOffset && (a = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj()), f && g.validRect && this._originalTexture && (e = f.getHtmlElementObj())) && (e = this._colorized ? cc.rect(0, 0, g.width, g.height) : g, e = this._gafGenerateTintImage(d.texture._htmlElementObj, e, a, this._tintOffset, g), f = new cc.Texture2D, f.initWithElement(e), f.handleLoadedTexture(), d.texture = f, this._colorized = !0)
        }
    }, a._gafGenerateTintImage = function (a, d,
                                           e, f, g, h) {
        g || (g = cc.rect(0, 0, a.width, a.height));
        var n = Math.min(g.width, e[0].width), p = Math.min(g.height, e[0].height), r;
        h ? (r = h.getContext("2d"), r.clearRect(0, 0, n, p)) : (h = document.createElement("canvas"), h.width = n, h.height = p, r = h.getContext("2d"));
        r.save();
        r.globalCompositeOperation = "source-over";
        r.drawImage(e[2], g.x, g.y, n, p, 0, 0, n, p);
        r.globalCompositeOperation = "source-in";
        r.fillStyle = "rgba(" + Math.round(f.r) + "," + Math.round(f.g) + "," + Math.round(f.b) + ",1)";
        r.fillRect(0, 0, n, p);
        r.globalCompositeOperation = "lighter";
        r.drawImage(a, d.x, d.y, n, p, 0, 0, n, p);
        r.restore();
        return h
    })
})();
(function () {
    gaf.Sprite.WebGLRenderCmd = function (a) {
        cc.Sprite.WebGLRenderCmd.call(this, a);
        this._defualtShader = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        this._customShader = gaf._Shaders.Alpha;
        this._ctxMatrixAppendix = this._ctxMatrixBody = this._tintOffset = this._tintMult = null
    };
    var a = gaf.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    a.constructor = gaf.Sprite.WebGLRenderCmd;
    a._identityVec = [1, 1, 1, 1];
    a._zeroVec = [0, 0, 0, 0];
    a._identityMat = [1, 0, 0, 0, 0, 1, 0, 0, 0,
        0, 1, 0, 0, 0, 0, 1];
    a._disableCtx = function () {
        this.setShaderProgram(this._defualtShader)
    };
    a._enableCtx = function () {
        this.setShaderProgram(this._customShader)
    };
    a._applyCtxState = function (a) {
        var d = a._cascadeColorMult;
        this._tintMult = [d.r / 255, d.g / 255, d.b / 255, d.a / 255];
        d = a._cascadeColorOffset;
        this._tintOffset = [d.r / 255, d.g / 255, d.b / 255, d.a / 255];
        (a = a._filterStack) && 0 < a.length && a[0].type === gaf.EFFECT_COLOR_MATRIX ? (a = a[0].colorMatrix, this._ctxMatrixBody = [a.rr, a.rg, a.rb, a.ra, a.gr, a.gg, a.gb, a.ga, a.br, a.bg, a.bb, a.ba, a.ar,
            a.ag, a.ab, a.aa], this._ctxMatrixAppendix = [a.r / 255, a.g / 255, a.b / 255, a.a / 255]) : this._ctxMatrixAppendix = this._ctxMatrixBody = null
    };
    a._setUniforms = function () {
        this._shaderProgram === this._customShader && (this._shaderProgram.use(), this._shaderProgram.setUniformLocationWith4fv(gaf._Uniforms.ColorTransformMult, this._tintMult, 1), this._shaderProgram.setUniformLocationWith4fv(gaf._Uniforms.ColorTransformOffset, this._tintOffset, 1), this._ctxMatrixBody && this._ctxMatrixAppendix ? (this._shaderProgram.setUniformLocationWithMatrix4fv(gaf._Uniforms.ColorMatrixBody,
            this._ctxMatrixBody, 1), this._shaderProgram.setUniformLocationWith4fv(gaf._Uniforms.ColorMatrixAppendix, this._ctxMatrixAppendix, 1)) : (this._shaderProgram.setUniformLocationWithMatrix4fv(gaf._Uniforms.ColorMatrixBody, this._identityMat, 1), this._shaderProgram.setUniformLocationWith4fv(gaf._Uniforms.ColorMatrixAppendix, this._zeroVec, 1)))
    };
    a.rendering = function (a) {
        this._setUniforms();
        cc.Sprite.WebGLRenderCmd.prototype.rendering.call(this, a)
    }
})();
gaf._TimeLineProto = function (a, b, d, e, f, g) {
    f = "undefined" != typeof f ? f : 0;
    g = g || "";
    this._objects = [];
    this.getTotalFrames = function () {
        return b
    };
    this.getBoundingBox = function () {
        return d
    };
    this.getId = function () {
        return f
    };
    this.getLinkageName = function () {
        return g
    };
    this.getPivot = function () {
        return e
    };
    this.getRect = function () {
        return d
    };
    this.getNamedParts = function () {
        return {}
    };
    this.getSequences = function () {
        return {}
    };
    this.getFrames = function () {
        return []
    };
    this.getFps = function () {
        return 60
    };
    this.getObjects = function () {
        return this._objects
    };
    this.getAsset = function () {
        return a
    };
    this._gafConstruct = function () {
        var a = this.getAsset()._usedAtlasScale, a = new gaf.TimeLine(this, a);
        a._init();
        return a
    }
};
gaf._SpriteProto = function (a, b, d) {
    this.getFrames = function () {
        return b
    };
    this.getIdRef = function () {
        return d
    };
    this.getAsset = function () {
        return a
    };
    this._gafConstruct = function () {
        var a = this.getAsset()._usedAtlasScale, a = new gaf.Sprite(this, a);
        a._init();
        return a
    }
};
gaf._SpriteProto.prototype.getFrame = function () {
    var a = this.getAsset()._usedAtlasScale;
    cc.assert(a, "Error. Atlas scale zero.");
    var b = this.getFrames()[a];
    cc.assert(b, "Error. No frames found for used scale `" + a + "`");
    return b[this.getIdRef()]
};
gaf._SpriteProto.prototype.getAnchor = function () {
    return this.getFrame()._gafAnchor
};
gaf._MaskProto = function (a, b, d) {
    this.getIdRef = function () {
        return d
    };
    this.getMaskNodeProto = function () {
        return b
    };
    this._gafConstruct = function () {
        var a = new gaf.Mask(this);
        a._init();
        return a
    }
};
gaf.ReadSingleTag = function (a) {
    var b = a.Ushort(), d = gaf.Tags[b], e = {};
    "undefined" === typeof d ? (console.log("GAF. Non implemented tag detected."), gaf.Tags.Default.parse(a, b)) : e = d.parse(a, b);
    return e
};
gaf.ReadTags = function (a) {
    var b = [];
    try {
        do {
            var d = gaf.ReadSingleTag(a);
            b.push(d)
        } while (0 != d.tagId)
    } catch (e) {
        if (e instanceof Error && "GAF format error" == e.message)console.log("GAF format error:\n" + e.stack); else throw console.log(e.stack), e;
    }
    return b
};
gaf.Tag = function () {
    this.Default = Object.create(gaf.Tag.base);
    this["0"] = Object.create(gaf.Tag.End);
    this["1"] = Object.create(gaf.Tag.DefineAtlas);
    this["2"] = Object.create(gaf.Tag.DefineAnimationMasks);
    this["3"] = Object.create(gaf.Tag.DefineAnimationObjects);
    this["4"] = Object.create(gaf.Tag.DefineAnimationFrames);
    this["5"] = Object.create(gaf.Tag.DefineNamedParts);
    this["6"] = Object.create(gaf.Tag.DefineSequences);
    this["7"] = Object.create(gaf.Tag.DefineTextFields);
    this["8"] = Object.create(gaf.Tag.DefineAtlas2);
    this["9"] = Object.create(gaf.Tag.DefineStage);
    this["10"] = Object.create(gaf.Tag.DefineAnimationObjects2);
    this["11"] = Object.create(gaf.Tag.DefineAnimationMasks2);
    this["12"] = Object.create(gaf.Tag.DefineAnimationFrames2);
    this["13"] = Object.create(gaf.Tag.DefineTimeline)
};
gaf.Tag.base = function () {
};
gaf.Tag.base.parse = function (a, b) {
    var d = a.Uint();
    a.startNestedBuffer(d);
    d = this.doParse(a);
    a.endNestedBuffer();
    d.tagName = this.tagName;
    d.tagId = b;
    return d
};
gaf.Tag.base.doParse = function (a) {
    return {}
};
gaf.Tag.End = Object.create(gaf.Tag.base);
gaf.Tag.End.tagName = "TagEnd";
gaf.Tag.DefineAtlas = Object.create(gaf.Tag.base);
gaf.Tag.DefineAtlas.tagName = "TagDefineAtlas";
gaf.Tag.DefineAtlas.doParse = function (a) {
    return {content: a.fields("scale", "Float", "atlases", a.array("Ubyte", a.fields("id", "Uint", "sources", a.array("Ubyte", a.fields("source", "String", "csf", "Float")))), "elements", a.array("Uint", a.fields("pivot", "Point", "origin", "Point", "scale", "Float", "size", "Point", "atlasId", "Uint", "elementAtlasId", "Uint")))()}
};
gaf.Tag.DefineAnimationMasks = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationMasks.tagName = "TagDefineAnimationMasks";
gaf.Tag.DefineAnimationMasks.doParse = function (a) {
    debugger;
    return {content: a.array("Uint", a.fields("objectId", "Uint", "elementAtlasIdRef", "Uint"))()}
};
gaf.Tag.DefineAnimationObjects = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationObjects.tagName = "TagDefineAnimationObjects";
gaf.Tag.DefineAnimationObjects.doParse = function (a) {
    return {content: a.array("Uint", a.fields("objectId", "Uint", "elementAtlasIdRef", "Uint"))()}
};
gaf.Tag.DefineAnimationFrames = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationFrames.tagName = "TagDefineAnimationFrames";
gaf.Tag.DefineAnimationFrames.doParse = function (a) {
    return {
        content: a.array("Uint", a.fields("frame", "Uint", "state", a.array("Uint", a.fields("hasColorTransform", "Ubyte", "hasMask", "Ubyte", "hasEffect", "Ubyte", "objectIdRef", "Uint", "depth", "Int", "alpha", "Float", "matrix", "Matrix", "colorTransform", a.condition("hasColorTransform", 1, a.fields("alphaOffset", "Float", "redMultiplier", "Float", "redOffset", "Float", "greenMultiplier", "Float", "greenOffset", "Float", "blueMultiplier", "Float", "blueOffset", "Float")), "effect",
            a.condition("hasEffect", 1, a.array("Ubyte", gaf.Tag._readFilter(a))), "maskObjectIdRef", a.condition("hasMask", 1, a.fields("maskObjectIdRef", "Uint"))))))()
    }
};
gaf.Tag.DefineNamedParts = Object.create(gaf.Tag.base);
gaf.Tag.DefineNamedParts.tagName = "TagDefineNamedParts";
gaf.Tag.DefineNamedParts.doParse = function (a) {
    return {content: a.array("Uint", a.fields("objectId", "Uint", "name", "String"))()}
};
gaf.Tag.DefineSequences = Object.create(gaf.Tag.base);
gaf.Tag.DefineSequences.tagName = "TagDefineSequences";
gaf.Tag.DefineSequences.doParse = function (a) {
    return {content: a.array("Uint", a.fields("id", "String", "start", "Ushort", "end", "Ushort"))()}
};
gaf.Tag.DefineTextFields = Object.create(gaf.Tag.base);
gaf.Tag.DefineTextFields.tagName = "TagDefineTextFields";
gaf.Tag.DefineTextFields.doParse = function (a) {
    return {
        content: a.array("Uint", a.fields("id", "Uint", "pivot", "Point", "end", "Ushort", "width", "Float", "height", "Float", "text", "String", "embedFonts", "Boolean", "multiline", "Boolean", "wordWrap", "Boolean", "hasRestrict", "Boolean", "restrict", a.condition("hasRestrict", 1, function () {
                return a.String
            }), "editable", "Boolean", "selectable", "Boolean", "displayAsPassword", "Boolean", "maxChars", "Uint", "align", "Uint", "blockIndent", "Uint", "bold", "Boolean", "bullet", "Boolean", "color",
            "color", "font", "String", "indent", "Uint", "italic", "Boolean", "kerning", "Boolean", "leading", "Uint", "leftMargin", "Uint", "letterSpacing", "Float", "rightMargin", "Uint", "size", "Uint", "tabStops", a.array("Uint", a.fields("value", "Uint")), "target", "string", "underline", "Boolean", "url", "String"))()
    }
};
gaf.Tag.DefineAtlas2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAtlas2.tagName = "TagDefineAtlas2";
gaf.Tag.DefineAtlas2.doParse = function (a) {
    return {
        content: a.fields("scale", "Float", "atlases", a.array("Ubyte", a.fields("id", "Uint", "sources", a.array("Ubyte", a.fields("source", "String", "csf", "Float")))), "elements", a.array("Uint", a.fields("pivot", "Point", "origin", "Point", "scale", "Float", "size", "Point", "atlasId", "Uint", "elementAtlasId", "Uint", "hasScale9Grid", "Boolean", "scale9GridRect", a.condition("hasScale9Grid", 1, function () {
            return a.Rect()
        }))))()
    }
};
gaf.Tag.DefineStage = Object.create(gaf.Tag.base);
gaf.Tag.DefineStage.tagName = "TagDefineStage";
gaf.Tag.DefineStage.doParse = function (a) {
    return {content: a.fields("fps", "Ubyte", "color", "color", "width", "Ushort", "height", "Ushort")()}
};
gaf.Tag.DefineAnimationObjects2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationObjects2.tagName = "TagDefineAnimationObjects2";
gaf.Tag.DefineAnimationObjects2.doParse = function (a) {
    return {content: a.array("Uint", a.fields("objectId", "Uint", "elementAtlasIdRef", "Uint", "type", "Ushort"))()}
};
gaf.Tag.DefineAnimationMasks2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationMasks2.tagName = "TagDefineAnimationMasks2";
gaf.Tag.DefineAnimationMasks2.doParse = function (a) {
    return {content: a.array("Uint", a.fields("objectId", "Uint", "elementAtlasIdRef", "Uint", "type", "Ushort"))()}
};
gaf.Tag.DefineAnimationFrames2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationFrames2.tagName = "TagDefineAnimationFrames2";
gaf.Tag.DefineAnimationFrames2.doParse = function (a) {
    return {
        content: a.array("Uint", a.fields("frame", "Uint", "hasChangesInDisplayList", "Boolean", "hasActions", "Boolean", "state", a.condition("hasChangesInDisplayList", 1, a.array("Uint", a.fields("hasColorTransform", "Boolean", "hasMask", "Boolean", "hasEffect", "Boolean", "objectIdRef", "Uint", "depth", "Int", "alpha", "Float", "matrix", "Matrix", "colorTransform", a.condition("hasColorTransform", 1, a.fields("alphaOffset", "Float", "redMultiplier", "Float", "redOffset", "Float",
            "greenMultiplier", "Float", "greenOffset", "Float", "blueMultiplier", "Float", "blueOffset", "Float")), "effect", a.condition("hasEffect", 1, a.array("Ubyte", gaf.Tag._readFilter(a))), "maskObjectIdRef", a.condition("hasMask", 1, function () {
            return a.Uint()
        })))), "actions", a.condition("hasActions", 1, a.array("Uint", a.fields("type", "Uint", "scope", "String", "params", gaf.Tag._readActionArguments(a))))))()
    }
};
gaf.Tag.DefineTimeline = Object.create(gaf.Tag.base);
gaf.Tag.DefineTimeline.tagName = "TagDefineTimeline";
gaf.Tag.DefineTimeline.doParse = function (a) {
    var b = {
        content: a.fields("id", "Uint", "animationFrameCount", "Uint", "boundingBox", "Rect", "pivotPoint", "Point", "hasLinkage", "Boolean", "linkageName", a.condition("hasLinkage", 1, function () {
            return a.String()
        }))()
    };
    b.content.tags = gaf.ReadTags(a);
    return b
};
gaf.Tag._readActionArguments = function (a) {
    return function () {
        var b = a.Uint(), d = [];
        for (a.startNestedBuffer(b); a.maxOffset() < a.tell();)d.push(a.String());
        a.endNestedBuffer();
        return d
    }
};
gaf.Tag._readFilter = function (a) {
    return a.fields("type", "Uint", "dropShadow", a.condition("type", gaf.EFFECT_DROP_SHADOW, a.fields("color", "color", "blurX", "Float", "blurY", "Float", "angle", "Float", "distance", "Float", "strength", "Float", "inner", "Boolean", "knockout", "Boolean")), "blur", a.condition("type", gaf.EFFECT_BLUR, a.fields("blurX", "Float", "blurY", "Float")), "glow", a.condition("type", gaf.EFFECT_GLOW, a.fields("color", "color", "blurX", "Float", "blurY", "Float", "strength", "Float", "inner", "Boolean", "knockout",
        "Boolean")), "colorMatrix", a.condition("type", gaf.EFFECT_COLOR_MATRIX, a.fields("rr", "Float", "gr", "Float", "br", "Float", "ar", "Float", "r", "Float", "rg", "Float", "gg", "Float", "bg", "Float", "ag", "Float", "g", "Float", "rb", "Float", "gb", "Float", "bb", "Float", "ab", "Float", "b", "Float", "ra", "Float", "ga", "Float", "ba", "Float", "aa", "Float", "a", "Float")))
};
gaf.Tags = new gaf.Tag;
gaf = gaf || {};
gaf.Loader = function () {
    this.LoadFile = function (a, b) {
        var d = new XMLHttpRequest;
        d.open("GET", a, !0);
        var e = this;
        d.responseType = "arraybuffer";
        d.onload = function (a) {
            a = new gaf.DataReader(d.response);
            a = e.LoadStream(a);
            b && b(a)
        };
        d.send()
    };
    this.LoadStream = function (a) {
        var b = {}, d = a;
        b.compression = d.Uint();
        b.versionMajor = d.Ubyte();
        b.versionMinor = d.Ubyte();
        b.fileLength = d.Uint();
        if (b.compression != gaf.COMPRESSION_NONE)if (b.compression == gaf.COMPRESSION_ZIP)a = a.dataRaw.slice(a.tell()), a = (new window.Zlib.Inflate(new Uint8Array(a))).decompress(), a =
            new gaf.DataReader(a.buffer); else throw Error("GAF syntax error.");
        if (4 > b.versionMajor)d = a, b.framesCount = d.Ushort(), b.frameSize = d.Rect(), b.pivot = d.Point(); else {
            var d = a, e = d.Uint();
            b.scaleValues = [];
            for (var f = 0; f < e; ++f)b.scaleValues.push(d.Float());
            e = d.Uint();
            b.csfValues = [];
            for (f = 0; f < e; ++f)b.csfValues.push(d.Float())
        }
        a = gaf.ReadTags(a);
        return {header: b, tags: a}
    }
};
gaf.DataReader = function (a) {
    this.dataRaw = a;
    this.buf = new DataView(a);
    this.offset = [0]
};
gaf.DataReader.prototype.constructor = gaf.DataReader;
gaf.DataReader.prototype.newOffset = function (a) {
    this.offset[this.offset.length - 1] += a;
    if (this.getOffset() > this.maxOffset())throw Error("GAF format error");
    return this.offset[this.offset.length - 1] - a
};
gaf.DataReader.prototype.maxOffset = function () {
    return 1 == this.offset.length ? this.buf.byteLength : this.offset[this.offset.length - 2]
};
gaf.DataReader.prototype.getOffset = function (a) {
    return this.offset[this.offset.length - 1]
};
gaf.DataReader.prototype.Ubyte = function () {
    return this.buf.getUint8(this.newOffset(1))
};
gaf.DataReader.prototype.Boolean = function () {
    var a = this.buf.getUint8(this.newOffset(1));
    if (1 < a)throw Error("GAF format error");
    return a
};
gaf.DataReader.prototype.Uint = function () {
    return this.buf.getUint32(this.newOffset(4), !0)
};
gaf.DataReader.prototype.Int = function () {
    return this.buf.getInt32(this.newOffset(4), !0)
};
gaf.DataReader.prototype.color = function () {
    return {b: this.Ubyte(), g: this.Ubyte(), r: this.Ubyte(), a: this.Ubyte()}
};
gaf.DataReader.prototype.Ushort = function () {
    return this.buf.getUint16(this.newOffset(2), !0)
};
gaf.DataReader.prototype.Float = function () {
    return this.buf.getFloat32(this.newOffset(4), !0)
};
gaf.DataReader.prototype.String = function () {
    var a = this.Ushort(), b = this.newOffset(a), a = this.getOffset();
    try {
        var d = this.dataRaw.slice(b, a)
    } catch (e) {
        if ("Object doesn't support property or method 'slice'" == e.message)for (d = []; b < a; ++b)d.push(this.buf.getUint8(b)); else throw e;
    }
    return decodeURIComponent(escape(String.fromCharCode.apply(null, new Uint8Array(d))))
};
gaf.DataReader.prototype.startNestedBuffer = function (a) {
    this.offset.push(this.offset[this.offset.length - 1]);
    this.offset[this.offset.length - 2] += a
};
gaf.DataReader.prototype.endNestedBuffer = function () {
    if (1 == this.offset.length)throw Error("No nested buffer available");
    this.offset.pop()
};
gaf.DataReader.prototype.Point = function () {
    return {x: this.Float(), y: this.Float()}
};
gaf.DataReader.prototype.Rect = function () {
    return {x: this.Float(), y: this.Float(), width: this.Float(), height: this.Float()}
};
gaf.DataReader.prototype.Matrix = function () {
    return {a: this.Float(), b: this.Float(), c: this.Float(), d: this.Float(), tx: this.Float(), ty: this.Float()}
};
gaf.DataReader.prototype.seek = function (a) {
    this.offset[this.offset.length - 1] = a
};
gaf.DataReader.prototype.tell = function () {
    return this.offset[this.offset.length - 1]
};
gaf.DataReader.prototype.fields = function () {
    var a = this, b = arguments;
    return function () {
        arguments.callee.result = {};
        var d = 0;
        if (b.length % 2)throw Error("Number of arguments is not even");
        for (; d < b.length;) {
            var e = b[d++], f = b[d++];
            if ("function" === typeof f)arguments.callee.result[e] = f(); else if (f in a && "function" === typeof a[f])arguments.callee.result[e] = a[f].call(a); else throw Error("Object DataReader has no function `" + f + "`");
        }
        return arguments.callee.result
    }
};
gaf.DataReader.prototype.condition = function (a, b, d) {
    var e = arguments;
    return function () {
        if (3 != e.length)throw Error("Condition function");
        var a = arguments.callee.caller;
        if (!("result" in a))throw Error("Condition function caller has no key `result`");
        var b = a.result, d = e[0], n = e[1], a = e[2];
        return ("function" === typeof n ? function () {
            return n(b[d])
        } : function () {
            return n == b[d]
        })() ? a() : null
    }
};
gaf.DataReader.prototype.array = function () {
    var a = this, b = arguments;
    return function () {
        arguments.callee.result = [];
        for (var d = a[b[0]].call(a), e = 0; e < d; ++e) {
            var f = b[1].call();
            arguments.callee.result.push(f)
        }
        return arguments.callee.result
    }
};
gaf.SHADER_GAUSSIAN_BLUR_FRAG = "varying mediump vec2 v_texCoord;\nuniform mediump vec2 u_step;\nvoid main()\n{ \n    mediump vec4 sum \x3d vec4(0.0);                                      \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 4.0) * 0.05;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 3.0) * 0.09;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 2.0) * 0.12;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 1.0) * 0.15;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 0.0) * 0.18;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 1.0) * 0.15;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 2.0) * 0.12;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 3.0) * 0.09;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 4.0) * 0.05;   \n    gl_FragColor \x3d sum;                                                \n} \n";
gaf.SHADER_GLOW_FRAG = "varying mediump vec2 v_texCoord;\nuniform mediump vec2 u_step;\nuniform mediump vec4 u_glowColor;\nvoid main()\n{ \n    mediump vec4 sum \x3d vec4(0.0);                                      \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 4.0) * 0.05;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 3.0) * 0.09;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 2.0) * 0.12;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord - u_step * 1.0) * 0.15;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 0.0) * 0.18;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 1.0) * 0.15;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 2.0) * 0.12;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 3.0) * 0.09;   \n    sum +\x3d texture2D(CC_Texture0, v_texCoord + u_step * 4.0) * 0.05;   \n    gl_FragColor \x3d sum * u_glowColor;                                  \n} \n";
gaf.SHADER_COLOR_MATRIX_FRAG = "varying mediump vec2 v_texCoord;\nvarying mediump vec4 v_fragmentColor;\nuniform mediump vec4 colorTransformMult;\nuniform mediump vec4 colorTransformOffsets;\nuniform mediump mat4 colorMatrix;\nuniform mediump vec4 colorMatrix2;\nvoid main()\n{ \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);                          \n    const float kMinimalAlphaAllowed \x3d 1.0e-8;                                   \n    if (texColor.a \x3e kMinimalAlphaAllowed)                                       \n    {                                                                            \n        texColor \x3d vec4(texColor.rgb / texColor.a, texColor.a);                  \n        vec4 ctxColor \x3d texColor * colorTransformMult + colorTransformOffsets;   \n        vec4 adjustColor \x3d colorMatrix * ctxColor + colorMatrix2;                \n        adjustColor *\x3d v_fragmentColor;                                          \n        texColor \x3d vec4(adjustColor.rgb * adjustColor.a, adjustColor.a);         \n    }                                                                            \n    gl_FragColor \x3d texColor;                                                     \n}\n";
gaf._glShaderInit = function () {
    gaf._Uniforms = {
        ColorTransformMult: -1,
        ColorTransformOffset: -1,
        ColorMatrixBody: -1,
        ColorMatrixAppendix: -1,
        BlurTexelOffset: -1,
        GlowTexelOffset: -1,
        GlowColor: -1
    };
    gaf._shaderCreate = function (a, b) {
        var d = new cc.GLProgram, e = d.initWithVertexShaderByteArray(b, a);
        cc.assert(e, "Shader init error");
        d.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
        d.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
        d.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        e = d.link();
        cc.assert(e, "Shader linking error");
        d.updateUniforms();
        return d
    };
    gaf._shaderCreateAlpha = function () {
        var a = gaf._shaderCreate(gaf.SHADER_COLOR_MATRIX_FRAG, cc.SHADER_POSITION_TEXTURE_COLOR_VERT);
        gaf._Uniforms.ColorTransformMult = a.getUniformLocationForName(gaf.UNIFORM_ALPHA_TINT_MULT);
        gaf._Uniforms.ColorTransformOffset = a.getUniformLocationForName(gaf.UNIFORM_ALPHA_TINT_OFFSET);
        gaf._Uniforms.ColorMatrixBody = a.getUniformLocationForName(gaf.UNIFORM_ALPHA_COLOR_MATRIX_BODY);
        gaf._Uniforms.ColorMatrixAppendix =
            a.getUniformLocationForName(gaf.UNIFORM_ALPHA_COLOR_MATRIX_APPENDIX);
        return a
    };
    gaf._shaderCreateBlur = function () {
        var a = gaf._shaderCreate(gaf.SHADER_GAUSSIAN_BLUR_FRAG, cc.SHADER_POSITION_TEXTURE_COLOR_VERT);
        gaf._Uniforms.BlurTexelOffset = a._glContext.getUniformLocation(a._programObj, gaf.UNIFORM_BLUR_TEXEL_OFFSET);
        return a
    };
    gaf._shaderCreateGlow = function () {
        var a = gaf._shaderCreate(gaf.SHADER_GLOW_FRAG, cc.SHADER_POSITION_TEXTURE_COLOR_VERT);
        gaf._Uniforms.GlowTexelOffset = a._glContext.getUniformLocation(a._programObj,
            gaf.UNIFORM_GLOW_TEXEL_OFFSET);
        gaf._Uniforms.GlowColor = a._glContext.getUniformLocation(a._programObj, gaf.UNIFORM_GLOW_COLOR);
        return a
    };
    gaf._Shaders = {Alpha: gaf._shaderCreateAlpha(), Blur: gaf._shaderCreateBlur(), Glow: gaf._shaderCreateGlow()}
};
gaf._setupShaders = function () {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL ? gaf._glShaderInit() : delete gaf._glShaderInit
};
gaf._AtlasLoader = {};
gaf._AtlasLoader.execute = function (a, b, d) {
    a() ? b() : d()
};
gaf._AtlasLoader.checkAtlas = function (a) {
    return function () {
        return a && "string" !== typeof a && a.isLoaded()
    }
};
gaf._AtlasLoader.load = function (a, b, d) {
    cc.textureCache.addImage(a, function (a) {
        gaf._AtlasLoader.execute(gaf._AtlasLoader.checkAtlas(a), function () {
            b(a)
        }, d)
    })
};
gaf._AtlasLoader.loadFront = function (a, b, d) {
    return function () {
        0 < a.length ? gaf._AtlasLoader.load(a[0], b, gaf._AtlasLoader.loadFront(a.slice(1), b, d)) : d()
    }
};
gaf._AtlasLoader.loadArray = function (a, b, d) {
    gaf._AtlasLoader.loadFront(a, b, d)()
};
var fonts = {custom_font: "res/fonts/customFont.ttf"}, baseRes = {
    AlertResource_png: "res/AlertResource.png",
    AlertResource_plist: "res/AlertResource.plist",
    baseUI_png: "res/baseUI.png",
    baseUI_plist: "res/baseUI.plist",
    HelloWorld_png: "res/HelloWorld.png",
    qishi_plist: "res/qishi_loading.plist",
    qishi_png: "res/qishi_loading.png",
    defen_fnt: "res/fonts/defen.fnt",
    defen_png: "res/fonts/defen.png"
}, baseRes_resources = [];
for (i in baseRes)baseRes_resources.push(baseRes[i]);
var loginSceneRes = {
    loginScene_json: "res/loginScene/LoginScene.json",
    logindonghuaxiaoguo_json: "res/loginScene/logodonghuaxiaoguo.json",
    qidong_baimaguanyinzhangdonghua_json: "res/loginScene/qidong_baimaguanyinzhangdonghua.json",
    niao_json: "res/loginScene/niao.json",
    niaodonghua_json: "res/loginScene/niaodonghua.json",
    yun_json: "res/loginScene/yun.json",
    qidong_di_png: "res/loginScene/qidong_di.jpg",
    qidongdonghua_plist: "res/loginScene/qidongdonghua.plist",
    qidongdonghua_png: "res/loginScene/qidongdonghua.png",
    feixing_plist: "res/particle/feixing.plist",
    feixing_png: "res/particle/feixing.png",
    tongyong_tishixing01_plist: "res/particle/tongyong_tishixing01.plist",
    tongyong_tishixing01_png: "res/particle/tongyong_tishixing01.png",
    xingxing03_plist: "res/particle/xingxing03.plist",
    xingxing03_png: "res/particle/xingxing03.png",
    xuanz005_plist: "res/particle/xuanz005.plist",
    xuanz005_png: "res/particle/xuanz005.png",
    zair002_png: "res/particle/zair002.png",
    zair002_plist: "res/particle/zair002.plist"
}, loginSceneRes_resources =
    [];
for (i in loginSceneRes)loginSceneRes_resources.push(loginSceneRes[i]);
var audioRes = {}, res = {
    game_top_json: "res/gameScene/gameTop.json",
    baseUI_plist: "res/baseUI.plist",
    baseUI_png: "res/baseUI.png",
    MainScene_json: "res/MainScene.json",
    custom_ttf: "res/gameScene/fonts/customFont.ttf",
    defen_fnt: "res/gameScene/fonts/defen.fnt",
    defen_png: "res/gameScene/fonts/defen.png",
    jcdf_fnt: "res/gameScene/fonts/jcdf.fnt",
    jcdf_png: "res/gameScene/fonts/jcdf.png",
    ljdf_png: "res/gameScene/fonts/gameUI_lianjidengfen.png",
    scratch_png: "res/gameScene/scratch/scratch1.png",
    scratch_plist: "res/gameScene/scratch/scratch1.plist",
    scratch_json: "res/gameScene/scratch/scratch1.json",
    clue_bg: "res/background/ClueUI_bg.jpg",
    menu_bg: "res/background/qidong_di.jpg",
    menu_png: "res/menu.png",
    line_animation_plist: "res/animation/wupumingchenghuaquxian_Animation/anjianwupinhuaxian_Animation.plist",
    line_animation_png: "res/animation/wupumingchenghuaquxian_Animation/anjianwupinhuaxian_Animation.png",
    game_bottom_json: "res/gameScene/gameBottom.json",
    game_sceneui_plist: "res/gameSceneUI.plist",
    game_sceneui_png: "res/gameSceneUI.png",
    lianji_plist: "res/animation/lianji/changjing_lianjiXGJL.plist",
    lianji_png: "res/animation/lianji/changjing_lianjiXGJL.png",
    lianji_num1_plist: "res/animation/lianji/changjing_lianjiXGJL1.plist",
    lianji_num1_png: "res/animation/lianji/changjing_lianjiXGJL1.png",
    lianji_num3_plist: "res/animation/lianji/changjing_lianjiXGJLX3.plist",
    lianji_num3_png: "res/animation/lianji/changjing_lianjiXGJLX3.png",
    lianji_num4_plist: "res/animation/lianji/changjing_lianjiXGJLX4.plist",
    lianji_num4_png: "res/animation/lianji/changjing_lianjiXGJLX4.png",
    lianji_num5_plist: "res/animation/lianji/changjing_lianjiXGJLX5.plist",
    lianji_num5_png: "res/animation/lianji/changjing_lianjiXGJLX5.png",
    lianji_num6_plist: "res/animation/lianji/changjing_lianjiXGJLX6.plist",
    lianji_num6_png: "res/animation/lianji/changjing_lianjiXGJLX6.png",
    lianji_jiangli_json: "res/animation/lianji/xianchang_liangjiJLXG.json",
    lianji_num2_json: "res/animation/lianji/xianchang_lianjiX2.json",
    lianji_num3_json: "res/animation/lianji/xianchang_lianjiX3.json",
    lianji_num4_json: "res/animation/lianji/xianchang_lianjiX4.json",
    lianji_num5_json: "res/animation/lianji/xianchang_lianjiX5.json",
    lianji_num6_json: "res/animation/lianji/xianchang_lianjiX6.json",
    lianji_json: "res/animation/lianji/xianchang_lianjiXG.json",
    lianji_boom_json: "res/animation/lianjibaozha/baozhaguangxiaoguo.json",
    boom_lizi_plist: "res/animation/lianjibaozha/bz01.plist",
    boom_lizi_png: "res/animation/lianjibaozha/bz01.png",
    click_wrong_plist: "res/animation/cuowudianji/dianjicuowudonghua.plist",
    click_wrong_png: "res/animation/cuowudianji/dianjicuowudonghua.png",
    click_continuousError_json: "res/animation/cuowudianji/continuousError.json",
    click_error_daojishi_json: "res/animation/cuowudianji/cuowu_shijiandaojishi.json",
    gameFail_json: "res/animation/tiaozhanshibai/gameFail.json",
    jixvBtn_png: "res/animation/tiaozhanshibai/gameUI_zdxjixu.png",
    shibai_png: "res/animation/tiaozhanshibai/shibai.png",
    shibaixg_png: "res/animation/tiaozhanshibai/shibaiguangxiao.png",
    tiaozhan_png: "res/animation/tiaozhanshibai/tianzhan.png",
    success_json: "res/animation/tiaozhanchenggong/accountsView.json",
    success_cg_png: "res/animation/tiaozhanchenggong/jiesuan_chenggong.png",
    success_fg_png: "res/animation/tiaozhanchenggong/jiesuan_chenggongfaguang.png",
    success_tz_png: "res/animation/tiaozhanchenggong/jiesuan_tianzhan.png",
    pauseUI_json: "res/gameScene/pauseUI.json",
    prompt_fire_plist: "res/animation/tishihuoyan/xianchang_zhukongqu_houyanXG.plist",
    prompt_fire_png: "res/animation/tishihuoyan/xianchang_zhukongqu_houyanXG.png",
    prompt_fire_json: "res/animation/tishihuoyan/zhukongqu_houyanXG.json",
    click_tip_json: "res/animation/tishidianji/dianjijinengxiaoguo.json",
    click_tip_plist: "res/animation/tishidianji/dianjijinengxiaoguo.plist",
    click_tip_png: "res/animation/tishidianji/dianjijinengxiaoguo.png",
    wuzhenglihe_png: "res/gameScene/searchGame/gameScene_1/evidence/gameUI_wuzhenglihe.png",
    wuzhengshoupai_png: "res/gameScene/searchGame/gameScene_1/evidence/gameUI_wuzhengshoupai.png",
    gameScene_1_jpg: "res/gameScene/searchGame/gameScene_1/gameScene_1.jpg",
    gameScene_1_json: "res/gameScene/searchGame/gameScene_1/gameScene_1.json",
    gameScene_1_plist: "res/gameScene/searchGame/gameScene_1/gameScene_1.plist",
    gameScene_1_png: "res/gameScene/searchGame/gameScene_1/gameScene_1.png",
    gameScene_1_02_jpg: "res/gameScene/searchGame/gameScene_1/gameScene_1_02.jpg",
    gameScene_1_zhuguang_plist: "res/gameScene/searchGame/gameScene_1/gameScene_1_zhuguang.plist",
    gameScene_1_zhuguang_png: "res/gameScene/searchGame/gameScene_1/gameScene_1_zhuguang.png",
    huomiao_json: "res/gameScene/searchGame/gameScene_1/huomiao.json",
    jiangli_tq_plist: "res/gameScene/searchGame/gameScene_1/jiangli_tq.plist",
    jiangli_tq_png: "res/gameScene/searchGame/gameScene_1/jiangli_tq.png",
    shoushihe_json: "res/gameScene/searchGame/gameScene_1/shoushihe.json",
    common_click_mp3: "res/audio/Sound/common_click.mp3",
    clickError_mp3: "res/audio/Sound/game_clickError.mp3",
    clickWarn_mp3: "res/audio/Sound/game_clickWarn.mp3",
    game_combo2_mp3: "res/audio/Sound/game_combo2.mp3",
    game_combo3_mp3: "res/audio/Sound/game_combo3.mp3",
    game_combo4_mp3: "res/audio/Sound/game_combo4.mp3",
    game_combo5_mp3: "res/audio/Sound/game_combo5.mp3",
    game_comboAward1_mp3: "res/audio/Sound/game_comboAward1.mp3",
    game_comboAward2_mp3: "res/audio/Sound/game_comboAward2.mp3",
    game_find_mp3: "res/audio/Sound/game_find.mp3",
    game_listTime_mp3: "res/audio/Sound/game_listTime.mp3",
    game_newEvidence_mp3: "res/audio/Sound/game_newEvidence.mp3",
    game_Prompt_mp3: "res/audio/Sound/game_Prompt.mp3",
    game_useSkill_mp3: "res/audio/Sound/game_useSkill.mp3",
    Hello_png: "res/HelloWorld.png"
}, g_resources = [];
for (i in res)g_resources.push(res[i]);
var g_menuResources = [res.menu_bg, res.Hello_png, res.common_click_mp3], g_scratchGame = [res.scratch_json, res.scratch_png, res.scratch_plist, res.clue_bg], g_searchGame = [[res.custom_ttf, res.ljdf_png, res.defen_fnt, res.defen_png, res.jcdf_fnt, res.jcdf_png, res.line_animation_plist, res.line_animation_png, res.game_bottom_json, res.game_sceneui_plist, res.game_sceneui_png, res.line_animation_png, res.line_animation_plist, res.game_top_json, res.click_wrong_plist, res.click_wrong_png, res.baseUI_plist, res.baseUI_png, res.lianji_plist,
    res.lianji_png, res.lianji_num1_plist, res.lianji_num1_png, res.lianji_num3_plist, res.lianji_num3_png, res.lianji_num4_plist, res.lianji_num4_png, res.lianji_num5_plist, res.lianji_num5_png, res.lianji_num6_plist, res.lianji_num6_png, res.lianji_jiangli_json, res.lianji_num2_json, res.lianji_num3_json, res.lianji_num4_json, res.lianji_num5_json, res.lianji_num6_json, res.lianji_json, res.clickError_mp3, res.clickWarn_mp3, res.game_combo2_mp3, res.game_combo3_mp3, res.game_combo4_mp3, res.game_combo5_mp3, res.game_comboAward1_mp3,
    res.game_comboAward2_mp3, res.game_find_mp3, res.game_listTime_mp3, res.game_newEvidence_mp3, res.game_Prompt_mp3, res.game_useSkill_mp3, res.click_continuousError_json, res.click_error_daojishi_json, res.lianji_boom_json, res.boom_lizi_plist, res.boom_lizi_png, res.gameFail_json, res.jixvBtn_png, res.shibai_png, res.shibaixg_png, res.tiaozhan_png, res.pauseUI_json, res.prompt_fire_plist, res.prompt_fire_png, res.prompt_fire_json, res.click_tip_json, res.click_tip_plist, res.click_tip_png, res.common_click_mp3, res.success_json,
    res.success_cg_png, res.success_tz_png, res.success_fg_png], [res.wuzhenglihe_png, res.wuzhengshoupai_png, res.gameScene_1_jpg, res.gameScene_1_json, res.gameScene_1_plist, res.gameScene_1_png, res.gameScene_1_02_jpg, res.gameScene_1_zhuguang_plist, res.gameScene_1_zhuguang_png, res.huomiao_json, res.jiangli_tq_plist, res.jiangli_tq_png, res.shoushihe_json]];
function plistAsyncLoading(a, b, d, e) {
    function f(b) {
        "" != a && (cc.spriteFrameCache.addSpriteFrames(a), console.log("loading...SpriteFrame:" + a));
        console.log("loading...texture:" + b.getName());
        addUITableManagement(b, a);
        d(e)
    }

    jsb.fileUtils.isFileExist(b) ? cc.director.getTextureCache().addImageAsync(b, f) : f()
}
var spriteFrameUITable = [], textureUITable = [];
function addUITableManagement(a, b) {
    if (!isComUI(b)) {
        console.log("express plist:" + b);
        var d = jsb.fileUtils.getValueMapFromFile(b), e;
        for (e in d.frames)e && (d = cc.spriteFrameCache.getSpriteFrame(e)) && (d.retain(), spriteFrameUITable.push(d))
    }
    a && (textureUITable.push(a), a.retain())
}
STATIC_RESOURCE = ["baseUI.plist"];
function isComUI(a) {
    STATIC_RESOURCE.forEach(function (b) {
        if (a == b)return !0
    });
    return !1
}
function removeUITableManagement() {
    spriteFrameUITable.forEach(function (a) {
        a.release()
    });
    textureUITable.forEach(function (a) {
        a.release()
    });
    textureUITable = [];
    spriteFrameUITable = []
}
function saveComUI(a) {
    a = jsb.fileUtils.getValueMapFromFile(a).frames;
    for (var b in a.frames)b && (a = cc.spriteFrameCache.getSpriteFrame(b)) && a.retain()
};var audioHelper = {
    isPlayMusic: "true", isPlaySound: "false", openMusic: function (a) {
        audioHelper.isPlayMusic = "true";
        cc.sys.localStorage.setItem("isPlayMusic", !0);
        !cc.audioEngine.isMusicPlaying() && a && cc.audioEngine.playMusic(a, !0)
    }, playSound: function (a) {
        audioHelper.isPlayMusic = "true";
        cc.sys.localStorage.setItem("isPlayMusic", !0);
        !cc.audioEngine.isMusicPlaying() && a && cc.audioEngine.playMusic(a, !0)
    }, closeMusic: function () {
        audioHelper.isPlayMusic = "false";
        cc.sys.localStorage.setItem("isPlayMusic", !1);
        cc.audioEngine.isMusicPlaying &&
        cc.audioEngine.stopMusic(!0)
    }, setMusicVolume: function (a) {
        a = 0 > a ? 0 : a;
        cc.audioEngine.setMusicVolume(a);
        cc.sys.localStorage.setItem("musicVolume", a)
    }, openSound: function () {
        audioHelper.isPlaySound = "true";
        cc.sys.localStorage.setItem("isPlaySound", !0)
    }, closeSound: function () {
        audioHelper.isPlaySound = "false";
        cc.sys.localStorage.setItem("isPlaySound", !1);
        cc.audioEngine.stopAllEffects()
    }, setSoundVolume: function (a) {
        cc.audioEngine.setEffectsVolume(a);
        cc.sys.localStorage.setItem("soundVolume", a)
    }, init: function () {
        var a =
            cc.sys.localStorage.getItem("isPlayMusic");
        a || (a = !0, cc.sys.localStorage.setItem("isPlayMusic", a));
        audioHelper.isPlayMusic = a;
        a = cc.sys.localStorage.getItem("isPlaySound");
        a || (a = !0, cc.sys.localStorage.setItem("isPlaySound", a));
        audioHelper.isPlaySound = a;
        (a = cc.sys.localStorage.getItem("musicVolume")) || audioHelper.setMusicVolume(1);
        cc.audioEngine.setMusicVolume(Number(a));
        (a = cc.sys.localStorage.getItem("soundVolume")) || audioHelper.setSoundVolume(1);
        cc.audioEngine.setEffectsVolume(Number(a))
    }
};
var timerHelper = {
    TEMPORARY_TIMER_TABLE: [], createTimer: function (a, b, d, e, f, g, h) {
        var n = {};
        4 == arguments.length ? (cc.director.getScheduler().schedule(a, b, d, cc.REPEAT_FOREVER, 0, !1, e), n = {
            k: e,
            tar: b
        }) : (cc.director.getScheduler().schedule(a, b, d, e, f, g, h), n = {k: h, tar: b});
        timerHelper.TEMPORARY_TIMER_TABLE.push(n)
    }, removeTimer: function (a) {
        for (var b in this.TEMPORARY_TIMER_TABLE) {
            var d = this.TEMPORARY_TIMER_TABLE[b];
            if (d.k == a) {
                this.TEMPORARY_TIMER_TABLE.splice(Number(b), 1);
                cc.director.getScheduler().unschedule(a, d.tar);
                break
            }
        }
    }, removeAllTimer: function () {
        this.TEMPORARY_TIMER_TABLE.forEach(function (a) {
            cc.director.getScheduler().unschedule(a.k, a.tar)
        });
        this.TEMPORARY_TIMER_TABLE = []
    }
};
var TASK_DATA = {
    ID: 0,
    NAME: 1,
    DESCRIBE: 2,
    BEHAVIOR_TYPENAMOUNT1: 3,
    BEHAVIOR_TARGET1: 4,
    BEHAVIOR_TYPENAMOUNT2: 5,
    BEHAVIOR_TARGET2: 6,
    PREVTASKS: 7,
    NEXTTASKS: 8,
    AUTO_COMPLETE: 9,
    CONDITION: 10,
    BEGIN_DIALOGUE: 11,
    DOING_DIALOGUE: 12,
    END_DIALOGUE: 13,
    PRIZE_TYPENAMOUNT1: 14,
    PRIZE_TYPENAMOUNT2: 15,
    TASK_LOGO: 16,
    TASK_LOGO2: 17,
    COMPLETE_DESCRIBE: 18,
    FAST_CONDITION: 19,
    QUEST_TYPE: 20,
    data: [[1001, "task1", "kill some monsters", 10, 1, 0, 0, "", "1002", 0, "", 0, 0, 0, 0, 0, "", "", "", "", 0], [1002, "task2", "kill some monsters", 10, 1, 0, 0, "1001", "1003",
        0, "", 0, 0, 0, 0, 0, "", "", "", "", 0], [1003, "task3", "kill some monsters", 10, 1, 0, 0, "1002", "1004", 0, "", 0, 0, 0, 0, 0, "", "", "", "", 0], [1004, "task4", "kill boss", 10, 1, 0, 0, "1003", "", 0, "", 0, 0, 0, 0, 0, "", "", "", "", 0]]
};
var gt = {UPDATE_VERSION: "", UPDATE_OK: ""};
var tskTrcHlp = {
    INDEXID: 0,
    TASK_ID: 1,
    AMOUNT1: 2,
    AMOUNT2: 3,
    STATUS: 4,
    task_trace: [],
    TST_NOT_ACCEPT: 0,
    TST_ACCEPT_NOTFIN: 1,
    TST_ACCEPT_FIN: 2,
    TST_OVER: 3,
    TST_ACCEPT_LOCK: 4,
    PZT_COIN: 1,
    PZT_ENERGY: 2,
    PZT_EXP: 3,
    PZT_RMB: 4,
    PZT_OTHER: 5,
    onTimeUpdateTaskTrace: function (a, b, d) {
        var e = a.behavior, f = a.tid;
        a = tskTrcHlp.findTaskTraceIndexByTaskId(f);
        var f = tskTrcHlp.findTaskStaticByTaskId(f), g = !1;
        if (null != f && 0 <= a) {
            var g = Math.floor(f[TASK_DATA.BEHAVIOR_TYPENAMOUNT2] / 1E3), h = f[TASK_DATA.BEHAVIOR_TYPENAMOUNT2] % 1E3, n = f[TASK_DATA.BEHAVIOR_TARGET2],
                f = tskTrcHlp.checkStep(Math.floor(f[TASK_DATA.BEHAVIOR_TYPENAMOUNT1] / 1E3), f[TASK_DATA.BEHAVIOR_TARGET1], f[TASK_DATA.BEHAVIOR_TYPENAMOUNT1] % 1E3, e, b, d, a, tskTrcHlp.AMOUNT1);
            b = tskTrcHlp.checkStep(g, n, h, e, b, d, a, tskTrcHlp.AMOUNT2);
            if (g = f && b)tskTrcHlp.task_trace[a][tskTrcHlp.STATUS] = tskTrcHlp.TST_OVER, tskTrcHlp.triggerEndTask(a), tskTrcHlp.deleteTaskTraceByIdx(a), console.log("you complete a task sir!")
        }
        return g
    },
    findTaskTraceIndexByTaskId: function (a) {
        for (var b in tskTrcHlp.task_trace)if (tskTrcHlp.task_trace[b][tskTrcHlp.TASK_ID] ==
            a)return Number(b);
        return -1
    },
    findTaskStaticByTaskId: function (a) {
        for (var b in TASK_DATA.data) {
            var d = TASK_DATA.data[b];
            if (d[TASK_DATA.ID] == a)return d
        }
        return null
    },
    checkStep: function (a, b, d, e, f, g, h, n) {
        if (0 != a) {
            if (e == a && b == f) {
                if (null == tskTrcHlp.task_trace[h] || cc.isUndefined(tskTrcHlp.task_trace[h]))return !1;
                tskTrcHlp.task_trace[h][n] += g;
                return tskTrcHlp.task_trace[h][n] >= d ? !0 : !1
            }
            return !1
        }
        return !0
    },
    triggerEndTask: function (a) {
        tskTrcHlp.completeTask(a, null)
    },
    completeTask: function (a, b) {
        var d = tskTrcHlp.findTaskStaticByTaskId(tskTrcHlp.task_trace[a][tskTrcHlp.TASK_ID]),
            e = d[TASK_DATA.NEXTTASKS];
        if ("" != e) {
            tskTrcHlp.giveTaskPrizes(d);
            var f = [], d = [];
            if (-1 != e.indexOf("_")) {
                if (e = e.split("_"), 0 < e.length)for (d = null != e[b] ? e[b].split("`") : e[1].split("`"), e = 0; e < d.length; e++)f.push(d[e])
            } else for (d = e.split("`"), e = 0; e < d.length; e++)f.push(d[e])
        }
        d = [];
        for (e = 0; e < f.length; e++) {
            var g = Number(f[e]);
            if (tskTrcHlp.acceptTask(g))for (e in tskTrcHlp.task_trace) {
                var h = tskTrcHlp.task_trace[e][tskTrcHlp.STATUS], g = tskTrcHlp.task_trace[e][tskTrcHlp.TASK_ID];
                tskTrcHlp.findTaskStaticByTaskId(g)[TASK_DATA.NEXTTASKS].indexOf("_");
                h == tskTrcHlp.TST_OVER && (d[e] = g)
            }
        }
        for (var n in d)tskTrcHlp.deleteTracesByTaskid(d[n])
    },
    checkPrevTask: function (a, b) {
        if ("" == b)return !0;
        var d = !1, e = 0, f = [];
        0 < b.indexOf("_") ? (f = b.split("_"), e = 1) : (f = b.split("`"), e = 2);
        var g = 0, h;
        for (h in tskTrcHlp.task_trace) {
            var n = tskTrcHlp.task_trace[h][tskTrcHlp.TASK_ID];
            h = tskTrcHlp.task_trace[h][tskTrcHlp.STATUS];
            for (var p in f) {
                var r = f[p];
                if (1 == e) {
                    if (h == tskTrcHlp.TST_OVER && Number(r) == n) {
                        d = !0;
                        break
                    }
                } else 2 == e && h == tskTrcHlp.TST_OVER && Number(r) == n && (g += 1);
                if (d)break
            }
            g == f.length &&
            2 == e && (d = !0);
            return d
        }
    },
    acceptTask: function (a) {
        var b = !1;
        if (0 != a) {
            var d = tskTrcHlp.findTaskStaticByTaskId(a);
            if (b = tskTrcHlp.checkPrevTask(a, d[TASK_DATA.PREVTASKS])) {
                var e = [];
                e.push(1);
                e.push(a);
                e.push(0);
                e.push(0);
                var f = 0, f = "" == d[TASK_DATA.CONDITION] ? tskTrcHlp.TST_ACCEPT_NOTFIN : tskTrcHlp.TST_ACCEPT_LOCK;
                e.push(f);
                tskTrcHlp.task_trace.push(e);
                console.log("changllenge:" + a + " accepted")
            } else console.log("condition not fit")
        }
        return b
    },
    deleteTaskTraceByIdx: function (a) {
        for (var b in tskTrcHlp.task_trace)if (tskTrcHlp.task_trace[b][tskTrcHlp.TASK_ID] ==
            a) {
            tskTrcHlp.task_trace.splice(b, 1);
            console.log("delete traceIdx \x3d " + a);
            break
        }
    },
    deleteTracesByTaskid: function (a) {
        for (var b in tskTrcHlp.task_trace)if (tskTrcHlp.task_trace[b][tskTrcHlp.TASK_ID] == a) {
            tskTrcHlp.task_trace.splice(b, 1);
            console.log("delete taskid \x3d " + a);
            break
        }
    },
    giveTaskPrize: function (a, b) {
    },
    giveTaskPrizes: function (a) {
        var b = a[TASK_DATA.PRIZE_TYPENAMOUNT1], d = a[TASK_DATA.PRIZE_TYPENAMOUNT2];
        a = d % 1E6;
        d = Math.floor(d / 1E6);
        tskTrcHlp.giveTaskPrize(Math.floor(b / 1E6), b % 1E6);
        tskTrcHlp.giveTaskPrize(d,
            a)
    }
};
var loadingProgressLayer = cc.Layer.extend({
    sprite: null, ctor: function () {
        this._super();
        var a = new cc.LabelTTF("loading", "Arial", 48);
        this.addChild(a);
        a.color = cc.color(255, 0, 0);
        a.x = vSize.width / 2;
        a.y = vSize.height / 2;
        return !0
    }, loadingFinishCall: function (a) {
        saveComUI(baseRes.baseUI_plist);
        console.log("loading finish!");
        var b = new ccui.Button(res.HelloWorld_png, res.HelloWorld_png, res.HelloWorld_png);
        console.log("fuck you");
        b.addClickEventListener(function () {
            removeUITableManagement();
            cc.spriteFrameCache.removeUnusedSpriteFrames();
            cc.director.getTextureCache().removeUnusedTextures();
            var b = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("Alert_reel_di.png"));
            b.x = vSize.width / 3;
            b.y = vSize.height / 3;
            a.addChild(b)
        });
        a.addChild(b);
        b.attr({x: vSize.width / 2, y: vSize.height / 2})
    }, enterHelloScene: function () {
        var a = [];
        a.push({plist: baseRes.baseUI_plist, png: baseRes.baseUI_png});
        a.push({plist: baseRes.AlertResource_plist, png: baseRes.AlertResource_png});
        this.loopLoadingRes(a, this.loadingFinishCall, this)
    }, iniLoading: function (a, b) {
        switch (a) {
            case 1:
                this.enterHelloScene()
        }
        b &&
        b.call()
    }, loopLoadingRes: function (a, b, d) {
        function e(g) {
            f = g + 1;
            f >= a.length ? b(d) : (g = a[f], plistAsyncLoading(g.plist, g.png, e, f))
        }

        cc.spriteFrameCache.removeUnusedSpriteFrames();
        cc.director.getTextureCache().removeUnusedTextures();
        var f = 0;
        e(-1)
    }
}), loadingProgressScene = cc.Scene.extend({
    layer: null, sid: 0, cb: null, ctor: function (a, b) {
        this._super();
        this.sid = a;
        this.cb = b;
        removeUITableManagement()
    }, onEnter: function () {
        console.log("onEnter");
        this._super();
        this.layer = new loadingProgressLayer;
        this.addChild(this.layer)
    },
    onEnterTransitionDidFinish: function () {
        this._super();
        console.log("onEnterTransitionDidFinish");
        this.layer.iniLoading(this.sid, this.cb)
    }, onExitTransitionDidStart: function () {
        this._super();
        console.log("onExitTransitionDidStart")
    }, onExit: function () {
        console.log("onExit")
    }, cleanup: function () {
        this._super();
        console.log("cleanup")
    }
});
var loginLayer = cc.Layer.extend({
    _updateInfoText: null,
    _waitText: null,
    _loadingBar: null,
    _loadingMove: null,
    _enterBtn: null,
    _loginAndRegisterBtn: null,
    currentVersion: "",
    beforeVersion: "",
    _percent: 100,
    logo: null,
    logoLight: null,
    logoRender: null,
    ctor: function () {
        this._super();
        this.init()
    },
    init: function () {
        self = this;
        self._updateInfoText = new ccui.Text("", fonts.custom_font, 25);
        self._updateInfoText.setAnchorPoint(0.5, 0.5);
        self._updateInfoText.setTextHorizontalAlignment(cc.TEXT_ALIGNMENT_LEFT);
        self._updateInfoText.setUnifySizeEnabled(!0);
        self._updateInfoText.setContentSize(cc.size(200, 40));
        self._updateInfoText.setPosition(cc.winSize.width / 2, 50);
        self.addChild(self._updateInfoText, 1E3);
        self._waitText = new ccui.Text("", fonts.custom_font, 25);
        self._waitText.setAnchorPoint(0, 0);
        self._waitText.setPositionX(self._updateInfoText.width);
        self._updateInfoText.addChild(self._waitText);
        var a = ccs.load(loginSceneRes.loginScene_json);
        self._loginUI = a.node;
        a = a.action;
        self._loadingBar = self._loginUI.getChildByName("loadingBar");
        var b = new cc.ParticleSystem(loginSceneRes.zair002_plist);
        b.setPosition(0, 0);
        b.texture = cc.textureCache.addImage(loginSceneRes.zair002_png);
        self._loadingMove = new cc.ParticleBatchNode(b.texture);
        self._loadingMove.addChild(b);
        self._loadingBar.addChild(self._loadingMove);
        self._loadingMove.setPosition(cc.p(0, 9));
        self._loadingMove.setVisible(!1);
        self._loadingMove.setOpacity(100);
        b.setPositionType(cc.ParticleSystem.TYPE_GROUPED);
        self._loginUI.getChildByName("imgMove").setVisible(!1);
        self._loadingDi = self._loginUI.getChildByName("imgLoadingDi");
        self._loadingDi.setVisible(!1);
        self._loginUI.runAction(a);
        self.addChild(self._loginUI);
        a.gotoFrameAndPlay(0, 155, !1);
        var d = ccs.load(loginSceneRes.qidong_baimaguanyinzhangdonghua_json), b = d.node, d = d.action;
        b.runAction(d);
        self._loginUI.getChildByName("imgBG").setLocalZOrder(-2);
        self._loginUI.addChild(b, 1);
        b.setPosition(self._loginUI.width - 30, 270);
        d.gotoFrameAndPlay(0, !1);
        d = ccs.load(loginSceneRes.logindonghuaxiaoguo_json);
        b = d.node;
        d = d.action;
        b.runAction(d);
        d.gotoFrameAndPlay(0, !1);
        b.setPosition(590, 400);
        b.setName("logoAnimation");
        self._loginUI.addChild(b);
        a.setFrameEventCallFunc(function (a) {
            "appear" == a.getEvent() && (self.addLight(), self.onSuccess(), self._updateInfoText.setString(""))
        });
        self.setLoginButton()
    },
    setLoginButton: function () {
        self = this;
        self._enterBtn = new ccui.Button;
        self._enterBtn.setTouchEnabled(!1);
        self._enterBtn.loadTextures("dengrujiemian_kuaisukaishi.png", "", "", ccui.Widget.PLIST_TEXTURE);
        self._enterBtn.setOpacity(0);
        self._enterBtn.setPosition(cc.winSize.width / 2 - 160, 20);
        self.addChild(self._enterBtn);
        extraFunc.setButtonFun(self._enterBtn,
            null, null, function (a) {
                if (cc.sys.localStorage.getItem("isBinding")) {
                    a = c.sys.localStorage.getItem("userName");
                    var b = c.sys.localStorage.getItem("passWord");
                    a && "" != a && b && "" != b && (cryptoHelper.decryptoDataByKey(a), cryptoHelper.decryptoDataByKey(b))
                }
                cc.sys.localStorage.getItem("TourAccount")
            });
        self._loginAndRegisterBtn = new ccui.Button;
        self._loginAndRegisterBtn.setTouchEnabled(!1);
        self._loginAndRegisterBtn.loadTextures("dengrujiemian_dengruzhuce.png", "", "", ccui.Widget.PLIST_TEXTURE);
        self._loginAndRegisterBtn.setOpacity(0);
        self._loginAndRegisterBtn.setPosition(cc.winSize.width / 2 + 190, 20);
        self.addChild(self._loginAndRegisterBtn);
        extraFunc.setButtonFun(self._loginAndRegisterBtn, null, null, function (a) {
            display();
            self._loginAndRegisterBtn.setVisible(!1);
            self._enterBtn.setVisible(!1);
            cc.audioEngine.playEffect("audio/Sound/common_click.mp3", !1)
        })
    },
    onSuccess: function (a, b, d) {
        self = this;
        a ? (self.currentVersion = b, self.beforeVersion = d) : (self._updateInfoText.setString(""), self._waitText.setString(""));
        self._isDownload = a;
        this.moveLoading()
    },
    addLight: function () {
        self = this;
        self.logo = extraFunc.createSprite("qidong_datongqian1.png", loginSceneRes.qidongdonghua_plist);
        self.logoLight = extraFunc.createSprite("qidong_datongqian1-0.png", loginSceneRes.qidongdonghua_plist);
        var a = new cc.ClippingNode;
        a.setInverted(!1);
        a.addChild(self.logo);
        a.setStencil(self.logoLight);
        var b = self._loginUI.getChildByName("logoAnimation");
        a.setPosition(b.x - 16, b.y + 20);
        self._loginUI.addChild(a);
        self.logoLight.x = -300;
        timerHelper.createTimer(function () {
            var a = self.logoLight.x,
                a = a + 6;
            a > self.logo.width + 1400 && (a = -300);
            cc.log(a);
            self.logoLight.setPosition(a, 0)
        }, this, 0, gc.TIMER_KEY_logoLight)
    },
    removeLight: function () {
        timerHelper.removeTimer(gc.TIMER_KEY_logoLight);
        this.logoRender = null;
        this.logoLight.release();
        this.logo.release();
        this.logo = this.logoLight = null
    },
    enterGame: function () {
    },
    displayVersionText: function () {
        self = this;
        self._versionTxt = new ccui.Text("", fonts.custom_font, 40);
        self._versionTxt.setUnifySizeEnabled(!0);
        self._versionTxt.setContentSize(200, 50);
        self._versionTxt.setTextColor(cc.color(250,
            190, 110));
        self._versionTxt.setCascadeOpacityEnabled(!0);
        self._versionTxt.setOpacity(0);
        self._versionTxt.setTouchEnabled(!0);
        self._versionTxt.setEnabled(!0);
        self._versionTxt.setPosition(cc.winSize.width - self._versionTxt.width / 2, cc.winSize.height - self._versionTxt.height);
        self.addChild(self._versionTxt, 1E4);
        extraFunc.setButtonFun(self._versionTxt, null, null, function (a) {
            0 == self._versionTxt.getOpacity() ? a.setOpacity(255) : a.setOpacity(0)
        })
    },
    moveLoading: function () {
        self = this;
        self._loadingDi.isVisible() && (self._updateInfoText.setPositionY(50),
            self._loadingDi.setVisible(!0));
        var a = 0;
        timerHelper.createTimer(function () {
            if (a < self._percent && (a += 1, self._updateInfoText.setString(gt.UPDATE_VERSION + a + "%"), self._loadingBar.setPercent(a), self._loadingMove.setVisible(!0), self._loadingMove.setPositionX(self._loadingBar.width * a / 100), 100 <= a)) {
                timerHelper.removeTimer(gc.TIMER_KEY_LODERBAR);
                self._updateInfoText.setString("");
                self._waitText.setString("");
                self._loadingBar.setVisible(!1);
                self._loadingDi.setVisible(!1);
                self.addEnterButton();
                var b = self.currentVersion.split("_")[0].split("."),
                    b = b[b.length - 1].match("(%d+)%a"), d = self.beforeVersion, d = d.split("."), d = d[d.length - 1], d = d.match("(%d+)%a");
                b != d && alertHelper.showAlert("\u63d0\u793a", gt.UPDATE_OK, [gc.BTN_LOGIN_OK], function (a) {
                    1 == a && self.removeLight()
                })
            }
        }, self, 0, gc.TIMER_KEY_LODERBAR)
    },
    addEnterButton: function () {
        function a(a) {
            a.setTouchEnabled(!0)
        }

        var b = new cc.MoveBy(0.4, cc.p(0, 160)), d = new cc.FadeIn(0.5), b = new cc.Spawn(b, d), d = b.clone();
        self._enterBtn.runAction(new cc.Sequence(b, new cc.CallFunc(a)));
        self._loginAndRegisterBtn.runAction(new cc.Sequence(d,
            new cc.CallFunc(a)))
    },
    showButton: function () {
        self = this;
        var a = new cc.ScaleTo(0.1, 1), a = new cc.EaseBounceOut(a);
        self._loginAndRegisterBtn.setScale(0.1);
        self._loginAndRegisterBtn.setVisible(!0);
        self._loginAndRegisterBtn.runAction(a);
        var b = cc.sys.localStorage.getItem("isBinding");
        if (void 0 == b || "" == b)self._enterBtn.setScale(0.1), self._enterBtn.setVisible(!0), self._enterBtn.runAction(a.clone())
    }
}), loginScene = cc.Scene.extend({
    layer: null, onEnter: function () {
        console.log("onEnter");
        this._super();
        this.layer = new loginLayer;
        this.addChild(this.layer);
        this.onMusic()
    }, onEnterTransitionDidFinish: function () {
        this._super();
        console.log("onEnterTransitionDidFinish")
    }, onExitTransitionDidStart: function () {
        this._super();
        console.log("onExitTransitionDidStart")
    }, onExit: function () {
        this._super();
        console.log("onExit")
    }, cleanup: function () {
        this._super();
        console.log("cleanup")
    }, onMusic: function () {
    }
});
vSize = cc.director.getVisibleSize();
vSizeOrg = cc.director.getVisibleOrigin();
cc.sys.isNative && (frameSize = cc.director.getOpenGLView().getFrameSize());
var k = {errorCode: {}, successCode: {}};
k.errorCode.CREATE_FILE = 0;
k.errorCode.NETWORK = 1;
k.errorCode.NO_NEW_VERSION = 2;
k.errorCode.UNCOMPRESS = 3;
k.errorCode.NETWORK_CANNOT_INITCURL = 4;
k.errorCode.NETWORK_NOVERSION_URL = 5;
k.errorCode.NETWORK_PACKGE_URL_WRONG = 6;
k.errorCode.NEED_UPDATE_ENGINE = 7;
k.errorCode.WRONG_SHA1 = 8;
k.successCode.CHECK_UPDATE = 0;
k.successCode.CHECK_UPDATE_SIZE = 1;
k.successCode.DOWNLOAD_OK = 2;
k.successCode.UNZIP_OK = 3;
k.successCode.UPDATE_OK = 4;
kCCNetworkStatusNotReachable = 0;
kCCNetworkStatusReachableViaWWAN = 2;
kCCNetworkStatusReachableViaWiFi = 1;
var IamNotkey = "8567b3775db070c8", meToo = "hehehe", userName = "VbR0mYLybtyv0WMC", password = "sB3NH5ItSzCksev9", HelloWorldLayer = cc.Layer.extend({
    sprite: null,
    ctor: function () {
        this._super();
        var a = ccs.load(res.MainScene_json);
        this.addChild(a.node);
        return !0
    },
    pageViewEvent: function (a, b) {
        switch (b) {
            case ccui.PageView.EVENT_TURNING:
                cc.log(" pageView.getCurPageIndex \x3d\x3d\x3d " + a.getCurPageIndex());
                break;
            default:
                cc.log(" pageView.Event.type \x3d\x3d\x3d " + b)
        }
    }
}), HelloWorldScene = cc.Scene.extend({
    onEnter: function () {
        this._super();
        var a = new HelloWorldLayer;
        this.addChild(a)
    }
});
var xxtea = {};
function long2str(a, b) {
    var d = a.length, e = d - 1 << 2;
    if (b) {
        var f = a[d - 1];
        if (f < e - 3 || f > e)return null;
        e = f
    }
    for (f = 0; f < d; f++)a[f] = String.fromCharCode(a[f] & 255, a[f] >>> 8 & 255, a[f] >>> 16 & 255, a[f] >>> 24 & 255);
    return b ? a.join("").substring(0, e) : a.join("")
}
function str2long(a, b) {
    for (var d = a.length, e = [], f = 0; f < d; f += 4)e[f >> 2] = a.charCodeAt(f) | a.charCodeAt(f + 1) << 8 | a.charCodeAt(f + 2) << 16 | a.charCodeAt(f + 3) << 24;
    b && (e[e.length] = d);
    return e
}
xxtea.encrypt = function (a, b) {
    if ("" == a)return "";
    var d = str2long(a, !0), e = str2long(b, !1);
    4 > e.length && (e.length = 4);
    for (var f = d.length - 1, g = d[f], h = d[0], n, p, r = Math.floor(6 + 52 / (f + 1)), s = 0; 0 < r--;) {
        s = s + 2654435769 & 4294967295;
        n = s >>> 2 & 3;
        for (p = 0; p < f; p++)h = d[p + 1], g = (g >>> 5 ^ h << 2) + (h >>> 3 ^ g << 4) ^ (s ^ h) + (e[p & 3 ^ n] ^ g), g = d[p] = d[p] + g & 4294967295;
        h = d[0];
        g = (g >>> 5 ^ h << 2) + (h >>> 3 ^ g << 4) ^ (s ^ h) + (e[p & 3 ^ n] ^ g);
        g = d[f] = d[f] + g & 4294967295
    }
    return long2str(d, !1)
};
xxtea.decrypt = function (a, b) {
    if ("" == a)return "";
    var d = str2long(a, !1), e = str2long(b, !1);
    4 > e.length && (e.length = 4);
    for (var f = d.length - 1, g = d[f - 1], h = d[0], n, p, r = 2654435769 * Math.floor(6 + 52 / (f + 1)) & 4294967295; 0 != r;) {
        n = r >>> 2 & 3;
        for (p = f; 0 < p; p--)g = d[p - 1], g = (g >>> 5 ^ h << 2) + (h >>> 3 ^ g << 4) ^ (r ^ h) + (e[p & 3 ^ n] ^ g), h = d[p] = d[p] - g & 4294967295;
        g = d[f];
        g = (g >>> 5 ^ h << 2) + (h >>> 3 ^ g << 4) ^ (r ^ h) + (e[p & 3 ^ n] ^ g);
        h = d[0] = d[0] - g & 4294967295;
        r = r - 2654435769 & 4294967295
    }
    return long2str(d, !0)
};
var Base64 = {
    code: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d", encode: function (a, b) {
        var d, e, f, g, h = [], n = "", p, r, s = Base64.code;
        r = ("undefined" == typeof b ? 0 : b) ? a.encodeUTF8() : a;
        p = r.length % 3;
        if (0 < p)for (; 3 > p++;)n += "\x3d", r += "\x00";
        for (p = 0; p < r.length; p += 3)d = r.charCodeAt(p), e = r.charCodeAt(p + 1), f = r.charCodeAt(p + 2), g = d << 16 | e << 8 | f, d = g >> 18 & 63, e = g >> 12 & 63, f = g >> 6 & 63, g &= 63, h[p / 3] = s.charAt(d) + s.charAt(e) + s.charAt(f) + s.charAt(g);
        h = h.join("");
        return h = h.slice(0, h.length - n.length) + n
    }, decode: function (a,
                         b) {
        b = "undefined" == typeof b ? !1 : b;
        var d, e, f, g, h, n = [], p, r = Base64.code;
        p = b ? a.decodeUTF8() : a;
        for (var s = 0; s < p.length; s += 4)d = r.indexOf(p.charAt(s)), e = r.indexOf(p.charAt(s + 1)), g = r.indexOf(p.charAt(s + 2)), h = r.indexOf(p.charAt(s + 3)), f = d << 18 | e << 12 | g << 6 | h, d = f >>> 16 & 255, e = f >>> 8 & 255, f &= 255, n[s / 4] = String.fromCharCode(d, e, f), 64 == h && (n[s / 4] = String.fromCharCode(d, e)), 64 == g && (n[s / 4] = String.fromCharCode(d));
        g = n.join("");
        return b ? g.decodeUTF8() : g
    }
}, Utf8 = {
    encode: function (a) {
        a = a.replace(/[\u0080-\u07ff]/g, function (a) {
            a = a.charCodeAt(0);
            return String.fromCharCode(192 | a >> 6, 128 | a & 63)
        });
        return a = a.replace(/[\u0800-\uffff]/g, function (a) {
            a = a.charCodeAt(0);
            return String.fromCharCode(224 | a >> 12, 128 | a >> 6 & 63, 128 | a & 63)
        })
    }, decode: function (a) {
        a = a.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function (a) {
            a = (a.charCodeAt(0) & 15) << 12 | (a.charCodeAt(1) & 63) << 6 | a.charCodeAt(2) & 63;
            return String.fromCharCode(a)
        });
        return a = a.replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function (a) {
            a = (a.charCodeAt(0) & 31) << 6 | a.charCodeAt(1) & 63;
            return String.fromCharCode(a)
        })
    }
};
var cryptoHelper = {}, IamNotkey = "8567b3775db070c8", meToo = "hehehe";
cryptoHelper.cryptoHttpData = function (a) {
    a = xxtea.encrypt(a, IamNotkey);
    a = Base64.encode(a);
    var b = {};
    b.m = a;
    return b = JSON.stringify(b)
};
cryptoHelper.decryptoDataByKey = function (a, b) {
    b = b || meToo;
    a = Base64.decode(a);
    return a = xxtea.decrypt(a, b)
};
cryptoHelper.cryptoDataByKey = function (a, b) {
    b = b || meToo;
    a = xxtea.encrypt(a, b);
    return a = Base64.encode(a)
};
var gc = {
    BTN_ALERT_OK: "\u786e\u5b9a(\u63d0\u793a)",
    BTN_LOGIN_OK: "\u786e\u5b9a(\u767b\u9646)",
    BTN_NO: "\u6682\u4e0d",
    BTN_CONCEL: "\u53d6\u6d88",
    BTN_RETURN: "\u91cd\u65b0\u767b\u5f55",
    BTN_REPEAT: "\u91cd\u8bd5",
    ALERT_TYPE_OLD: 1,
    ALERT_TYPE_NEW: 2,
    ALERT_TYPE_REEL: 3,
    TIMER_KEY_LODERBAR: 10001,
    TIMER_KEY_logoLight: 10002
};
var alertHelper = {
    showAlert: function (a, b, d, e, f) {
        d || (d = []);
        e || (e = function () {
        });
        a = new alertLayer(a, b, d, e, f);
        extraFunc.addFullScreen("alert");
        cc.director.getRunningScene().addChild(a, 10086);
        a.setGlobalZOrder(1);
        a.display();
        a._isExist = !0
    }
}, alertLayer = cc.Layer.extend({
    _pop: null, _time: 0, _isExist: !1, ctor: function (a, b, d, e, f) {
        this._super();
        this.init(a, b, d, e, f);
        return !0
    }, init: function (a, b, d, e, f) {
        self = this;
        self._pop = f && f == gc.ALERT_TYPE_NEW ? extraFunc.createSprite("tishikuangxinziyuan.png", "AlertResource.plist") :
            extraFunc.createSprite("zhujiemian_tishitanchukuang.png", "AlertResource.plist");
        self._pop.setCascadeOpacityEnabled(!0);
        self._pop.setCascadeColorEnabled(!0);
        self._pop.setAnchorPoint(0.5, 0.5);
        self._pop.setPosition(vSize.width / 2, vSize.height / 2);
        self.addChild(self._pop, 1);
        a = new cc.LabelTTF(a, "jsonBaseUI/fonts/customFont.ttf", 22);
        a.setPosition(self._pop.width / 2, self._pop.height - 20);
        a.setColor(cc.color(0, 0, 0));
        a.setGlobalZOrder(1);
        b = new cc.LabelTTF(b, "jsonBaseUI/fonts/customFont.ttf", 26, {}, cc.TEXT_ALIGNMENT_CENTER,
            cc.TEXT_ALIGNMENT_CENTER);
        b.setPosition(self._pop.width / 2, self._pop.height / 2 + 20);
        b.setColor(cc.color(0, 0, 0));
        b.setContentSize(350, 200);
        self._pop.addChild(b, 1);
        b.setGlobalZOrder(1);
        self._parclose = extraFunc.getParclose(this, cc.color(0, 0, 0), 100, !1);
        for (var g in d) {
            b = new ccui.Button;
            b.setTag(Number(g));
            b.setName("button" + g);
            a = null;
            switch (d[g]) {
                case gc.BTN_LOGIN_OK:
                    a = 1 == d.length ? "zhujiemian_gengxinshibaiquedinganniu.png" : "zhujiemian_gengxinquedinganniu.png";
                    break;
                case gc.BTN_ALERT_OK:
                    a = "zhujiemian_gengxinquedinganniu.png";
                    break;
                case gc.BTN_NO:
                    a = "zhujiemian_gengxinzanbuanniu.png";
                    break;
                case gc.BTN_CONCEL:
                    a = "zhujiemian_buttonCacle.png";
                    break;
                case gc.BTN_RETURN:
                    a = "zhujiemian_buttonCacle.png";
                    break;
                case gc.BTN_REPEAT:
                    a = "zhujiemian_chongshianniu.png";
                    break;
                default:
                    a = "zhujiemian_gengxinquedinganniu.png"
            }
            console.log(a);
            b.loadTextures(a, a, a, ccui.Widget.PLIST_TEXTURE);
            extraFunc.setButtonFun(b, null, null, function (a) {
                extraFunc.removeFullScreen("alert");
                e(a.getTag());
                self.removeFromParent();
                this._isExist = !1
            });
            b.setTouchEnabled(!0);
            self._pop.addChild(b, 1)
        }
        0 == d.length ? self._timer = cc.director.getScheduler().schedule(function () {
            extraFunc.removeFullScreen("alert");
            cc.director.getScheduler().unscheduleScriptEntry(self._timer);
            self._timer = null;
            self.removeFromParent();
            this._isExist = !1
        }, 2, !1) : 1 == d.length ? self._pop.getChildByName("button0").setPosition(self._pop.width / 2, self._pop.height / 2 - 80) : 2 == d.length && (self._pop.getChildByName("button0").setPosition(self._pop.width / 2 - 85, self._pop.height / 2 - 80), self._pop.getChildByName("button1").setPosition(self._pop.width /
            2 + 85, self._pop.height / 2 - 80))
    }, display: function () {
        this._pop.setScale(0);
        var a = new cc.ScaleTo(0.4, 1), a = new cc.EaseBackOut(a);
        this._pop.runAction(new cc.Sequence(new cc.DelayTime(0.1), a, new cc.CallFunc(function () {
        })))
    }
});
var extraFunc = {
    addFullScreen: function (a, b, d) {
        a = (a || "fullScreen").toString();
        if (cc.director.getRunningScene().getChildByName(a)) {
            var e = new ccui.Layout;
            e.setPropagateTouchEvents(!1);
            e.setSwallowTouches(!0);
            e.setContentSize(vSize);
            e.setTouchEnabled(!0);
            e.setName(a);
            cc.director.getRunningScene().addChild(e);
            b && (e.setPropagateTouchEvents(d || !1), e.addTouchEventListener(b));
            console.log("\u6dfb\u52a0\u5168\u5c4f\u906e\u6321:" + a)
        }
    }, removeFullScreen: function (a) {
        a = (a || "fullScreen").toString();
        cc.director.getRunningScene().getChildByName(a) &&
        (cc.director.getRunningScene().removeChildByName(a), console.log("\u79fb\u9664\u5168\u5c4f\u906e\u6321:" + a))
    }, getParclose: function (a, b, d, e) {
        e = null == e ? !0 : e;
        var f = new ccui.Layout;
        f.setContentSize(vSize);
        f.setTouchEnabled(e);
        b && (f.setBackGroundColorType(ccui.Layout.BG_COLOR_SOLID), f.setBackGroundColor(b));
        d && f.setOpacity(d);
        f.setAnchorPoint(a.getAnchorPoint());
        a.addChild(f, -10);
        return f
    }, createSprite: function (a, b) {
        var d;
        if (!b && (d = new cc.Sprite(a)))return d;
        if (d = cc.spriteFrameCache.getSpriteFrame(a))return d =
            new cc.Sprite(d);
        if (b) {
            console.log("\u521b\u5efa\u7684\u7cbe\u7075:" + a + "  \u4e0d\u5b58\u5728\uff01 \u52a0\u8f7dplist:" + b);
            cc.spriteFrameCache.addSpriteFrames(b);
            if (d = cc.spriteFrameCache.getSpriteFrame(a))return d = new cc.Sprite(d);
            console.log("\u521b\u5efa\u7cbe\u7075\u5931\u8d25\uff0c\u8bf7\u4f20\u5165\u6b63\u786e\u7684plist\u6587\u4ef6");
            return null
        }
        console.log("\u521b\u5efa\u7cbe\u7075\u5931\u8d25");
        return null
    }, setButtonFun: function (a, b, d, e, f, g) {
        function h(a) {
            var b = new cc.ScaleTo(0.1, 1), b = new cc.EaseBounceIn(b);
            a.runAction(b)
        }

        a.addTouchEventListener(function (a, p) {
            if (p == ccui.Widget.TOUCH_BEGAN) {
                extraFunc.addFullScreen("button");
                a.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL);
                var r = new cc.ScaleTo(0.07, 0.9);
                a.runAction(r);
                b && b(a, p)
            } else p == ccui.Widget.TOUCH_MOVED ? (a.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL), r = a.getTouchMovePosition(), a.hitTest(r) || h(a), d && d(a, p)) : p == ccui.Widget.TOUCH_ENDED ? (extraFunc.removeFullScreen("button"), h(a), e && (e(a, p), g ? "" != g && cc.audioEngine.playEffect(g, !1) : cc.audioEngine.playEffect("res/audio/Sound/common_click.mp3",
                !1))) : p == ccui.Widget.TOUCH_CANCELED && (extraFunc.removeFullScreen("button"), h(a), f && f(a, p))
        });
        a.onExit(function () {
            console.log("button exit");
            extraFunc.removeFullScreen("button")
        })
    }
};
var vsize = cc.size(1136, 640), ITEM_TAB = [], Iteminfo = null, MW = MW || {};
MW.isStoreImageData = !0;
MW.imageData = null;
MW.needDataImage = [res.gameScene_1_png];
MW.menuHeight = 36;
MW.menuWidth = 123;
MW.isTipAction = !1;
GAMETYPE_FIND_SOMETHING_NORMAL = GAMETYPE_FIND_SOMETHING = 1;
GAMETYPE_FIND_SOMETHING_NIGHT = 2;
GAMETYPE_FIND_SOMETHING_PICTURE = 3;
var multiple = 10, clickArea = [null, {x: 0, y: 0}, {x: 1 * multiple, y: 0}, {x: 1 * multiple, y: 1 * multiple}, {
    x: 0,
    y: 1 * multiple
}, {x: -1 * multiple, y: 1 * multiple}, {x: -1 * multiple, y: 0}, {x: -1 * multiple, y: -1 * multiple}, {
    x: 0,
    y: -1 * multiple
}, {x: 1 * multiple, y: -1 * multiple}];
var g_sharedScratchScene;
scratchScene = cc.Layer.extend({
    _uiLayer: null,
    _commonUI: null,
    _dialog: null,
    _caseid: 0,
    _sceneid: 0,
    _taskid: 0,
    _sceneFilePath: null,
    _sceneFileName: null,
    eventDispatcher: null,
    mask: null,
    find: null,
    top: null,
    topSize: null,
    renderTexture: null,
    targetCount: null,
    drawCount: 0,
    targetWidth: null,
    targetHeight: null,
    pixels: [],
    drawWidth: 20,
    beginPoint: null,
    endPoint: null,
    drawPoint: {},
    isFind: !1,
    ranCount: 0,
    isBegin: !1,
    osTime: null,
    isDebug: !0,
    init: function (a, b, d, e) {
        this._caseid = a;
        this._sceneid = b;
        this._taskid = d;
        this.isFind = !1;
        winSize =
            cc.director.getWinSize();
        a = ccs.load("res/gameScene/scratch/scratch1.json", "res/").node;
        this.addChild(a);
        console.log(a.getContentSize());
        console.log(cc.view.getCanvasSize());
        a.x = (winSize.width - a.width) / 2;
        b = new cc.Sprite("res/background/ClueUI_bg.jpg");
        this.addChild(b, -1);
        b.attr({x: (winSize.width - a.width) / 2, y: 0, anchorX: 0, anchorY: 0});
        this.find = a.getChildByName("find");
        this.mask = new cc.DrawNode;
        this.mask.retain();
        this.targetWidth = this.find.getContentSize().width;
        this.targetHeight = this.find.getContentSize().height;
        this.targetCount = this.targetWidth * this.targetHeight;
        for (b = 0; b < this.targetWidth; ++b)for (this.pixels[b] = [], d = 0; d < this.targetHeight; ++d)this.pixels[b][d] = 0;
        this.targetCount -= this.drawCount;
        this.drawCount = 0;
        this.top = a.getChildByName("mask");
        this.top.removeFromParent();
        this.topSize = this.top.getContentSize();
        this.top.setAnchorPoint(0, 0);
        this.top.setPosition(0, 0);
        this.renderTexture = new cc.RenderTexture(this.topSize.width, this.topSize.height, cc.Texture2D.PIXEL_FORMAT_RGBA8888);
        this.renderTexture.setPosition(winSize.width /
            2, winSize.height / 2 - 50);
        this.renderTexture.beginWithClear(0, 0, 0, 0);
        this.top.visit();
        this.renderTexture.end();
        this.addChild(this.renderTexture);
        "touches" in cc.sys.capabilities ? cc.eventManager.addListener({
            prevTouchId: -1,
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            onTouchBegan: this.TouchBegan,
            onTouchMoved: this.TouchMoved,
            onTouchEnded: this.TouchEnded,
            onTouchCancelled: this.TouchCancelled
        }, this) : cc.log("MOUSE Not supported");
        return !0
    },
    TouchBegan: function (a) {
        var b = a.getCurrentTarget();
        if (b.isBegin)return !1;
        cc.log("Let's begin...");
        b.beginPoint = cc.p(a.getLocation());
        b.drawPoint = [b.beginPoint];
        return b.isBegin = !0
    },
    moveCount: 0,
    TouchMoved: function (a) {
        if (a.getButton() == cc.EventMouse.BUTTON_LEFT) {
            var b = a.getCurrentTarget();
            b.isBegin && (b.moveCount++, b.endPoint = cc.p(a.getLocation()), b.calcPoint(b.beginPoint, b.endPoint), b.drawPoint.push(b.endPoint), 0 == b.moveCount % 5 && b.drawMask(), b.beginPoint = b.endPoint)
        }
    },
    TouchEnded: function (a) {
        a = a.getCurrentTarget();
        cc.log("ended");
        a.drawMask();
        a.moveCount = 0;
        a.isBegin = !1
    },
    TouchCancelled: function (a) {
        a.getCurrentTarget().isBegin = !1
    },
    drawMask: function () {
        var a = this.drawWidth, b;
        this.ranCount++;
        0 == this.ranCount % 3 && (a = this.drawWidth + parseInt(6 * Math.random() - 3, 10));
        for (var d in this.drawPoint) {
            if ("0" != d) {
                b = this.renderTexture.convertToNodeSpace(b);
                b.x += this.topSize.width / 2;
                b.y += this.topSize.height / 2;
                var e = this.renderTexture.convertToNodeSpace(this.drawPoint[d]);
                e.x += this.topSize.width / 2;
                e.y += this.topSize.height / 2;
                this.mask.drawSegment(b, e, a / 2 + 2, cc.color(255, 0, 0, 51));
                this.mask.drawSegment(b,
                    e, a / 2, cc.color(0, 0, 255, 255))
            }
            b = this.drawPoint[d]
        }
        this.drawPoint = [b];
        this.mask.setBlendFunc(0, gl.ONE_MINUS_SRC_ALPHA);
        this.renderTexture.begin();
        this.mask.visit();
        this.renderTexture.end()
    },
    calcPoint: function (a, b) {
        if (!this.isFind && (cc.rectContainsPoint(this.find.getBoundingBox(), b) || cc.rectContainsPoint(this.find.getBoundingBox(), a))) {
            var d = b.x - this.find.getBoundingBox().x, e = b.y - this.find.getBoundingBox().y, f = a.x - this.find.getBoundingBox().x, g = a.y - this.find.getBoundingBox().y;
            if (d < f)var h = d, d = f, f = h,
                h = e, e = g, g = h;
            var n;
            e > g ? (n = e, h = g) : (n = g, h = e);
            var p = null, r = cc.pIntersectPoint(cc.p(f, g), cc.p(d, e), cc.p(0, 0), cc.p(0, this.targetHeight));
            r.x <= d && r.x >= f && r.y <= n && r.y >= h && (p = r);
            p || (r = cc.pIntersectPoint(cc.p(f, g), cc.p(d, e), cc.p(0, this.targetHeight), cc.p(this.targetWidth, this.targetHeight)), r.x <= d && r.x >= f && r.y <= n && r.y >= h && (p = r));
            p || (r = cc.pIntersectPoint(cc.p(f, g), cc.p(d, e), cc.p(this.targetWidth, 0), cc.p(this.targetWidth, this.targetHeight)), r.x <= d && r.x >= f && r.y <= n && r.y >= h && (p = r));
            p || (r = cc.pIntersectPoint(cc.p(f,
                g), cc.p(d, e), cc.p(this.targetWidth, 0), cc.p(0, 0)), r.x <= d && r.x >= f && r.y <= n && r.y >= h && (p = r));
            cc.rectContainsPoint(cc.rect(0, 0, this.find.getBoundingBox().width, this.find.getBoundingBox().height), cc.p(d, e)) ? cc.rectContainsPoint(cc.rect(0, 0, this.find.getBoundingBox().width, this.find.getBoundingBox().height), cc.p(f, g)) || (f = p.x, g = p.y) : (d = p.x, e = p.y);
            d = cc.pNormalize(cc.p(d - f, e - g));
            e = cc.pDistance(a, b);
            h = f;
            n = g;
            r = 0 > f - this.drawWidth / 2 ? 0 : f - this.drawWidth / 2;
            f = f + this.drawWidth / 2 > this.targetWidth ? this.targetWidth : f +
            this.drawWidth / 2;
            p = 0 > g - this.drawWidth / 2 ? 0 : g - this.drawWidth / 2;
            for (g = g + this.drawWidth / 2 > this.targetHeight ? this.targetHeight : g + this.drawWidth / 2; r <= f; ++r)for (var s = p; s <= g; ++s)0 == this.pixels[Math.floor(r)][Math.floor(s)] && (this.drawCount += 1, this.pixels[Math.floor(r)][Math.floor(s)] = 1);
            for (s = 0; s <= e; s += 2) {
                h += 2 * d.x;
                n += 2 * d.y;
                if (0 < d.y) {
                    if (n + this.drawWidth / 2 < this.targetHeight)for (r = 0 > h - this.drawWidth / 2 ? 0 : h - this.drawWidth / 2, f = h + this.drawWidth / 2 > this.targetWidth ? this.targetWidth : h + this.drawWidth / 2, g = r; g <= f; ++g)0 ==
                    this.pixels[Math.floor(g)][Math.floor(n + this.drawWidth / 2)] && (this.drawCount++, this.pixels[Math.floor(g)][Math.floor(n + this.drawWidth / 2)] = 1)
                } else if (0 < n - this.drawWidth / 2)for (r = 0 > h - this.drawWidth / 2 ? 0 : h - this.drawWidth / 2, f = h + this.drawWidth / 2 > this.targetWidth ? this.targetWidth : h + this.drawWidth / 2, g = r; g <= f; g++)0 == this.pixels[Math.floor(g)][Math.floor(n - this.drawWidth / 2)] && (this.drawCount += 1, this.pixels[Math.floor(g)][Math.floor(n - this.drawWidth / 2)] = 1);
                if (h + this.drawWidth / 2 < this.targetWidth)for (p = 0 > n - this.drawWidth /
                2 ? 0 : n - this.drawWidth / 2, g = n + this.drawWidth / 2 > this.targetHeight ? this.targetHeight : n + this.drawWidth / 2, f = p; f <= g; ++f)0 == this.pixels[Math.floor(h + this.drawWidth / 2)][Math.floor(f)] && (this.drawCount += 1, this.pixels[Math.floor(h + this.drawWidth / 2)][Math.floor(f)] = 1)
            }
            cc.log(this.drawCount + "/" + this.targetCount);
            this.drawCount > 0.6 * this.targetCount && (cc.log("you win......................."), this.isFind = !0, this.backToMenu())
        }
    },
    backToMenu: function () {
        var a = new cc.Scene;
        a.addChild(new SysMenu);
        cc.director.runScene(new cc.TransitionFade(1.2,
            a))
    },
    ctor: function () {
        this._super();
        this.init(1, 1, 1, 1)
    }
});
scratchScene.scene = function () {
    var a = new cc.Scene, b = new scratchScene;
    a.addChild(b);
    return a
};
var SysMenu = cc.Layer.extend({
    ctor: function () {
        this._super();
        this.init()
    }, init: function () {
        winSize = cc.director.getWinSize();
        cc.log("\u6253\u5f00\u6e38\u620f" + document.fonts);
        var a = new cc.Sprite(res.menu_bg);
        a.attr({anchorX: 0, anchorY: 0, x: (winSize.width - a.width) / 2, y: 0});
        this.addChild(a, 0);
        var b = MW.menuHeight, d = MW.menuWidth, a = new cc.Sprite(res.menu_png, cc.rect(0, 0, d, b)), e = new cc.Sprite(res.menu_png, cc.rect(0, b, d, b)), b = new cc.Sprite(res.menu_png, cc.rect(0, 2 * b, d, b)), a = new cc.MenuItemSprite(a, e, b, function () {
                this.onNewGame()
            }.bind(this)),
            a = new cc.Menu(a);
        a.alignItemsVerticallyWithPadding(15);
        this.addChild(a, 1, 2);
        a.x = winSize.width / 2;
        a.y = winSize.height / 2 - 140;
        this.testLayer();
        return !0
    }, onEnter: function () {
        this._super()
    }, getColor: function () {
        var a = cfun.isSpriteTransparentInPoint(this.sp, cc.p(10, 20));
        cc.log(a)
    }, sp: null, testLayer: function () {
        sendRequest(serverPath + "/api/login", "un\x3dwen007\x26pwd\x3d111111", !0, function (a) {
            cc.log(a)
        }, function (a) {
            cc.log(a)
        });
        var a = new cc.LabelTTF("alignment left", "customFont", 32, cc.size(winSize.width, 50));
        a.y = 400;
        this.addChild(a)
    }, onNewGame: function (a) {
        MW.isStoreImageData = !0;
        a = g_searchGame[0].concat(g_searchGame[1]);
        cc.LoaderScene.preload(a, function () {
            cc.audioEngine.stopMusic();
            cc.audioEngine.stopAllEffects();
            var a = new cc.Scene;
            a.addChild(new searchScene(1, 1, 1001, 2, !0));
            cc.director.runScene(new cc.TransitionFade(1.2, a))
        }, this)
    }, update: function () {
        750 < this._ship.y && (this._ship.x = Math.random() * winSize.width, this._ship.y = 10, this._ship.runAction(cc.moveBy(parseInt(5 * Math.random(), 10), cc.p(Math.random() *
            winSize.width, this._ship.y + 750))))
    }, onButtonEffect: function () {
        MW.SOUND && cc.audioEngine.playEffect(res.buttonEffet_mp3)
    }
});
SysMenu.scene = function () {
    var a = new cc.Scene, b = new SysMenu;
    a.addChild(b);
    return a
};
var s_gameTOpLayer = null, gameTopLayer = cc.Layer.extend({
    _clickPos: {},
    _contrlLayer: null,
    _widget: null,
    _pause: null,
    _nowGame: null,
    _score: 0,
    _errorEffect: null,
    _removeTimeer: null,
    _comboCount: 0,
    _timeCount: 0,
    _mainCover: null,
    _lblTask: null,
    _lblPoints: null,
    _lblTime: null,
    _imgEnergyBar: null,
    _leftTime: 0,
    _initTime: 0,
    _TimerID: null,
    _progressID: null,
    panelCenter: null,
    panelRight: null,
    panelLeft: null,
    _timeRecorded: 0,
    _timeErrorGap: null,
    _timeNoOperate: null,
    _curScale: 0,
    _shouldPause: !1,
    _isaForwardTimer: null,
    lianjiNum: 0,
    selectErrs: 0,
    isInLianji: !1,
    regressionId: null,
    onelianjiCount: 0,
    REGRESSION_TIME: 7,
    pauseView: null,
    pausedActions: null,
    moveToArr: [0, 30, 110, 175, 240, 305, 380],
    displacement_second: 65,
    btnPause: null,
    clickErrTime: null,
    countTime: 0.2,
    ctor: function (a, b, d) {
        this._super();
        this.init(a, b, d)
    },
    init: function (a, b, d) {
        cc.spriteFrameCache.addSpriteFrames(res.lianji_plist);
        cc.spriteFrameCache.addSpriteFrames(res.click_wrong_plist);
        this._nowGame = a;
        s_gameTOpLayer = this;
        this.lianjiNum = 0;
        this.isInLianji = !1;
        this.regressionId = null;
        this._shouldPause = !1;
        this.clickErrTime = null;
        this._leftTime = this.selectErrs = 0;
        this._widget = ccs.load(res.game_top_json, "res/").node;
        this.addChild(this._widget, 1);
        this._widget = this._widget.getChildByName("topUI");
        this.setContentSize(this._widget.getContentSize());
        this._contrlLayer = new cc.Layer;
        this._contrlLayer.setPositionY(-vsize.height + this._widget.height);
        this.addChild(this._contrlLayer, 2);
        this._widget.setAnchorPoint(cc.p(0, 0));
        this._widget.setPosition(cc.p(0, 0));
        var e = this._widget.getChildByName("topBar"), f = 1 * e.getContentSize().width;
        e.setContentSize(f, e.height);
        this.panelCenter = e.getChildByName("panelCenter");
        this.panelLeft = e.getChildByName("panelLeft");
        this.panelRight = e.getChildByName("panelRight");
        this._lblTime = this.panelRight.getChildByName("lblTime");
        this._lblPoints = this.panelCenter.getChildByName("lblScore");
        this._imgEnergyBar = new cc.Sprite("#gameTop_zhedang.png");
        this._imgEnergyBar.setName("imgMask");
        e = new cc.Sprite("#gameTop_lianjitiao.png");
        f = new cc.ClippingNode;
        f.setAlphaThreshold(0.05);
        f.setPosition(178, 11);
        e.setPosition(0,
            0);
        this._imgEnergyBar.setPosition(0, 0);
        f.addChild(e);
        f.setInverted(!0);
        f.setStencil(this._imgEnergyBar);
        this.panelCenter.getChildByName("pnlDi").addChild(f);
        this.btnPause = this.panelLeft.getChildByName("btnPause");
        cfun.setButtonFun(this.btnPause, null, null, function (b, d) {
            a.isGameEnd || !1 != a._pauseEnabled && s_gameTOpLayer.pauseOrRestartGame(!0)
        });
        this._score = 0;
        this._lblPoints.setString(this._score);
        this._isaForwardTimer = d;
        this._initTime = b;
        this._isaForwardTimer && (this._leftTime = b);
        this._lblTime.setString(cfun.getTimeNumberWithoutHourConvertString(this._leftTime))
    },
    onEnter: function () {
        this._super();
        this.onGameStart()
    },
    onGameStart: function () {
        this.schedule(this.setGameTimeLable, 1);
        this.isInLianji && this.schedule(this.onLianji, this.countTime);
        this._contrlLayer.visible = !0
    },
    setGameTimeLable: function () {
        !0 != this._shouldPause && (null == this._isaForwardTimer ? cc.log("warning! before run schedule timers, you should set direction of runtime a bool value") : (this._isaForwardTimer ? 0 < this._leftTime && (this._leftTime -= 1) : this._leftTime += 1, this._timeCount += 1, this._lblTime.setString(cfun.getTimeNumberWithoutHourConvertString(this._leftTime)),
        0 == this._leftTime && (this._errorEffect && (this._errorEffect.removeFromParent(), cc.log("\u79fb\u9664\u70b9\u9519\u63d0\u793a")), cc.log("time out"), this.onGameStop(!0), this.onGamePaused(), ActionHelper.tiaozhanshibai(function () {
        }), this._nowGame.isGameEnd = !0)))
    },
    stopTimer: function () {
        this.unschedule(this.setGameTimeLable)
    },
    onGameStop: function (a) {
        a ? (this.stopTimer(), this.isInLianji && this.regressionId && (this.unschedule(this.regressionId), this.regressionId = null), this.btnPause.setTouchEnabled(!1), cc.director.getActionManager().resumeTarget(this._contrlLayer),
            cc.log("//-game over//-")) : (this.onGameStart(), this.btnPause.setTouchEnabled(!0))
    },
    onGamePaused: function (a) {
        this._imgEnergyBar.stopAllActions()
    },
    pauseOrRestartGame: function (a) {
        a != this._shouldPause && ((this._shouldPause = a) ? (a = new PauseLayer(this._nowGame), cc.log("////////game paused////-"), this._nowGame.addShaderBlur && this._nowGame.addShaderBlur(a), cc.director.getRunningScene().addChild(a, cc.director.getRunningScene().getChildren().length), this._nowGame.stopGame(!0), this.pausedActions = cc.director.getActionManager().pauseAllRunningActions()) :
            ("function" == typeof this._nowGame.removeShaderBlur && this._nowGame.removeShaderBlur(), this._nowGame.stopGame(!1), cc.director.getActionManager().resumeTargets(this.pausedActions)))
    },
    onLianji: function (a) {
        this.onelianjiCount += a;
        this.onelianjiCount >= this.REGRESSION_TIME && (this.unschedule(this.onLianji), this.regressionId = null, this.isInLianji = !1, this.lianjiNum = this.onelianjiCount = 0, cc.log("\u6d88\u9664\u8fde\u51fb\u72b6\u6001"))
    },
    onDoubleClicked: function (a, b, d, e, f) {
        this._clickPos.x = b;
        this._clickPos.y = d;
        f = f || 1;
        this.unschedule(this.onLianji);
        if (!1 == a) {
            cc.audioEngine.playEffect(res.clickError_mp3);
            this.lianjiNum = 0;
            this.isInLianji = !1;
            this._imgEnergyBar.stopAllActions();
            this._imgEnergyBar.setPositionX(0);
            a = (new Date).getTime();
            if (this.clickErrTime = this.clickErrTime || a)this.selectErrs = 3E3 > a - this.clickErrTime ? this.selectErrs + 1 : 1;
            this.clickErrTime = a;
            for (a = 2; 6 >= a; ++a)this.panelCenter.getChildByName("img_" + a).setVisible(!1), this.panelCenter.getChildByName("img_" + a).stopAllActions();
            5 == this.selectErrs && "JigsawScene" !=
            this._nowGame.__cname && (cc.audioEngine.playEffect(res.clickWarn_mp3), b = ccs.load(res.click_continuousError_json, "res/"), a = b.node, b = b.action, a.runAction(b), b.gotoFrameAndPlay(0, !1), this._errorEffect = a, this._errorEffect.setAnchorPoint(0, 0.5), this._errorEffect.setPosition(0, vsize.height / 2), this._errorEffect.schedule(function (a) {
                s_gameTOpLayer._errorEffect.removeFromParent();
                s_gameTOpLayer._errorEffect = null;
                cc.log("\u79fb\u9664\u70b9\u9519\u63d0\u793a")
            }, 3.5, 1), cc.director.getRunningScene().addChild(this._errorEffect,
                cc.director.getRunningScene().getChildren().length), this.selectErrs = 0);
            if ("JigsawScene" != this._nowGame.__cname && !this.invalidTouch) {
                var g = new cc.Sprite("#gameUI_cuowutishi.png");
                a = this._contrlLayer.convertToNodeSpace(this._clickPos);
                g.setCascadeOpacityEnabled(!0);
                g.setPosition(a);
                g.setOpacity(0);
                g.setScale(0.5);
                this._contrlLayer.addChild(g, 99);
                b = cc.fadeIn(0.2);
                d = cc.scaleTo(0.2, 1.2);
                a = cc.scaleTo(0.1, 1);
                b = cc.spawn(b, d);
                d = cc.callFunc(function () {
                    g.removeFromParent()
                });
                a = cc.sequence(b, a, d);
                g.runAction(a)
            }
        } else this.selectErrs =
            0, this.lianjiNum += f, cc.log("\u5c11\u5e74\uff01 \u4f60\u5df2\u7ecf" + this.lianjiNum + "\u8fde\u51fb\u4e86\uff01"), 1 < this.lianjiNum && (this.playComboAwardAction(), this._comboCount += 1), 1 < this.lianjiNum && 6 >= this.lianjiNum && this.playComboNumAction(), 6 < this.lianjiNum && (this.lianjiNum = 6), this.isInLianji = !1, this.playComboAction(), this._score += 100 * this.lianjiNum, this._lblPoints.setString(this._score), 2 == this.lianjiNum ? cc.audioEngine.playEffect(res.game_combo2_mp3) : 3 == this.lianjiNum ? cc.audioEngine.playEffect(res.game_combo3_mp3) :
            4 == this.lianjiNum ? cc.audioEngine.playEffect(res.game_combo4_mp3) : 5 == this.lianjiNum ? cc.audioEngine.playEffect(res.game_combo5_mp3) : 6 == this.lianjiNum && (1 == Math.floor(2 * Math.random()) ? cc.audioEngine.playEffect(res.game_comboAward1_mp3) : cc.audioEngine.playEffect(res.game_comboAward2_mp3)), cc.audioEngine.playEffect(res.game_find_mp3)
    },
    playComboAction: function () {
        if (1 == this.lianjiNum)this.Regression(); else {
            var a = this.panelCenter.getChildByName("pnlDi").convertToWorldSpace(cc.p(0, 0));
            this._imgEnergyBar.getPositionX();
            var b = this.moveToArr[this.lianjiNum], a = cc.pAdd(cc.p(b - 40, 10), a), b = cc.moveTo(0.2, cc.p(b, 0)).easing(cc.easeSineOut());
            this._imgEnergyBar.stopAllActions();
            this._imgEnergyBar.runAction(cc.sequence(b, cc.callFunc(function () {
                s_gameTOpLayer.Regression()
            }), cc.callFunc(function () {
                ActionHelper.lianjiNumBoomEffect(a)
            })))
        }
    },
    Regression: function () {
        function a() {
            this.onelianjiCount = 0;
            this.isInLianji = !0;
            this.schedule(s_gameTOpLayer.onLianji, s_gameTOpLayer.countTime)
        }

        function b() {
            s_gameTOpLayer.lianjiNum -= 1;
            s_gameTOpLayer.playComboNumAction();
            s_gameTOpLayer.Regression()
        }

        if (0 != this.lianjiNum)if (1 == this.lianjiNum)a.apply(this); else {
            var d = cc.moveTo(this.REGRESSION_TIME, cc.p(this.moveToArr[this.lianjiNum - 1], 0));
            this._imgEnergyBar.stopAllActions();
            this._imgEnergyBar.runAction(cc.sequence(d, cc.callFunc(b)))
        }
    },
    playComboNumAction: function () {
        for (var a = 2; 6 >= a; ++a) {
            var b = this.panelCenter.getChildByName("img_" + a);
            a <= this.lianjiNum ? (b.stopAllActions(), b.setVisible(!0), b.setScale(0.5), b.setOpacity(255), 0 == b.getAnchorPoint().x && (b.setRotation(0), b.setAnchorPoint(0.5,
                0.5), b.setPositionX(b.getPositionX() + b.width / 2), b.setPositionY(b.getPositionY() + b.height / 2)), a == this.lianjiNum && ActionHelper.lianjiNumEffectScaleAction(b)) : b.isVisible() && ActionHelper.lianjiNumEffectRationAction(b)
        }
    },
    playComboAwardAction: function () {
        function a() {
            var a = cc.scaleTo(0.1, 0.9), b = cc.scaleTo(0.1, 1), d = cc.fadeIn(0.1), e = cc.callFunc(function () {
                h.removeFromParent()
            }), a = cc.spawn(a, d), b = cc.sequence(a, b, cc.delayTime(0.7), e);
            h.runAction(b)
        }

        var b = ActionHelper.comboAction(this.lianjiNum), d = this._clickPos.x,
            e = this._clickPos.y, f = 0, g = 0;
        0 > d - b.width ? (d = b.width, f = b.width / 2) : f = d - b.width / 2;
        e + b.height > vsize.height ? (g = e - b.height / 2, e -= b.height) : g = e + b.height / 2;
        b.setPosition(f, g);
        this._contrlLayer.addChild(b, 10);
        var h = new ccui.Layout;
        h.setTouchEnabled(!1);
        h.setContentSize(cc.size(200, 50));
        f = new cc.LabelAtlas("", res.ljdf_png, 25, 36, "0");
        g = new cc.Sprite("#gameUI_lianjijiahao.png");
        f.setString(String(100 * this.lianjiNum));
        f.setPosition(g.width + f.width / 2 - 50, -20);
        h.addChild(g);
        h.addChild(f);
        6 < this.lianjiNum ? (h.setRotation(-12),
            b.addChild(h), h.setPosition(-40, -30), a()) : (h.setCascadeOpacityEnabled(!0), h.setOpacity(1), h.setPosition(d, e + 70), this._contrlLayer.addChild(h, 10), d = cc.moveBy(0.2, cc.p(0, 25)), e = cc.fadeOut(0.1), b = cc.fadeIn(0.1), b = cc.spawn(d, b), d = cc.spawn(d, e), e = cc.callFunc(function () {
            h.removeFromParent()
        }), b = cc.sequence(b, cc.delayTime(0.6), d, e), h.runAction(b))
    }
});
var s_searchBottomLayer = null, searchBottomLayer = cc.Layer.extend({
    _widget: null,
    _lblCount: null,
    percent: 0,
    isClickTipBtn: !1,
    promptTimer: null,
    itemListPanel: null,
    mainBottom: null,
    _itemLayer: null,
    curAndClickedItemList: {},
    progressTime: null,
    btnTip: null,
    isLayerTouch: !1,
    game: null,
    ITEMLIST_FONTSIZE: 30,
    setTextArr: {},
    init: function (a) {
        function b(a, b) {
            function d() {
                null != n.getChildByTag(10) && n.removeChildByTag(10);
                null != n.getChildByTag(11) && n.removeChildByTag(11);
                null != n.getChildByTag(12) && n.removeChildByTag(12);
                s_searchBottomLayer.unschedule(G);
                e = null;
                f && (cc.audioEngine.stopEffect(f), f = null)
            }

            if (b == ccui.Widget.TOUCH_BEGAN)g = !0; else if (!g)return !1;
            null == e && (e = a);
            if (a == e) {
                var h = a.getTag(), n = s_searchBottomLayer.itemListPanel.getChildByName("Panel_" + h);
                if (b == ccui.Widget.TOUCH_MOVED) {
                    if (15 < cc.pDistance(a.getTouchBeganPosition(), a.getTouchMovePosition()))return d(), !1
                } else {
                    if (b == ccui.Widget.TOUCH_ENDED || b == ccui.Widget.TOUCH_CANCELED)return g = !1, d(), !1;
                    if (b == ccui.Widget.TOUCH_BEGAN && (h = s_searchBottomLayer._itemLayer._curItemList[h - 1], null != h)) {
                        f =
                            cc.audioEngine.playEffect(res.game_listTime_mp3);
                        var h = s_searchBottomLayer._itemLayer.itemPanel.getChildByTag(h.itemTag), u, x = h.getChildren()[0];
                        u = x ? new cc.Sprite(x.texture, x.getTextureRect(), x.isTextureRectRotated()) : new cc.Sprite(h.texture, h.getTextureRect(), h.isTextureRectRotated());
                        var w = null, h = new cc.Sprite("#SceneUI_wupts.png"), y = 100, A = new cc.Layer;
                        A.setContentSize(h.getContentSize());
                        var D = new cc.ProgressTimer(new cc.Sprite("#SceneUI_wupts2.png")), G = function () {
                            y -= 1;
                            D.setPercentage(y);
                            if (0 ==
                                y) {
                                A.reorderChild(u, A.getChildrenCount());
                                w.removeFromParent();
                                s_searchBottomLayer.unschedule(G);
                                f && (cc.audioEngine.stopEffect(f), f = null);
                                var a = u.getScale(), a = cc.scaleTo(0.3, 1.15 * a).easing(cc.easeBackOut());
                                u.runAction(a)
                            }
                        };
                        D.type = cc.ProgressTimer.TYPE_RADIAL;
                        D.setReverseDirection(!1);
                        D.setPercentage(y);
                        x = cc.p(n.width / 2, n.height / 2);
                        D.setAnchorPoint(0.5, 0);
                        D.setPosition(0, 20);
                        h.setAnchorPoint(0.5, 0);
                        u.setAnchorPoint(0.5, 0.5);
                        A.setPosition(x.x, x.y + 80);
                        A.setTag(10);
                        var x = u.getContentSize(), B = h.getContentSize(),
                            C = 0, C = x.height > x.width ? 80 / x.height : 80 / x.width;
                        1 < C && (C = 1);
                        u.setScale(C);
                        u.setPosition(0, B.height / 2);
                        w = new cc.Sprite(u.texture, u.getTextureRect(), u.isTextureRectRotated());
                        w = s_searchBottomLayer.makeShadow(w);
                        w.setAnchorPoint(0.5, 0.5);
                        w.setScale(C);
                        w.setPosition(0, B.height / 2);
                        A.addChild(h, 0);
                        A.addChild(u, 1);
                        A.addChild(w, 2);
                        A.addChild(D, 3);
                        n.addChild(A);
                        s_searchBottomLayer.schedule(G, 0.03)
                    }
                }
            }
        }

        s_searchBottomLayer = this;
        this.game = a;
        this._itemLayer = a._itemLayer;
        this.setTextArr = {};
        cc.spriteFrameCache.addSpriteFrames(res.line_animation_plist);
        cc.spriteFrameCache.addSpriteFrames(res.game_sceneui_plist);
        cc.spriteFrameCache.addSpriteFrames(res.click_tip_plist);
        var d = ccs.load("res/gameScene/gameBottom.json", "res/");
        this._widget = d.node.getChildByName("bottomUI");
        this.setContentSize(this._widget.getContentSize());
        this.mainBottom = this._widget.getChildByName("panelMain");
        this.itemListPanel = this.mainBottom.getChildByName("itemListPanel");
        this.btnTIp = this.mainBottom.getChildByName("btnTip");
        this.addChild(d.node);
        d = this.mainBottom.getChildByName("pnlCount");
        d.setVisible(!0);
        this._lblCount = d.getChildByName("lblPro");
        this._lblCount.setString(a.itemListData.length + "/" + a.itemListData.length);
        for (var e = null, f = null, g = !1, d = 1; 6 >= d; ++d) {
            var h = this.itemListPanel.getChildByName("Panel_" + d);
            if (3 == a.gameType) {
                h.setContentSize(cc.size(65, 65));
                h.removeAllChildren();
                var n = 0;
                6 > d ? n = 71 * (d - 1) : (h.setVisible(!1), h.setTouchEnabled(!1));
                h.setPosition(n, 10);
                cc.log("pnlX \x3d " + n)
            } else h.getChildByTag(d);
            h.addTouchEventListener(b)
        }
        cfun.setButtonFun(this.btnTIp, null, null, this.tipFun,
            null, this);
        this.promptTimer = this.schedule(this.addPromptTimes, 1);
        return !0
    },
    tipFun: function (a) {
        if (s_searchBottomLayer.isLayerTouch)return cc.log("WTF.........ohohohohohohohohoooo"), !0;
        if (20 < s_searchBottomLayer.percent)s_searchBottomLayer.isClickTipBtn = !0, s_searchBottomLayer.percent -= 20, s_searchBottomLayer.mainBottom.removeChild(s_searchBottomLayer.mainBottom.getChildByName("tipTrought" + (Math.floor(s_searchBottomLayer.percent / 20) + 1))), a.setTouchEnabled(!1), s_searchBottomLayer._itemLayer.setTipFun(a);
        else if (cc.log("\u4e0d\u80fd\u63d0\u793a\uff0c\u5475\u5475"), !s_searchBottomLayer.parent.getChildByName("tipRecover")) {
            var b = ActionHelper.tipRecover();
            a.getParent().addChild(b);
            b.setName("tipRecover");
            b.setPosition(a.getPositionX() + a.width / 2, a.getPositionY() + a.height / 2)
        }
    },
    addPromptTimes: function (a) {
        this.percent += 1;
        if (100 < this.percent)this.percent = 100; else {
            a = Math.floor(this.percent / 20) + 1;
            for (var b = 1, d = [0, 44, 16, 5, 16, 44]; a > b;) {
                var e = this.mainBottom.getChildByName("imgPnl" + b), f = e.getChildByName("imgtishi" +
                    b);
                e.setPositionY(d[b]);
                f.setPositionY(f.height / 2);
                null == this.mainBottom.getChildByName("tipTrought" + b) && (f = ActionHelper.TipTroughAction(), f.setName("tipTrought" + b), f.setPosition(e.getPositionX() + f.width / 2, d[b] + f.height / 2), this.mainBottom.addChild(f));
                b += 1
            }
            if (5 >= a) {
                var e = this.mainBottom.getChildByName("imgPnl" + a), f = e.getChildByName("imgtishi" + a), b = f.height, g = 0;
                this.isClickTipBtn && (g = this.percent % 20 / 20 * b, e.setPositionY(d[a] - e.height + g), f.setPositionY(b / 2 + e.height - g), this.isClickTipBtn = !1);
                g = (e.height -
                    g) / 20;
                b = cc.moveBy(0.95, cc.p(0, -g));
                g = cc.moveBy(0.95, cc.p(0, g));
                f.runAction(b);
                for (e.runAction(g); 5 > a;)a += 1, e = this.mainBottom.getChildByName("imgPnl" + a), f = e.getChildByName("imgtishi" + a), b = f.height, e.setPositionY(d[a] - e.height), f.setPositionY(b / 2 + e.height)
            }
        }
    },
    onEnter: function () {
        this._super();
        cc.each(this.setTextArr, function (a, b) {
            a.setString(b)
        })
    },
    initItemListText: function () {
        for (var a = 1, b = null, d = 0; d < this.game.itemListData.length; ++d) {
            var e = Math.floor(Math.random() * this.game.itemListData.length), b = this.game.itemListData[d];
            this.game.itemListData[d] = this.game.itemListData[e];
            this.game.itemListData[e] = b
        }
        b = [];
        for (this._itemLayer._curAndClickedItemList = {}; a <= this.game.itemCurCount;) {
            var e = this.game.itemListData[a], f = e[Iteminfo.ITEMNAME], g = e[Iteminfo.ID], d = e[Iteminfo.TARGET];
            this._itemLayer.itemPanel.getChildByTag(g) ? (this._itemLayer._curAndClickedItemList[g] = {
                index: a,
                name: f
            }, b.push({
                itemTag: e[Iteminfo.ID],
                name: f,
                target: d
            }), d = this.itemListPanel.getChildByName("Panel_" + a), 3 != this.game.gameType ? (d.getChildByTag(a).setFontSize(this.ITEMLIST_FONTSIZE),
                this.setTextArr[f] = d.getChildByTag(a)) : (g = e[Iteminfo.ID], e = this._itemLayer.itemPanel.getChildByTag(g), e = new cc.Sprite(e.texture, e.getTextureRect(), e.isTextureRectRotated()), e.setAnchorPoint(0, 0), e.width > e.height ? e.setScale(d.width / e.width) : e.setScale(d.width / e.height), e.setPosition(0, 0), e = this.makeShadow(e), e.attr({
                tag: a,
                x: d.width / 2,
                y: d.height / 2
            }), d.addChild(e)), a += 1) : cc.log("\u6ca1\u6709\u627e\u5230\u7269\u54c1:" + g)
        }
        this._itemLayer.setCurItemList(b)
    },
    getPositionById: function (a) {
        a = this.itemListPanel.getChildByName("Panel_" +
            a).getChildByTag(a);
        return a.convertToWorldSpace(cc.p(a.width * a.getAnchorPoint().x, a.height * a.getAnchorPoint().y))
    },
    getLineAnimation: function () {
        var a = cc.animationCache.getAnimation("LineAnimation");
        if (!a) {
            for (var a = [], b = "", d = 0; 6 > d; d++)b = "wupimingchenghuaxian" + d + ".png", b = cc.spriteFrameCache.getSpriteFrame(b), a.push(b);
            a = new cc.Animation(a, 0.05);
            cc.animationCache.addAnimation(a, "LineAnimation")
        }
        return cc.animate(a)
    },
    playDeleteText: function (a, b, d, e) {
        var f;
        f = 3 != this.game.gameType ? ccui.helper.seekWidgetByName(this.itemListPanel,
            "Panel_" + a).getChildren()[0] : ccui.helper.seekWidgetByName(this.itemListPanel, "Panel_" + a);
        var g = this.getLineAnimation(), h = !1, n = new cc.Sprite("#wupimingchenghuaxian1.png");
        n.x = f.width / 2;
        n.y = f.height / 2;
        f.addChild(n);
        n.runAction(cc.sequence(g, cc.callFunc(function (f) {
            h = !0;
            f.removeFromParent();
            s_searchBottomLayer.setItemListPanelText(a, b, d);
            "function" == typeof e && e()
        }, n)));
        var p = null, p = this.schedule(function () {
            h || this.setItemListPanelText(a, "", d);
            this.unschedule(p)
        }, 0.2, !1)
    },
    setItemListPanelText: function (a,
                                    b, d) {
        var e = this.itemListPanel.getChildByName("Panel_" + a);
        if (3 != this.game.gameType) {
            var f = e.getChildByTag(a);
            f.setString(b);
            cc.log(f.getFontName());
            "" != b && (f.getColor(), f.setScale(0), f.setAnchorPoint(0.5, 0.5), a = cc.scaleTo(0.3, 1), f.runAction(cc.sequence(cc.delayTime(0.5), a.easing(cc.easeElasticOut(0.5)), cc.callFunc(function () {
                f.setTextColor(cc.color(255, 255, 255));
                f.setColor(cc.color(255, 255, 255))
            }), cc.delayTime(0.15), cc.callFunc(function () {
                f.setTextColor(cc.color(40, 58, 50));
                f.setColor(cc.color(255,
                    255, 255))
            }))))
        } else e.removeChildByTag(a), -1 != d && (b = this._itemLayer.itemPanel.getChildByTag(d), b = new cc.Sprite(b.getTexture(), b.getTextureRect(), b.isTextureRectRotated()), b.setColor(cc.color(1, 0, 0, 0)), b.setVisible(!0), b.setAnchorPoint(0.5, 0.5), b.width > b.height ? b.setScale(e.width / b.width) : b.setScale(e.width / b.height), b = this.makeShadow(b), b.setTag(a), b.setPositionX(e.getContentSize().width / 2), b.setPositionY(e.getContentSize().height / 2), b.setAnchorPoint(0, 0), e.addChild(b))
    },
    makeShadow: function (a) {
        var b =
            cc.p(a.getPositionX(), a.getPositionY()), d = a.getAnchorPoint();
        a.setPosition(0, 0);
        a.setAnchorPoint(0, 0);
        var e = new cc.RenderTexture(a.width, a.height, cc.Texture2D.PIXEL_FORMAT_RGBA8888), f = new cc.DrawNode, g = new cc.DrawNode, h = new cc.DrawNode, n = a.getBoundingBox(), n = [cc.p(0, 0), cc.p(n.width, 0), cc.p(n.width, n.height), cc.p(0, n.height)];
        f.drawPoly(n, cc.color(0, 0, 0, 255), 0, cc.color(0, 0, 0, 0));
        g.drawPoly(n, cc.color(0, 0, 0, 255), 0, cc.color(0, 0, 0, 0));
        h.drawPoly(n, cc.color(0, 0, 0, 255), 0, cc.color(0, 0, 0, 0));
        f.setBlendFunc(gl.DST_COLOR,
            1);
        g.setBlendFunc(gl.DST_COLOR, 1);
        h.setBlendFunc(gl.DST_COLOR, 0);
        e.begin();
        a.visit();
        f.visit();
        g.visit();
        h.visit();
        e.end();
        a.setPosition(b);
        a.setAnchorPoint(d);
        return e
    },
    getPositionById: function (a) {
        a = this.itemListPanel.getChildByName("Panel_" + a).getChildByTag(a);
        return a.convertToWorldSpace(cc.p(a.width * a.getAnchorPoint().x, a.height * a.getAnchorPoint().y))
    },
    onGameStop: function (a) {
        a ? this.unschedule(this.addPromptTimes) : this.schedule(this.addPromptTimes, 1)
    },
    ctor: function (a) {
        this._super();
        this.init(a)
    }
});
var s_searchItemLayer = null, searchItemLayer = cc.Layer.extend({
    game: null,
    menuLayer: null,
    _fullCover: null,
    _tipEffectTab: {},
    _curItemList: [],
    _curAndClickedItemList: {},
    _isPlayFindAnimation: !1,
    _reward: {},
    _dragItem: null,
    _sceneid: null,
    compass: null,
    compassTarget: null,
    bottom: null,
    animationCount: 0,
    area: null,
    isPlayTip: !1,
    itemPanel: null,
    _checkClickItems: [],
    _actionItems: [],
    loadBackgroundTimeID: 0,
    _itemScene: null,
    schemeNum: 0,
    itemTab: {},
    schemeTab: {},
    curScheme: null,
    logText: null,
    totalItemNum: null,
    remainItemNum: null,
    scenePath: null,
    ctor: function (a) {
        this._super();
        this.init(a)
    },
    init: function (a) {
        function b(a, h) {
            var n = h.getCurrentTarget();
            f -= 1;
            if (!1 == n.game._selectEnabled)cc.log("\u5df2\u88ab\u8bbe\u7f6e\u6210\u4e0d\u53ef\u9009"); else {
                if (!0 == n.game.isGameEnd)return cc.log("\u6e38\u620f\u5df2\u7ed3\u675f");
                if (0 < f)return cc.log("\u591a\u70b9\u70b9\u51fb");
                if (e)d = e = !1; else if (d)d = !1; else {
                    var p = a.getLocation(), p = cc.pAdd(p, clickArea[g]), u = n._itemScene.convertToNodeSpace(p), x = n.getClickItem(u), w = x[1];
                    if (x[0]) {
                        if (null == w)return !1;
                        var x =
                            [], y = n.itemPanel.getChildren(), A;
                        for (A in y)cc.rectContainsPoint(y[A].getBoundingBox(), u) && 0 <= y[A].getTag() && x.push(y[A]);
                        u = w.getLocalZOrder();
                        for (A = x.length - 1; 0 <= A;) {
                            y = x[A];
                            if (y.getLocalZOrder() > u) {
                                var D;
                                a:{
                                    D = y.getTag();
                                    var G = void 0;
                                    for (G in n._curItemList)if (n._curItemList[G] && D == n._curItemList[G].itemTag) {
                                        D = !0;
                                        break a
                                    }
                                    D = !1
                                }
                                if (D && 1 == Iteminfo.data[y.getTag() - 1][Iteminfo.ISTRANSPREN]) {
                                    w = y;
                                    break
                                } else if (cfun.getOriginalAlphaPoint(y, p))cc.log("\u70b9\u51fb\u5230\u900f\u660e\u533a\u57df"); else {
                                    w = y;
                                    break
                                }
                            }
                            A -=
                                1
                        }
                        null != table.keyOfItem(n._checkClickItems, w.getTag()) ? (g = 1, n.itemTouchFun(w)) : 9 > g ? (g += 1, f += 1, b(a, h)) : (g = 1, n.game.top.onDoubleClicked(!1, p.x, p.y))
                    } else 9 > g ? (g += 1, f += 1, b(a, h)) : (g = 1, n.game.top.onDoubleClicked(!1, p.x, p.y))
                }
            }
        }

        s_searchItemLayer = this;
        this.game = a;
        this._actionItems = [];
        this.remainItemNum = this.totalItemNum = this.game.itemAllCount;
        this._sceneid = a.sceneID;
        this.compass = null;
        this._contrlLayer = new cc.Layer;
        this.addChild(this._contrlLayer);
        this.isPlayTip = !1;
        this.scenePath = "res/gameScene/searchGame/gameScene_" +
            Number(a.sceneID + 1);
        this._itemScene = ccs.load(this.scenePath + "/gameScene_" + Number(a.sceneID + 1) + ".json").node;
        this.itemPanel = this._itemScene.getChildByName("scheme0");
        this._itemScene.setAnchorPoint(0, 0);
        this._itemScene.setPositionX(vsize.width / 2 - this._itemScene.width / 2);
        this.addChild(this._itemScene);
        var d = !1, e = !1, f = 0, g = 1, h;
        for (h in this.game.prizeItemData)this._checkClickItems.push(this.game.prizeItemData[h][Iteminfo.ID]);
        cfun.addEventListener(this, function (a, b) {
            f += 1;
            1 < f && (e = !0);
            var d = b.getCurrentTarget(),
                h = a.getLocation(), h = cc.pAdd(h, clickArea[g]);
            d._itemScene.convertToNodeSpace(h);
            return !0
        }, function (a, b) {
            var e = b.getCurrentTarget(), f = a.getLocation(), g = e.itemPanel.convertToNodeSpace(f);
            if (e._dragItem && !e._dragItem.isLock)return 1 == e._dragItem.getScale() ? e._dragItem.setPosition(g.x, g.y + 70) : e._dragItem.setPositionX(g.x), !0;
            d || (e = cc.pDistance(f, a.getStartLocation()), 30 < Math.abs(e) && (d = !0))
        }, b);
        a = "scheme0" == this.itemPanel.getName();
        for (var n in this.itemPanel.getChildren()) {
            var p = this.itemPanel.getChildren()[n];
            a && p.setLocalZOrder(Number(n))
        }
        for (h in this._itemScene.getChildren())n = this._itemScene.getChildren()[h], a = n.getName(), -1 != a.indexOf("scheme") && ("scheme0" == a ? n.setVisible(!0) : n.setVisible(!1));
        cc.log("load } .........");
        this.animationCount = 0;
        return !0
    },
    deleteTipByTag: function (a) {
        MW.isTipAction && (a = s_searchItemLayer._tipEffectTab[a]) && (cc.log("\u6e05\u9664", a.name), a.removeFromParent(), delete s_searchItemLayer._tipEffectTab.tag)
    },
    deleteAllTip: function () {
        for (var a in s_searchItemLayer._tipEffectTab)cc.log("\u6e05\u9664",
            s_searchItemLayer._tipEffectTab[a]._itemTag), s_searchItemLayer._tipEffectTab[a] && s_searchItemLayer._tipEffectTab[a]._itemTag && s_searchItemLayer._tipEffectTab[a].removeFromParent();
        s_searchItemLayer._tipEffectTab = []
    },
    setTipFun: function (a, b) {
        function d() {
            for (var d = 1; d <= b; ++d) {
                f = Math.floor(Math.random() * g.length);
                r = g[f].itemTag;
                p = new Tip(g[f].itemTag);
                p.setName("tip" + f);
                p.setTag(-100);
                s_searchItemLayer._tipEffectTab[g[f].itemTag] = p;
                var h = s_searchItemLayer.itemPanel.getChildByTag(g[f].itemTag);
                h.isInTip = !0;
                cc.log("\u63d0\u793a\uff1a" + g[f].name);
                s_searchItemLayer.itemPanel.addChild(p, 1E4);
                var n = cc.p(a.getPositionX(), a.getPositionY()), n = a.convertToWorldSpace(), n = s_searchItemLayer.itemPanel.convertToNodeSpace(n);
                p.setPosition(n);
                n = function () {
                    var b = cc.p(h.getPositionX(), h.getPositionY());
                    p.runTipAction(b, function () {
                        a.setTouchEnabled(!0);
                        h.isInTip = !1
                    })
                };
                e ? n() : ActionHelper.TipEffect(s_searchItemLayer.game._bottom.mainBottom, 1, n);
                g[f] = void 0
            }
        }

        MW.isTipAction && this.deleteAllTip();
        var e = !0;
        null == b && (b = 1, e = !1);
        MW.isTipAction = !0;
        for (var f = 0, g = []; f < this.game.itemCurCount;) {
            var h = this._curItemList[f];
            h && (h.target ? table.find(self._actionItems, h.target) || g.push(this._curItemList[f]) : g.push(this._curItemList[f]));
            f += 1
        }
        for (var n in this._actionItems)g.push({name: "superItem", itemTag: this._actionItems[n]});
        if (0 != g.length) {
            b > g.length && (b = g.length);
            var p = null, r = null;
            d();
            cc.audioEngine.playEffect(res.game_Prompt_mp3);
            return r
        }
    },
    getClickItem: function (a, b) {
        b = b || this._checkClickItems;
        var d = null, e = -1, f;
        for (f in b) {
            var g =
                b[f], h = this.itemPanel.getChildByTag(g);
            if (null != h && 0 <= g) {
                var n = h.getBoundingBox();
                if (0 == n.width) {
                    var p = h.getChildren()[0];
                    n.width = p.width;
                    n.height = p.height;
                    n.x -= n.width / 2;
                    n.y -= n.height / 2
                }
                cc.rectContainsPoint(n, a) && (n = h.getLocalZOrder(), cfun.getOriginalAlphaPoint(h, a), 1 == Iteminfo.data[g - 1][Iteminfo.ISTRANSPREN] && n > e && (d = h, e = n))
            }
        }
        return d ? d.isInTip ? [!0, null] : [!0, d] : [!1]
    },
    setCurItemList: function (a) {
        this._curItemList = a;
        for (var b in this._curItemList)this._checkClickItems.push(this._curItemList[b].itemTag)
    },
    itemTouchFun: function (a) {
        function b(a, b) {
            if (null == b)return [!0];
            if (1 == b[Iteminfo.ISPRIZE])return [!1, -1];
            for (var d in a._curAndClickedItemList)if (a._curAndClickedItemList[d].name == b[Iteminfo.ITEMNAME])return [!1, a._curAndClickedItemList[d].index, a._curAndClickedItemList[d].name];
            return [!0]
        }

        var d = a.getTag();
        this.deleteTipByTag(d);
        var d = function (a) {
            for (var b in a._checkClickItems)if (d == a._checkClickItems[b])return a._checkClickItems[b]
        }(this), e = Iteminfo.data[d - 1], f = b(this, e), g = f[0], h = f[1], f = f[2];
        if (!g) {
            var n,
                g = -1;
            if (-1 == h)cc.log("u find prize item"), self._reward.push(e[Iteminfo.PRIZEINFO]); else {
                this.game.top.onDoubleClicked(d, a.x, a.y);
                var p = Object.keys(this._curAndClickedItemList);
                if (this.game.itemAllCount != p.length) {
                    g = !1;
                    for (p = {}; !g;)p = Math.floor(Math.random() * this.game.itemAllCount), p = this.game.itemListData[p], n = p[Iteminfo.ITEMNAME], g = b(this, p)[0];
                    g = p[Iteminfo.ID];
                    this._curItemList[h - 1] = {itemTag: g, name: n, target: p[Iteminfo.TARGET]};
                    cc.log("curItemList:" + n + " " + g);
                    p = table.keyOfItem(this._checkClickItems,
                        d);
                    this._checkClickItems[p] = g;
                    this._curAndClickedItemList[g] = {index: h, name: n};
                    cc.log("insert table curAndClickedItemList ")
                } else table.removeItem(this._checkClickItems, d), this._curItemList[h - 1] = null, n = "", 0 == this._curItemList.length && (this.game._bottom.onGameStop(!0), this.game.isGameEnd = !0);
                a == this.compassTarget && this.compass && (cc.log("\u76ee\u6807\u5df2\u6e05\u9664"), this.compassTarget = null, this.compass.remove(), this.compass = null)
            }
            2 == e[Iteminfo.ISEVIDENCE] ? this.playFindedAnimation(a, h, !0, f, n, g, this.checkSuccess) :
                1 == e[Iteminfo.ISEVIDENCE] && this.game._input.taskId == e[Iteminfo.TASKID] ? this.playFindedAnimation(a, h, !0, f, n, g, this.checkSuccess) : this.playFindedAnimation(a, h, !1, "", n, g, this.checkSuccess)
        }
    },
    checkSuccess: function () {
        s_searchItemLayer.animationCount -= 1;
        var a = cfun.getNum(s_searchItemLayer._curItemList);
        cc.log("the curItemList's nums is " + a);
        0 == a && 0 == s_searchItemLayer.animationCount && s_searchItemLayer.game.finish()
    },
    playFindedAnimation: function (a, b, d, e, f, g, h) {
        function n(a) {
            a.removeFromParent()
        }

        function p() {
            -1 !=
            b && (s_searchItemLayer.remainItemNum -= 1, s_searchItemLayer.game._bottom._lblCount.setString(s_searchItemLayer.remainItemNum + "/" + s_searchItemLayer.totalItemNum))
        }

        function r(b) {
            a.setScale(1);
            b = cc.scaleTo(0.3, 1.2);
            var d = cc.scaleTo(0.3, 1), e = cc.fadeOut(0.5), f = cc.pDistance(cc.p(u.x + 50, u.y), cc.p(a.getPositionX(), a.getPositionY())), f = cc.moveTo(f / 1E3, cc.p(u.x, u.y));
            return cc.sequence(b, cc.callFunc(p), d, cc.spawn(f, e), cc.callFunc(n))
        }

        function s() {
            s_searchItemLayer.game._bottom.playDeleteText(b, f, g, function () {
                s_searchItemLayer._isPlayFindAnimation = !1;
                d || h()
            })
        }

        function t() {
            if (this.game._input.taskId) {
                var b = Iteminfo.data[a.getTag() - 1][Iteminfo.PICTURE];
                new cc.Sprite(this.scenePath + "/evidence/" + b);
                Iteminfo.data[a.getTag() - 1][Iteminfo.BRIEF] || a.getTag()
            }
        }

        function v() {
            s_searchItemLayer._isPlayFindAnimation = !1
        }

        searchItemLayer._isPlayFindAnimation = !0;
        var u = null;
        e = a.getParent().convertToWorldSpace(cc.p(a.getPosition()));
        -1 == b ? u = e : (this.animationCount += 1, u = this.game._bottom.getPositionById(b));
        a.setPosition(e);
        a.retain();
        a.removeFromParent();
        cc.director.getRunningScene().addChild(a,
            cc.director.getRunningScene().getChildren().length);
        a.release();
        e = r(this);
        d ? a.playIt ? (a.callback = function () {
            if (a.actionType == ITEM_TYPE.FIND_WITHOUT_ANIMATION)t(), s(), table.removeItem(this._actionItems, a.getTag()); else if (a.actionType == ITEM_TYPE.FIND_ANIMATION) {
                var b = r(this);
                a.runAction(cc.sequence(b, cc.callFunc(t), cc.callFunc(s)))
            } else a.actionType == ITEM_TYPE.CASE_ITEM && (t(), s())
        }, a.playIt()) : a.runAction(cc.sequence(e, cc.callFunc(t), cc.callFunc(s))) : -1 == b ? a.runAction(cc.sequence(e, cc.callFunc(v))) :
            a.runAction(cc.sequence(e, cc.callFunc(s)))
    }
});
var searchScene = cc.Layer.extend({
    __cname: "searchScene",
    _widget: null,
    _uiLayer: null,
    caseID: 0,
    sceneID: 0,
    gameType: 0,
    taskID: 1001,
    itemAllCount: 7,
    itemCurCount: 6,
    allItemCount: 0,
    top: null,
    _bottom: null,
    _itemLayer: null,
    _input: null,
    _isCountDown: !1,
    prizeItemData: [],
    isGameEnd: !1,
    itemListData: [],
    _selectEnabled: !0,
    _pauseEnabled: !0,
    _inventory: null,
    _level: null,
    ctor: function (a, b, d, e, f) {
        this._super();
        this.init(a, b, d, e, f)
    },
    getItemStaticData: function (a) {
        Iteminfo = ITEM_TAB[a]
    },
    init: function (a, b, d, e, f) {
        this.sceneID = a;
        this.level =
            b;
        this.taskID = d;
        this.gameType = e;
        this._isCountDown = f;
        this.getItemStaticData(a);
        this._uiLayer = new cc.Layer;
        this.addChild(this._uiLayer);
        this.itemListData = [];
        this.allItemCount = Iteminfo.data.length;
        cc.spriteFrameCache.addSpriteFrames(res.baseUI_plist);
        this._itemLayer = new searchItemLayer(this);
        for (this._uiLayer.addChild(this._itemLayer, 0); this.itemListData.length < this.itemAllCount;)a = Math.floor(Math.random() * this.allItemCount), 2 == Iteminfo.data[a][Iteminfo.ISEVIDENCE] || null != Iteminfo.data[a][Iteminfo.ACTION_TYPE] &&
        1 != Iteminfo.data[a][Iteminfo.ACTION_TYPE] || 1 == Iteminfo.data[a][Iteminfo.ISPRIZE] || gfun.checkHasItemByTable(this.itemListData, Iteminfo.data[a][Iteminfo.ID], Iteminfo.ID) || !this._itemLayer.itemPanel.getChildByTag(Iteminfo.data[a][Iteminfo.ID]) || (cc.log("random num is \x3d\x3d " + a), this.itemListData.push(Iteminfo.data[a]));
        this._bottom = new searchBottomLayer(this);
        this._bottom.setAnchorPoint(0, 0);
        this._bottom.setPositionX(vsize.width / 2 - this._bottom.width / 2);
        this._bottom.initItemListText();
        this._uiLayer.addChild(this._bottom,
            2);
        this.top = new gameTopLayer(this, 120, !1);
        this.top.setAnchorPoint(0, 0);
        this.top.setPosition(cc.winSize.width / 2 - this.top.width / 2, vsize.height - this.top.height);
        this._uiLayer.addChild(this.top, 4);
        this.gameType == GAMETYPE_FIND_SOMETHING_NORMAL && textModule();
        MW.isTipAction = !1;
        return !0
    },
    stopGame: function (a) {
        this.top.onGameStop(a);
        this._bottom.onGameStop(a)
    },
    quitFromGame: function (a) {
        a = new cc.Scene;
        a.addChild(new SysMenu);
        cc.director.runScene(new cc.TransitionFade(1.2, a))
    },
    replay: function () {
        var a = searchScene.scene(this.sceneID,
            this.level, this.taskID, this.gameType, this._isCountDown);
        cc.director.runScene(new cc.TransitionFade(1.2, a))
    },
    finish: function () {
        cc.director.getActionManager().pauseAllRunningActions();
        this.stopGame(!0);
        var a = ccs.load(res.success_json, "res/"), b = a.node, a = a.action;
        b.runAction(a);
        a.gotoFrameAndPlay(0, !1);
        b.x = (cc.winSize.width - b.width) / 2;
        b.y = (cc.winSize.height - b.height) / 2;
        this.addChild(b);
        a = b.getChildByName("btnExit");
        b = b.getChildByName("btnReplay");
        cfun.setButtonFun(a, null, null, this.quitFromGame, null, this);
        cfun.setButtonFun(b, null, null, this.replay, null, this)
    },
    onSoundControl: function () {
        MW.SOUND = !MW.SOUND;
        var a = cc.audioEngine;
        MW.SOUND ? a.playMusic(res.mainMainMusic_mp3) : (a.stopMusic(), a.stopAllEffects())
    },
    onModeControl: function () {
    },
    onExit: function () {
        this._super();
        MW.isStoreImageData = !1;
        MW.imageData = null
    }
});
searchScene.scene = function (a, b, d, e, f) {
    var g = new cc.Scene;
    a = new searchScene(a, b, d, e, f);
    g.addChild(a);
    return g
};
var m = {
    ID: 0,
    ITEMNAME: 1,
    ISPRIZE: 2,
    ISEVIDENCE: 3,
    TASKID: 4,
    ISTRANSPREN: 5,
    PICTURE: 6,
    PRIZEINFO: 7,
    GROUNPID: 8,
    ACTION_TYPE: 9,
    ANIMATION_PATH: 10,
    TARGET: 11,
    TIP_TEXT: 12,
    BRIEF: 13,
    data: [[1, "\u706f\u7b3c", 0, 0, 0, 1, "", "", 0], [2, "\u7b1b\u5b50", 0, 0, 0, 1, "", "", 0], [3, "\u809a\u515c", 0, 0, 0, 1, "", "", 0], [4, "\u5bab\u6247", 0, 0, 0, 1, "", "", 0], [5, "\u89c2\u97f3\u50cf", 0, 0, 0, 1, "", "", 0], [6, "\u9ed1\u91c9\u7f50", 0, 0, 0, 1, "", "", 0], [7, "\u9ed1\u73cd\u73e0", 0, 0, 0, 1, "", "", 0], [8, "\u8774\u8776", 0, 0, 0, 1, "", "", 0], [9, "\u72d0\u5c3e", 0, 0, 0, 1, "", "",
        0], [10, "\u6212\u6307", 0, 0, 0, 1, "", "", 0], [11, "\u9152\u676f", 0, 0, 0, 1, "", "", 0], [12, "\u5377\u8f74", 0, 0, 0, 1, "", "", 0], [13, "\u91d1\u76c6", 0, 0, 0, 1, "", "", 0], [14, "\u9f99", 0, 0, 0, 1, "", "", 1], [15, "\u732b\u722a", 0, 0, 0, 1, "", "", 0], [16, "\u9762\u5177", 0, 0, 0, 1, "", "", 0], [17, "\u7261\u4e39", 0, 0, 0, 1, "", "", 0], [18, "\u9e1f", 0, 0, 0, 1, "", "", 0], [19, "\u4f69\u5251", 0, 0, 0, 1, "", "", 0], [20, "\u6d41\u82cf", 0, 0, 0, 1, "", "", 0], [21, "\u53d1\u7c2a", 0, 0, 0, 1, "", "", 0], [22, "\u82f9\u679c", 0, 0, 0, 1, "", "", 0], [23, "\u7435\u7436", 0, 0, 0, 1, "", "", 0], [24, "\u957f\u547d\u9501",
        0, 0, 0, 1, "", "", 0], [25, "\u5723\u65e8", 0, 0, 0, 1, "", "", 0], [26, "\u98df\u76d2", 0, 0, 0, 1, "", "", 0], [27, "\u624b\u4e32", 0, 0, 0, 1, "", "", 0], [28, "\u624b\u5e15", 0, 0, 1001, 1, "gameUI_wuzhengshoupai.png", "", 0], [29, "\u9996\u9970\u76d2", 0, 0, 1001, 1, "gameUI_wuzhenglihe.png", "", 0, 1, "res/case1/gameScene_1/shoushihe.csb"], [30, "\u624b\u956f", 0, 0, 0, 1, "", "", 0], [31, "\u9ab0\u5b50", 0, 0, 0, 1, "", "", 0], [32, "\u68b3\u5b50", 0, 0, 0, 1, "", "", 0], [33, "\u4fe1\u4ef6", 0, 0, 0, 1, "", "", 0], [34, "\u94dc\u955c", 0, 0, 0, 1, "", "", 0], [35, "\u7709\u7b14", 0, 0, 0,
        1, "", "", 0], [36, "\u5934\u9970", 0, 0, 0, 1, "", "", 0], [37, "\u9999\u56ca", 0, 0, 0, 1, "", "", 0], [38, "\u7ee3\u82b1\u978b", 0, 0, 0, 1, "", "", 0], [39, "\u80ed\u8102\u76d2", 0, 0, 0, 1, "", "", 0], [40, "\u94a5\u5319", 0, 0, 0, 1, "", "", 0], [41, "\u591c\u660e\u73e0", 0, 0, 0, 1, "", "", 0], [42, "\u5143\u5b9d", 1, 0, 0, 1, "", "2`10", 0], [43, "\u7fbd\u7fce", 0, 0, 0, 1, "", "", 0], [44, "\u7389\u4f69", 0, 0, 0, 1, "", "", 0], [45, "\u7389\u73ba", 0, 0, 0, 1, "", "", 0], [46, "\u540a\u5760", 0, 0, 1118, 1, "", "", 0], [47, "\u9e64", 0, 0, 0, 1, "", "", 0], [48, "\u6307\u5957", 0, 0, 0, 1, "", "", 0], [49,
        "\u5175\u7b26", 0, 0, 0, 1, "", "", 0]]
};
ITEM_TAB[0] = m;
var cfun = {
    dispatchEvent: function (a, b) {
        var d = new cc.EventCustom(a);
        d.setUserData(b);
        cc.eventManager.dispatchEvent(d)
    }, eventListener: function (a, b) {
        var d = cc.EventListener.create({event: cc.EventListener.CUSTOM, eventName: a, callback: b});
        cc.eventManager.addListener(d, 1);
        return d
    }, addEventListener: function (a, b, d, e, f) {
        var g = {event: cc.EventListener.TOUCH_ONE_BY_ONE};
        b && (g.onTouchBegan = b);
        d && (g.onTouchMoved = d);
        e && (g.onTouchEnded = e);
        f && (g.onTouchCancelled = f);
        cc.eventManager.addListener(g, a)
    }, setButtonFun: function (a,
                               b, d, e, f, g, h) {
        function n(a) {
            var b = cc.scaleTo(0.1, 1).easing(cc.easeBounceIn());
            a.runAction(b)
        }

        a.addTouchEventListener(function (a, r) {
            if (r == ccui.Widget.TOUCH_BEGAN) {
                a.isTouch = !0;
                cfun.addFullScreen("button");
                a.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL);
                var s = cc.scaleTo(0.07, 0.9);
                a.runAction(s);
                b && (g && b.call(g, a, r), g || b(a, r))
            } else r == ccui.Widget.TOUCH_MOVED ? (a.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL), s = a.getTouchMovePosition(), a.hitTest(s) || n(a), d && (g && d.call(g, a, r), g || d(a, r))) : r == ccui.Widget.TOUCH_ENDED ?
                (a.isTouch = !1, cfun.removeFullScreen("button"), n(a), e && (g && e.call(g, a, r), g || e(a, r), h ? "" != h && cc.audioEngine.playEffect(h) : cc.audioEngine.playEffect(res.common_click_mp3))) : r == ccui.Widget.TOUCH_CANCELED && (a.isTouch = !1, cfun.removeFullScreen("button"), n(a), f && (g && f.call(g, a, r), g || f(a, r)))
        }, g);
        a.onExit = function () {
            a.isTouch && cfun.removeFullScreen("button")
        }
    }, addFullScreen: function (a, b, d) {
        a = String(a || "fullScreen");
        if (!cc.director.getRunningScene().getChildByName(a)) {
            var e = new ccui.Layout;
            e.setPropagateTouchEvents(!1);
            e.setSwallowTouches(!0);
            e.setContentSize(vsize);
            e.setTouchEnabled(!0);
            e.setName(a);
            cc.director.getRunningScene().addChild(e);
            b && (e.setPropagateTouchEvents(d || !1), e.addTouchEventListener(b));
            cc.log("\u6dfb\u52a0\u5168\u5c4f\u906e\u6321:" + a)
        }
    }, removeFullScreen: function (a) {
        a = String(a || "fullScreen");
        var b = cc.director.getRunningScene().getChildByName(a);
        b && (cc.director.getRunningScene().removeChild(b), cc.log("\u79fb\u9664\u5168\u5c4f\u906e\u6321:" + a))
    }, getTimeNumberWithoutHourConvertString: function (a) {
        var b;
        if (60 > a)b = "0", a = String(a); else if (6E3 > a)b = String(Math.floor(a / 60)), a = String(a % 60); else return "99:59";
        if (1 == b.length || 0 == b.length)b = "0" + b;
        if (1 == a.length || 0 == a.length)a = "0" + a;
        return b + ":" + a
    }, isSpriteTransparentInPoint: function (a, b) {
        var d = a.getPosition(), e = new Uint8Array(4);
        a.setPosition(0, 0);
        a.getTexture();
        var f = new cc.RenderTexture(a.width, a.height);
        f.begin();
        a.visit();
        gl.readPixels(b.x, b.y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, e);
        f.end();
        a.setPosition(d);
        return e
    }, getOriginalAlphaPoint: function (a, b) {
        if (!MW.imageData)return !1;
        var d = a.texture, e = a.convertToNodeSpace(b), d = d.getContentSizeInPixels(), f = a.getTextureRect(), g = a.isTextureRectRotated();
        e.y = f.height - e.y;
        g && (e = cc.p(f.height - e.y, e.x));
        g = Math.round(e.x + f.x);
        e = Math.round(f.y + e.y);
        return 0 > g || 0 > e ? !1 : 0 == MW.imageData[(e - 1) * d.width + g]
    }, isNeedAlphaData: function (a) {
        for (var b = 0; b < MW.needDataImage.length; ++b)if (MW.needDataImage[b] == a)return !0;
        return !1
    }, getNum: function (a) {
        if (!cc.isArray(a))return cc.log("\u65e0\u6cd5\u83b7\u53d6\u957f\u5ea6"), 0;
        var b = 0;
        cc.each(a, function (a, e) {
            cc.isUndefined(a) ||
            null == a || b++
        });
        return b
    }
};
var gfun = gfun || {};
gfun.checkHasItemByTable = function (a, b, d) {
    if (null == a)return !1;
    for (var e in a)if (a[e][d] == b)return !0;
    return !1
};
var table = {
    keyOfItem: function (a, b) {
        for (var d in a)if (a[d] == b)return d;
        return null
    }, removeItem: function (a, b, d) {
        for (var e = a.length; 1 <= e && (a[e] != b || (a.splice(e, 1), d)); --e);
    }
};
var ActionHelper = {
    comboAction: function (a) {
        var b = null, d = null, d = null, d = 7 > a ? ccs.load("res/animation/lianji/xianchang_lianjiX" + a + ".json", "res/") : ccs.load("res/animation/lianji/xianchang_liangjiJLXG.json", "res/"), b = d.node, d = d.action;
        b.runAction(d);
        b.setContentSize(200, 200);
        d.gotoFrameAndPlay(0, !1);
        d.setFrameEventCallFunc(function (a) {
            "end" == a.getEvent() && b.removeFromParent()
        });
        return b
    }, lianjiNumEffectScaleAction: function (a) {
        var b = cc.scaleTo(0.5, 0.6), d = cc.scaleTo(0.5, 0.5), b = cc.sequence(b, d);
        a.runAction(cc.repeatForever(b))
    },
    lianjiNumEffectRationAction: function (a, b) {
        a.setAnchorPoint(0, 0);
        a.setPositionX(a.getPositionX() - a.width / 2);
        a.setPositionY(a.getPositionY() - a.height / 2);
        var d = cc.fadeOut(1), e = cc.rotateBy(1, 90, 90), d = cc.spawn(d, e), e = cc.callFunc(function () {
            a.setCascadeOpacityEnabled(!0);
            a.setRotation(0);
            a.setVisible(!1);
            a.setOpacity(255);
            a.setAnchorPoint(0.5, 0.5);
            a.setPositionX(a.x + a.width / 2);
            a.setPositionY(a.y + a.height / 2);
            "function" == typeof b && b()
        }), d = cc.sequence(d, e);
        a.runAction(d)
    }, lianjiNumBoomEffect: function (a, b) {
        var d =
            ccs.load(res.lianji_boom_json, "res/"), e = d.node, d = d.action;
        cc.director.getRunningScene().addChild(e);
        e.setAnchorPoint(1, 0.5);
        e.setPosition(a);
        e.runAction(d);
        d.gotoFrameAndPlay(0, 40, !1);
        d.setFrameEventCallFunc(function (a) {
            "endCallFun" == a.getEvent() && e.removeFromParent()
        })
    }, tiaozhanshibai: function (a) {
        var b = ccs.load(res.gameFail_json, "res/"), d = b.node, b = b.action;
        cc.director.getRunningScene().addChild(d);
        d.setPosition(vsize.width / 2 - d.width / 2, vsize.height / 2 - d.height / 2);
        d.runAction(b);
        b.gotoFrameAndPlay(0,
            100, !1);
        gfun.setButtonFun(d.getChildByName("btnCon"), null, null, function (b, d) {
            a()
        })
    }, TipTroughAction: function () {
        var a = ccs.load(res.prompt_fire_json, "res/"), b = a.node, a = a.action;
        b.runAction(a);
        a.gotoFrameAndPlay(0, !0);
        b.setContentSize(35, 55);
        return b
    }, tipRecover: function () {
        var a = new cc.Sprite("#gameUI_skillrecover.png");
        a.setScale(0);
        var b = cc.scaleTo(0.2, 1), d = cc.moveBy(0.2, cc.p(0, 90)), b = cc.spawn(b, d), d = cc.fadeOut(0.2), e = cc.moveBy(0.2, cc.p(0, 40)), d = cc.spawn(d, e);
        a.runAction(cc.sequence(b, cc.delayTime(1),
            d, cc.callFunc(function () {
                a.removeFromParent()
            })));
        return a
    }, TipEffect: function (a, b, d) {
        var e = ccs.load(res.click_tip_json), f = e.node, e = e.action;
        f.setPositionX(115);
        f.setPositionY(60);
        f.runAction(e);
        e.gotoFrameAndPlay(0, !1);
        e.setFrameEventCallFunc(function (e) {
            if ("end" == e.getEvent()) {
                f.removeFromParent();
                a.getChildByName("tishi" + b);
                var h = a.getChildByName("imgPnl" + b).getChildByName("imgtishi" + b);
                a.getChildByName("imgPnl" + b).setClippingEnabled(!1);
                var n = cc.scaleBy(0.2, 5), p = cc.fadeOut(0.2);
                e = cc.callFunc(d);
                var r = cc.callFunc(function () {
                    h.setOpacity(255);
                    h.setScale(1);
                    a.getChildByName("imgPnl" + b).setClippingEnabled(!0)
                }), n = cc.spawn(n, p);
                e = cc.sequence(n, e, r);
                h.runAction(e)
            }
        });
        a.addChild(f, 100)
    }
};
var s_PauseLayer = null, PauseLayer = cc.Layer.extend({
    game: null, instance: null, ctor: function (a) {
        this._super();
        this.init(a)
    }, init: function (a) {
        this.game = a;
        s_PauseLayer = this;
        this.instance = ccs.load(res.pauseUI_json, "res/").node;
        this.addChild(this.instance);
        this.instance.setName("pauseLayer");
        a = this.instance.getChildByName("btnContinue");
        cfun.setButtonFun(a, null, null, this.onContinueGame);
        this.instance.setPosition(cc.winSize.width / 2 - this.instance.width / 2, 0);
        a = this.instance.getChildByName("btnQuit");
        a.setTouchEnabled(!0);
        cfun.setButtonFun(a, null, null, this.quitFromGame);
        a = this.instance.getChildByName("btnSet");
        cfun.setButtonFun(a, null, null, this.setGameFun);
        a = this.instance.getChildByName("btnAgain");
        cfun.setButtonFun(a, null, null, this.resetGameFun);
        this.instance.getChildByName("black").setOpacity(200);
        return !0
    }, onContinueGame: function (a, b) {
        s_PauseLayer.game.top.pauseOrRestartGame(!1);
        s_PauseLayer.removeFromParent(!0)
    }, quitFromGame: function () {
        s_PauseLayer.game.quitFromGame && s_PauseLayer.game.quitFromGame()
    }, setGameFun: function () {
    },
    resetGameFun: function () {
        s_PauseLayer.game.replay && s_PauseLayer.game.replay()
    }
});
var Tip = cc.Layer.extend({
    _itemTag: null, _action: null, tip: null, ctor: function (a) {
        this._super();
        this.init(a)
    }, init: function (a) {
        this._itemTag = a;
        this.tip = new cc.Sprite("#gameBottom_tishidonghua.png");
        this.tip.setScale(0);
        this.addChild(this.tip)
    }, runTipAction: function (a, b) {
        var d = cc.p(this.x, this.y), e = cc.pDistance(d, a), d = cc.moveTo(e / 1200, a).easing(cc.easeIn(0.6)), e = cc.scaleTo(e / 1200, 1, 1), f = this.tip;
        this.runAction(cc.sequence(d, cc.callFunc(function () {
            var a = cc.rotateBy(2, 360), d = cc.scaleTo(1, 1.2), e = cc.scaleTo(1,
                1);
            f.runAction(cc.repeatForever(cc.spawn(a, cc.sequence(d, e))));
            b()
        })));
        this.tip.runAction(e)
    }
});
var serverPath = "http://192.168.18.216:8088", sendRequest = function (a, b, d, e, f) {
    if (null != a && "" != a) {
        var g = cc.loader.getXMLHttpRequest();
        d ? g.open("POST", a) : g.open("GET", a);
        g.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        g.onreadystatechange = function () {
            if (4 == g.readyState && 200 == g.status) {
                var a = g.responseText;
                e && e(a)
            } else 4 == g.readyState && 200 != g.status && (a = g.responseText, f && f(a))
        };
        null == b || "" == b ? g.send() : g.send(b)
    }
};
cc.game.onStart = function () {
    !cc.sys.isNative && document.getElementById("cocosLoading") && document.body.removeChild(document.getElementById("cocosLoading"));
    cc.view.enableRetina(cc.sys.os === cc.sys.OS_IOS ? !0 : !1);
    cc.view.adjustViewPort(!0);
    cc.view.setDesignResolutionSize(1136, 640, cc.ResolutionPolicy.FIXED_HEIGHT);
    cc.view.resizeWithBrowserSize(!0);
    cc.LoaderScene.preload(g_resources, function () {
        var a = searchScene.scene(0, 1, 1001, 3, !1);
        cc.director.runScene(a)
    }, this)
};
cc.game.run();